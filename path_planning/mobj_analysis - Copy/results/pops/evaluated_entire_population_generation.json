{
    "operator": "e1",
    "algorithm_description": "This algorithm is a bidirectional RRT* (Rapidly-exploring Random Tree Star) planner that simultaneously grows two trees rooted at the start and goal positions. The two trees incrementally explore the configuration space by sampling and extending towards random samples. When the two trees connect, an initial path is found, which is then optimized locally through rewiring to improve path quality, smoothness, and cost, resulting in efficient and robust planning.",
    "planning_mechanism": "The planner alternates expansions between the start tree and the goal tree, extending each towards random samples with goal biasing. Nodes are connected only if collision checks pass. After connection, the path is optimized by rewiring nearby nodes to reduce overall path cost, enhancing path smoothness and shortness while maintaining collision-free constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n\n    def set_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        tree_start = []\n        tree_goal = []\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        tree_start.append(root_start)\n        tree_goal.append(root_goal)\n\n        def dist(a, b):\n            return math.dist(a.position, b.position)\n\n        def steer(from_node, to_point):\n            direction = tuple(to_point[d] - from_node.position[d] for d in range(len(to_point)))\n            length = math.dist(from_node.position, to_point)\n            if length == 0:\n                return from_node.position\n            unit = tuple(d / length for d in direction)\n            new_pos = tuple(from_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(to_point)))\n            # Clamp within bounds\n            new_pos_clamped = tuple(\n                max(0.0, min(new_pos[d], bounds[d])) for d in range(len(bounds))\n            )\n            return new_pos_clamped\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, new_node):\n            n = len(tree)\n            r = min(self.neighbor_radius, self.step_size * (math.log(n + 1) / (n + 1))**(1/len(bounds)))\n            neighbors = [node for node in tree if math.dist(node.position, new_node.position) <= r]\n            return neighbors\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_connect(t1_nodes, t2_nodes, new_node):\n            # Try to find a node in t2_nodes close enough to new_node to connect directly\n            nearest_in_other = nearest_node(t2_nodes, new_node.position)\n            if dist(new_node, nearest_in_other) <= self.step_size:\n                if collision_free(new_node.position, nearest_in_other.position):\n                    # Connect trees\n                    return nearest_in_other\n            return None\n\n        for i in range(self.max_iter):\n            # Alternate trees expansion\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Sample point with goal biasing (towards the other tree root)\n                if random.random() < self.goal_sample_rate:\n                    sample = tree_b[0].position\n                else:\n                    sample = tuple(random.uniform(0.0, bounds[d]) for d in range(len(bounds)))\n\n                nearest = nearest_node(tree_a, sample)\n                new_pos = steer(nearest, sample)\n\n                if not collision_free(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                edges.append((nearest, new_node))\n\n                # Rewire strategy for RRT*\n                neighbors = near_nodes(tree_a, new_node)\n                for neighbor in neighbors:\n                    if neighbor == nearest:\n                        continue\n                    potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if potential_cost < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                        neighbor.set_parent(new_node, potential_cost)\n                        # Update edges to reflect rewiring\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        edges.append((new_node, neighbor))\n\n                # Check connection to other tree\n                connected_node = try_connect(tree_a, tree_b, new_node)\n                if connected_node:\n                    # Build full path\n                    path_from_start = []\n                    node = None\n                    if tree_a is tree_start:\n                        node = new_node\n                    else:\n                        node = connected_node\n                    while node:\n                        path_from_start.append(node.position)\n                        node = node.parent\n                    path_from_start = path_from_start[::-1]\n\n                    path_from_goal = []\n                    node = None\n                    if tree_a is tree_start:\n                        node = connected_node\n                    else:\n                        node = new_node\n                    while node:\n                        path_from_goal.append(node.position)\n                        node = node.parent\n\n                    extracted_path = path_from_start + path_from_goal\n                    success_state = True\n                    break\n            if success_state:\n                break\n\n        if success_state:\n            # Path smoothing via shortcutting\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=tree_start + tree_goal,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) -1:\n            next_idx = len(path) -1\n            for j in range(len(path) -1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            smoothed.append(path[next_idx])\n            idx = next_idx\n        # Clamp path points within bounds\n        clamped_path = []\n        for p in smoothed:\n            clamped = tuple(\n                max(0.0, min(p[d], bounds[d])) for d in range(len(bounds))\n            )\n            clamped_path.append(clamped)\n        return clamped_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -21.45165,
    "time_improvement": 32.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021691560745239258,
            "num_nodes_avg": 88.2,
            "path_length_avg": 167.65248055838853,
            "smoothness_avg": 0.04611375164900843,
            "success_improvement": 0.0,
            "time_improvement": 13.821797408620192,
            "length_improvement": 8.10701878238765,
            "smoothness_improvement": 621.7803509214458,
            "objective_score": 8.876844733670817
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04520514011383057,
            "num_nodes_avg": 262.4,
            "path_length_avg": 236.36653822500003,
            "smoothness_avg": 0.11826030550714299,
            "success_improvement": 0.0,
            "time_improvement": 72.07872627552989,
            "length_improvement": 21.0940461069188,
            "smoothness_improvement": 2942.9228401538667,
            "objective_score": 40.55704130481206
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.043665170669555664,
            "num_nodes_avg": 277.2,
            "path_length_avg": 129.61753426148306,
            "smoothness_avg": 0.14488075464607306,
            "success_improvement": 0.0,
            "time_improvement": 11.412842900668906,
            "length_improvement": 13.91420546723941,
            "smoothness_improvement": 1742.8725051131419,
            "objective_score": 14.921056489214264
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid algorithm combines bidirectional incremental tree growth with rewiring optimization and goal biasing to enhance path quality, success rate, and planning efficiency. It samples with goal bias, grows two trees from start and goal, extends and rewires locally to minimize path cost, attempts connection between trees, and post-processes the path via shortcut smoothing to reduce length and improve smoothness.",
    "planning_mechanism": "The planner grows two trees from start and goal, sampling randomly with goal bias, steering towards samples with fixed step size. Upon each extension, it rewires neighbors to optimize costs. It attempts to connect the two trees each iteration. When connected, it extracts a combined path and applies shortcut smoothing by attempting to replace path segments with collision-free straight lines, yielding a shorter, smoother path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def collision_free(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if any(self._is_edge_in_obstacle(node.position, pos, obstacles, is_3d) for node in nodes if node.parent is None or node.parent is not None):\n                # This check in loop is expensive, so we only do edge checks on increments, below we do dedicated checking\n                pass\n            return True\n\n        def is_node_valid(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_valid(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def extend_and_rewire(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_node_valid(new_pos) or not is_edge_valid(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            neighbors = near_nodes(tree, new_pos, self.rewire_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and is_edge_valid(neighbor.position, new_pos):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and is_edge_valid(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def connect_trees(node_from_start, tree_goal):\n            nearest_in_goal = nearest(tree_goal, node_from_start.position)\n            current = nearest_in_goal\n            while True:\n                new_pos = steer(current.position, node_from_start.position)\n                if not is_node_valid(new_pos) or not is_edge_valid(current.position, new_pos):\n                    return None\n                connect_node = Node(new_pos)\n                neighbors = near_nodes(tree_goal, new_pos, self.rewire_radius)\n\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for neighbor in neighbors:\n                    cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if cost < min_cost and is_edge_valid(neighbor.position, new_pos):\n                        min_cost = cost\n                        best_parent = neighbor\n\n                best_parent.add_child(connect_node)\n                connect_node.cost = min_cost\n                tree_goal.append(connect_node)\n                nodes.append(connect_node)\n                edges.append((best_parent, connect_node))\n\n                for neighbor in neighbors:\n                    new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                    if new_cost < neighbor.cost and is_edge_valid(connect_node.position, neighbor.position):\n                        if neighbor.parent:\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                            if neighbor in neighbor.parent.children:\n                                neighbor.parent.children.remove(neighbor)\n                        neighbor.parent = connect_node\n                        neighbor.cost = new_cost\n                        connect_node.add_child(neighbor)\n                        edges.append((connect_node, neighbor))\n\n                if math.dist(connect_node.position, node_from_start.position) <= self.step_size:\n                    return connect_node\n                current = connect_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate join node\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            \"\"\"Attempt to shortcut path by replacing intermediate nodes with direct connections if obstacle-free.\"\"\"\n            if len(path) <= 2:\n                return path\n            import math\n            i = 0\n            new_path = [path[0]]\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                new_path.append(path[j])\n                i = j\n            return new_path\n\n        for i in range(self.max_iter):\n            p_sample = sample()\n\n            new_start = extend_and_rewire(tree_start, p_sample)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_goal = connect_trees(new_start, tree_goal)\n            if new_goal is not None:\n                success_state = True\n                extracted_path = extract_full_path(new_start, new_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 40.69164,
    "time_improvement": 46.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021788787841796876,
            "num_nodes_avg": 78.6,
            "path_length_avg": 163.49386596699551,
            "smoothness_avg": 0.04051967421901699,
            "success_improvement": 0.0,
            "time_improvement": 13.435524769093643,
            "length_improvement": 10.386421337395337,
            "smoothness_improvement": 534.2208914085094,
            "objective_score": 8.779046155249707
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.05285842418670654,
            "num_nodes_avg": 274.7,
            "path_length_avg": 216.84767075060682,
            "smoothness_avg": 0.09950157634370833,
            "success_improvement": -19.999999999999996,
            "time_improvement": 67.35162137215367,
            "length_improvement": 27.610005889320576,
            "smoothness_improvement": 2460.24722741221,
            "objective_score": -61.971276273428714
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.020376372337341308,
            "num_nodes_avg": 150.2,
            "path_length_avg": 109.82565195988104,
            "smoothness_avg": 0.13533536564407955,
            "success_improvement": -19.999999999999996,
            "time_improvement": 58.66076166235932,
            "length_improvement": 27.05903130380518,
            "smoothness_improvement": 1621.455861575111,
            "objective_score": -68.88268593265559
        }
    ],
    "success_rate": 0.8666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm combines the asymptotic optimality of the bidirectional RRT* approach with goal biasing and path smoothing to improve planning efficiency, path quality, and success rate. It grows two optimized trees from start and goal, rewires locally to minimize cost, incorporates goal biasing samples to accelerate convergence, and applies a post-processing smoothening step on the found path for better path lengths and smoothness.",
    "planning_mechanism": "The planner alternates growth between two trees (start and goal) by sampling free points with a goal bias, extending and rewiring the trees towards samples, attempts to connect the trees, and when successful, extracts the path and applies shortcut smoothing to reduce unnecessary waypoints and improve path quality. Throughout, collision checks for nodes and edges are strictly enforced, and rewiring improves path cost robustly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.1, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                raw_path = path_a + path_b[::-1]\n                extracted_path = self._shortcut_smooth(raw_path, obstacles, is_3d)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, self.rewire_radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    if neighbor in neighbor.parent.children:\n                        neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        current_pos = nearest.position\n        while True:\n            new_pos = self._steer(current_pos, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, self.rewire_radius)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n            current_pos = connect_node.position\n\n    def _shortcut_smooth(self, path, obstacles, is_3d):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        max_iter = 100\n        smooth_path = path[:]\n\n        for _ in range(max_iter):\n            if len(smooth_path) <= 2:\n                break\n            i = random.randint(0, len(smooth_path) - 3)\n            j = random.randint(i + 2, len(smooth_path) - 1)\n\n            # Check if direct connection possible without collision\n            if not self._is_edge_in_obstacle(smooth_path[i], smooth_path[j], obstacles, is_3d):\n                # Remove intermediate points between i and j\n                smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n        return smooth_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 31.21818,
    "time_improvement": 24.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03234224319458008,
            "num_nodes_avg": 94.5,
            "path_length_avg": 158.65577729700198,
            "smoothness_avg": 0.04307841512403752,
            "success_improvement": 0.0,
            "time_improvement": -28.492201138358165,
            "length_improvement": 13.038254401839753,
            "smoothness_improvement": 574.270742966889,
            "objective_score": -3.068655746305053
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.0382080078125,
            "num_nodes_avg": 242.4,
            "path_length_avg": 218.52081984692646,
            "smoothness_avg": 0.09989758274776599,
            "success_improvement": -9.999999999999998,
            "time_improvement": 76.40055440790215,
            "length_improvement": 27.05146056204259,
            "smoothness_improvement": 2470.436757420497,
            "objective_score": -9.317357778118346
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.038083887100219725,
            "num_nodes_avg": 176.3,
            "path_length_avg": 106.81298646394683,
            "smoothness_avg": 0.10375352802878442,
            "success_improvement": -19.999999999999996,
            "time_improvement": 22.736056271672762,
            "length_improvement": 29.059900278489863,
            "smoothness_improvement": 1219.7372182373226,
            "objective_score": -81.26851697161358
        }
    ],
    "success_rate": 0.9
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines Rapidly-exploring Random Tree (RRT) basic sampling with a rewiring step inspired by RRT* to improve path quality and efficiency. It uses goal bias sampling and incremental tree building while periodically attempting to rewire nodes locally to reduce overall path cost, resulting in smoother, shorter, and more robust paths. Collision checks for new nodes and edges are strictly enforced to maintain validity.",
    "planning_mechanism": "The planner samples random points with goal bias, extends the nearest tree node toward samples, and adds collision-free nodes. It rewires nearby nodes if a lower-cost connection is found, improving path optimality incrementally without sacrificing exploration. The search terminates when the goal is reached within a step size or maximum iterations expire.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            dir_vect = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n            length = distance(from_pos, to_pos)\n            if length == 0:\n                return None\n            scale = min(max_dist, length) / length\n            new_pos = tuple(from_pos[d] + dir_vect[d] * scale for d in range(len(from_pos)))\n            return new_pos\n\n        def get_nearest_node(pos):\n            return min(nodes, key=lambda n: distance(n.position, pos))\n\n        def get_near_nodes(pos, radius):\n            return [node for node in nodes if distance(node.position, pos) <= radius]\n\n        for iter in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = get_nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n            if new_pos is None:\n                continue\n\n            # Boundary check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + distance(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes for path quality improvement\n            near_nodes = get_near_nodes(new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node == nearest:\n                    continue\n                edge_cost = distance(new_pos, near_node.position)\n                potential_cost = new_node.cost + edge_cost\n                if potential_cost < near_node.cost:\n                    # Check if edge between new_node and near_node is collision free\n                    if (not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(near_node.position, obstacles, is_3d)):\n                        # Rewire\n                        # Remove near_node from old parent's children list\n                        if near_node.parent is not None:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        # Update costs in the subtree rooted at near_node\n                        self._update_subtree_costs(near_node, distance)\n\n            # Check goal reach\n            if distance(new_pos, goal_position) <= self.step_size:\n                # Check goal edge collision\n                if (not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and\n                    not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + distance(new_pos, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    new_node = goal_node\n                    break\n\n        if success_state:\n            path = []\n            node = new_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_subtree_costs(self, root_node, distance_func):\n        # BFS update of cost for subtree nodes after rewiring\n        from collections import deque\n        queue = deque([root_node])\n        while queue:\n            node = queue.popleft()\n            if node.parent is not None:\n                node.cost = node.parent.cost + distance_func(node.position, node.parent.position)\n            for child in node.children:\n                queue.append(child)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 56.5407,
    "time_improvement": -198.0,
    "length_improvement": 11.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.09297432899475097,
            "num_nodes_avg": 305.5,
            "path_length_avg": 180.54776566815573,
            "smoothness_avg": 0.01304869598517903,
            "success_improvement": 0.0,
            "time_improvement": -269.29535476588217,
            "length_improvement": 1.0389086748554386,
            "smoothness_improvement": 104.24042786491216,
            "objective_score": -80.05962255546899
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.41061508655548096,
            "num_nodes_avg": 930.4,
            "path_length_avg": 239.581590952644,
            "smoothness_avg": 0.010745015119273862,
            "success_improvement": 0.0,
            "time_improvement": -148.81508165884955,
            "length_improvement": 20.020768966269504,
            "smoothness_improvement": 176.47697834048114,
            "objective_score": -39.75798581269856
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.14150092601776124,
            "num_nodes_avg": 498.6,
            "path_length_avg": 132.2878475866428,
            "smoothness_avg": 0.018921492691862447,
            "success_improvement": 0.0,
            "time_improvement": -176.4534000860805,
            "length_improvement": 12.140710503324602,
            "smoothness_improvement": 140.67999040117982,
            "objective_score": -49.804477973153325
        }
    ],
    "smoothness_improvement": 140.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner that grows two trees simultaneously from the start and goal positions while optimizing path quality by rewiring around new nodes to achieve shorter paths. It integrates collision checking and edge validation rigorously to ensure robustness and path feasibility. The approach improves success rates and reduces search times by focusing explorations efficiently and smoothing paths during planning.",
    "planning_mechanism": "The planner alternately extends the start and goal trees towards random free samples, attempts to connect the trees, and applies rewiring to improve the path cost locally. When the trees connect, it reconstructs the path by merging their solutions. Rigorous collision and edge checks are performed for node validity. The rewiring step iteratively updates parents of nearby nodes if a better cost path is found through the newly added node, enhancing path quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path: list[tuple] = []\n\n        start_root = Node(start_pos, parent=None, cost=0.0)\n        goal_root = Node(goal_pos, parent=None, cost=0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def near_nodes(tree, new_node):\n            rn = self.neighbor_radius\n            return [node for node in tree if math.dist(node.position, new_node.position) <= rn]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def add_node(tree, new_pos, parent_node):\n            cost_from_parent = parent_node.cost + math.dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent_node, cost_from_parent)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node)\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                dist_to_new = math.dist(new_node.position, node.position)\n                new_cost = new_node.cost + dist_to_new\n                if new_cost < node.cost and can_connect(new_node.position, node.position):\n                    # Rewire parent\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            old_parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.children.append(node)\n                    # Update edges list for the rewiring\n                    # Remove old edge\n                    try:\n                        edges.remove((old_parent, node))\n                    except ValueError:\n                        pass\n                    edges.append((new_node, node))\n                    # Recursively update costs of descendants\n                    self._update_costs_descendants(node)\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            for tree_src, tree_tgt in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_src, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not can_connect(nearest_node.position, new_pos):\n                    continue\n                new_node = add_node(tree_src, new_pos, nearest_node)\n                rewire(tree_src, new_node)\n\n                # Try connecting to other tree\n                nearest_target = nearest(tree_tgt, new_node.position)\n                if can_connect(new_node.position, nearest_target.position):\n                    connecting_node = add_node(tree_tgt, nearest_target.position, nearest_target.parent if nearest_target.parent else nearest_target)\n                    # Link new_node and connecting_node by setting parents accordingly\n                    # Connect new_node -> connecting_node or vice versa depends on tree roles\n                    # We create a shortcut edge in other tree if needed\n                    # Simplify by assuming connecting_node is nearest_target itself since no new node is added\n\n                    total_path = self._extract_full_path(new_node, nearest_target)\n                    if total_path:\n                        extracted_path = total_path\n                        success_state = True\n                        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n            # Swap trees for next iteration to balance growth\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _update_costs_descendants(self, node):\n        # Recursive update of costs for subtree below node after rewiring\n        for child in node.children:\n            child.cost = node.cost + math.dist(node.position, child.position)\n            self._update_costs_descendants(child)\n\n    def _extract_full_path(self, node_start_tree, node_goal_tree):\n        # Extract path from start root to node_start_tree\n        path_start = []\n        node = node_start_tree\n        while node:\n            path_start.append(node.position)\n            node = node.parent\n        path_start.reverse()\n\n        # Extract path from node_goal_tree to goal root\n        path_goal = []\n        node = node_goal_tree\n        while node:\n            path_goal.append(node.position)\n            node = node.parent\n\n        # Avoid duplicating meet point if same node\n        if path_start[-1] == path_goal[0]:\n            path_goal = path_goal[1:]\n\n        return path_start + path_goal\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.64222,
    "time_improvement": 14.0,
    "length_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.032508444786071775,
            "num_nodes_avg": 107.8,
            "path_length_avg": 199.59364496649934,
            "smoothness_avg": 0.010782634789436678,
            "success_improvement": 0.0,
            "time_improvement": -29.12400422741684,
            "length_improvement": -9.400439569837324,
            "smoothness_improvement": 68.7716493208972,
            "objective_score": -10.273430935588031
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043404030799865725,
            "num_nodes_avg": 215.7,
            "path_length_avg": 279.15852204878036,
            "smoothness_avg": 0.007839119789248315,
            "success_improvement": 0.0,
            "time_improvement": 73.69902416789888,
            "length_improvement": 6.808850207579963,
            "smoothness_improvement": 101.7061984671186,
            "objective_score": 23.98000828422125
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05189414024353027,
            "num_nodes_avg": 249.6,
            "path_length_avg": 149.3506433285222,
            "smoothness_avg": 0.015321086115321444,
            "success_improvement": 0.0,
            "time_improvement": -1.3866970246335524,
            "length_improvement": 0.8084140145896085,
            "smoothness_improvement": 94.88308450194768,
            "objective_score": 0.2200891180375944
        }
    ],
    "smoothness_improvement": 88.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an optimized bidirectional RRT* planner with adaptive radius tuning and goal biasing, aimed at improving planning efficiency, path quality, and success rate. It grows two trees from start and goal while dynamically rewiring nodes within an adaptive radius to minimize cost and frequently attempts connection between trees with careful collision checks. Enhanced sampling near the goal and adaptive rewiring radius improve convergence speed and path smoothness.",
    "planning_mechanism": "The planner alternately grows two trees by sampling points with a goal bias, extending trees toward sampled points with fixed step size, rewiring neighbors within an adaptively scaled radius to optimize costs, and attempts to connect the trees at each iteration. Collision validity is strictly checked for nodes and edges. The path is extracted once the trees are connected, returning the optimized combined path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, base_radius: float = 30.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = base_radius     # Max rewiring radius\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling goal to bias search\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a,b): return math.dist(a,b)\n        volume = 1\n        for b in bounds:\n            volume *= b\n        dim = len(bounds)\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_a, tree_b = [start_root], [goal_root]\n        success_state = False\n        extracted_path = []\n\n        for iter_num in range(1, self.max_iter + 1):\n            radius = min(self.base_radius * (math.log(iter_num) / iter_num) ** (1/dim), self.base_radius)\n\n            # Goal biased sampling for faster convergence\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges, radius)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            connect_node = self._nearest(tree_b, new_a.position)\n            if dist(connect_node.position, new_a.position) <= self.step_size and \\\n               not self._is_edge_in_obstacle(connect_node.position, new_a.position, obstacles, is_3d):\n                # Try to connect trees by adding a new node in tree_b towards new_a\n                new_b = self._extend_and_rewire(tree_b, new_a.position, obstacles, is_3d, nodes, edges, radius)\n                if new_b:\n                    success_state = True\n                    path_a = new_a.path_from_root()\n                    path_b = new_b.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, target_point, obstacles, is_3d, nodes, edges, radius):\n        nearest = self._nearest(tree, target_point)\n        new_pos = self._steer(nearest.position, target_point)\n\n        # Collision checks for node and edge\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors for potential better cost\n        for neighbor in neighbors:\n            if neighbor == best_parent:\n                continue\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    except Exception:\n                        pass\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.76639,
    "time_improvement": 32.0,
    "length_improvement": -1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.029661917686462404,
            "num_nodes_avg": 163.9,
            "path_length_avg": 185.48815011793954,
            "smoothness_avg": 0.013437297972123261,
            "success_improvement": -9.999999999999998,
            "time_improvement": -17.81755817433171,
            "length_improvement": -1.6689943274723857,
            "smoothness_improvement": 110.32289282331054,
            "objective_score": -55.127451853677435
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04360947608947754,
            "num_nodes_avg": 342.8,
            "path_length_avg": 300.1341930293572,
            "smoothness_avg": 0.006879041384904136,
            "success_improvement": 0.0,
            "time_improvement": 73.57453315871555,
            "length_improvement": -0.19343251694987623,
            "smoothness_improvement": 77.00268960681954,
            "objective_score": 22.418686892258787
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030527329444885253,
            "num_nodes_avg": 225.7,
            "path_length_avg": 151.67279605712346,
            "smoothness_avg": 0.014920581950300557,
            "success_improvement": 0.0,
            "time_improvement": 40.358100416055684,
            "length_improvement": -0.733849258717081,
            "smoothness_improvement": 89.78870108502437,
            "objective_score": 12.409603778498411
        }
    ],
    "smoothness_improvement": 92.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is an optimized variant of RRT* that incrementally builds a tree from the start towards the goal by sampling points, extending towards them, and rewiring the tree to lower path costs. It balances exploration and exploitation with goal biasing, collision checking for nodes and edges, and rewiring for path improvement.",
    "planning_mechanism": "The planner samples random points with optional goal bias, chooses the best parent among nearby nodes for the new sample to minimize cost, adds collision-free edges, and rewires neighbors to improve the tree while iterating until a feasible path to the goal is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children: List[Node] = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Sample with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node to sample\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards sample within step_size\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            unit_dir = tuple(d / dist for d in direction)\n            new_pos = tuple(nearest_node.position[d] + unit_dir[d] * min(self.step_size, dist) for d in range(len(bounds)))\n\n            # Check bounds\n            if any(not (0 <= new_pos[d] <= bounds[d]) for d in range(len(bounds))):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and find neighbors within radius\n            new_node = Node(new_pos)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent among neighbors to minimize cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_temp = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_temp < min_cost:\n                    min_cost = cost_temp\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n\n            # Add new node and edge\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                        # Update parent and edges\n                        if near_node.parent:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if goal is reachable from new_node\n            if math.dist(new_pos, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_pos, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    cur = goal_node\n                    while cur:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution: float = 1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 144.10997,
    "time_improvement": -497.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.23091566562652588,
            "num_nodes_avg": 251.2,
            "path_length_avg": 164.50977998465356,
            "smoothness_avg": 0.01980902585763928,
            "success_improvement": 0.0,
            "time_improvement": -817.2003022830324,
            "length_improvement": 9.82958276612918,
            "smoothness_improvement": 210.05427066019936,
            "objective_score": -242.1439027783829
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.0462196826934815,
            "num_nodes_avg": 972.5,
            "path_length_avg": 225.1297112772796,
            "smoothness_avg": 0.01629291155887199,
            "success_improvement": 0.0,
            "time_improvement": -533.9641291949982,
            "length_improvement": 24.84522237619828,
            "smoothness_improvement": 319.22834971962743,
            "objective_score": -153.62405253466167
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.12341940402984619,
            "num_nodes_avg": 302.2,
            "path_length_avg": 118.7171316911566,
            "smoothness_avg": 0.032160996705163716,
            "success_improvement": 0.0,
            "time_improvement": -141.12714199740267,
            "length_improvement": 21.15373383305823,
            "smoothness_improvement": 309.0855042118392,
            "objective_score": -36.56196831154996
        }
    ],
    "smoothness_improvement": 279.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an improved hybrid bidirectional RRT* algorithm integrating informed ellipsoidal sampling, KD-tree acceleration, adaptive neighbor radius, collision caching, incremental rewiring, periodic pruning, and aggressive shortcut smoothing for fast convergence to short and smooth paths. It employs balanced tree growth, enhanced nearest and radius search, and rigorous collision and boundary checks to improve path length, planning time, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling points within an ellipsoid defined by the current best path cost for focused exploration. KD-trees accelerate nearest neighbor and radius queries for rewiring, collision results are cached to reduce redundant checks, and nodes are periodically pruned to remove suboptimal branches. Upon successful tree connection, the best path undergoes shortcut smoothing to improve path quality. This combination ensures efficient, reliable, and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.44167,
    "time_improvement": 39.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02169802188873291,
            "num_nodes_avg": 80.9,
            "path_length_avg": 157.57814870223828,
            "smoothness_avg": 0.04764540259502782,
            "success_improvement": 0.0,
            "time_improvement": 13.8151490012917,
            "length_improvement": 13.628919710747569,
            "smoothness_improvement": 645.7540142599136,
            "objective_score": 10.099098713836593
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05104916095733643,
            "num_nodes_avg": 217.4,
            "path_length_avg": 235.39968977102907,
            "smoothness_avg": 0.09157597560954919,
            "success_improvement": 0.0,
            "time_improvement": 69.0664041139677,
            "length_improvement": 21.41680795004402,
            "smoothness_improvement": 2256.3158119428285,
            "objective_score": 36.284861883913266
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03416609764099121,
            "num_nodes_avg": 154.4,
            "path_length_avg": 124.42529858311859,
            "smoothness_avg": 0.12568992365837842,
            "success_improvement": 0.0,
            "time_improvement": 33.24896079238765,
            "length_improvement": 17.362641177115243,
            "smoothness_improvement": 1498.7665514694615,
            "objective_score": 20.94104923048665
        }
    ],
    "smoothness_improvement": 1467.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner builds upon the bidirectional RRT* framework with adaptive informed sampling and balanced bidirectional tree growth. It incorporates an enhanced dynamic radius rewiring strategy with logarithmic decay, efficient collision checks, and periodic dead-end pruning to maintain computational efficiency. Additionally, the sampling bias dynamically adjusts based on the relative sizes of the trees for faster convergence. Iterative shortcut smoothing is applied upon finding a connection to yield shorter and smoother paths. To reduce computation overhead, caching of nearest neighbors and radius computations optimize rewiring steps, and the edge collision checks are done with adaptive resolution. Tree growth always favors expanding the smaller tree to keep search balanced and minimize redundant expansions. This results in faster planning with higher success rates and improved path quality while strictly enforcing collision-free, map-bound paths.",
    "planning_mechanism": "The planner alternates extension between start and goal trees, sampling adaptively biased towards start or goal to accelerate progress. Each extension rewires neighbors within a dynamically shrinking radius to optimize local costs. Upon connecting the two trees, the path is extracted and refined via shortcut smoothing iterations to shorten and smooth the trajectory. Dead-end nodes are pruned periodically to reduce computational load. The planner uses rigorous collision and boundary checks for nodes and edges, enforcing feasibility. This balanced and adaptive growth approach promotes rapid, robust convergence to high-quality, smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost update down children recursively to keep consistency\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + sum((self._distance(self.parent.position, self.position),))\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 5.0,\n                 prune_interval: int = 100,\n                 prune_threshold: int = 120,\n                 smoothing_iterations: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(size_start, size_goal):\n            p_bias = 0.75\n            # Adaptive bias sampling proportion based on tree size ratio\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            # With prob goal_sample_rate sample biased between start and goal, else uniform free\n            if random.random() < self.goal_sample_rate:\n                # Choose start or goal with bias proportional to size\n                if random.random() < (bias_goal * p_bias):\n                    return goal_position\n                elif random.random() < (bias_start * p_bias / (1 - bias_goal * p_bias)):\n                    return start_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Optimized nearest using simple linear search (can be replaced by spatial indexing)\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            # Logarithmic decay for radius to balance exploration\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            # Collision and bounds check\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost efficiently\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            # Remove leaf nodes (dead-ends) except roots\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Always extend the smaller tree first to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Combined path: start->connection->goal reversed (avoid double joint node)\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.82279,
    "time_improvement": 35.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027561044692993163,
            "num_nodes_avg": 82.4,
            "path_length_avg": 159.95946170997846,
            "smoothness_avg": 0.03919379441318278,
            "success_improvement": 0.0,
            "time_improvement": -9.47286081722483,
            "length_improvement": 12.323684316885842,
            "smoothness_improvement": 513.4679932531224,
            "objective_score": 2.1902185844753315
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05026965141296387,
            "num_nodes_avg": 123.5,
            "path_length_avg": 241.28509223189593,
            "smoothness_avg": 0.0937151505467923,
            "success_improvement": 0.0,
            "time_improvement": 69.53875337069844,
            "length_improvement": 19.452091206689573,
            "smoothness_improvement": 2311.3583238635224,
            "objective_score": 36.308835871865064
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027540087699890137,
            "num_nodes_avg": 118.2,
            "path_length_avg": 123.18829835962379,
            "smoothness_avg": 0.10965737125236882,
            "success_improvement": 0.0,
            "time_improvement": 46.19433881056144,
            "length_improvement": 18.184197825939695,
            "smoothness_improvement": 1294.8336682649397,
            "objective_score": 23.96930954968107
        }
    ],
    "smoothness_improvement": 1373.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation enhances the bidirectional informed RRT* planner by integrating a dynamically adaptive informed sampling ellipsoid, efficient KD-tree neighbor searches, collision caching, incremental rewiring, and aggressive pruning. Additionally, it emphasizes path quality by incorporating a more robust shortcut smoothing method that leverages edge shortcuts verified by collision checks. The planner maintains two trees rooted at start and goal, iteratively growing and rewiring them to minimize path length, while pruning non-promising nodes to reduce computational overhead. These improvements collectively boost planning efficiency, path quality, success rate, and smoothness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions, samples nodes adaptively within an ellipsoid that shrinks as better paths are found, uses KD-tree-based nearest neighbor and radius queries for rewiring and extension, caches collision outcomes to avoid redundant computations, prunes nodes that cannot improve the current best path, and applies shortcut smoothing on the final path to reduce length and improve smoothness. It stops upon finding a connecting path or after reaching the maximum iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...] position in 2D or 3D\n        self.parent = parent          # Parent Node or None\n        self.cost = cost              # Cost from root to this node\n        self.children = []            # Children Nodes\n        self.valid = True             # For collision validity if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree with simple linear search (quicker for small data, can upgrade to balanced structure)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling inside ellipsoid based on current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for obstacle free\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Allow more tries but break early for efficiency\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform sampling if ellipsoid fails\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path: list = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction depending on size for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connecting trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Mark success and update best path\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to yield improvement\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.24121,
    "time_improvement": 39.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02421252727508545,
            "num_nodes_avg": 84.0,
            "path_length_avg": 163.03586017152315,
            "smoothness_avg": 0.03982455083038601,
            "success_improvement": 0.0,
            "time_improvement": 3.8274979071256188,
            "length_improvement": 10.63746157146,
            "smoothness_improvement": 523.3407008918359,
            "objective_score": 5.892445190888865
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05236344337463379,
            "num_nodes_avg": 227.1,
            "path_length_avg": 234.57044411783062,
            "smoothness_avg": 0.09292093831093264,
            "success_improvement": 0.0,
            "time_improvement": 68.27000549713694,
            "length_improvement": 21.69363401759437,
            "smoothness_improvement": 2290.922670986902,
            "objective_score": 36.27434180759447
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.028946614265441893,
            "num_nodes_avg": 132.5,
            "path_length_avg": 123.69278957364477,
            "smoothness_avg": 0.13291123176527828,
            "success_improvement": 0.0,
            "time_improvement": 43.44637763248849,
            "length_improvement": 17.849138782877038,
            "smoothness_improvement": 1590.6210575677087,
            "objective_score": 24.556846334160497
        }
    ],
    "smoothness_improvement": 1468.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an RRT* (Rapidly-exploring Random Tree Star) planner, which incrementally builds a tree by sampling points in the configuration space and rewires the tree to minimize path costs, resulting in asymptotically optimal paths. It combines goal biasing for faster convergence, radius-based neighbor search for rewiring, and pruning of suboptimal branches to improve path quality, smoothness, and success rate.",
    "planning_mechanism": "The planner samples random points with occasional goal biasing, extends towards these points, and connects valid nodes within a computed radius to rewire for lower-cost paths. Each extension and edge is verified for collision and obstacle intersections. Once the goal is reached, the path is extracted by backtracking from the goal node.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        dim = len(bounds)\n        unit_ball_volume = {2: math.pi, 3: 4 / 3 * math.pi}[dim] if dim in [2, 3] else 1.0\n\n        for i in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                if is_3d:\n                    sample = (random.uniform(0, bounds[0]),\n                              random.uniform(0, bounds[1]),\n                              random.uniform(0, bounds[2]))\n                else:\n                    sample = (random.uniform(0, bounds[0]),\n                              random.uniform(0, bounds[1]))\n\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = self._nearest(nodes, sample)\n\n            new_position = self._steer(nearest_node.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Prepare cost for new node\n            dist_from_nearest = math.dist(nearest_node.position, new_position)\n            new_cost = nearest_node.cost + dist_from_nearest\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n\n            # Radius for rewiring (RRT* radius)\n            gamma_rrt = 30.0  # Scaling constant, adjust if needed\n            radius = min(self.step_size * 5.0, \n                         gamma_rrt * ((math.log(len(nodes) + 1) / (len(nodes) + 1)) ** (1 / dim)))\n\n            # Find neighbors within radius\n            neighbors = [node for node in nodes if math.dist(node.position, new_position) <= radius]\n\n            # Choose the parent that produces the lowest cost to new_node\n            min_cost = new_node.cost\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(neighbor.position, new_position, obstacles, is_3d):\n                    continue\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_position)\n                if cost_through_neighbor < min_cost:\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            if best_parent != nearest_node:\n                # Reassign parent for new_node\n                new_node.parent.children.remove(new_node)\n                new_node.parent = best_parent\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if routing through new_node reduces cost\n            for neighbor in neighbors:\n                if neighbor == best_parent or neighbor == new_node:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost_through_new_node = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost_through_new_node < neighbor.cost:\n                    # Rewire neighbor to new_node\n                    if neighbor.parent is not None:\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost_through_new_node\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Check if we can connect to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and \\\n                   not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearest(self, nodes, point):\n        import math\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 26.01331,
    "time_improvement": -92.0,
    "length_improvement": 6.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0791013240814209,
            "num_nodes_avg": 281.4,
            "path_length_avg": 175.96523994861022,
            "smoothness_avg": 0.012761885458867472,
            "success_improvement": 0.0,
            "time_improvement": -214.1915822887902,
            "length_improvement": 3.550663636505194,
            "smoothness_improvement": 99.75122030910985,
            "objective_score": -63.048585857790464
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.23334090709686278,
            "num_nodes_avg": 865.0,
            "path_length_avg": 284.3191644666365,
            "smoothness_avg": 0.006692292737075871,
            "success_improvement": 0.0,
            "time_improvement": -41.394553572525,
            "length_improvement": 5.086079227643657,
            "smoothness_improvement": 72.19751238858414,
            "objective_score": -11.040162664285846
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06193044185638428,
            "num_nodes_avg": 408.5,
            "path_length_avg": 137.107263085941,
            "smoothness_avg": 0.01665580039402449,
            "success_improvement": 0.0,
            "time_improvement": -20.994835170772888,
            "length_improvement": 8.939884204595412,
            "smoothness_improvement": 111.86055160869034,
            "objective_score": -3.951170952269332
        }
    ],
    "smoothness_improvement": 95.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges the bidirectional informed RRT* approach with incremental rewiring and goal biasing for efficient exploration. It adaptively samples within a shrinking informed ellipsoid around the best path found, employs KD-tree accelerated neighbor searches, caches collision checks to avoid redundant computations, and aggressively prunes nodes unlikely to improve the solution. The planner alternates tree growth from start and goal to rapidly connect the two, and applies robust shortcut smoothing to enhance final path quality and smoothness. These combined techniques optimize planning efficiency, path quality, success rate, and computational overhead in complex 2D/3D environments.",
    "planning_mechanism": "The planner maintains two trees from start and goal positions, alternately sampling adaptively and extending towards sampled points with step-size control. It uses KD-tree-based searches to select best parents minimizing cost, rewires neighbors for incremental path improvement, and attempts connection between trees each iteration. Collision checking of nodes and edges is cached and leveraged extensively. The best path is adaptively refined and periodically pruned during iterations to reduce search space. Upon successful connection, a shortcut smoothing phase improves path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from tree root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.1,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # Use informed sampling inside ellipsoid\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for collision-free sample\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback: random anyway\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            # Try multiple times for collision-free sample\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback again to uniform if ellipsoid fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            # check if pos inside any obstacle\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KDTree with linear search (sufficient for moderate node counts)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        # Trees: lists of nodes for start and goal sides\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        # All nodes and edges\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample point with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth tree selection for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            # Build KDTree for tree_a and find nearest to q_rand\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect trees via new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            # Extend tree_b towards new_node stepwise\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Depending on tree assignment, assemble path\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Shortcut smoothing to improve path quality\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    # Collision helpers unchanged\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -21.39406,
    "time_improvement": 33.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01638748645782471,
            "num_nodes_avg": 69.8,
            "path_length_avg": 156.77104356827704,
            "smoothness_avg": 0.042380982844713186,
            "success_improvement": 0.0,
            "time_improvement": 34.90867112893999,
            "length_improvement": 14.071306824071005,
            "smoothness_improvement": 563.3544132970283,
            "objective_score": 16.10363476998134
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06851754188537598,
            "num_nodes_avg": 279.8,
            "path_length_avg": 234.47724576367142,
            "smoothness_avg": 0.10093387513099414,
            "success_improvement": 0.0,
            "time_improvement": 58.4813165968027,
            "length_improvement": 21.724746310778592,
            "smoothness_improvement": 2497.1013068521906,
            "objective_score": 34.37485077545748
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04835000038146973,
            "num_nodes_avg": 213.9,
            "path_length_avg": 123.59421078042612,
            "smoothness_avg": 0.14087353326908802,
            "success_improvement": 0.0,
            "time_improvement": 5.537565189200058,
            "length_improvement": 17.914610123515168,
            "smoothness_improvement": 1691.9009449802068,
            "objective_score": 13.703696306364085
        }
    ],
    "smoothness_improvement": 1584.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates a goal-biased bidirectional RRT* approach with adaptive rewiring and dynamic neighborhood radius to enhance planning efficiency, path optimality, and robustness. It grows two trees simultaneously from the start and goal states, attempts connection between them at each iteration, and performs local rewiring using an adaptive radius that shrinks as more nodes are explored, promoting smoother and shorter paths. Strict collision checks on nodes and edges ensure validity. The planner thus leverages the fast convergence of bidirectional search and asymptotic optimality of RRT*, while reducing search time and improving path quality.",
    "planning_mechanism": "The planner alternates expanding two trees grown from the start and goal by sampling points with goal bias and steering towards them. After each extension, it attempts to connect the new node to the other tree. Nearby nodes within an adaptive radius are rewired if a lower-cost connection is possible. The adaptive radius decreases with tree size for finer local optimization as the search proceeds. The search terminates upon successful tree connection within step size, extracting a concatenated optimal path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent                # Parent Node or None\n        self.cost = cost                    # Cost from root to this node\n        self.children = []                  # Child nodes for cost updates\n        self.valid = True                   # Validity flag for collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.15, max_rewire_radius: float=20.0, min_rewire_radius: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_rewire_radius = max_rewire_radius\n        self.min_rewire_radius = min_rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n            dist = distance(from_pos, to_pos)\n            if dist == 0:\n                return None\n            scale = min(max_dist, dist) / dist\n            new_pos = tuple(from_pos[d] + vec[d]*scale for d in range(len(from_pos)))\n            return new_pos\n\n        def nearest(tree, pos):\n            return min(tree, key=lambda n: distance(n.position, pos))\n\n        def near(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def adaptive_radius(n_nodes: int):\n            # Radius shrink with number of nodes, between max and min\n            return max(self.min_rewire_radius, min(self.max_rewire_radius, self.max_rewire_radius * (math.log(n_nodes+1)/ (n_nodes+1))**0.5))\n\n        def extract_path(node_start_tree, node_goal_tree):\n            path_start = []\n            node = node_start_tree\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_goal = []\n            node = node_goal_tree\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n            return path_start[::-1] + path_goal\n\n        def update_subtree_costs(root_node):\n            from collections import deque\n            queue = deque([root_node])\n            while queue:\n                node = queue.popleft()\n                for child in node.children:\n                    old_cost = child.cost\n                    child.cost = node.cost + distance(node.position, child.position)\n                    if abs(child.cost - old_cost) > 1e-8:\n                        queue.append(child)\n\n        for iter in range(self.max_iter):\n            # Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n                if new_pos is None:\n                    continue\n\n                # Boundary check\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(bounds))):\n                    continue\n\n                # Collision check node & edge\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                # Create new node with minimal cost parent chosen from near nodes\n                current_nodes_count = len(tree_a)\n                r = adaptive_radius(current_nodes_count)\n                near_nodes = near(tree_a, new_pos, r)\n\n                min_parent = nearest_node\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                for near_node in near_nodes:\n                    cost_through_near = near_node.cost + distance(near_node.position, new_pos)\n                    if cost_through_near < min_cost:\n                        # Collision check for edge between near_node and new_pos\n                        if (not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d) and\n                            not self._is_in_obstacle(new_pos, obstacles, is_3d)):\n                            min_cost = cost_through_near\n                            min_parent = near_node\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                # Rewire nearby nodes (except the parent) to possibly lower costs\n                for near_node in near_nodes:\n                    if near_node == min_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, near_node.position)\n                    if cost_via_new < near_node.cost:\n                        # Edge collision and node collision check\n                        if (not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d) and\n                            not self._is_in_obstacle(near_node.position, obstacles, is_3d)):\n                            # Remove from old parent's children\n                            if near_node.parent:\n                                near_node.parent.remove_child(near_node)\n                                if (near_node.parent, near_node) in edges:\n                                    edges.remove((near_node.parent, near_node))\n                            near_node.parent = new_node\n                            near_node.cost = cost_via_new\n                            new_node.add_child(near_node)\n                            edges.append((new_node, near_node))\n                            update_subtree_costs(near_node)\n\n                # Attempt to connect to other tree\n                connect_node = nearest(tree_b, new_node.position)\n                dist_to_connect = distance(new_node.position, connect_node.position)\n                if dist_to_connect <= self.step_size:\n                    # Edge collision check between new_node and connect_node\n                    if (not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(connect_node.position, obstacles, is_3d)):\n                        success_state = True\n                        extracted_path = extract_path(new_node, connect_node)\n                        return PlannerResult(True, extracted_path, nodes, edges)\n\n        return PlannerResult(False, [], nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.69623,
    "time_improvement": 25.0,
    "length_improvement": 1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.022455310821533202,
            "num_nodes_avg": 124.1,
            "path_length_avg": 183.05971784628233,
            "smoothness_avg": 0.012951579394045348,
            "success_improvement": -9.999999999999998,
            "time_improvement": 10.807186608634387,
            "length_improvement": -0.3379321184052112,
            "smoothness_improvement": 102.72034232161698,
            "objective_score": -46.311828729482635
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03984384536743164,
            "num_nodes_avg": 265.9,
            "path_length_avg": 296.76803915724594,
            "smoothness_avg": 0.006643989550008535,
            "success_improvement": 0.0,
            "time_improvement": 75.85634341430716,
            "length_improvement": 0.9302865349279021,
            "smoothness_improvement": 70.95463659396223,
            "objective_score": 23.29773351424754
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05755317211151123,
            "num_nodes_avg": 283.0,
            "path_length_avg": 148.5252738219993,
            "smoothness_avg": 0.013945641681102294,
            "success_improvement": 0.0,
            "time_improvement": -12.442869200513508,
            "length_improvement": 1.3565851409497234,
            "smoothness_improvement": 77.3875328234275,
            "objective_score": -3.07460606784697
        }
    ],
    "smoothness_improvement": 84.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant with adaptive informed sampling, dynamic rewiring radius with logarithmic decay, balanced tree growth, efficient collision and boundary checks, periodic dead-end pruning, and iterative shortcut smoothing upon path connection. It is tuned with adjusted parameters to improve planning efficiency, robustness, success rate, and path quality, while reducing search time and path lengths.",
    "planning_mechanism": "The planner alternates expanding the smaller of two trees (start and goal), sampling adaptively biased points to favor progress towards start or goal. New nodes are added with rewiring of neighbors within a dynamic radius to optimize costs. Collision-free edges and nodes are strictly enforced within map bounds. Dead-end pruning and cached nearest neighbor computations keep runtime manageable. Upon successful connection of trees, iterative shortcut smoothing improves path smoothness and reduces length, enabling rapid convergence to high-quality, feasible paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._update_cost_recursive()\n\n    def _distance(self, p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n        import math\n        return math.dist(p1, p2)\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + self._distance(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 6.0,\n                 goal_sample_rate: float = 0.20,\n                 radius_constant: float = 28.0,\n                 radius_min: float = 6.0,\n                 prune_interval: int = 80,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def sample_free(size_start: int, size_goal: int) -> Tuple[float, ...]:\n            p_bias = 0.7  # Slightly strengthened bias for goal/start sampling\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            if random.random() < self.goal_sample_rate:\n                r = random.random()\n                if r < bias_goal * p_bias:\n                    return goal_position\n                elif r < bias_goal * p_bias + bias_start * p_bias:\n                    return start_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r_sq]\n\n        def radius_dynamic(n: int) -> float:\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            # Adaptive resolution proportional to step size ensures thorough checking with efficiency\n            resolution = min(0.3, self.step_size / 10.0)\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=resolution)\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        if neighbor.parent:\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Always extend the smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # Avoid duplicate joint node\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 0.3) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -10.85402,
    "time_improvement": 5.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.04786636829376221,
            "num_nodes_avg": 97.6,
            "path_length_avg": 169.2049139925801,
            "smoothness_avg": 0.04338590473855787,
            "success_improvement": 0.0,
            "time_improvement": -90.1258944433712,
            "length_improvement": 7.2561054172252755,
            "smoothness_improvement": 579.0836231585178,
            "objective_score": -22.691129133773714
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05106112957000732,
            "num_nodes_avg": 128.1,
            "path_length_avg": 246.8626860839372,
            "smoothness_avg": 0.08915352709829646,
            "success_improvement": 0.0,
            "time_improvement": 69.05915164946614,
            "length_improvement": 17.590129836740665,
            "smoothness_improvement": 2193.9844669291597,
            "objective_score": 35.20569379683378
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.033048367500305174,
            "num_nodes_avg": 108.4,
            "path_length_avg": 128.04836186259698,
            "smoothness_avg": 0.10890654974465504,
            "success_improvement": 0.0,
            "time_improvement": 35.432694188821834,
            "length_improvement": 14.956375058619512,
            "smoothness_improvement": 1285.2832741066989,
            "objective_score": 20.047499638903947
        }
    ],
    "smoothness_improvement": 1353.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is an improved RRT* variant with goal biasing and rewiring for faster convergence and better path quality. It samples points in free space, extends the nearest node toward samples with collision checks, and rewires the tree locally to optimize costs. It respects map bounds and obstacles to maintain robustness.",
    "planning_mechanism": "The planner incrementally grows a single tree rooted at the start. At each iteration, it samples the goal with some probability (goal biasing) or a random free state, finds the nearest node, steers toward it by a fixed step size while ensuring collision-free extension, then rewires nearby nodes to optimize path costs. The process continues until the goal is connected or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Check sampled point is inside map bounds and free from obstacles\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer from nearest_node to sample\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            ratio = min(self.step_size / dist, 1.0)\n            new_pos = tuple(nearest_node.position[d] + direction[d] * ratio for d in range(dim))\n\n            # Keep new_pos within bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checking for node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node\n            new_node = Node(new_pos)\n            # Search nearby nodes for better parent (rewiring radius)\n            near_nodes = [node for node in nodes if math.dist(node.position, new_pos) <= self.radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            min_parent = nearest_node\n            for near_node in near_nodes:\n                if self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    continue\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    min_cost = cost_through_near\n                    min_parent = near_node\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes if cheaper passing through new_node\n            for near_node in near_nodes:\n                if near_node == min_parent:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost:\n                    # Rewire\n                    if near_node.parent:\n                        try: \n                            edges.remove((near_node.parent, near_node))\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n            # Check if connected to goal within step_size and collision-free\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)) and (not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path\n                    path = []\n                    current = goal_node\n                    while current:\n                        path.append(current.position)\n                        current = current.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 818.92034,
    "time_improvement": -2699.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.43947055339813235,
            "num_nodes_avg": 256.3,
            "path_length_avg": 157.97618421670876,
            "smoothness_avg": 0.021945974438081786,
            "success_improvement": 0.0,
            "time_improvement": -1645.5832774602168,
            "length_improvement": 13.410750137989952,
            "smoothness_improvement": 243.5021564022401,
            "objective_score": -489.77532242845587
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.030008578300476,
            "num_nodes_avg": 1047.4,
            "path_length_avg": 224.94907749855935,
            "smoothness_avg": 0.016607802140836486,
            "success_improvement": 0.0,
            "time_improvement": -1130.0978866000605,
            "length_improvement": 24.905523130790137,
            "smoothness_improvement": 327.3307112000925,
            "objective_score": -332.4116077978597
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 2.775113916397095,
            "num_nodes_avg": 795.3,
            "path_length_avg": 117.9407469527336,
            "smoothness_avg": 0.12786141944705404,
            "success_improvement": -9.999999999999998,
            "time_improvement": -5321.799697041402,
            "length_improvement": 21.66937160885037,
            "smoothness_improvement": 1526.387817618269,
            "objective_score": -1634.5740957025594
        }
    ],
    "smoothness_improvement": 699.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates a bidirectional anytime informed RRT* framework combining adaptive ellipsoidal sampling, KD-tree accelerated neighbor search, lazy collision checking with caching, dynamic neighbor radius adjustment, and incremental multi-step connection attempts. It prioritizes extending the smaller tree and aggressively prunes nodes unlikely to improve the current best solution. Path quality is enhanced through iterative shortcut smoothing of the best path, minimizing length and improving smoothness. These strategies collectively reduce search time, improve path optimality, increase success rates, and maintain robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree by sampling within an evolving informed ellipsoidal domain biased by the current best path cost, or adaptively near the best path with Gaussian noise for focused exploration. It uses a KD-tree-based neighbor search for efficient rewiring and lazy collision checking with caching to minimize redundant computations. Incremental multi-step connection attempts link the two trees, while periodic pruning removes nodes that cannot lead to better solutions. Once a path is found, iterative shortcut smoothing refines it for minimal length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node for cost improvement\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic aggressive pruning to maintain efficiency and focus\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.86472,
    "time_improvement": 54.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014759683609008789,
            "num_nodes_avg": 60.3,
            "path_length_avg": 157.31274397795977,
            "smoothness_avg": 0.037706714453848114,
            "success_improvement": 0.0,
            "time_improvement": 41.3743271550924,
            "length_improvement": 13.774392245731606,
            "smoothness_improvement": 490.1919626437174,
            "objective_score": 17.618136408892628
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.059581637382507324,
            "num_nodes_avg": 252.9,
            "path_length_avg": 231.24957894505343,
            "smoothness_avg": 0.0959050568562929,
            "success_improvement": 0.0,
            "time_improvement": 63.89609038708946,
            "length_improvement": 22.80223439807149,
            "smoothness_improvement": 2367.7061905327314,
            "objective_score": 35.5678049484048
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021940040588378906,
            "num_nodes_avg": 117.9,
            "path_length_avg": 121.80944976052179,
            "smoothness_avg": 0.10924039422725276,
            "success_improvement": 0.0,
            "time_improvement": 57.135271200114765,
            "length_improvement": 19.099963411748654,
            "smoothness_improvement": 1289.5297512835057,
            "objective_score": 27.408222798801688
        }
    ],
    "smoothness_improvement": 1382.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner enhances performance by implementing a bidirectional anytime informed RRT* with focused adaptive sampling near the current best path. It employs a KD-tree for efficient nearest neighbor queries, lazy collision checking with caching to avoid redundant computations, dynamic neighbor radius adjustment based on progress, and incremental multi-step connections to efficiently merge trees. Aggressive pruning removes nodes unlikely to improve the current solution, and iterative shortcut smoothing refines the final path to improve length and smoothness. Optimizations reduce redundant computations and focus sampling towards promising regions, improving planning efficiency, success rate, and path quality without compromising robustness in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, extending the smaller tree alternately. Sampling is biased inside an informed ellipsoidal domain shaped by the current best cost or adaptive Gaussian noise along the best path for focused exploration. KD-trees accelerate neighbor search for rewiring. Lazy collision checking with caching minimizes computations. Multi-step incremental connections attempt linking trees promptly. Periodic pruning discards nodes that cannot improve solutions. On finding a feasible path, iterative shortcut smoothing reduces path length and improves smoothness, yielding an efficient, high-quality solution with reduced search time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Pre-check in-obstacle for a node\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Check edge collision with caching\n        edge_collision_cache = {}\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return not is_edge_in_obstacle(p1, p2)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                # Linear search as heuristic: may be replaced with scipy.spatial.cKDTree outside\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(self.nodes[i])\n                return results\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        # Enhanced sampling: biased sampling inside evolving ellipsoidal informed domain or adaptive near best path point with Gaussian noise\n        def informed_sample(c_best_, c_min_, start, goal):\n            if c_best_ == float('inf') or c_best_ < c_min_ * 1.00001 or random.random() < 0.1:\n                # Uniform sampling with multiple tries quickly rejecting obstacle samples\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            import numpy.linalg as la\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min_ for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = la.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best_ / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min_ / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = la.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x /= norm_x\n                x *= np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # fallback uniform random\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # last fallback\n\n        def adaptive_sample(best_path_, c_best_, c_min_):\n            if best_path_ and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path_[random.randint(0, len(best_path_) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best_, c_min_, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            removed = 0\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.00637,
    "time_improvement": 22.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.037831354141235354,
            "num_nodes_avg": 99.6,
            "path_length_avg": 161.68172401057873,
            "smoothness_avg": 0.040869981136941916,
            "success_improvement": -9.999999999999998,
            "time_improvement": -50.26667575788571,
            "length_improvement": 11.379685058934246,
            "smoothness_improvement": 539.7039553776822,
            "objective_score": -60.10554593869045
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.058111381530761716,
            "num_nodes_avg": 217.3,
            "path_length_avg": 239.9895540230735,
            "smoothness_avg": 0.10784615475704551,
            "success_improvement": 0.0,
            "time_improvement": 64.78700219668771,
            "length_improvement": 19.884579150794238,
            "smoothness_improvement": 2674.9592403442657,
            "objective_score": 36.78781269088649
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.02559342384338379,
            "num_nodes_avg": 113.7,
            "path_length_avg": 127.18358914700532,
            "smoothness_avg": 0.12096283786498092,
            "success_improvement": -9.999999999999998,
            "time_improvement": 49.997577821791026,
            "length_improvement": 15.530715920263896,
            "smoothness_improvement": 1438.6383690946238,
            "objective_score": -24.701391623936786
        }
    ],
    "smoothness_improvement": 1551.0,
    "success_rate": 0.9333333333333332
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with informed ellipsoidal sampling to focus exploration within the heuristic-informed domain shaped by the current best path cost. It features adaptive neighbor radius tuning for efficient rewiring, KD-tree accelerated nearest-neighbor and radius searches, and collision caching for optimized collision checking. A persistent aggressive shortcut smoothing is applied to the best found path to minimize length and enhance smoothness. Periodic pruning of nodes unlikely to produce better paths reduces computational overhead. The incremental rewiring ensures continuous path cost improvement, balancing exploration and exploitation to yield higher success rates, shorter and smoother paths, and reduced planning times in both 2D and 3D maps.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal alternatively, sampling informed points inside an ellipsoidal subset based on current best cost. Each extension attempts rewiring nearby nodes to reduce cost using KD-tree for efficient neighborhood queries. When trees connect, the path is aggressively shortcut-smoothed. Periodically, the planner prunes nodes unlikely to improve the solution, thereby reducing search space and improving responsiveness. Collision checks are cached to avoid redundant computations, and all new nodes and edges are validated for collision and boundary constraints before insertion.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with rejection inside obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    # Uniform sampling inside unit ball\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balance tree extension: smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connect opposite tree towards new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n\n            # Periodic pruning to reduce complexity\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n            # Early break on success and stability\n            if connected and it > self.max_iter*0.10:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 41.67225,
    "time_improvement": -175.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.160676908493042,
            "num_nodes_avg": 321.1,
            "path_length_avg": 156.56749983932,
            "smoothness_avg": 0.045309872174129254,
            "success_improvement": 0.0,
            "time_improvement": -538.210961737332,
            "length_improvement": 14.182872367269148,
            "smoothness_improvement": 609.1978914873669,
            "objective_score": -155.58072459030893
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0572551965713501,
            "num_nodes_avg": 246.4,
            "path_length_avg": 234.31167063448075,
            "smoothness_avg": 0.09484437741977376,
            "success_improvement": 0.0,
            "time_improvement": 65.3058134570779,
            "length_improvement": 21.780020054718285,
            "smoothness_improvement": 2340.414144654576,
            "objective_score": 35.64981877133991
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0779463529586792,
            "num_nodes_avg": 245.1,
            "path_length_avg": 118.8276404009005,
            "smoothness_avg": 0.10823535581726274,
            "success_improvement": 0.0,
            "time_improvement": -52.28546488121081,
            "length_improvement": 21.0803392099056,
            "smoothness_improvement": 1276.7457368926512,
            "objective_score": -5.085842937918865
        }
    ],
    "smoothness_improvement": 1409.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional RRT* with Sampling Bias and Localized Lazy Collision Checking to improve planning efficiency, path quality, robustness, and smoothness. It dynamically adjusts the sampling domain using heuristic-guided informed sampling biased towards promising regions, interleaves tree growth from start and goal, employs KD-tree for efficient neighbor queries, and performs lazy collision checks during rewiring to reduce expensive computations. Additionally, a post-processing shortcut smoothing using smart edge checking is applied to enhance path smoothness and shorten final path length.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, samples points adaptively biased towards the current best path region, extends one tree toward sampled points, rewires neighbors using efficient KD-tree-based radius search with lazy collision checking, and attempts to connect the two trees. Upon connection, it extracts and shortcuts the combined path while validating collision-free edges. It leverages pruning of nodes not capable of improving current best path and maintains balanced tree growth for robustness and reduced search time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision validity or lazy checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 shortcut_iter: int = 150, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(iteration, n_nodes):\n            if n_nodes == 0:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius)*math.sqrt(math.log(n_nodes + 1) / (n_nodes))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision cache for edges and nodes\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b)\n            key_rev = (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # KDTree for neighbor search (simple linear search)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling biased towards best found path corridor with heuristic weights\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with retries for obstacle free\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-5:  # avoid zero vector\n                    x_ball = x_ball / norm_x * random.uniform(0,1) ** (1.0/dim)  # uniform in ball\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n\n            # fallback uniform sampling\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Shortcut smoothing on path using lazy collision checks\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n\n        nodes_start = [root_start]\n        nodes_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Balanced tree growth flag\n        grow_start_tree = True\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Select which tree to grow based on sizes for balance\n            if len(nodes_start) <= len(nodes_goal):\n                tree_a_nodes, tree_b_nodes = nodes_start, nodes_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a_nodes, tree_b_nodes = nodes_goal, nodes_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a_nodes])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = radius(iteration, len(nodes_all))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: first minimal cost parent selection (do edge check lazily)\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost:\n                    # Check connectivity lazily now\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a_nodes.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost paths if possible\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, c_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b_nodes])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            if dist(new_node.position, nearest_b.position) <= self.step_size and \\\n               not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Connect directly\n                cost_connection = new_node.cost + dist(new_node.position, nearest_b.position)\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_connection)\n                new_node.children.append(connect_node)\n                tree_a_nodes.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                # Extract full path\n                if growing_from_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate node\n\n                # Shortcut smoothing for improved path quality\n                smoothed_path = shortcut_path(merged_path)\n\n                c_candidate = connect_node.cost + (nearest_b.cost if growing_from_start else new_node.cost)\n                if c_candidate < c_best:\n                    c_best = c_candidate\n                    best_path = smoothed_path\n                    success_state = True\n\n                extracted_path = best_path\n                break\n\n            # Else do incremental connection attempt with limited steps from nearest_b toward new_node\n            dist_to_newnode = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_to_newnode / self.step_size))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos) or is_edge_colliding_cached(last_node_b.position, next_pos):\n                    break\n                cost_next = last_node_b.cost + dist(last_node_b.position, next_pos)\n                new_node_b = Node(next_pos, parent=last_node_b, cost=cost_next)\n                last_node_b.children.append(new_node_b)\n                tree_b_nodes.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b around new_node_b\n                near_b = kdtree_b.radius_search(next_pos, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    # Connect finally\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b_nodes.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if cost_conn < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n                        success_state = True\n\n                    extracted_path = best_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                break\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.30002,
    "time_improvement": 43.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016922187805175782,
            "num_nodes_avg": 73.5,
            "path_length_avg": 154.23200362778806,
            "smoothness_avg": 0.04002093790061885,
            "success_improvement": 0.0,
            "time_improvement": 32.784829785863906,
            "length_improvement": 15.46299484911554,
            "smoothness_improvement": 526.4145850023286,
            "objective_score": 15.560120830593922
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.045720887184143064,
            "num_nodes_avg": 212.9,
            "path_length_avg": 237.2164084286152,
            "smoothness_avg": 0.10522668171555331,
            "success_improvement": 0.0,
            "time_improvement": 72.29510884836787,
            "length_improvement": 20.81033497079458,
            "smoothness_improvement": 2607.558312256502,
            "objective_score": 38.88839120995179
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03875234127044678,
            "num_nodes_avg": 157.1,
            "path_length_avg": 123.32472678199296,
            "smoothness_avg": 0.1265137676603671,
            "success_improvement": 0.0,
            "time_improvement": 24.288718052866827,
            "length_improvement": 18.093588563825442,
            "smoothness_improvement": 1509.245786364919,
            "objective_score": 18.45156206044973
        }
    ],
    "smoothness_improvement": 1548.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner leverages adaptive informed sampling within a dynamically shrinking ellipsoid to focus growth towards promising regions, while maintaining bidirectional RRT*-based tree expansion with incremental rewiring for path optimality. The algorithm integrates collision caching for efficiency, aggressive pruning of non-promising nodes, and robust shortcut smoothing to enhance path quality and smoothness. It alternates tree growth from start and goal, uses KD-tree-like nearest neighbor queries for rewiring, and employs connection attempts between trees similar to RRT-Connect for rapid convergence and improved success rates in 2D and 3D spaces.",
    "planning_mechanism": "The planner iteratively samples nodes adaptively within an informed ellipsoid shaped by current best path costs to reduce exploration area and improve convergence. It grows two trees bidirectionally, rewires locally to minimize costs, caches collision checks to reduce redundant computations, and prunes nodes unlikely to yield improvements. Connections between trees are aggressively attempted, and the final path undergoes shortcut smoothing to ensure minimal length and enhanced smoothness, outputting a high-quality, collision-free path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Simple KDTree substitute for nearest and radius searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed sampling inside ellipsoid based on current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for obstacle free\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors around new_node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from new_node to the other tree (tree_b)\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes unlikely to improve the path periodically\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -14.43883,
    "time_improvement": 13.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.019157958030700684,
            "num_nodes_avg": 67.0,
            "path_length_avg": 158.49583155130003,
            "smoothness_avg": 0.047400650631977306,
            "success_improvement": 0.0,
            "time_improvement": 23.90431870783473,
            "length_improvement": 13.125923199561521,
            "smoothness_improvement": 641.9231145507785,
            "objective_score": 13.006095825016615
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05653114318847656,
            "num_nodes_avg": 225.7,
            "path_length_avg": 235.25056936585833,
            "smoothness_avg": 0.09084560193031925,
            "success_improvement": 0.0,
            "time_improvement": 65.74455866514202,
            "length_improvement": 21.466588633482893,
            "smoothness_improvement": 2237.5227711093453,
            "objective_score": 35.20429918178591
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07700245380401612,
            "num_nodes_avg": 192.0,
            "path_length_avg": 126.88439228796013,
            "smoothness_avg": 0.1193813140935434,
            "success_improvement": 0.0,
            "time_improvement": -50.44134881788389,
            "length_improvement": 15.729428227818307,
            "smoothness_improvement": 1418.5215034578803,
            "objective_score": -4.893911482512104
        }
    ],
    "smoothness_improvement": 1433.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements a hybrid bidirectional informed RRT* algorithm enhanced with dynamically adaptive ellipsoidal sampling, efficient nearest neighbor searches via KD-tree, collision caching to avoid redundant checks, incremental rewiring for cost improvements, and aggressive pruning of non-promising nodes. It emphasizes path quality through multiple shortcut smoothing iterations and ensures nodes and edges validity through rigorous obstacle and boundary checks. The planner alternates growth between start and goal trees and progressively shrinks the ellipsoidal sampling region as better paths are found, improving efficiency, success rate, and smoothness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately sampling informed points within a shrinking ellipsoid guided by the current best path cost. Nearest neighbors and radius queries utilize a KD-tree structure to accelerate rewiring and extension. Collision checks for nodes and edges are cached to reduce computation. Pruning periodically removes nodes unlikely to contribute to better paths. Upon successfully connecting the two trees, the planner applies shortcut smoothing to the final path for improved smoothness and shorter length, returning the best found solution within max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle boxes\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform sampling with retries for free space\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if i == 0 else 0 for i in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2)**2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0,1) ** (1/dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    sample = rot @ (x_scaled * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sampling if ellipsoid sampling fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balanced growth between two trees\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection from opposite tree to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.14286,
    "time_improvement": 51.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015091204643249511,
            "num_nodes_avg": 52.7,
            "path_length_avg": 156.05146269834086,
            "smoothness_avg": 0.04973613979534058,
            "success_improvement": 0.0,
            "time_improvement": 40.05752090033372,
            "length_improvement": 14.46572050137159,
            "smoothness_improvement": 678.4785915533056,
            "objective_score": 18.30279332814096
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05079507827758789,
            "num_nodes_avg": 215.2,
            "path_length_avg": 237.17997973032212,
            "smoothness_avg": 0.1171984471414971,
            "success_improvement": 0.0,
            "time_improvement": 69.22036728965143,
            "length_improvement": 20.822495918826757,
            "smoothness_improvement": 2915.6004595801314,
            "objective_score": 39.508611668561436
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02931373119354248,
            "num_nodes_avg": 130.6,
            "path_length_avg": 122.02606881850924,
            "smoothness_avg": 0.11803849126325175,
            "success_improvement": 0.0,
            "time_improvement": 42.72913340053325,
            "length_improvement": 18.956095347724464,
            "smoothness_improvement": 1401.4408961734418,
            "objective_score": 23.617163570572078
        }
    ],
    "smoothness_improvement": 1665.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced hybrid bidirectional informed RRT* variant with refined parameter tuning aimed at maximizing planning efficiency, path quality, success rate, and computational speed. It features adaptive sampling within an informed ellipsoid, dynamic neighbor radius control, goal biasing, collision caching, aggressive pruning of redundant nodes, incremental rewiring, balanced tree growth, and robust shortcut smoothing to generate shorter and smoother paths more reliably in complex 2D/3D environments.",
    "planning_mechanism": "The planner alternates between extending two trees rooted at start and goal. It samples points adaptively within a shrinking ellipsoid to focus search near the best known path. KD-tree inspired neighbor searches enable rewiring for incremental improvements while caching collision checks reduces overhead. It prunes nodes unlikely to improve solutions periodically and applies shortcut smoothing to enhance final path quality, thus balancing exploration, optimization, and computational cost for faster, robust planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 6.0,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15,  # more frequent goal bias\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 200,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            # informed sampling inside ellipsoid focusing near best path\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with collision check retries\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            direction = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = direction - np.array([1] + [0] * (dim -1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best * 0.5\n            r_other = math.sqrt(max(r1 * r1 - (c_min * 0.5) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            # Simple linear search based KDTree substitute optimized for iteration\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                # Slightly tighter condition for pruning improves runtime\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: list[tuple] = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvements with pruning of expensive rewires\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_ext_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            for _ in range(max_ext_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -20.26536,
    "time_improvement": 33.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02238790988922119,
            "num_nodes_avg": 77.0,
            "path_length_avg": 168.1601616915515,
            "smoothness_avg": 0.04350127346738022,
            "success_improvement": 0.0,
            "time_improvement": 11.07490406869931,
            "length_improvement": 7.828750708578664,
            "smoothness_improvement": 580.8893942917919,
            "objective_score": 7.792668333784485
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05254693031311035,
            "num_nodes_avg": 224.2,
            "path_length_avg": 242.65001573363708,
            "smoothness_avg": 0.09995825129568903,
            "success_improvement": 0.0,
            "time_improvement": 68.15882030430012,
            "length_improvement": 18.996440454663716,
            "smoothness_improvement": 2471.9978028563455,
            "objective_score": 36.60692319650451
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.041457104682922366,
            "num_nodes_avg": 182.2,
            "path_length_avg": 126.29069487361997,
            "smoothness_avg": 0.1253220957696637,
            "success_improvement": 0.0,
            "time_improvement": 19.004363647204144,
            "length_improvement": 16.123733781590172,
            "smoothness_improvement": 1494.087807875241,
            "objective_score": 16.396494889855482
        }
    ],
    "smoothness_improvement": 1516.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a simplified bidirectional RRT* variant that balances between exploration and optimization. It alternates growth of two trees from start and goal, adaptively sampling points, checking collisions rigorously, and dynamically rewiring to improve path cost. It enforces strict boundary and obstacle checks, provides efficient neighbor search within a dynamic radius, and applies shortcut smoothing after connecting trees to yield smooth, short, and feasible paths. This design improves planning efficiency, robustness, and path quality while reducing computation time.",
    "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal, alternately extending the smaller tree towards adaptively sampled points. New nodes are connected only if collision-free, and neighbors within a dynamic radius are rewired for lower-cost paths. Upon successful connection of both trees, the combined path is shortcut-smoothed iteratively to enhance smoothness and reduce length, yielding an efficient, high-quality path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            self.cost = self.parent.cost + math.dist(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0,\n                 goal_sample_rate: float = 0.2,\n                 radius_constant: float = 20.0,\n                 radius_min: float = 5.0,\n                 smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free(size_start: int, size_goal: int) -> Tuple[float, ...]:\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            if random.random() < self.goal_sample_rate:\n                r = random.random()\n                if r < bias_goal * 0.7:\n                    return goal_pos\n                elif r < (bias_goal + bias_start) * 0.7:\n                    return start_pos\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(len(from_p)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def radius_dynamic(n: int) -> float:\n            if n <= 1:\n                return self.radius_constant\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos)**2 <= r_sq]\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            resolution = min(0.3, self.step_size / 10.0)\n            return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution))\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_through_new + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    if node.parent:\n                        try:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_connect(path[i], path[j]):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            # Extend smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # avoid duplicate joint node\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    final_path = smoothed\n                else:\n                    final_path = raw_path\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.3):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -11.67723,
    "time_improvement": 13.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.034816956520080565,
            "num_nodes_avg": 109.2,
            "path_length_avg": 176.8368770111015,
            "smoothness_avg": 0.024335449327707342,
            "success_improvement": 0.0,
            "time_improvement": -38.29344560988822,
            "length_improvement": 3.072905550580595,
            "smoothness_improvement": 280.90262725265296,
            "objective_score": -9.468939436587082
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.052289271354675294,
            "num_nodes_avg": 229.3,
            "path_length_avg": 245.89940126451285,
            "smoothness_avg": 0.06741372456188324,
            "success_improvement": 0.0,
            "time_improvement": 68.31495055105006,
            "length_improvement": 17.911702036080698,
            "smoothness_improvement": 1634.6036891204037,
            "objective_score": 32.249844018133174
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04734020233154297,
            "num_nodes_avg": 214.0,
            "path_length_avg": 124.01286896686602,
            "smoothness_avg": 0.10959746120126557,
            "success_improvement": 0.0,
            "time_improvement": 7.510429340403599,
            "length_improvement": 17.636557290442312,
            "smoothness_improvement": 1294.071616837006,
            "objective_score": 12.250798344394571
        }
    ],
    "smoothness_improvement": 1070.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an optimized bidirectional anytime informed RRT* variant that combines adaptive ellipsoidal sampling guided by the current best path, KD-tree accelerated neighbor searches, lazy collision checking with caching, dynamic neighbor radius adjustment, iterative rewiring, and aggressive pruning of non-promising nodes. It balances fast convergence and high-quality path discovery by prioritizing smaller tree extensions, incremental multi-step connection attempts between trees, and comprehensive shortcut smoothing for path refinement. This approach improves planning time, robustness, and path optimality in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two trees from start and goal. Each iteration extends the smaller tree by sampling adaptively within an evolving informed ellipsoid biased by the best path found so far or near the best path using Gaussian perturbations. It uses KD-tree structures for efficient nearest and radius neighbor queries and lazy collision checks with caching for edges. Incremental multi-step extensions attempt to connect opposite trees, while rewiring locally optimizes paths. Periodic aggressive pruning discards nodes unlikely to improve the current best solution, keeping the trees manageable. Once connected, iterative shortcut smoothing refines path quality before returning the solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For pruning etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp position within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KD-tree approximation (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            h = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning when good path exists and node count is high\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.28407,
    "time_improvement": 36.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021583127975463866,
            "num_nodes_avg": 71.8,
            "path_length_avg": 158.58444319624488,
            "smoothness_avg": 0.041607666795992704,
            "success_improvement": 0.0,
            "time_improvement": 14.271509255997362,
            "length_improvement": 13.077353752825879,
            "smoothness_improvement": 551.250337851875,
            "objective_score": 9.65317521662376
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05545804500579834,
            "num_nodes_avg": 228.6,
            "path_length_avg": 241.31274324250552,
            "smoothness_avg": 0.11501020495036371,
            "success_improvement": 0.0,
            "time_improvement": 66.39481000926783,
            "length_improvement": 19.442860503457883,
            "smoothness_improvement": 2859.295411875127,
            "objective_score": 38.10349216284756
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.036947321891784665,
            "num_nodes_avg": 154.6,
            "path_length_avg": 121.78117599783027,
            "smoothness_avg": 0.11678105345078149,
            "success_improvement": 0.0,
            "time_improvement": 27.815223203721956,
            "length_improvement": 19.118741498676453,
            "smoothness_improvement": 1385.4463800132248,
            "objective_score": 19.095547160918002
        }
    ],
    "smoothness_improvement": 1599.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with enhanced adaptive informed sampling biased toward start and goal, dynamic rewiring radius shrinking with samples, fast collision and edge checking, and balanced growth by always extending the smaller tree. It applies iterative shortcut smoothing upon path discovery and prunes dead-end nodes periodically to keep search efficient. The use of spatial hashing for collision and neighbor queries accelerates nearest-neighbor lookups and obstacle checks, improving the overall timing. The planner respects map bounds and performs rigorous collision validation for nodes and edges to guarantee path feasibility while minimizing redundant exploration and improving path quality.",
    "planning_mechanism": "The algorithm alternately grows two trees from start and goal, always extending the smaller tree, sampling adaptively close to start or goal with randomized bias. New nodes are connected with rewiring in a dynamically computed radius that shrinks with samples, improving local optimality. Upon connection, the combined path undergoes iterative shortcut smoothing to reduce length and curvature. Dead-end nodes without children are pruned periodically to optimize tree structure and reduce computations. The process repeats until the path is found or max iterations are reached, returning the best found path, the explored nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=20.0,\n                 radius_min: float=4.0, prune_interval: int=100,\n                 prune_threshold: int=120, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.7\n            # Adaptive informed sampling bias: biased toward start/goal\n            if random.random() < self.goal_sample_rate:\n                # 70% goal, 30% start bias for faster convergence\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                for _ in range(10):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to goal to avoid stalling\n                return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            # Linear search is retained for simplicity; could be replaced with spatial indexing\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            # Linear near search with early prune by squared distance\n            result = []\n            for node in tree:\n                d = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d += diff * diff\n                    if d > radius_sq:\n                        break\n                if d <= radius_sq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos): return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final edge to node.position\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove dead-end nodes (no children) except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            # Attempts iterative shortcut smoothing improving both length and smoothness\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance search effort\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                # Use smoothed path if shorter\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Prune dead-ends periodically to reduce overhead\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        # Early exit on collision for efficiency\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.71987,
    "time_improvement": 36.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011481571197509765,
            "num_nodes_avg": 66.8,
            "path_length_avg": 160.4213014965881,
            "smoothness_avg": 0.026907098392694905,
            "success_improvement": 0.0,
            "time_improvement": 54.39503619441572,
            "length_improvement": 12.070542611525363,
            "smoothness_improvement": 321.15451954503476,
            "objective_score": 20.33839197835496
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0377842903137207,
            "num_nodes_avg": 191.9,
            "path_length_avg": 246.52838420182957,
            "smoothness_avg": 0.07303336660913587,
            "success_improvement": 0.0,
            "time_improvement": 77.10434519419485,
            "length_improvement": 17.701729427334346,
            "smoothness_improvement": 1779.2011266607726,
            "objective_score": 35.56765507702919
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06316671371459961,
            "num_nodes_avg": 143.9,
            "path_length_avg": 124.97421472360108,
            "smoothness_avg": 0.06882091501543851,
            "success_improvement": 0.0,
            "time_improvement": -23.410166068264452,
            "length_improvement": 16.99807721318453,
            "smoothness_improvement": 775.3969591648413,
            "objective_score": 0.25355041798177735
        }
    ],
    "smoothness_improvement": 959.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation develops an advanced bidirectional informed RRT* planner that focuses on minimizing path length by adaptively sampling within an ellipsoid shaped by the current best path, which improves convergence speed. The planner efficiently manages nodes using KD-tree neighbor searches, caches collision checks to avoid redundant computations, rewires incrementally for cost optimization, prunes nodes unlikely to improve the path, and applies shortcut smoothing on the obtained path to enhance smoothness and reduce length. These enhancements collectively improve planning efficiency, robustness, success rate, and path quality in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, sampling within an ellipsoidal informed region that shrinks as better solutions are found. It incrementally connects and rewires nodes ensuring collision-free safeguards for nodes and edges. Pruning and collision cache clearing happen periodically to maintain efficiency. Once a feasible path is found, shortcut smoothing refines the path. The process continues until a max iteration limit or an optimal path is finalized.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision-validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        # Informed sampling inside an ellipsoid defined by start-goal and current best cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # No good path yet: uniform random sampling with obstacle rejection\n                trials = 0\n                while trials < 20:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                    trials += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            # Rotation matrix that aligns x-axis with a1 via Householder transform\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim - 1))\n\n            for _ in range(100):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # fallback uniform random\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent and rm_node in rm_node.parent.children:\n                    rm_node.parent.children.remove(rm_node)\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path: list = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost and collision-free edge\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to improve their cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection to opposite tree\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if we can connect new_node_b directly to new_node to close the trees\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Merge paths from start and goal trees\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]  # avoid duplicated node\n\n                    # Update best path if improved\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of unpromising nodes for efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.05396,
    "time_improvement": 32.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014794063568115235,
            "num_nodes_avg": 66.6,
            "path_length_avg": 156.89092179508836,
            "smoothness_avg": 0.03711808451837075,
            "success_improvement": 0.0,
            "time_improvement": 41.23776946941373,
            "length_improvement": 14.005599668363654,
            "smoothness_improvement": 480.97862592313305,
            "objective_score": 17.577343904112514
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04550454616546631,
            "num_nodes_avg": 219.4,
            "path_length_avg": 234.7442100183161,
            "smoothness_avg": 0.09456512667699488,
            "success_improvement": 0.0,
            "time_improvement": 72.4262022007329,
            "length_improvement": 21.63562595843819,
            "smoothness_improvement": 2333.2288219066954,
            "objective_score": 37.72112996144099
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06006522178649902,
            "num_nodes_avg": 212.7,
            "path_length_avg": 126.23472190811553,
            "smoothness_avg": 0.11535332710218134,
            "success_improvement": 0.0,
            "time_improvement": -17.35071463573235,
            "length_improvement": 16.160908360132023,
            "smoothness_improvement": 1367.2858062428277,
            "objective_score": 4.863396312520839
        }
    ],
    "smoothness_improvement": 1394.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a Fast Informed Bidirectional RRT* with Dynamic Domain Reduction and Hierarchical Sampling. It combines bidirectional tree growth from start and goal with an adaptive sampling domain shrinking around the current best path cost, enhanced by a dynamic informed ellipsoid sampling. It incorporates hierarchical sampling levels to focus exploration near promising regions while maintaining global exploration, aggressive pruning of nodes unlikely to improve the solution, and prioritized rewiring with lazy collision checks. The algorithm includes a novel batch shortcut smoothing that applies both local and global path shortcuts to improve smoothness and reduce path length efficiently. The planner stops either when the maximum iteration count is reached or a path meeting quality criteria is found.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal, adaptively sampling in a dynamically shrinking informed ellipsoid augmented by hierarchical global samples to avoid local minima. It uses efficient KD-tree-like neighbor searches to perform rewiring and node connections. Lazy collision caching reduces redundant checks during rewiring and connections. Aggressive node pruning removes nodes whose cost combined with heuristics exceeds the best solution, conserving memory and search time. Upon connecting the two trees, a batch shortcut smoothing is applied combining long-range and local shortcuts validated by collision checks, yielding a high-quality, smooth path. This strategy balances rapid global exploration and focused local optimization, improving efficiency, robustness, and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validity or lazy checking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 neighbor_min_radius: float = 5.0, neighbor_max_radius: float = 30.0,\n                 smoothing_batch_iters: int = 100,\n                 prune_interval: int = 150, prune_threshold: int = 350,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.smoothing_batch_iters = smoothing_batch_iters\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_in_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_in_obstacle_cache:\n                return node_in_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_in_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Informed ellipsoid sampling with augmented hierarchical global exploration\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # Hierarchical sampling parameters\n            elite_rate = 0.8    # Fraction of samples from informed ellipsoid\n            global_rate = 0.2   # Fraction from global uniform\n\n            # If no solution yet, uniform random sampling tries\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Choose sampling mode (ellipsoid or global)\n            if random.random() < elite_rate:\n                # Ellipsoid sampling\n                center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n                a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n                id_m = np.eye(dim)\n\n                v = a1 - np.array([1] + [0] * (dim - 1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = id_m - 2 * np.outer(v, v)\n                else:\n                    rot = id_m\n\n                r1 = c_best / 2.0\n                r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n                radii = np.array([r1] + [r_others] * (dim - 1))\n\n                for _ in range(100):\n                    x_ball = np.random.uniform(-1, 1, dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-8:\n                        # Uniformly sample inside unit ball\n                        r_scale = random.uniform(0,1) ** (1.0 / dim)\n                        x_ball = x_ball / norm_x * r_scale\n                        sample = rot @ (x_ball * radii) + center\n                        p = tuple(float(c) for c in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fail ellipsoid, fallback global\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            else:\n                # Global uniform hierarchical exploration sample biased near bounds edges to avoid local minima\n                # To maintain global exploration, sample dominantly near boundary regions as well (20%)\n                ranges = []\n                for d_ in range(dim):\n                    e = bounds[d_]\n                    ranges.append((0, e))\n                # Sample with edge bias (uniform, but 40% chance to be near edges)\n                def edge_biased_sample(d):\n                    if random.random() < 0.4:\n                        edge_zone = 0.15 * bounds[d]\n                        if random.random() < 0.5:\n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[d] - edge_zone, bounds[d])\n                    else:\n                        return random.uniform(0, bounds[d])\n                for _ in range(30):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # KDTree for neighbor queries (linear search, adequate for moderate sizes)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        res.append(n)\n                return res\n\n        # Add node with collision and edge validity checks\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        # Aggressive pruning - remove nodes not capable of improving current best cost\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                # Remove edges with rn if present\n                edges = [e for e in edges if e[0] != rn and e[1] != rn]\n                removed += 1\n            return removed\n\n        # Batch shortcut smoothing combining local and long-range shortcuts\n        def batch_shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n            for _ in range(self.smoothing_batch_iters):\n                if length < 3:\n                    break\n                # Random long-range shortcut attempt\n                i = random.randint(0, length - 3)\n                j = random.randint(i + 2, length - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n                    length = len(p)\n                    continue\n                # Attempt local shortcut for adjacent triples to smooth jagged edges\n                if length >= 4:\n                    li = random.randint(0, length - 4)\n                    if can_connect(p[li], p[li+2]):\n                        p = p[:li+1] + p[li+2:]\n                        length = len(p)\n            return p\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to optimize paths\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try connect new_node to tree_b by incremental steps towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for nb in near_b:\n                    if nb is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nb.position)\n                    if c_via_new_b + 1e-12 < nb.cost and can_connect(new_node_b.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nb))\n\n                # Check connection termination condition\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Extract full path & update best\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Batch shortcut smoothing\n                    smoothed_path = batch_shortcut_path(merged_path)\n\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_in_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.10161,
    "time_improvement": 29.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014202570915222168,
            "num_nodes_avg": 56.9,
            "path_length_avg": 152.88041791210188,
            "smoothness_avg": 0.04373393242318906,
            "success_improvement": 0.0,
            "time_improvement": 43.58718668439454,
            "length_improvement": 16.203820397129356,
            "smoothness_improvement": 584.5310121772093,
            "objective_score": 19.23957514563028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05148146152496338,
            "num_nodes_avg": 206.3,
            "path_length_avg": 238.89910138307377,
            "smoothness_avg": 0.11296072838976305,
            "success_improvement": 0.0,
            "time_improvement": 68.8044485634847,
            "length_improvement": 20.248603628965096,
            "smoothness_improvement": 2806.5609037925724,
            "objective_score": 38.72385981380129
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06440050601959228,
            "num_nodes_avg": 188.5,
            "path_length_avg": 126.36258764892011,
            "smoothness_avg": 0.11591866387777214,
            "success_improvement": 0.0,
            "time_improvement": -25.820652609338058,
            "length_improvement": 16.075986023401896,
            "smoothness_improvement": 1374.4768482995228,
            "objective_score": 2.3413856633765766
        }
    ],
    "smoothness_improvement": 1589.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines adaptive bidirectional RRT* features with informed sampling, KD-tree accelerated neighbor search, cached collision checks, and incremental rewiring. It utilizes adaptive neighborhood radius tuning, goal-biased and ellipsoidal informed sampling, aggressive pruning, and shortcut path smoothing. By alternately growing start and goal trees, reusing caches, and carefully managing rewiring and pruning, it achieves improved planning efficiency, path quality, robustness, and smoothness in 2D/3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, sampling adaptively within an informed ellipsoid when a solution is found to focus search. KD-tree searches enable fast neighbor queries for rewiring and parent selection, while collision checks for nodes and edges are cached to reduce computational overhead. The planner aggressively prunes nodes unlikely to improve path cost, connects trees stepwise, and refines the path with shortcut smoothing before returning the optimized final route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...] \u2192 2D:(x,y) or 3D:(x,y,z)\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Path cost from root\n        self.children = []\n        self.valid = True                # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 goal_sample_rate: float=0.1, prune_interval: int=200,\n                 prune_threshold: int=300, smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_point(p):\n            return tuple(max(0, min(p[d], bounds[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return clamp_point(new_p)\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def uniform_sample():\n            for _ in range(50):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            # fallback random anyway\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                return uniform_sample()\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim -1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            return uniform_sample()\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(p):\n            return in_bounds(p) and not is_in_obstacle(p)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p)-3)\n                j = random.randint(i+2, len(p)-1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        def prune_nodes(c_best):\n            removed_count = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= c_best:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed_count += 1\n            return removed_count\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(1, self.max_iter + 1):\n            # Sample with goal bias or informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree selection: balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                cand_cost = nbr.cost + dist(nbr.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(nbr.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for nbr in near_nodes:\n                if nbr is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, nbr.position)\n                if cost_via_new + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    if nbr.parent:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                            nbr.parent.remove_child(nbr)\n                        except ValueError:\n                            pass\n                    nbr.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, nbr))\n\n            # Attempt to connect opposite tree stepwise towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for nbr_b in near_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if cost_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        if nbr_b.parent:\n                            try:\n                                edges.remove((nbr_b.parent, nbr_b))\n                                nbr_b.parent.remove_child(nbr_b)\n                            except ValueError:\n                                pass\n                        nbr_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and speed up\n            if iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 17.96901,
    "time_improvement": -40.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.05157711505889893,
            "num_nodes_avg": 126.0,
            "path_length_avg": 178.00407719559124,
            "smoothness_avg": 0.04138081580311949,
            "success_improvement": -9.999999999999998,
            "time_improvement": -104.86503327764964,
            "length_improvement": 2.433144633991271,
            "smoothness_improvement": 547.6996271985937,
            "objective_score": -78.23438292050365
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06695287227630616,
            "num_nodes_avg": 268.4,
            "path_length_avg": 240.83500970159199,
            "smoothness_avg": 0.1104016403724694,
            "success_improvement": 0.0,
            "time_improvement": 59.4294390825488,
            "length_improvement": 19.60234171021236,
            "smoothness_improvement": 2740.7137258710122,
            "objective_score": 35.45286869616217
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08916919231414795,
            "num_nodes_avg": 274.6,
            "path_length_avg": 125.34156552824898,
            "smoothness_avg": 0.1303025742801091,
            "success_improvement": 0.0,
            "time_improvement": -74.21176731438199,
            "length_improvement": 16.75410030010294,
            "smoothness_improvement": 1557.439126907423,
            "objective_score": -11.125514499756889
        }
    ],
    "smoothness_improvement": 1615.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "m1",
    "algorithm_description": "This hybrid bidirectional informed RRT* planner improves path planning performance by combining adaptive sampling within a shrinking ellipsoid, bidirectional tree expansion, incremental rewiring, collision caching, and aggressive pruning. It maintains high path quality and efficiency by focusing search in promising regions, balancing exploration between start and goal trees, and applying shortcut smoothing to the final path.",
    "planning_mechanism": "The planner alternately grows two trees rooted at the start and goal positions, sampling adaptively within an ellipsoid defined by the current best path cost to bias exploration toward optimal solutions. Nodes are connected and rewired incrementally using nearest neighbor queries, while collision checks and pruning remove unpromising areas. The two trees aggressively attempt to connect via collision-free edges, with smooth shortcutting refining the result. The approach optimizes path length, robustness, and convergence speed in 2D/3D environments.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root to this node\n        self.children: List[Node] = []   # Children nodes\n        self.valid = True                 # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds: Tuple[int, ...] = map.size\n        start_pos: Tuple[float, ...] = map.start\n        goal_pos: Tuple[float, ...] = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2.0 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        # Initialize root nodes and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth: expand smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cost improves\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node with opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed_path = shortcut_path(merged_path)\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically to maintain efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List,\n                             is_3d: bool, resolution: float=1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -15.57017,
    "time_improvement": 17.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024022626876831054,
            "num_nodes_avg": 86.1,
            "path_length_avg": 163.88170326070446,
            "smoothness_avg": 0.042392431825554355,
            "success_improvement": 0.0,
            "time_improvement": 4.5817849850941865,
            "length_improvement": 10.173841571038267,
            "smoothness_improvement": 563.5336147090525,
            "objective_score": 6.226971883281172
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06401140689849853,
            "num_nodes_avg": 243.8,
            "path_length_avg": 239.2855829404569,
            "smoothness_avg": 0.096460101085603,
            "success_improvement": 0.0,
            "time_improvement": 61.21184058736294,
            "length_improvement": 20.119584960855782,
            "smoothness_improvement": 2381.9878783350796,
            "objective_score": 34.29740856005543
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05933775901794434,
            "num_nodes_avg": 205.5,
            "path_length_avg": 126.99325952829236,
            "smoothness_avg": 0.13103119786397122,
            "success_improvement": 0.0,
            "time_improvement": -15.929454991270852,
            "length_improvement": 15.657123790490541,
            "smoothness_improvement": 1566.7071651127508,
            "objective_score": 6.186124086280607
        }
    ],
    "smoothness_improvement": 1504.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced RRT* planner combining adaptive goal biasing, dynamically computed rewiring radius based on the number of nodes and problem dimension, and step size tuning for improved exploration and exploitation balance. It leverages radius-based neighbor rewiring for asymptotic optimality, efficient collision checking, and path extraction after connecting to the goal to improve planning efficiency, path quality, robustness, and success rate. The approach incorporates bounds enforcement and obstacle validation at every step.",
    "planning_mechanism": "The planner incrementally grows a tree from start sampling the goal with adaptive frequency and free space otherwise, steering towards sampled points by controlled step sizes. It selects the best parent among neighbors within a computed radius for cost minimization, performs rewiring to update suboptimal branches, and checks collision rigorously for nodes and edges. The algorithm terminates on successful connection to the goal and returns the optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.15, gamma_rrt: float = 25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.gamma_rrt = gamma_rrt  # Rewiring scaling constant\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Adaptive goal biasing: Increase goal bias as iterations grow\n            goal_bias = min(self.goal_sample_rate + (_ / self.max_iter) * 0.3, 0.5)\n            if random.random() < goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Check sample within bounds and not inside obstacles\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = self._nearest(nodes, sample)\n            new_position = self._steer(nearest_node.position, sample, self.step_size)\n\n            # Enforce bounds for new_position\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            dist_from_nearest = math.dist(nearest_node.position, new_position)\n            new_cost = nearest_node.cost + dist_from_nearest\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n\n            # Adaptive radius for rewiring based on number of nodes and dimension\n            n = len(nodes) + 1\n            radius = min(self.step_size * 10.0,\n                         self.gamma_rrt * ((math.log(n) / n) ** (1 / dim)))\n\n            neighbors = [node for node in nodes if math.dist(node.position, new_position) <= radius]\n\n            # Choose best parent for new_node among neighbors\n            min_cost = new_node.cost\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                if neighbor == nearest_node:\n                    continue\n                if self._is_edge_in_obstacle(neighbor.position, new_position, obstacles, is_3d):\n                    continue\n                cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_position)\n                if cost_through_neighbor < min_cost:\n                    min_cost = cost_through_neighbor\n                    best_parent = neighbor\n\n            if best_parent != nearest_node:\n                # Reassign parent and fix children lists\n                new_node.parent.children.remove(new_node)\n                new_node.parent = best_parent\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if cheaper path possible through new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent or neighbor == new_node:\n                    continue\n                if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    continue\n                new_cost_through_new_node = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost_through_new_node < neighbor.cost:\n                    if neighbor.parent is not None:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost_through_new_node\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n            # Check if new_node can connect directly to goal\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d)) and \\\n                   (not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _nearest(self, nodes, point):\n        import math\n        return min(nodes, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 106.79042,
    "time_improvement": -302.0,
    "length_improvement": 1.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.10697097778320312,
            "num_nodes_avg": 308.7,
            "path_length_avg": 183.6254466961106,
            "smoothness_avg": 0.009723440602134733,
            "success_improvement": -9.999999999999998,
            "time_improvement": -324.89024247038725,
            "length_improvement": -0.6480170655433821,
            "smoothness_improvement": 52.19296021263001,
            "objective_score": -147.33571135316168
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4623361587524414,
            "num_nodes_avg": 1192.9,
            "path_length_avg": 298.7109983564952,
            "smoothness_avg": 0.005082014825305228,
            "success_improvement": 0.0,
            "time_improvement": -180.15582685680064,
            "length_improvement": 0.2816708292387842,
            "smoothness_improvement": 30.7639018824266,
            "objective_score": -53.8365943817803
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2562359094619751,
            "num_nodes_avg": 763.7,
            "path_length_avg": 145.38552324131268,
            "smoothness_avg": 0.012527840237759474,
            "success_improvement": 0.0,
            "time_improvement": -400.6136029528216,
            "length_improvement": 3.4418579777855145,
            "smoothness_improvement": 59.35320311532344,
            "objective_score": -119.19894327471276
        }
    ],
    "smoothness_improvement": 47.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm integrates bidirectional RRT's rapid tree growth from both start and goal points with RRT* inspired rewiring to improve path quality and optimize the resulting path cost. It samples points goal-biased to efficiently explore free space, connects two growing trees while ensuring collision-free nodes and edges, and performs local rewiring to reduce path costs and enhance robustness. The approach balances exploration and exploitation, yielding smoother, shorter, and more reliable paths with improved convergence performance.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, randomly sampling points with a customizable goal bias. Each tree extends toward sampled points with collision checks, attempts connecting the two trees when possible, and locally rewires near nodes for cost improvement. The search stops when the trees connect, reconstructing an optimized path by backtracking through node parents.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def sample_point(tree_flag):\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if tree_flag == 0 else start_pos\n            return tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, point):\n            r = self.rewire_radius\n            return [node for node in tree if dist(node.position, point) <= r]\n\n        def can_connect(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            if any(to_pos[d] < 0 or to_pos[d] > bounds[d] for d in range(len(bounds))):\n                return False\n            return True\n\n        def add_node(tree, new_pos, parent_node):\n            cost = parent_node.cost + dist(parent_node.position, new_pos)\n            new_node = Node(new_pos, parent=parent_node, cost=cost)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def try_rewire(tree, new_node):\n            for near_node in near_nodes(tree, new_node.position):\n                if near_node is new_node.parent:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost < near_node.cost:\n                    if can_connect(new_node.position, near_node.position):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = potential_cost\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n                        self._update_subtree_costs(near_node)\n\n        for iter in range(self.max_iter):\n            tree_flag = iter % 2  # 0 for start tree, 1 for goal tree\n            tree_a = tree_start if tree_flag == 0 else tree_goal\n            tree_b = tree_goal if tree_flag == 0 else tree_start\n\n            rand_pt = sample_point(tree_flag)\n            nearest = nearest_node(tree_a, rand_pt)\n            new_pos = steer(nearest.position, rand_pt)\n\n            if not can_connect(nearest.position, new_pos):\n                continue\n\n            new_node = add_node(tree_a, new_pos, nearest)\n            try_rewire(tree_a, new_node)\n\n            # Try to connect the other tree to new_node\n            nearest_b = nearest_node(tree_b, new_node.position)\n            while True:\n                connect_pos = steer(nearest_b.position, new_node.position)\n                if not can_connect(nearest_b.position, connect_pos):\n                    break\n                connect_node = add_node(tree_b, connect_pos, nearest_b)\n                try_rewire(tree_b, connect_node)\n                if dist(connect_node.position, new_node.position) <= self.step_size:\n                    # Trees connected\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    path = path_start + path_goal[::-1]\n                    break\n                nearest_b = connect_node\n\n            if success:\n                break\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _update_subtree_costs(self, root_node):\n        import collections\n        from math import dist\n\n        queue = collections.deque([root_node])\n        while queue:\n            node = queue.popleft()\n            if node.parent:\n                node.cost = node.parent.cost + dist(node.position, node.parent.position)\n            queue.extend(node.children)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 45.40101,
    "time_improvement": 65.0,
    "length_improvement": 6.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011718511581420898,
            "num_nodes_avg": 88.2,
            "path_length_avg": 189.53810148354953,
            "smoothness_avg": 0.010746898305621823,
            "success_improvement": 0.0,
            "time_improvement": 53.45390562557056,
            "length_improvement": -3.8888368465493905,
            "smoothness_improvement": 68.21229574617801,
            "objective_score": 15.59946579709218
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03497514724731445,
            "num_nodes_avg": 237.9,
            "path_length_avg": 282.9374799077046,
            "smoothness_avg": 0.007860855754151835,
            "success_improvement": 0.0,
            "time_improvement": 78.80656506955937,
            "length_improvement": 5.547325303000072,
            "smoothness_improvement": 102.26548049986887,
            "objective_score": 25.26276198396717
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.01881999969482422,
            "num_nodes_avg": 142.9,
            "path_length_avg": 127.19380587936192,
            "smoothness_avg": 0.021394245555835675,
            "success_improvement": -40.0,
            "time_improvement": 63.23096214508103,
            "length_improvement": 15.523930453101158,
            "smoothness_improvement": 172.13322431128876,
            "objective_score": -177.06525914429903
        }
    ],
    "smoothness_improvement": 114.0,
    "success_rate": 0.8666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved algorithm is a bidirectional informed RRT* planner enhanced with adaptive ellipsoidal sampling, KD-tree accelerated nearest neighbor search, collision caching, incremental rewiring, pruning of nodes unlikely to improve the best path, and post-planning shortcut smoothing. It synergizes aggressive informed sampling to focus search in promising regions, efficient data structures for speedy queries, and heuristic pruning to minimize computation. The method balances rapid convergence, path quality, and robustness in both 2D and 3D spaces while strictly validating collision-free states and edges.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately. Sampling is concentrated within a dynamic ellipsoid defined by the best current path to bias exploration. New nodes are connected with minimal cost parent from neighbors found efficiently using a KD-tree structure. The planner rewires neighbors for cost improvement and attempts connecting both trees incrementally. Periodic pruning removes nodes that cannot contribute to a better path. On successful connection, shortcut smoothing refines the path for smoothness and minimal length. Collision checks are cached to avoid redundancy, and all expansions obey strict collision and boundary constraints, optimizing planning speed and path optimality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Ensure new_p within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.step_size * 15 * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.step_size * 8 * math.sqrt(math.log(c + 1) / c)\n            r = max(self.step_size * 3, min(r_iter, r_nodes))\n            return r\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=1.0)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            # If no solution found yet, sample uniformly inside map free space\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Fallback uniform sample without obstacle check\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            rr = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(rr)\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sample\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(150):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_position)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_position, cost=0.0)\n        root_goal = Node(goal_position, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Alternate tree growth, smaller first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce search space and maintain speed\n            if it > 0 and it % 200 == 0 and len(nodes) > 300 and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.24912,
    "time_improvement": 30.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023321080207824706,
            "num_nodes_avg": 63.3,
            "path_length_avg": 156.20421051138774,
            "smoothness_avg": 0.04175374744685328,
            "success_improvement": 0.0,
            "time_improvement": 7.368338314563752,
            "length_improvement": 14.381997004596602,
            "smoothness_improvement": 553.5368172570537,
            "objective_score": 7.854584981573715
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0528256893157959,
            "num_nodes_avg": 228.1,
            "path_length_avg": 236.87605303184245,
            "smoothness_avg": 0.1027365135094304,
            "success_improvement": 0.0,
            "time_improvement": 67.98990433825956,
            "length_improvement": 20.92395539882424,
            "smoothness_improvement": 2543.4844907172983,
            "objective_score": 37.29918483482921
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04322056770324707,
            "num_nodes_avg": 179.9,
            "path_length_avg": 122.6417820386079,
            "smoothness_avg": 0.12132860892370778,
            "success_improvement": 0.0,
            "time_improvement": 15.559048046699587,
            "length_improvement": 18.547167944047814,
            "smoothness_improvement": 1443.2909499632185,
            "objective_score": 15.593602752635531
        }
    ],
    "smoothness_improvement": 1513.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved bidirectional RRT* planner incorporates informed sampling within an ellipsoidal subset once a solution is found to focus exploration and reduce planning time. It uses KD-Trees to accelerate nearest and near neighbor searches. Adaptive rewiring radius scales properly with node count to balance exploration and optimization. The planning alternates growth between start and goal trees, applying a goal bias that shifts based on progress to maintain efficiency. Collision checks prevent invalid expansions. The path is reconstructed by backtracking upon connection, with local rewiring ensuring smoother and lower-cost paths. This approach improves convergence speed, path optimality, and robustness while reducing the computational load.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling points either towards goal/start with adaptive bias or uniformly in free space. After an initial path discovery, sampling is restricted to an informed ellipsoidal region around the current best path, reducing unnecessary exploration. KD-tree accelerates nearest/near neighbor queries required for extension and rewiring. Each extension respects step size and collision constraints. Rewiring nearby nodes locally refines costs and improves path quality. Upon connection, path merging produces the final smooth path with minimized length and collision-free guarantees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_const: float=35.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Utility: Euclidean distance\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # KD-tree for fast nearest/near neighbor queries\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n                self.dim = len(points_nodes[0][0]) if points_nodes else 0\n                self.tree = None\n                if points_nodes:\n                    self.tree = self._build(list(zip(self.points, self.nodes)), depth=0)\n\n            class NodeKD:\n                def __init__(self, point, node, left, right):\n                    self.point = point\n                    self.node = node\n                    self.left = left\n                    self.right = right\n\n            def _build(self, point_node_list, depth):\n                if not point_node_list:\n                    return None\n                axis = depth % self.dim\n                point_node_list.sort(key=lambda x: x[0][axis])\n                median = len(point_node_list)//2\n                return self.NodeKD(\n                    point_node_list[median][0],\n                    point_node_list[median][1],\n                    self._build(point_node_list[:median], depth+1),\n                    self._build(point_node_list[median+1:], depth+1)\n                )\n\n            def nearest(self, target):\n                best = [None, float('inf')]  # node, dist\n\n                def recurse(nd, depth=0):\n                    if nd is None:\n                        return\n                    axis = depth % self.dim\n                    point = nd.point\n                    d = dist(point, target)\n                    if d < best[1]:\n                        best[0], best[1] = nd.node, d\n                    diff = target[axis] - point[axis]\n                    close, away = (nd.left, nd.right) if diff < 0 else (nd.right, nd.left)\n                    recurse(close, depth+1)\n                    if abs(diff) < best[1]:\n                        recurse(away, depth+1)\n                recurse(self.tree)\n                return best[0]\n\n            def near(self, target, radius):\n                result = []\n\n                def recurse(nd, depth=0):\n                    if nd is None:\n                        return\n                    axis = depth % self.dim\n                    point = nd.point\n                    if dist(point, target) <= radius:\n                        result.append(nd.node)\n                    diff = target[axis] - point[axis]\n                    if diff < 0:\n                        recurse(nd.left, depth+1)\n                        if abs(diff) <= radius:\n                            recurse(nd.right, depth+1)\n                    else:\n                        recurse(nd.right, depth+1)\n                        if abs(diff) <= radius:\n                            recurse(nd.left, depth+1)\n                recurse(self.tree)\n                return result\n\n        def sample_free(current_best_cost=None):\n            # Before path found, normal goal biasing; after found, sample in informed ellipsoid\n            if current_best_cost is not None:\n                # Informed sampling in ellipsoid\n                return informed_sample(current_best_cost)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    # With 70% probability sample goal, else start to balance trees\n                    return goal_position if random.random() < 0.7 else start_position\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def informed_sample(c_best):\n            # Ellipsoidal sampling between start and goal for RRT* informed pruning\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                # Numerical stability fallback\n                return sample_free()\n            if is_3d:\n                center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n                dx = goal_position[0] - start_position[0]\n                dy = goal_position[1] - start_position[1]\n                dz = goal_position[2] - start_position[2]\n                a1 = (dx, dy, dz)\n                a1_len = math.sqrt(dx*dx + dy*dy + dz*dz)\n                if a1_len == 0:\n                    return sample_free()\n\n                # Rotation matrix R aligning first axis with vector from start to goal\n                import numpy as np\n                e1 = np.array([1.0,0,0])\n                a1v = np.array(a1)/a1_len\n                v = np.cross(e1,a1v)\n                s = np.linalg.norm(v)\n                c = np.dot(e1,a1v)\n                if s == 0:\n                    R = np.eye(3)\n                else:\n                    vx = np.array([[0,-v[2],v[1]],\n                                   [v[2],0,-v[0]],\n                                   [-v[1],v[0],0]])\n                    R = np.eye(3) + vx + vx.dot(vx)*((1 - c)/(s*s))\n                # Radii of the ellipsoid\n                r1 = c_best/2\n                r2 = math.sqrt(c_best**2 - c_min**2)/2\n                r3 = r2\n                while True:\n                    # Sample in unit ball\n                    x = np.random.normal(0,1,3)\n                    x /= np.linalg.norm(x)\n                    scale = np.random.rand()**(1/3)\n                    x *= scale\n                    # Scale according to ellipsoid axes\n                    x = np.array([r1*x[0], r2*x[1], r3*x[2]])\n                    # Rotate and translate\n                    sample = center + R.dot(x)\n                    p = tuple(float(si) for si in sample)\n                    if all(0 <= p[d] <= bounds[d] for d in range(3)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                # 2D case similar without numpy, so do uniform samples until falling in ellipse\n                # Ellipse center and axes\n                center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n                c_min = dist(start_position, goal_position)\n                r1 = c_best / 2.0\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n                dx = goal_position[0] - start_position[0]\n                dy = goal_position[1] - start_position[1]\n                if dx == 0 and dy == 0:\n                    return sample_free()\n\n                angle = math.atan2(dy, dx)\n                cos_ang = math.cos(angle)\n                sin_ang = math.sin(angle)\n\n                while True:\n                    # Sample in unit circle\n                    theta = random.uniform(0, 2*math.pi)\n                    radius = random.uniform(0,1)**0.5\n                    x_ball = radius * math.cos(theta)\n                    y_ball = radius * math.sin(theta)\n                    # Scale by ellipse axes\n                    x_ellipse = r1 * x_ball\n                    y_ellipse = r2 * y_ball\n                    # Rotate by transformation angle and translate\n                    x_world = center[0] + cos_ang * x_ellipse - sin_ang * y_ellipse\n                    y_world = center[1] + sin_ang * x_ellipse + cos_ang * y_ellipse\n                    p = (x_world, y_world)\n                    if 0 <= p[0] <= bounds[0] and 0 <= p[1] <= bounds[1] and not self._is_in_obstacle(p, obstacles, False):\n                        return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(num_nodes):\n            r = self.radius_const * (math.log(num_nodes + 1) / (num_nodes + 1))**(1.0/dim)\n            return max(self.radius_min, r)\n\n        def nearest(tree_kdtree, point):\n            return tree_kdtree.nearest(point)\n\n        def near_nodes(tree_kdtree, pos, radius):\n            return tree_kdtree.near(pos, radius)\n\n        def try_extend(tree, tree_kdtree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree_kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, tree_kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        best_path_cost = None\n\n        for itr in range(self.max_iter):\n            # Build KD-trees for fast queries\n            tree_start_kdtree = KDTree([(n.position, n) for n in tree_start])\n            tree_goal_kdtree = KDTree([(n.position, n) for n in tree_goal])\n\n            # Adaptive goal sample rate: after path found, use informed sampling\n            if best_path_cost is not None:\n                sample = sample_free(best_path_cost)\n            else:\n                sample = sample_free()\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_start_kdtree, tree_goal_kdtree = tree_goal_kdtree, tree_start_kdtree\n\n            new_node_start = try_extend(tree_start, tree_start_kdtree, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, tree_goal_kdtree, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                # Track best path cost and path\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                candidate_path = path_start + path_goal[::-1][1:]\n                total_cost = new_node_start.cost + new_node_goal.cost + dist(new_node_start.position, new_node_goal.position)\n                if best_path_cost is None or total_cost < best_path_cost:\n                    extracted_path = candidate_path\n                    best_path_cost = total_cost\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 49.5837,
    "time_improvement": -174.0,
    "length_improvement": 9.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.034673023223876956,
            "num_nodes_avg": 88.0,
            "path_length_avg": 169.23597734191665,
            "smoothness_avg": 0.016643456141558946,
            "success_improvement": 0.0,
            "time_improvement": -37.72174051388117,
            "length_improvement": 7.239079103223635,
            "smoothness_improvement": 160.50623045887917,
            "objective_score": -9.066175181225228
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3502053737640381,
            "num_nodes_avg": 299.1,
            "path_length_avg": 280.7551511067476,
            "smoothness_avg": 0.008082599687281894,
            "success_improvement": 0.0,
            "time_improvement": -112.2093939641292,
            "length_improvement": 6.275849471611193,
            "smoothness_improvement": 107.97111161500456,
            "objective_score": -31.867792736841505
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.240952205657959,
            "num_nodes_avg": 210.5,
            "path_length_avg": 130.48269595174102,
            "smoothness_avg": 0.019512825539765667,
            "success_improvement": 0.0,
            "time_improvement": -370.75350237652947,
            "length_improvement": 13.339606267142647,
            "smoothness_improvement": 148.20170057885824,
            "objective_score": -107.81712095663602
        }
    ],
    "smoothness_improvement": 139.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation enhances the bidirectional informed RRT* by integrating adaptive ellipsoidal sampling focused on the current best path length, efficient KD-tree based nearest neighbor queries and rewiring, collision caching to avoid redundant checks, and periodic pruning of nodes unlikely to improve the solution. The planner incrementally refines the path by connecting the two trees grown from start and goal, rewiring neighbors for cost reduction, and applying shortcut smoothing to the final path to minimize length and enhance smoothness, thereby improving planning efficiency, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternating expansions. Sampling is biased within an adaptive ellipsoid enclosing the best path found so far to accelerate convergence towards shorter paths. The KD-tree accelerates nearest neighbor and radius searches for rewiring. New nodes and edges are added after thorough collision checks. Incremental rewiring enhances path cost improvements, and pruning removes nodes that can't improve the current best cost to reduce computational load. Once a path is found, shortcut smoothing refines the path length and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best, best_dist = None, float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best, best_dist = self.nodes[i], d\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)], dtype=float)\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)], dtype=float)\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min / 2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.41515,
    "time_improvement": 25.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02038121223449707,
            "num_nodes_avg": 75.7,
            "path_length_avg": 170.00074963763453,
            "smoothness_avg": 0.045661882485008146,
            "success_improvement": 0.0,
            "time_improvement": 19.04553564326056,
            "length_improvement": 6.819895289348138,
            "smoothness_improvement": 614.7076172552462,
            "objective_score": 10.151177837124028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04544069766998291,
            "num_nodes_avg": 210.0,
            "path_length_avg": 229.22177479210396,
            "smoothness_avg": 0.10448643197711793,
            "success_improvement": 0.0,
            "time_improvement": 72.4648916428349,
            "length_improvement": 23.479173791432316,
            "smoothness_improvement": 2588.5111533062245,
            "objective_score": 39.37785801766805
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.058935809135437014,
            "num_nodes_avg": 190.0,
            "path_length_avg": 123.1088988983347,
            "smoothness_avg": 0.11182887949059708,
            "success_improvement": 0.0,
            "time_improvement": -15.144156867713681,
            "length_improvement": 18.236931167531854,
            "smoothness_improvement": 1322.455092771138,
            "objective_score": 5.716414637047957
        }
    ],
    "smoothness_improvement": 1509.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a Hybrid Adaptive Bidirectional Anytime RRT* (HABA-RRT*) strategy that combines dynamic informed ellipsoid and uniform sampling with an adaptive neighbor radius evolving over iterations. It grows two trees bidirectionally with prioritized rewiring and lazy collision checks for efficiency. The planner incorporates a dynamic domain reduction based on current best path cost, aggressive pruning of non-promising nodes, and multi-scale shortcut smoothing applying both local and global shortcuts incrementally over the planning process. The integration of a priority queue for rewiring candidates accelerates optimization steps, while caching collision checks minimizes redundant queries. The approach balances exploration and exploitation, resulting in improved path quality, robustness, and reduced planning time in complex 2D/3D environments.",
    "planning_mechanism": "The planner alternates growth between start and goal trees, sampling adaptively inside a dynamically shrinking informed ellipsoid augmented with occasional global uniform samples to avoid local minima. It uses a priority queue to manage rewiring for quick convergence, caching collision results for efficiency. Aggressive node pruning removes nodes unlikely to contribute to better solutions. Incremental multi-scale shortcut smoothing progressively enhances path smoothness without heavy computational cost per iteration. The planner stops when it finds a high-quality path or reaches maximum iterations, outputting a refined collision-free path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children = []\n        self.valid = True                   # For collision validity or lazy checking\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float = 5.0,\n                 neighbor_min_radius: float = 6.0, neighbor_max_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 350,\n                 smoothing_iters_local: int = 80, smoothing_iters_global: int = 40,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters_local = smoothing_iters_local\n        self.smoothing_iters_global = smoothing_iters_global\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import heapq\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        # Adaptive neighbor radius shrinks over iterations and depends on node count\n        def neighbor_radius(iteration, n_nodes):\n            n = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.93)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(n+1) / n)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # Collision caches for nodes and edges: Lazy evaluation\n        node_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_obstacle_cache:\n                return node_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Dynamic informed ellipsoid sampler with occasional global uniform samples (10%) to avoid local minima\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            elite_sample_prob = 0.90\n\n            # If no path found yet, uniform random sampling with retries\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            if random.random() < elite_sample_prob:\n                center = np.array([(start[d]+goal[d])/2.0 for d in range(dim)])\n                a1 = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n                I = np.eye(dim)\n\n                v = a1 - np.array([1]+[0]*(dim-1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = I - 2*np.outer(v, v)\n                else:\n                    rot = I\n\n                r1 = c_best/2.0\n                r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n                radii = np.array([r1]+[r_others]*(dim-1))\n\n                for _ in range(150):\n                    x_ball = np.random.uniform(-1,1,dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-10:\n                        r_scale = random.uniform(0,1)**(1.0/dim)\n                        sample = rot @ (x_ball/norm_x*r_scale*radii) + center\n                        p = tuple(float(ci) for ci in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fallback uniform\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            else:\n                # Global uniform with slight edge bias to maintain global exploration (~10%)\n                def edge_biased_sample(dim_idx):\n                    edge_zone = bounds[dim_idx]*0.15\n                    choice = random.random()\n                    if choice < 0.4:\n                        if random.random() < 0.5: \n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[dim_idx]-edge_zone, bounds[dim_idx])\n                    else:\n                        return random.uniform(0, bounds[dim_idx])\n                for _ in range(25):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n        # KDTree substitute for nearest and radius search: linear scan for moderate node counts\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius*radius\n                results = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta*delta\n                        if sqd > radius_sq:\n                            break\n                    if sqd <= radius_sq:\n                        results.append(n)\n                return results\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        # Aggressive pruning of nodes unlikely to improve best path cost\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            dist_heuristic = dist  # alias for performance\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist_heuristic(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                edges = [e for e in edges if e[0]!=rn and e[1]!=rn]\n                removed += 1\n            return removed\n\n        # Multi-scale incremental shortcut smoothing:\n        # local smoothing: small-step adjacent shortcuts\n        # global smoothing: long range shortcuts between random nodes\n        def incremental_smooth_path(path, local_iters, global_iters):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n\n            for _ in range(local_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length-3)\n                if can_connect(p[i], p[i+2]):\n                    p = p[:i+1] + p[i+2:]\n                    length = len(p)\n\n            for _ in range(global_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length-3)\n                j = random.randint(i+2, length-1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n\n            return p\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        # Priority queue for rewiring candidates: (cost_improvement, node)\n        # This speeds up rewiring selection and early pruning\n        def rewire_neighbors(new_node, near_nodes):\n            rewire_candidates = []\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    heapq.heappush(rewire_candidates, (neighbor.cost - cost_through_new, neighbor))\n            while rewire_candidates:\n                _, neighbor = heapq.heappop(rewire_candidates)\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth direction for balance & progress\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node efficiently\n            rewire_neighbors(new_node, near_nodes)\n\n            # Try connect new_node to tree_b incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                rewire_neighbors(new_node_b, near_b)\n\n                # Check termination condition of connection\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Incremental multi-scale smoothing with progressively more global shortcuts for better refinement\n                    # Early iterations favor local smoothing, later favor global\n                    local_iterations = max(1, int(self.smoothing_iters_local * (1.0 - iteration / self.max_iter)))\n                    global_iterations = max(1, int(self.smoothing_iters_global * (iteration / self.max_iter)))\n\n                    smoothed_path = incremental_smooth_path(merged_path, local_iterations, global_iterations)\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Aggressive periodic pruning for memory and planning speed\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -19.86697,
    "time_improvement": 32.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02017521858215332,
            "num_nodes_avg": 71.7,
            "path_length_avg": 162.06219238469308,
            "smoothness_avg": 0.04753312979874469,
            "success_improvement": 0.0,
            "time_improvement": 19.863745354955277,
            "length_improvement": 11.17114431417498,
            "smoothness_improvement": 643.9967011938032,
            "objective_score": 11.413335975290593
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04936656951904297,
            "num_nodes_avg": 213.7,
            "path_length_avg": 233.98320844140443,
            "smoothness_avg": 0.08986418475998188,
            "success_improvement": 0.0,
            "time_improvement": 70.08598215633684,
            "length_improvement": 21.889670189027182,
            "smoothness_improvement": 2212.2702004303496,
            "objective_score": 36.46507968685823
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.047847533226013185,
            "num_nodes_avg": 171.9,
            "path_length_avg": 126.6899026289639,
            "smoothness_avg": 0.1115574428032223,
            "success_improvement": 0.0,
            "time_improvement": 6.51924606908424,
            "length_improvement": 15.858598998721254,
            "smoothness_improvement": 1319.0024381431028,
            "objective_score": 11.722505811185037
        }
    ],
    "smoothness_improvement": 1392.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the strengths of bidirectional informed RRT* algorithms with adaptive ellipsoidal and Gaussian perturbation sampling, efficient KD-tree accelerated nearest neighbor search, lazy collision checking with caching, incremental multi-step tree connection, dynamic neighbor radius adjustment, aggressive pruning of non-promising nodes, and iterative shortcut smoothing. It balances rapid convergence, robustness, and path optimality in both 2D and 3D environments by adaptively focusing sampling within the promising informed ellipsoid or near the best path and maintaining lean trees through pruning.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternating growth on the smaller tree. Sampling alternates between adaptive perturbation near the current best path and ellipsoidal informed sampling within an evolving ellipsoid bounded by the shortest known path. Nearest neighbors and radius searches use a simple KD-tree structure for efficiency. Nodes and edges are added only after strict collision and boundary validations, with edges cached to reduce redundant checks. Incremental multi-step connections attempt to join the two trees. Aggressive pruning removes nodes unlikely to improve the current best path to reduce search space. Upon finding a connection, iterative shortcut smoothing refines the path for length and smoothness before returning the solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_pos(p):\n            return tuple(max(0, min(p[d], bounds[d])) for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return clamp_pos(new_p)\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) **2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) -1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                # Prune if cost + heuristic >= best_cost (with numerical margin)\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            # Adaptive sampling near best path or ellipsoidal informed sampling\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Grow smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from the other tree toward new_node.pos\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Post-connection iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Aggressive periodic pruning of nodes unlikely to improve best path\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.39332,
    "time_improvement": 24.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020981764793395995,
            "num_nodes_avg": 66.9,
            "path_length_avg": 161.3011772801486,
            "smoothness_avg": 0.05375936329665141,
            "success_improvement": 0.0,
            "time_improvement": 16.660132352996886,
            "length_improvement": 11.588268752031828,
            "smoothness_improvement": 741.4507759184868,
            "objective_score": 11.022947335897866
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05384230613708496,
            "num_nodes_avg": 234.3,
            "path_length_avg": 237.84247146561407,
            "smoothness_avg": 0.09678145807054907,
            "success_improvement": 0.0,
            "time_improvement": 67.37387826983937,
            "length_improvement": 20.601337108819003,
            "smoothness_improvement": 2390.256625021822,
            "objective_score": 36.283714027824715
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05718584060668945,
            "num_nodes_avg": 205.1,
            "path_length_avg": 123.13583881209067,
            "smoothness_avg": 0.12967151087218626,
            "success_improvement": 0.0,
            "time_improvement": -11.725205745406713,
            "length_improvement": 18.219038959555977,
            "smoothness_improvement": 1549.4120469389,
            "objective_score": 7.873306302983681
        }
    ],
    "smoothness_improvement": 1560.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an enhanced bidirectional informed RRT* variant combining adaptive ellipsoidal and Gaussian sampling for focused exploration near the current best path, KD-tree accelerated nearest and radius searches, lazy collision checking with caching, dynamic neighbor radius adaptation, incremental multi-step connection attempts, aggressive pruning of non-promising nodes, and iterative shortcut smoothing for efficient convergence to short, smooth, and robust paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal by sampling mostly near the best known path and adaptively within an informed ellipsoid defined by the current best solution. It extends the smaller tree each iteration, connecting new nodes with rewiring for local optimization. Incremental multi-step attempts connect opposite trees efficiently, while collision caching reduces redundant checks. Periodic aggressive pruning eliminates costly suboptimal nodes. Once connected, the best path undergoes iterative shortcut smoothing to improve quality. This combination enhances planning efficiency, path quality, success rate, and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For pruning or collision checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # With goal bias\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2.0) ** 2, 0)\n            r_others = math.sqrt(val)\n            radii = np.array([r1] + [r_others] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x_norm = x / norm_x\n                radius_sample = np.power(np.random.uniform(0, 1), 1 / dim)\n                sample = rot @ (x_norm * radius_sample * radii) + center\n                p_tuple = tuple(float(coord) for coord in sample)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            # 75% near best path with gaussian noise, else informed ellipsoid sampling\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_pt = tuple(base[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_pt) and not is_in_obstacle(sample_pt):\n                        return sample_pt\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(node_list, best_cost, root_s, root_g):\n            removed_count = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in node_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                # Disconnect from parent\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(node)\n                except ValueError:\n                    pass\n                removed_count += 1\n            return removed_count\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b toward new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative smoothing\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic aggressive pruning\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -23.44177,
    "time_improvement": 41.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01934525966644287,
            "num_nodes_avg": 69.5,
            "path_length_avg": 157.26922340812618,
            "smoothness_avg": 0.04823528206544871,
            "success_improvement": 0.0,
            "time_improvement": 23.16035395146047,
            "length_improvement": 13.798246559684957,
            "smoothness_improvement": 654.9869089157728,
            "objective_score": 12.982690041953996
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04646854400634766,
            "num_nodes_avg": 212.7,
            "path_length_avg": 236.15684812686385,
            "smoothness_avg": 0.10129187144661571,
            "success_improvement": 0.0,
            "time_improvement": 71.8420609712668,
            "length_improvement": 21.16404669727148,
            "smoothness_improvement": 2506.312809907457,
            "objective_score": 38.31699168037162
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.036221981048583984,
            "num_nodes_avg": 155.2,
            "path_length_avg": 123.94116138336044,
            "smoothness_avg": 0.11350843290569693,
            "success_improvement": 0.0,
            "time_improvement": 29.23233719701811,
            "length_improvement": 17.68418205305853,
            "smoothness_improvement": 1343.8188882394704,
            "objective_score": 19.025632010914492
        }
    ],
    "smoothness_improvement": 1502.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This implementation enhances the bidirectional informed RRT* path planning by tuning and optimizing critical parameters for improved planning efficiency, success rate, and path quality. Key improvements include adaptive step size and neighbor radius for faster convergence, increased pruning frequency and threshold to remove unpromising nodes early, refined collision check resolution for precision, and more shortcut smoothing iterations for smoother, shorter paths. This planner maintains robust collision checking and incremental rewiring for cost minimization in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, sampling adaptively within a shrinking ellipsoid informed by the best path cost found. It uses a KD-tree for efficient nearest and neighbor searches, incrementally connects and rewires nodes with collision checks, prunes nodes unlikely to contribute to better paths regularly, and applies shortcut smoothing on the final path to improve smoothness and length. The process continues until reaching a maximum iteration limit or an improved optimal path is obtained.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Collision-validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 7000, step_size: float=4.0,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=25.0,\n                 prune_interval: int=100,\n                 prune_threshold: int=250,\n                 smoothing_iterations: int=150,\n                 collision_check_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                trials = 0\n                while trials < 15:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                    trials += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim - 1))\n\n            for _ in range(60):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent and rm_node in rm_node.parent.children:\n                    rm_node.parent.children.remove(rm_node)\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-14 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-14 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-14 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-14 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.01386,
    "time_improvement": -8.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.036229491233825684,
            "num_nodes_avg": 93.1,
            "path_length_avg": 159.61183234321436,
            "smoothness_avg": 0.043447859017905495,
            "success_improvement": -9.999999999999998,
            "time_improvement": -43.90405354728003,
            "length_improvement": 12.514225481349067,
            "smoothness_improvement": 580.0533421661789,
            "objective_score": -57.768104257083294
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0785480260848999,
            "num_nodes_avg": 306.0,
            "path_length_avg": 235.1558705128943,
            "smoothness_avg": 0.09665593925570524,
            "success_improvement": 0.0,
            "time_improvement": 52.40327458885245,
            "length_improvement": 21.498201836357634,
            "smoothness_improvement": 2387.026935508343,
            "objective_score": 31.955757421468977
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06712758541107178,
            "num_nodes_avg": 200.0,
            "path_length_avg": 124.61266994997796,
            "smoothness_avg": 0.12842366331244742,
            "success_improvement": 0.0,
            "time_improvement": -31.148606222762147,
            "length_improvement": 17.238198036912944,
            "smoothness_improvement": 1533.5395180855478,
            "objective_score": 1.7707553309816841
        }
    ],
    "smoothness_improvement": 1500.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified, generalized bidirectional RRT* planner optimized for path quality and efficiency. It grows two trees from the start and goal, alternately extending towards randomly sampled free points, while ensuring collision-free nodes and edges. Rewiring locally improves path cost, and path extraction merges the trees once connected. The approach balances exploration and optimization to achieve robust, smooth, and efficient path planning in both 2D and 3D spaces.",
    "planning_mechanism": "The planner alternately samples random free positions within map bounds, extends the start and goal trees towards these samples by a fixed step size, checks collisions for nodes and edges rigorously, and rewires neighbors to reduce path cost locally. Upon connecting the two trees, the final path is extracted by merging their root-to-connection-node paths, avoiding duplication. The process runs until a path is found or maximum iterations are reached.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position                  # Tuple[float, ...] \u2192 2D or 3D point\n        self.parent = parent                      # Parent Node or None\n        self.cost = cost                          # Cost from root to this node\n        self.children: List['Node'] = []         # Child nodes\n        self.valid = True                         # Validity flag (collision-free)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Map size tuple (W,H) or (W,H,D)\n        start_pos = map.start              # Start position tuple\n        goal_pos = map.goal                # Goal position tuple\n        obstacles = map.obstacles          # List of obstacles as boxes\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n        success = False\n        path: List[Tuple[float, ...]] = []\n\n        start_root = Node(start_pos, None, 0.0)\n        goal_root = Node(goal_pos, None, 0.0)\n        start_tree = [start_root]\n        goal_tree = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def sample_free() -> Tuple[float, ...]:\n            while True:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def near_nodes(tree: List[Node], new_node: Node) -> List[Node]:\n            return [node for node in tree if math.dist(node.position, new_node.position) <= self.neighbor_radius]\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            if any(p2[i] < 0 or p2[i] > bounds[i] for i in range(len(bounds))):\n                return False\n            return True\n\n        def add_node(tree: List[Node], pos: Tuple[float, ...], parent_node: Node) -> Node:\n            cost = parent_node.cost + math.dist(parent_node.position, pos)\n            new_node = Node(pos, parent_node, cost)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def rewire(tree: List[Node], new_node: Node):\n            neighbors = near_nodes(tree, new_node)\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                dist_new_to_node = math.dist(new_node.position, node.position)\n                new_cost = new_node.cost + dist_new_to_node\n                if new_cost < node.cost and can_connect(new_node.position, node.position):\n                    old_parent = node.parent\n                    if old_parent:\n                        try:\n                            old_parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    node.parent = new_node\n                    node.cost = new_cost\n                    new_node.children.append(node)\n                    try:\n                        edges.remove((old_parent, node))\n                    except ValueError:\n                        pass\n                    edges.append((new_node, node))\n                    self._update_costs_descendants(node)\n\n        def trees_can_connect(node_start: Node, node_goal: Node) -> bool:\n            if not can_connect(node_start.position, node_goal.position):\n                return False\n            return True\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            # Remove duplicate connection point if any\n            if path_start[-1] == path_goal[0]:\n                path_goal = path_goal[1:]\n            return path_start + path_goal\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate between extending start_tree and goal_tree\n            for tree_src, tree_tgt in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_src, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not can_connect(nearest_node.position, new_pos):\n                    continue\n\n                new_node = add_node(tree_src, new_pos, nearest_node)\n                rewire(tree_src, new_node)\n\n                nearest_other = nearest(tree_tgt, new_node.position)\n                if trees_can_connect(new_node, nearest_other):\n                    # Connect trees and extract the path\n                    success = True\n                    path = extract_path(new_node, nearest_other)\n                    return PlannerResult(success, path, nodes, edges)\n\n            # Swap trees to balance growth\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return PlannerResult(success, path, nodes, edges)\n\n    def _update_costs_descendants(self, node: Node):\n        import math\n        for child in node.children:\n            child.cost = node.cost + math.dist(node.position, child.position)\n            self._update_costs_descendants(child)\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -8.86629,
    "time_improvement": 29.0,
    "length_improvement": -2.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017812442779541016,
            "num_nodes_avg": 93.2,
            "path_length_avg": 194.89947960061312,
            "smoothness_avg": 0.011280241958940302,
            "success_improvement": 0.0,
            "time_improvement": 29.248724388331414,
            "length_improvement": -6.827493148984826,
            "smoothness_improvement": 76.56028209489263,
            "objective_score": 7.791920097176921
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03372082710266113,
            "num_nodes_avg": 230.4,
            "path_length_avg": 286.2111397362346,
            "smoothness_avg": 0.007529462813502211,
            "success_improvement": 0.0,
            "time_improvement": 79.56662912818008,
            "length_improvement": 4.4544834251631515,
            "smoothness_improvement": 93.73850144426693,
            "objective_score": 25.229577930707986
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06206090450286865,
            "num_nodes_avg": 295.6,
            "path_length_avg": 154.25072039822524,
            "smoothness_avg": 0.014803096003523784,
            "success_improvement": 0.0,
            "time_improvement": -21.249722846916473,
            "length_improvement": -2.4459838585112386,
            "smoothness_improvement": 88.29428851393433,
            "objective_score": -6.422642183207518
        }
    ],
    "smoothness_improvement": 86.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is a high-performance bidirectional RRT* variant that integrates adaptive informed ellipsoidal sampling with dynamic neighbor radius tuning, efficient KD-tree accelerated nearest and radius search, collision caching for optimized collision checks, incremental rewiring for improved path quality, and aggressive shortcut smoothing for path refinement. It balances exploration and exploitation by extending the smaller tree first, pruning non-promising nodes periodically, and strictly enforcing map bounds and collision constraints to ensure efficient search, faster convergence, shorter paths, and smooth final trajectories in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternating extension toward adaptive informed samples inside an ellipsoidal domain bounded by the current best path cost. KD-trees accelerate nearest neighbor queries for rewiring. Nodes and edges are added only if they pass rigorous collision and map-bound checks. Incremental connection attempts between trees improve chances of early successful path discovery. Periodically, nodes that cannot improve the current best solution are pruned. After finding a path, an aggressive shortcut smoothing is applied iteratively. Throughout, a collision cache reduces redundant expensive checks, maximizing planning efficiency and path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root along path\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle tuples\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d_] + ratio * (to_pos[d_] - from_pos[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform random sampling within bounds and free of obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Ellipsoidal informed sampling\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost: float) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: List[Tuple[float, ...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Extend smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection attempts from opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Continue to search if time allows for even better paths (optional: could break here)\n                # break  # Uncomment to stop at first found path\n\n            # Periodic pruning of nodes unlikely to improve the solution\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()  # Clearing cache after pruning\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 912.13033,
    "time_improvement": -3076.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.4713154554367065,
            "num_nodes_avg": 309.9,
            "path_length_avg": 159.69574578906995,
            "smoothness_avg": 0.048644910700398815,
            "success_improvement": 0.0,
            "time_improvement": -5744.085877927657,
            "length_improvement": 12.46823119198198,
            "smoothness_improvement": 661.3984865755599,
            "objective_score": -1717.4251247070226
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.31171555519104,
            "num_nodes_avg": 815.0,
            "path_length_avg": 235.73247924126264,
            "smoothness_avg": 0.09853560315232943,
            "success_improvement": 0.0,
            "time_improvement": -694.8432087965749,
            "length_improvement": 21.30571324606627,
            "smoothness_improvement": 2435.3920414356635,
            "objective_score": -192.0148597825809
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.478032922744751,
            "num_nodes_avg": 525.6,
            "path_length_avg": 124.2278120324066,
            "smoothness_avg": 0.09983779798623157,
            "success_improvement": 0.0,
            "time_improvement": -2787.664684828035,
            "length_improvement": 17.493802340799157,
            "smoothness_improvement": 1169.9294211251772,
            "objective_score": -826.9509978746248
        }
    ],
    "smoothness_improvement": 1422.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a hybrid bidirectional informed RRT* with enhanced adaptive ellipsoidal sampling, incorporates efficient KD-tree based nearest neighbor queries optimized via caching, and collision check memoization for nodes and edges. It aggressively prunes non-promising nodes based on heuristic cost bounds, uses incremental rewiring to improve path quality, and applies multiple shortcut smoothing iterations to yield smooth, shorter paths. The ellipsoidal sampling region shrinks dynamically as better paths are found, focusing the search and improving efficiency. The planner alternates tree growth between start and goal, ensures strict boundary and obstacle validation for nodes and edges, speeding up planning and increasing success rate and robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates expansion between two trees starting from start and goal positions. It samples points within a progressively shrinking informed ellipsoid shaped by the current best path cost, improving sampling efficiency. KD-tree structures support fast nearest neighbor and radius queries needed for rewiring. Collision checks for nodes and edges are cached to avoid redundant computations. Non-promising nodes are pruned regularly. Upon connecting the trees, multiple shortcut smoothing attempts refine the path. The process iterates up to max iterations or until a satisfactory path is found, balancing exploration and exploitation to improve planning time, path quality, and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coords\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        # Parameters for neighbor radius calculation\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n\n        # Pruning parameters\n        self.prune_interval = 150\n        self.prune_threshold = 250\n\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int,...]\n        start_pos = map.start              # Tuple[float,...]\n        goal_pos = map.goal                # Tuple[float,...]\n        obstacles = map.obstacles          # List obstacles (boxes)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                # Construct a simple kd-tree for nearest neighbor and radius search with caching\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                # Linear search sufficient due to limited node count per iteration and for caching simplicity\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    squared_dist = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        squared_dist += delta * delta\n                        if squared_dist > r2:\n                            break\n                    if squared_dist <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Informed sampling within adaptive ellipsoid centered at midpoint of start and goal\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                # Uniform random sampling with retry to avoid obstacles\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # Fallback naive uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if i == 0 else 0 for i in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    sample = rot @ (x_scaled * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sample if ellipsoid sampling fails\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            coll = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = coll\n            return not coll\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                # Heuristic-based pruning: prune if cost + heuristic >= best found cost\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        # Precompute heuristic distances to goal for pruning efficiency\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of trees biased to smaller tree for balanced expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent for new node among neighbors\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper and collision free\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect the opposite tree incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    # Merge path from both trees\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with multiple shortcut calls\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune nodes periodically to improve efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n               and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.95329,
    "time_improvement": 48.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015650105476379395,
            "num_nodes_avg": 67.5,
            "path_length_avg": 162.98104746529913,
            "smoothness_avg": 0.04185606495416218,
            "success_improvement": 0.0,
            "time_improvement": 37.83755885617312,
            "length_improvement": 10.6675052843043,
            "smoothness_improvement": 555.1383084324613,
            "objective_score": 16.260460255875103
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.051227784156799315,
            "num_nodes_avg": 219.8,
            "path_length_avg": 239.2812421323719,
            "smoothness_avg": 0.10209905014732215,
            "success_improvement": 0.0,
            "time_improvement": 68.95816613778094,
            "length_improvement": 20.12103404753779,
            "smoothness_improvement": 2527.0820992639524,
            "objective_score": 37.3470671471616
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03288521766662598,
            "num_nodes_avg": 157.8,
            "path_length_avg": 123.92216613288151,
            "smoothness_avg": 0.11772938731234146,
            "success_improvement": 0.0,
            "time_improvement": 35.75144352505184,
            "length_improvement": 17.696797793970003,
            "smoothness_improvement": 1397.5091167335431,
            "objective_score": 21.252338199977267
        }
    ],
    "smoothness_improvement": 1493.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved path planner implements a hybrid anytime informed bidirectional RRT* combined with adaptive lazy-collision bidirectional PRM* principles to optimize path length, smoothness, and planning efficiency. It uses an evolving informed ellipsoidal sampling region biased by the current best path cost and adaptive neighbor radius to balance exploration and exploitation. KD-tree accelerated neighbor queries enable efficient rewiring to reduce path costs. Lazy collision checking with caching avoids redundant costly computations, and incremental multi-step tree connections improve robustness. The planner aggressively prunes nodes that cannot lead to better solutions to maintain manageable search complexity. Finally, the extracted path is iteratively shortcut-smoothed to produce a shorter and smoother trajectory.",
    "planning_mechanism": "The planner initializes two trees from start and goal, extending the smaller tree each iteration by sampling inside an informed ellipsoid or near the current best path. New nodes connect to the best cost parents found within an adaptive neighbor radius, rewiring neighbors for cost improvement. Trees connect incrementally with multiple step attempts ensuring collision-free bridging. Periodic pruning discards suboptimal nodes to accelerate convergence. When a successful connection occurs, the path is extracted and shortcut-smoothed before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []              # For rewiring and pruning\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x /= norm_x\n                x *= np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(tree_nodes, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in tree_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Choose smaller tree to extend\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position,n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Parent selection minimizing cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt incremental multi-step connection from tree_b to new_node\n            kdtree_b = KDTree([(n.position,n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire neighbors in tree_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if connection to new_node is possible\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to remove nodes unlikely to improve solution\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.76458,
    "time_improvement": 42.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015248799324035644,
            "num_nodes_avg": 62.8,
            "path_length_avg": 155.5745732200483,
            "smoothness_avg": 0.037244017428828366,
            "success_improvement": 0.0,
            "time_improvement": 39.43155259080802,
            "length_improvement": 14.727111181221101,
            "smoothness_improvement": 482.9497494394867,
            "objective_score": 17.189636760684056
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.054264283180236815,
            "num_nodes_avg": 230.7,
            "path_length_avg": 234.42186128394013,
            "smoothness_avg": 0.09326487689474042,
            "success_improvement": 0.0,
            "time_improvement": 67.11817833116747,
            "length_improvement": 21.743235244266756,
            "smoothness_improvement": 2299.7724584772245,
            "objective_score": 35.982962840589714
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04189918041229248,
            "num_nodes_avg": 161.3,
            "path_length_avg": 126.64389596936796,
            "smoothness_avg": 0.11008114413305412,
            "success_improvement": 0.0,
            "time_improvement": 18.14067079430676,
            "length_improvement": 15.889154431423172,
            "smoothness_improvement": 1300.2240280275962,
            "objective_score": 15.121152264714643
        }
    ],
    "smoothness_improvement": 1361.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements a Bidirectional Informed RRT* with Progressive Region Refinement and Adaptive Tree Balancing. It combines dynamic ellipsoidal informed sampling focusing on increasingly narrower corridors as the path improves, aggressive yet efficient local rewiring using KD-tree approximations, and adaptive step sizing to balance exploration and exploitation. The planner includes lazy collision checks with caching, incremental multi-step tree connection attempts, and iterative post-processing shortcut smoothing to optimize path quality and smoothness. It prunes unpromising nodes periodically to maintain manageable tree sizes, enhancing robustness and reducing planning time while improving success rate and path optimality.",
    "planning_mechanism": "The planner alternately grows two RRT* trees from start and goal, using an adapting informed ellipsoid that shrinks with the current best path cost to bias sampling. Adaptive step sizes allow faster exploration early on, slowing near solutions for refinement. KD-trees accelerate neighbor queries for rewiring. Multi-step incremental connections attempt to link the trees with lazy collision checks to reduce overhead. Periodic pruning removes nodes unlikely to improve the solution, preventing bloated search. Upon connection, iterative shortcut smoothing refines the path for smoothness and shortened length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For marking validity / pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, \n                 step_size: float = 5.0,\n                 min_step_size: float = 1.0,\n                 max_step_size: float = 10.0,\n                 neighbor_min_radius: float = 5.0,\n                 neighbor_max_radius: float = 30.0,\n                 pruning_interval: int = 250,\n                 pruning_threshold: int = 400,\n                 shortcut_trials: int = 150,\n                 collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.pruning_interval = pruning_interval\n        self.pruning_threshold = pruning_threshold\n        self.shortcut_trials = shortcut_trials\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                new_p = to_p\n            else:\n                ratio = step / d\n                new_p = tuple(from_p[d] + ratio*(to_p[d]-from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        # Radius function with decay and node-count dependence\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.neighbor_max_radius\n            r_iter = self.neighbor_max_radius * (1 - (iteration/self.max_iter)**0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius-self.neighbor_min_radius)*math.sqrt(math.log(n_nodes + 1)/n_nodes)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        # KD-tree brute force wrapper\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        # Adaptive ellipsoidal informed sampling with progressive narrowing\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min*1.00001:\n                # Uniform sampling fallback\n                for _ in range(25):\n                    sp = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(sp):\n                        return sp\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            unit_vec = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = unit_vec - I[:,0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-10 < norm_x <= 1.0:\n                    x_ball = x_ball / norm_x * (random.uniform(0,1) ** (1.0/dim))\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n            # Fallback uniform\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Adaptive step size decreases as iterations progress and path improves\n        def adaptive_step(iteration, c_best, c_min):\n            if c_best == float('inf'):\n                return self.max_step_size\n            ratio = max(0.0, min(1.0, (c_best - c_min) / c_best))  # normalized gap\n            decayed = self.min_step_size + (self.max_step_size - self.min_step_size) * (ratio ** 1.5)\n            # also decay with iteration\n            iter_decay = self.min_step_size + (decayed - self.min_step_size) * (1 - iteration/self.max_iter)\n            return max(self.min_step_size, min(self.max_step_size, iter_decay))\n\n        # Shortcut smoothing with lazy collision checking\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_trials):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Prune nodes unlikely to improve cost using heuristic\n        def prune_tree(tree_nodes, best_cost, root_start, root_goal):\n            h = lambda pos: dist(pos, goal)\n            to_remove = []\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        # Initialize roots and trees\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        all_nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        for iter_id in range(self.max_iter):\n            step = adaptive_step(iter_id, c_best, c_min)\n\n            # Alternate tree with fewer nodes to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                grow_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                grow_from_start = False\n\n            # Build KD-tree for near queries in tree_a\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step)\n\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(len(all_nodes), iter_id)\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy rewiring: select best parent\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and not is_edge_colliding_cached(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cheaper cost\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and not is_edge_colliding_cached(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Build KD-tree for tree_b incremental connection attempts\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_b_new = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_b_new / step))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position, step)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_colliding_cached(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(all_nodes), iter_id)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_new = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_new + 1e-12 < nbr_b.cost and not is_edge_colliding_cached(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_new)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= step and not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n\n                    if grow_from_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Additional refinement through iterative shortcut smoothing\n                best_path = shortcut_path(best_path)\n                # Aggressive pruning of unpromising nodes if tree grows large\n                if len(all_nodes) > self.pruning_threshold:\n                    removed_start = prune_tree(tree_start, c_best, root_start, root_goal)\n                    removed_goal = prune_tree(tree_goal, c_best, root_start, root_goal)\n                    # Clear edge cache after pruning to avoid stale info\n                    edge_collision_cache.clear()\n                break\n\n            # Periodic pruning when trees grow large and a solution exists\n            if (iter_id > 0 and iter_id % self.pruning_interval == 0 and \n                len(all_nodes) > self.pruning_threshold and c_best < float('inf')):\n                removed_start = prune_tree(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_tree(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -27.21631,
    "time_improvement": 56.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02291569709777832,
            "num_nodes_avg": 71.8,
            "path_length_avg": 167.41125213292193,
            "smoothness_avg": 0.04959706276165424,
            "success_improvement": 0.0,
            "time_improvement": 8.978525783075938,
            "length_improvement": 8.23923990489491,
            "smoothness_improvement": 676.301733965502,
            "objective_score": 7.722914385729273
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01910278797149658,
            "num_nodes_avg": 108.4,
            "path_length_avg": 246.19192172859,
            "smoothness_avg": 0.10896772519235394,
            "success_improvement": 0.0,
            "time_improvement": 88.42453211129788,
            "length_improvement": 17.814050285437038,
            "smoothness_improvement": 2703.8180554792834,
            "objective_score": 43.609259967873186
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.015497398376464844,
            "num_nodes_avg": 82.1,
            "path_length_avg": 130.51260754238822,
            "smoothness_avg": 0.11377552512159901,
            "success_improvement": 0.0,
            "time_improvement": 69.72239974511233,
            "length_improvement": 13.319740412871662,
            "smoothness_improvement": 1347.2162815110482,
            "objective_score": 30.316749413663274
        }
    ],
    "smoothness_improvement": 1576.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines advanced bidirectional anytime informed RRT* features with adaptive ellipsoidal and heuristic-biased sampling, balanced tree growth, lazy collision checking with caching, dynamic neighbor radius adjustments, multi-step incremental connecting attempts, aggressive pruning of unpromising nodes, and iterative shortcut smoothing. It leverages KD-tree accelerated neighbor searches and robust rewiring strategies to improve convergence speed, robustness, and path quality in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately, using adaptive ellipsoidal sampling biased towards the current best path and Gaussian perturbations near it. Each iteration extends the smaller tree prioritizing minimal-cost parent selection via lazy collision checking. It incrementally attempts multi-step connections toward the opposite tree, rewires neighbors for path shortening, prunes nodes unlikely to improve the current best solution, and performs iterative shortcut smoothing to refine path quality. Caching and KD-tree searches optimize the computational cost to balance fast convergence, high success rates, and smooth, short paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking, pruning, etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 shortcut_iter: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_iter = shortcut_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp position within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Informed ellipsoidal sampling biased to current best path length\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                # Uniform sampling with retries to reduce obstacle collisions\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                # fallback uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            identity = np.eye(dim)\n            u = a1 - identity[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = identity - 2 * np.outer(u, u)\n            else:\n                rot = identity\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x < 1e-5 or norm_x > 1:\n                    continue\n                x_ball = x_ball / norm_x * np.random.uniform(0, 1) ** (1 / dim)\n                sample = rot @ (x_ball * radii) + center\n                p_tuple = tuple(float(coord) for coord in sample)\n                if in_bounds(p_tuple) and not is_in_obstacle_cached(p_tuple):\n                    return p_tuple\n\n            # fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # Adaptive sampling near best path with Gaussian perturbation plus fallback to informed sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle_cached(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if not is_edge_colliding_cached(p1, p2):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(nodes_list, best_cost, root_start, root_goal):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node is root_start or node is root_goal:\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes_all = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Grow smaller tree first to balance growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Node collision and edge collision checks\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes_all))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            # Select parent minimizing cost with lazy collision checks\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost:\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = cost_cand\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes_all.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve paths if possible (lazy collision checking)\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost_candidate = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_candidate + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, new_cost_candidate)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect new_node to opposite tree's nearest node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            dist_ab = dist(new_node.position, nearest_b.position)\n            connected = False\n\n            if dist_ab <= self.step_size and not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                # Direct connection possible\n                cost_conn = new_node.cost + dist_ab\n                connect_node = Node(nearest_b.position, parent=new_node, cost=cost_conn)\n                new_node.children.append(connect_node)\n                tree_a.append(connect_node)\n                nodes_all.append(connect_node)\n                edges.append((new_node, connect_node))\n\n                if tree_a is tree_start:\n                    path_start = connect_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connect_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_path(merged_path)\n\n                if cost_conn < c_best:\n                    c_best = cost_conn\n                    best_path = smoothed\n                    success_state = True\n\n                break  # finish on success\n\n            # Else incremental multi-step connection attempts from nearest_b toward new_node.position\n            max_steps = max(1, int(dist_ab / self.step_size))\n            last_node_b = nearest_b\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_colliding_cached(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes_all.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_nodes_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new)\n                            edges.append((new_node_b, neighbor_b))\n\n                # Check if can connect to new_node final step\n                if dist(new_node_b.position, new_node.position) <= self.step_size and \\\n                   not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    cost_final_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_final_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes_all.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed = shortcut_path(merged_path)\n\n                    if cost_final_conn < c_best:\n                        c_best = cost_final_conn\n                        best_path = smoothed\n                        success_state = True\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if success_state:\n                # Aggressively prune and shortcut upon success\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic aggressive pruning of nodes unlikely to improve best path\n            if it > 0 and it % self.prune_interval == 0 and len(nodes_all) > self.prune_threshold and c_best < float('inf'):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.99158,
    "time_improvement": 28.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018012094497680663,
            "num_nodes_avg": 66.5,
            "path_length_avg": 156.27054295348427,
            "smoothness_avg": 0.046106374276556464,
            "success_improvement": 0.0,
            "time_improvement": 28.455704929334715,
            "length_improvement": 14.345639141978689,
            "smoothness_improvement": 621.6648790223518,
            "objective_score": 14.514163702307911
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.043904471397399905,
            "num_nodes_avg": 204.6,
            "path_length_avg": 234.1694218222279,
            "smoothness_avg": 0.08872620193070556,
            "success_improvement": 0.0,
            "time_improvement": 73.39577869003443,
            "length_improvement": 21.82750680265333,
            "smoothness_improvement": 2182.9890825771686,
            "objective_score": 37.29918038042683
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05971472263336182,
            "num_nodes_avg": 200.8,
            "path_length_avg": 122.73903276137949,
            "smoothness_avg": 0.10950780387315384,
            "success_improvement": 0.0,
            "time_improvement": -16.66593690784731,
            "length_improvement": 18.4825786445647,
            "smoothness_improvement": 1292.9311822412405,
            "objective_score": 5.16139056776495
        }
    ],
    "smoothness_improvement": 1366.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a refined hybrid bidirectional RRT* algorithm combining informed ellipsoidal sampling and adaptive neighbor radius with efficient KD-tree based nearest neighbor searches, incremental rewiring, collision caching, and periodic pruning. It emphasizes focused sampling within an ellipsoid shaped by the current best path, aggressively prunes suboptimal branches, and applies shortcut smoothing to quickly converge on short, smooth, and collision-free paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two balanced trees rooted at start and goal, alternately sampling points informed by the best found cost to constrain search space. Using KD-trees for accelerated neighbor queries, it rewires nodes for path cost improvement and caches collision checks to reduce redundant computations. The two trees are incrementally connected, and upon successful linking, aggressive shortcut smoothing refines the solution. Periodic pruning removes nodes that cannot yield better paths, enhancing efficiency, robustness, and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            u = a1_np - np.array([1 if d == 0 else 0 for d in range(dim)])\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) * (c_min / 2), 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                    x_scaled = (x / norm_x) * radius_factor\n                    x_scaled = x_scaled * radii\n                    p = rot @ x_scaled + np.array(center)\n                    p_tuple = tuple(float(coord) for coord in p)\n                    if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                        return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -25.17326,
    "time_improvement": 43.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017141342163085938,
            "num_nodes_avg": 69.5,
            "path_length_avg": 155.4151103601911,
            "smoothness_avg": 0.047493421714181125,
            "success_improvement": 0.0,
            "time_improvement": 31.91434556481092,
            "length_improvement": 14.814515301559547,
            "smoothness_improvement": 643.3751834428977,
            "objective_score": 15.754082646969671
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04740707874298096,
            "num_nodes_avg": 222.9,
            "path_length_avg": 244.34756808487708,
            "smoothness_avg": 0.11688450983179502,
            "success_improvement": 0.0,
            "time_improvement": 71.27334928779209,
            "length_improvement": 18.429748618484563,
            "smoothness_improvement": 2907.5226264815924,
            "objective_score": 39.6055676424425
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.037335777282714845,
            "num_nodes_avg": 157.2,
            "path_length_avg": 123.68673778420703,
            "smoothness_avg": 0.14107973598461787,
            "success_improvement": 0.0,
            "time_improvement": 27.05628955836238,
            "length_improvement": 17.853158093266345,
            "smoothness_improvement": 1694.523828301445,
            "objective_score": 20.160137627669208
        }
    ],
    "smoothness_improvement": 1748.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This improved hybrid bidirectional informed RRT* planner integrates adaptive ellipse-based informed sampling, dynamic neighbor radius tuning, incremental rewiring, collision caching, aggressive pruning of non-promising nodes, and path shortcut smoothing. It balances exploration between start and goal trees, focuses sampling within a shrinking ellipsoid based on current best path cost, and applies efficient collision checks to enhance planning success, path quality, and convergence speed.",
    "planning_mechanism": "The planner alternately grows two bidirectional trees rooted at start and goal positions. It samples new nodes adaptively inside an ellipsoid defined by the best path cost to bias search towards the optimal path corridor. Nodes are steered with a step size limit, rewired within a dynamic radius, and connection attempts between trees happen frequently. Collision detection and pruning maintain efficiency. Final paths are smoothed with shortcutting for improved path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_iterations: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n\n            center = np.array([(start[d_] + goal[d_]) / 2.0 for d_ in range(dim)])\n            a1 = np.array([(goal[d_] - start[d_]) / c_min for d_ in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-10:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim - 1))\n\n            for _ in range(200):\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    try:\n                        rmn.parent.children.remove(rmn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate expanding smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect new_node with opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune unpromising nodes every prune_interval iterations\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.89619,
    "time_improvement": 41.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022204136848449706,
            "num_nodes_avg": 69.3,
            "path_length_avg": 156.81445324861423,
            "smoothness_avg": 0.04280664090635528,
            "success_improvement": 0.0,
            "time_improvement": 11.804853195752885,
            "length_improvement": 14.047513290407787,
            "smoothness_improvement": 570.0168862930024,
            "objective_score": 9.201043048272435
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.045001649856567384,
            "num_nodes_avg": 208.5,
            "path_length_avg": 238.47823771866751,
            "smoothness_avg": 0.0945938032058756,
            "success_improvement": 0.0,
            "time_improvement": 72.73093573406283,
            "length_improvement": 20.38910003403281,
            "smoothness_improvement": 2333.966689649665,
            "objective_score": 37.56693417527373
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03177974224090576,
            "num_nodes_avg": 139.3,
            "path_length_avg": 122.72318122172783,
            "smoothness_avg": 0.11554479808121051,
            "success_improvement": 0.0,
            "time_improvement": 37.91123462149739,
            "length_improvement": 18.493106482432133,
            "smoothness_improvement": 1369.7213029631612,
            "objective_score": 21.92059819775145
        }
    ],
    "smoothness_improvement": 1425.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified, efficient bidirectional RRT* with adaptive informed sampling biased towards start and goal. It balances growth by extending the smaller tree at each iteration, uses a dynamically shrinking rewiring radius for local optimality, enforces strict collision and boundary checks on nodes and edges, and periodically prunes dead-end nodes to maintain search efficiency. Upon connection of two trees, iterative shortcut smoothing refines the path for shorter and smoother trajectories, enhancing path quality and success rate while reducing computation time.",
    "planning_mechanism": "The planner alternates extension between start and goal trees, sampling adaptively biased towards start or goal positions. For each new sample, it steers from the nearest node in the smaller tree, adds collision-free nodes, and rewires nearby nodes within a dynamic radius to minimize cost. When the two trees connect, it extracts and smooths the path iteratively. Dead-end pruning helps reduce overhead and keeps the search focused.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision or pruning purposes\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 100,\n                 prune_threshold: int = 120, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success = False\n        path: list = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[i] <= bounds[i] for i in range(dim))\n\n        def sample_free(size_start, size_goal):\n            total = size_start + size_goal + 1e-9\n            bias_goal = size_goal / total\n            bias_start = size_start / total\n            p = random.random()\n            if p < self.goal_sample_rate:\n                p_biased = random.random()\n                if p_biased < (bias_goal * 0.75):\n                    return goal_pos\n                elif p_biased < (bias_goal * 0.75 + bias_start * 0.75):\n                    return start_pos\n            for _ in range(10):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return goal_pos\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + ratio * (to_pos[i] - from_pos[i]) for i in range(dim))\n\n        def nearest(tree, point):\n            min_node, min_d = None, float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_d:\n                    min_d = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (dist(n.position,pos)**2) <= r_sq]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            return max(self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)), self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p!=node and c!=node]\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def path_length(path_):\n            length = 0.\n            for i in range(len(path_)-1):\n                length += dist(path_[i], path_[i+1])\n            return length\n\n        def shortcut_smoothing(path_):\n            if len(path_) < 3:\n                return path_\n            for _ in range(self.smoothing_iterations):\n                if len(path_) < 3:\n                    break\n                i = random.randint(0, len(path_) - 3)\n                j = random.randint(i + 2, len(path_) - 1)\n                p1, p2 = path_[i], path_[j]\n                if can_connect(p1, p2):\n                    path_ = path_[:i+1] + path_[j:]\n            return path_\n\n        for iter_idx in range(self.max_iter):\n            sample_pt = sample_free(len(tree_start), len(tree_goal))\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    path = smoothed\n                else:\n                    path = raw_path\n                break\n\n            if iter_idx % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.42292,
    "time_improvement": 34.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.025647854804992674,
            "num_nodes_avg": 95.5,
            "path_length_avg": 166.44072607239266,
            "smoothness_avg": 0.03114752550170132,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1.8736434196620342,
            "length_improvement": 8.771200617640575,
            "smoothness_improvement": 387.52641203583534,
            "objective_score": -46.870220842191316
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06094250679016113,
            "num_nodes_avg": 143.3,
            "path_length_avg": 242.69448303826238,
            "smoothness_avg": 0.07053807817619023,
            "success_improvement": 0.0,
            "time_improvement": 63.071462057836236,
            "length_improvement": 18.981595988459393,
            "smoothness_improvement": 1714.9955579974699,
            "objective_score": 31.292735605030096
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030228853225708008,
            "num_nodes_avg": 112.8,
            "path_length_avg": 124.97370943696319,
            "smoothness_avg": 0.07333692289331398,
            "success_improvement": 0.0,
            "time_improvement": 40.941239819864464,
            "length_improvement": 16.99841280051025,
            "smoothness_improvement": 832.8402460343899,
            "objective_score": 19.84625573623334
        }
    ],
    "smoothness_improvement": 978.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines strengths from enhanced bidirectional RRT* and adaptive lazy-collision informed sampling techniques. It employs bidirectional tree growth with adaptive sampling biased towards the informed ellipsoid around the best path found so far. KD-tree-accelerated neighbor searches and caching of collision checks optimize computational cost. Dynamic neighbor radius shrinking, iterative rewiring, and aggressive pruning discard unpromising nodes to maintain efficiency. Continuous incremental connection attempts between the two trees improve the success rate and path quality. The planner applies iterative shortcut smoothing on the final path to ensure reduced path length and increased smoothness, while strictly enforcing bounds and collision constraints at every step.",
    "planning_mechanism": "The planner initializes two trees from start and goal and alternates extending the smaller one using samples drawn from an evolving informed ellipsoidal domain biased by the current best path cost. Each extension rewires neighbors within a dynamically adjusted radius leveraging KD-tree acceleration and lazy collision checks with caching. Incremental multi-step connection attempts facilitate bridging the trees. Periodic pruning maintains manageable tree size by removing nodes that cannot improve the best solution. Upon success, the path is extracted, shortcut smoothed, and returned, achieving improved planning efficiency, path optimality, and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 100, collision_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(p):\n            return self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        # Simple KD-tree for neighbor searching (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def can_connect(p1, p2):\n            # Cache key tuple sorted to avoid duplicates\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sampling inside evolving domain biased by current best cost c_best\n        def informed_sample(c_best, c_min, start, goal) -> tuple:\n            # If no path yet, sample random free points\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)   # Householder reflection matrix\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            # Try sampling points in the ellipsoid\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * (np.random.uniform(0,1) ** (1/dim))  # Uniform in unit ball\n                sample = rot @ (x * radii) + center\n                sample_tuple = tuple(float(s) for s in sample)\n                if in_bounds(sample_tuple) and not is_in_obstacle(sample_tuple):\n                    return sample_tuple\n\n            # Fallback random samples if unable to find in ellipsoid\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling: sample near best known path with Gaussian noise, fallback to informed_sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(max(n_nodes,1) + 1) / max(n_nodes,1))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(node_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for n in node_list:\n                if n in (root_s, root_g):\n                    continue\n                if n.cost + heuristic(n.position) >= best_cost - 1e-9:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    try:\n                        n.parent.children.remove(n)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(n)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        edge_collision_cache = {}\n\n        for itr in range(self.max_iter):\n            # Alternate which tree to extend (extend smaller)\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n            kdt_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdt_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), itr)\n            near_nodes_a = kdt_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, node.position)\n                if new_c + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_c)\n                    edges.append((new_node, node))\n\n            # Incrementally connect tree_b to new_node\n            kdt_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdt_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), itr)\n                near_nodes_b = kdt_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Connect check to new_node's position\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Prune nodes periodically for efficiency\n            if (itr > 0 and itr % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success else []\n\n        # Final smoothing for additional refinement\n        if success and len(extracted_path) > 2:\n            for _ in range(self.smoothing_iterations):\n                if len(extracted_path) < 3:\n                    break\n                i = random.randint(0, len(extracted_path) - 3)\n                j = random.randint(i + 2, len(extracted_path) - 1)\n                p1, p2 = extracted_path[i], extracted_path[j]\n                if can_connect(p1, p2):\n                    extracted_path = extracted_path[:i+1] + extracted_path[j:]\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -22.60429,
    "time_improvement": 40.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01983821392059326,
            "num_nodes_avg": 71.6,
            "path_length_avg": 162.40920970916468,
            "smoothness_avg": 0.04670560436178761,
            "success_improvement": 0.0,
            "time_improvement": 21.20233265527991,
            "length_improvement": 10.980938619790697,
            "smoothness_improvement": 631.0441311051766,
            "objective_score": 11.712108176067995
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05411078929901123,
            "num_nodes_avg": 223.6,
            "path_length_avg": 235.63868774199312,
            "smoothness_avg": 0.09815916646431869,
            "success_improvement": 0.0,
            "time_improvement": 67.21118902132905,
            "length_improvement": 21.337023548161053,
            "smoothness_improvement": 2425.7060543167604,
            "objective_score": 36.559291687614724
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.035620379447937014,
            "num_nodes_avg": 145.6,
            "path_length_avg": 125.56170039384592,
            "smoothness_avg": 0.1194595465961014,
            "success_improvement": 0.0,
            "time_improvement": 30.407699172919294,
            "length_improvement": 16.6078972040693,
            "smoothness_improvement": 1419.5166151158953,
            "objective_score": 19.541472268269125
        }
    ],
    "smoothness_improvement": 1492.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements an enhanced bidirectional RRT* algorithm with adaptive informed sampling that biases samples toward a heuristic ellipsoidal region between start and goal, reducing unnecessary exploration. It balances tree growth by always extending the smaller tree. The radius for rewiring dynamically decreases to focus local optimization efficiently. Collision and edge validity checks are rigorously enforced. Dead-end nodes are pruned periodically to maintain search efficiency, and an iterative shortcut smoothing refines the final path. Optimizations include early termination on connection with path cost improvements, adaptive sampling adapts search focus, and careful data structure management to speed up nearest neighbor queries and rewiring. These adjustments collectively reduce planning time, improve path optimality and smoothness, and increase success rate and robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal nodes, alternately extending the smaller tree to maintain balanced progress. The sampling is adaptively biased towards an informed ellipsoid region containing better paths, accelerating convergence. Each new node addition triggers rewiring within a dynamically computed radius that shrinks as the tree grows, enhancing local path optimality. Collision checks ensure safety when adding nodes or edges. Once the trees connect, the combined path undergoes iterative shortcut smoothing for refinement. Dead-end nodes get pruned periodically, decreasing overhead and improving computational efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position         # Tuple[float, ...]\n        self.parent = parent             # Node or None\n        self.cost = cost                 # Path cost from root\n        self.children = []\n        self.valid = True                # Collision validity flag\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0,\n                 radius_min: float = 5.0, prune_interval: int = 120,\n                 prune_threshold: int = 150, smoothing_iterations: int = 80,\n                 informed_sample_rate: float = 0.95):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.informed_sample_rate = informed_sample_rate  # Probability to sample inside ellipsoid\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Informed sampling helpers\n        def ellipse_contains(pos, c_best, c_min, start, goal):\n            # Returns True if pos inside ellipse defined by focal points start, goal and c_best cost.\n            # If no solution yet, consider whole space\n            if c_best == float('inf'):\n                return True\n\n            start_g = tuple(goal[d] - start[d] for d in range(len(start)))\n            c = c_best / 2.0\n            length = dist(start, goal) / 2.0\n            if length == 0:\n                return True\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(len(start)))\n            # Build rotation to align major axis along start-goal vector\n            if is_3d:\n                import numpy as np\n                focal_vec = np.array(start_g)\n                norm_focal = np.linalg.norm(focal_vec)\n                if norm_focal == 0:\n                    return True\n                focal_vec /= norm_focal\n                pos_vec = np.array([pos[d] - center[d] for d in range(len(pos))])\n                # Eigenvalues for ellipse axes\n                r1 = c\n                # Minor axes radii by sqrt difference\n                r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                # Transform pos_vec into ellipse coordinate frame\n                # Compute projection on major axis\n                proj = np.dot(pos_vec, focal_vec)\n                # Perp length squared\n                perp_len_sq = np.linalg.norm(pos_vec)**2 - proj**2\n                val = (proj**2)/(r1**2) + perp_len_sq/(r2**2 if r2 > 1e-8 else 1e-8)\n                return val <= 1.0\n            else:\n                # 2D ellipse test\n                dx = pos[0] - center[0]\n                dy = pos[1] - center[1]\n                cos_theta = (goal[0] - start[0]) / (2 * length) if (2 * length) != 0 else 1.0\n                sin_theta = (goal[1] - start[1]) / (2 * length) if (2 * length) != 0 else 0.0\n                x_rot = dx * cos_theta + dy * sin_theta\n                y_rot = -dx * sin_theta + dy * cos_theta\n                r1 = c\n                r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                if r2 < 1e-8:\n                    r2 = 1e-8\n                val = (x_rot**2)/(r1**2) + (y_rot**2)/(r2**2)\n                return val <= 1.0\n\n        def sample_informed(c_best, c_min):\n            # Sample inside ellipse aligned between start and goal with major axis c_best/2\n            while True:\n                if is_3d:\n                    # Sample within unit ball then scale and rotate\n                    import numpy as np\n                    dim = 3\n                    while True:\n                        rand_point = np.random.uniform(-1, 1, dim)\n                        if np.linalg.norm(rand_point) <= 1:\n                            break\n                    # Scale to ellipse radii\n                    length = dist(start_position, goal_position) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                    radii = np.array([r1, r2, r2])\n                    # Rotation matrix aligning x-axis to vector start->goal\n                    start_g = np.array([goal_position[d] - start_position[d] for d in range(dim)])\n                    norm_focal = np.linalg.norm(start_g)\n                    if norm_focal < 1e-8:\n                        center = np.array(start_position)\n                        sample = center + rand_point * radii\n                        sample_tuple = tuple(sample.tolist())\n                        if self._is_in_bounds(sample_tuple, bounds) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                            return sample_tuple\n                        continue\n                    focal_unit = start_g / norm_focal\n                    # Compute orthogonal basis with Gram-Schmidt (only first vector needed here)\n                    # Create rotation matrix that maps x-axis to focal_unit\n                    x_axis = np.array([1,0,0])\n                    v = np.cross(x_axis, focal_unit)\n                    s = np.linalg.norm(v)\n                    c_rot = np.dot(x_axis, focal_unit)\n                    if s < 1e-8:\n                        R = np.eye(3)\n                    else:\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(3) + vx + vx @ vx * ((1 - c_rot)/(s**2))\n                    center = np.array([(start_position[d] + goal_position[d]) / 2.0 for d in range(dim)])\n                    sample = center + R @ (rand_point * radii)\n                    sample_tuple = tuple(sample.tolist())\n                    if self._is_in_bounds(sample_tuple, bounds) and not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                        return sample_tuple\n                else:\n                    # 2D ellipse sampling: sample uniform in unit circle and scale\n                    import math as m\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x*x + y*y <= 1.0:\n                            break\n                    length = dist(start_position, goal_position) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c**2 - length**2, 0.0))\n                    if r2 < 1e-8:\n                        r2 = 1e-8\n                    sample_local = (x * r1, y * r2)\n                    center = ((start_position[0] + goal_position[0]) / 2.0,\n                              (start_position[1] + goal_position[1]) / 2.0)\n                    # Rotate sample_local to align major axis with start-goal vector\n                    dx = (goal_position[0] - start_position[0]) / (2*length) if 2*length>0 else 1.0\n                    dy = (goal_position[1] - start_position[1]) / (2*length) if 2*length>0 else 0.0\n                    sample_x = dx * sample_local[0] - dy * sample_local[1] + center[0]\n                    sample_y = dy * sample_local[0] + dx * sample_local[1] + center[1]\n                    sample = (sample_x, sample_y)\n                    if self._is_in_bounds(sample, bounds) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def sample_free(c_best):\n            p_bias = 0.7\n            # Adapted sample: 15% direct goal/start bias, 30% uniform in space, 55% informed ellipsoid sampling if solution known\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            if c_best < float('inf') and random.random() < self.informed_sample_rate:\n                return sample_informed(c_best, dist(start_position, goal_position))\n            else:\n                for _ in range(15):  # max tries to sample\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # Fallback uniform sample in bounds regardless of obstacle to avoid deadlock\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Using simple linear search; can be replaced with spatial structure\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            # in bounds and free\n            if not self._is_in_bounds(pos, bounds):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots to reduce overhead\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        def trees_connected(n_start, n_goal):\n            # Quick check if nodes are close and path feasible\n            if dist(n_start.position, n_goal.position) > self.step_size:\n                return False\n            if not can_connect(n_start.position, n_goal.position):\n                return False\n            return True\n\n        c_best = float('inf')  # current best path cost\n\n        for itr in range(self.max_iter):\n            # Maintain balance: extend smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_small, tree_big = tree_goal, tree_start\n            else:\n                tree_small, tree_big = tree_start, tree_goal\n\n            sample_pt = sample_free(c_best)\n\n            new_node_small = try_extend(tree_small, sample_pt)\n            if new_node_small is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_big = try_connect(tree_big, new_node_small)\n            if new_node_big is not None:\n                success_state = True\n                path_start = new_node_small.path_from_root()\n                path_goal = new_node_big.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                raw_cost = path_length(raw_path)\n                if raw_cost < c_best:\n                    c_best = raw_cost\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < raw_cost:\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -19.00158,
    "time_improvement": 28.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02131023406982422,
            "num_nodes_avg": 74.8,
            "path_length_avg": 159.38154570529133,
            "smoothness_avg": 0.038501886673069106,
            "success_improvement": 0.0,
            "time_improvement": 15.355447723596626,
            "length_improvement": 12.640449236719975,
            "smoothness_improvement": 502.6381346186374,
            "objective_score": 9.64791483751617
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.047920513153076175,
            "num_nodes_avg": 152.7,
            "path_length_avg": 239.80306984786063,
            "smoothness_avg": 0.08831560661395696,
            "success_improvement": 0.0,
            "time_improvement": 70.9622301183871,
            "length_improvement": 19.946832936129663,
            "smoothness_improvement": 2172.424169337374,
            "objective_score": 36.14015646942893
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05196504592895508,
            "num_nodes_avg": 121.0,
            "path_length_avg": 126.66520468288431,
            "smoothness_avg": 0.14149816755096417,
            "success_improvement": 0.0,
            "time_improvement": -1.5252269860464014,
            "length_improvement": 15.875002198517512,
            "smoothness_improvement": 1699.8462469399644,
            "objective_score": 11.216663578589404
        }
    ],
    "smoothness_improvement": 1458.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner improves the hybrid anytime informed bidirectional RRT* with adaptive lazy-collision bidirectional PRM* by enhancing path quality and efficiency. It synergizes informed ellipsoidal and adaptive sampling near the best path, uses KD-tree accelerated neighbor queries, lazy collision checking with caching, adaptive neighbor radius, iterative rewiring for cost optimization, and periodic aggressive pruning. Bidirectional extension always grows the smaller tree, attempts multi-step backward connections, and prunes nodes unlikely to improve the best cost. Finally, shortcut smoothing refines the path. This design reduces search space, accelerates convergence, and improves path smoothness and length, ensuring robust performance in 2D and 3D spaces.",
    "planning_mechanism": "The planner initializes two trees from start and goal and alternately expands the smaller one by sampling inside an informed ellipsoid or near the current best path via adaptive Gaussian noise. Connecting new nodes uses lazy collision checks cached for efficiency, and neighbors are rewired to minimize costs. Bidirectional link attempts employ incremental extension from the second tree toward new nodes. Periodic pruning discards nodes that cannot yield better solutions to focus the search. After successful connection, iterative shortcut smoothing improves path quality. The result is a fast, robust, and smooth path minimizing travel cost under obstacle constraints.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position                # Tuple[float, ...]: 2D or 3D point\n        self.parent = parent                    # Parent Node or None\n        self.cost = cost                        # Cost from root to this node\n        self.children: List[Node] = []         # Children for rewiring/pruning\n        self.valid = True                      # Node validity (used in pruning etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 100, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            const_factor = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(const_factor + 1) / const_factor)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree approx: brute force for portability\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d_\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # Informed ellipsoidal sampling biased by current best path cost\n        def informed_sample(c_best: float, c_min: float,\n                            start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                # Uniform random sampling fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * (np.random.uniform(0, 1) ** (1 / dim))  # Uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling around best known path with Gaussian noise, fallback informed\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing by attempting to replace path segments with direct edges\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            # Sample point with adaptive heuristic informed by best path\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Expand smaller tree first for bidirectional growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Validate new node and connection to parent\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Choose best parent minimizing path cost to new node\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if it improves their cost\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Attempt incremental multi-step connection from tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_to_new = dist(nearest_b.position, new_node.position)\n            max_steps = int(dist_to_new / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                # Rewire neighbors in tree_b towards new_node_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if can connect tree_b branch to new_node directly\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressively prune suboptimal nodes periodically after connection\n                if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold):\n                    removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                    removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                    edge_collision_cache.clear()\n                continue\n\n            # Periodic pruning even when no connection, if enough nodes and known best cost\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 948.07651,
    "time_improvement": -3191.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.586302065849304,
            "num_nodes_avg": 5118.7,
            "path_length_avg": 150.42033335284844,
            "smoothness_avg": 0.030843055791161755,
            "success_improvement": 0.0,
            "time_improvement": -6200.814327003572,
            "length_improvement": 17.55223172659061,
            "smoothness_improvement": 382.7607998993323,
            "objective_score": -1854.8200477562566
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.2575544834136962,
            "num_nodes_avg": 2391.7,
            "path_length_avg": 227.04558182481986,
            "smoothness_avg": 0.06072804302913141,
            "success_improvement": 0.0,
            "time_improvement": -662.023928798713,
            "length_improvement": 24.20564964215324,
            "smoothness_improvement": 1462.576287780935,
            "objective_score": -186.45316727227856
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.4378447532653809,
            "num_nodes_avg": 5014.5,
            "path_length_avg": 114.7034773534189,
            "smoothness_avg": 0.08685991162966711,
            "success_improvement": 0.0,
            "time_improvement": -2709.148194452467,
            "length_improvement": 23.819411934502284,
            "smoothness_improvement": 1004.8516645976033,
            "objective_score": -802.9563176258516
        }
    ],
    "smoothness_improvement": 950.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid Adaptive Bidirectional Informed RRT* with Dynamic Domain Sampling and Early Pruning. It balances exploration and exploitation by adaptively adjusting sampling domains guided by the current best path cost. The planner incorporates efficient rewiring using KD-tree accelerated neighbor search and aggressively prunes suboptimal branches early to reduce tree size and computational overhead. Incremental multi-step connection attempts increase robustness in bridging start and goal trees. After path discovery, progressive shortcut smoothing refines the trajectory for smoothness and length reduction. This design enhances planning efficiency, success rates, path quality, and robustness while reducing overall search time.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal positions. Each iteration, it adaptively samples in informed ellipsoidal domains refined by the best path cost found so far, with some noise introduced for exploration. The smaller tree is extended towards the sampled point, connecting new nodes with minimal path cost parents found via KD-tree neighbor searches. Rewiring is performed to optimize local path costs. Then, incremental multi-step attempts are made to connect the other tree towards the newly added node. Early pruning discards nodes that cannot improve the current best solution, maintaining manageable search complexity. Upon successful tree connection, the path is shortcut-smoothed iteratively before returning the optimized smooth path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root node\n        self.children = []                # Child nodes for rewiring/pruning\n        self.valid = True                 # Validity flag (collision checks)\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 150, prune_threshold: int = 250,\n                 smoothing_iterations: int = 120, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Utility functions\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_dist = float('inf')\n                best_node = None\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    squared_dist = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        squared_dist += delta * delta\n                        if squared_dist > r2:\n                            break\n                    if squared_dist <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Collision caches\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Dynamic neighbor radius with iteration and number of nodes\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(max(n_nodes,1)+1)/max(n_nodes,1))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Informed sampling inside ellipsoid domain with added dynamic domain factor\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.12:\n                # Uniform random sampling with obstacle rejection\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback uniform sample no check\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            c_vec = np.array([goal[d] - start[d] for d in range(dim)])\n            c_unit = c_vec / c_min\n\n            # Householder reflection to align sampling with start-goal axis\n            id_mat = np.eye(dim)\n            u = c_unit - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Reflection matrix\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(200):\n                x = np.random.uniform(low=-1, high=1, size=dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x  # on unit sphere\n                # Radius scaling for uniform sample in unit ball\n                scale = np.random.uniform(0, 1) ** (1/dim)\n                sample = rot @ (x * radii * scale) + center\n                p = tuple(float(val) for val in sample)\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n            # Fallback random samples if unsuccessful\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        # Adaptive sampling biased near best known path with Gaussian noise and fallback to informed sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.78:\n                for _ in range(60):\n                    base_p = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_p = tuple(base_p[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_p) and not self._is_in_obstacle(sample_p, obstacles, is_3d):\n                        return sample_p\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing with collision-checked edge connect\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i+2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        # Aggressive pruning of nodes that cannot improve best current cost\n        def prune_nodes(tree_nodes, best_cost, root_s, root_g):\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in tree_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            removed_cnt = 0\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                    removed_cnt += 1\n                except ValueError:\n                    pass\n            return removed_cnt\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            # Alternate extend smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n            kdt_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdt_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdt_a.radius_search(new_pos, radius_a)\n\n            # Choose best parent minimizing path cost + collision free edges\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-14 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper cost found\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, node.position)\n                if c_new + 1e-14 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, c_new)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection attempts from tree_b towards new_node\n            kdt_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdt_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdt_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-14 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Final connection check to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    # Recover paths from roots\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Update best solution\n                    if cost_connect + 1e-14 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Early exit on success\n            if connected:\n                break\n\n            # Aggressive pruning reduces search space and expedites convergence\n            if (iteration > 0 and iteration % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        # Final iterative shortcut smoothing for path refinement\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.13672,
    "time_improvement": 31.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.030854177474975587,
            "num_nodes_avg": 63.3,
            "path_length_avg": 161.4824135136809,
            "smoothness_avg": 0.047858599367835604,
            "success_improvement": -9.999999999999998,
            "time_improvement": -22.553230981359224,
            "length_improvement": 11.488930300560874,
            "smoothness_improvement": 649.0910067185575,
            "objective_score": -51.2227282007028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04439249038696289,
            "num_nodes_avg": 205.3,
            "path_length_avg": 233.84723914373203,
            "smoothness_avg": 0.09158691714716453,
            "success_improvement": 0.0,
            "time_improvement": 73.10006017233994,
            "length_improvement": 21.935060654249465,
            "smoothness_improvement": 2256.5973455865424,
            "objective_score": 37.600016910484584
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029001021385192872,
            "num_nodes_avg": 126.7,
            "path_length_avg": 121.41230082029983,
            "smoothness_avg": 0.10468785254132007,
            "success_improvement": 0.0,
            "time_improvement": 43.34008127339498,
            "length_improvement": 19.36373082764379,
            "smoothness_improvement": 1231.6217570721144,
            "objective_score": 23.03287933290782
        }
    ],
    "smoothness_improvement": 1379.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "A hybrid bidirectional informed RRT* planner combining adaptive ellipsoid sampling, dynamic neighbor radius adjustment, collision caching, incremental rewiring, and aggressive pruning. It balances exploration and exploitation by alternating tree growth, applying aggressive but efficient node pruning, and robust shortcut smoothing to ensure shorter, smoother, and more reliable paths in complex 2D/3D spaces. The algorithm emphasizes computational speed by caching collision checks and tuning parameters for quicker convergence and higher success rates.",
    "planning_mechanism": "The planner grows two balanced trees rooted at the start and goal, sampling within a dynamically shrinking ellipsoid focused on the best path found so far. Using a KD-tree inspired nearest-neighbor structure for efficient rewiring, it extends trees incrementally, verifying node and edge obstacles strictly. It prunes non-beneficial nodes regularly to reduce overhead and applies shortcut smoothing to enhance path quality. The process terminates upon connecting the two trees successfully or reaching iteration limits.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 25.0,\n                 goal_sample_rate: float = 0.15, prune_interval: int = 150,\n                 prune_threshold: int = 250, smoothing_iterations: int = 180,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.98)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(15):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path: list = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                c_candidate = node.cost + dist(node.position, new_pos)\n                if c_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring around the new node\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect the other tree to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_ext_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            for _ in range(max_ext_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -13.36323,
    "time_improvement": 9.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025389695167541505,
            "num_nodes_avg": 81.8,
            "path_length_avg": 157.60329701161916,
            "smoothness_avg": 0.044542295338489815,
            "success_improvement": 0.0,
            "time_improvement": -0.8482296744964901,
            "length_improvement": 13.615135523875443,
            "smoothness_improvement": 597.1836471898326,
            "objective_score": 5.454476438375305
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.080218505859375,
            "num_nodes_avg": 309.3,
            "path_length_avg": 236.48934545982314,
            "smoothness_avg": 0.09583915776839784,
            "success_improvement": 0.0,
            "time_improvement": 51.39103569382753,
            "length_improvement": 21.053049517124585,
            "smoothness_improvement": 2366.010559535997,
            "objective_score": 31.457973409253157
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06352026462554931,
            "num_nodes_avg": 243.7,
            "path_length_avg": 124.21924549264645,
            "smoothness_avg": 0.11647274275656214,
            "success_improvement": 0.0,
            "time_improvement": -24.10090608097156,
            "length_improvement": 17.499491828613063,
            "smoothness_improvement": 1381.5246907398828,
            "objective_score": 3.17724999513056
        }
    ],
    "smoothness_improvement": 1448.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a high-performance bidirectional informed RRT* variant integrating adaptive ellipsoidal sampling with Gaussian perturbations around the current best path, KD-tree accelerated nearest and radius neighbor searches, lazy collision checking with caching, incremental multi-step connection attempts, dynamic neighbor radius adjustment, aggressive pruning of non-promising nodes, and iterative shortcut smoothing. These components collectively enhance planning efficiency, solution quality, path smoothness, robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner maintains two trees grown alternately from start and goal positions. It samples new points adaptively using an evolving ellipsoid informed by the best path, with additional Gaussian-biased samples near the current best path. Each new node is connected using collision-checked nearest and neighbor rewiring with a dynamically adjusted radius. Incremental multi-step connections attempt to link the two trees rapidly. Periodic aggressive pruning discards nodes that cannot improve the current solution. Upon success, iterative shortcut smoothing refines the final path before returning it.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root\n        self.children: List['Node'] = []   # Children nodes\n        self.valid = True                   # For collision checking, pruning etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                     # Tuple[int, ...]\n        start_pos = map.start                 # Tuple[float, ...]\n        goal_pos = map.goal                   # Tuple[float, ...]\n        obstacles = map.obstacles             # List of obstacle tuples\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # Brute force KD-tree approximation for nearest and radius searches\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not (in_bounds(p1) and in_bounds(p2)):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Always extend smaller tree first for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not (can_add_node(new_pos) and can_connect(nearest_a.position, new_pos)):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not (can_add_node(next_pos_b) and can_connect(last_node_b.position, next_pos_b)):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing after connection\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic aggressive pruning when solution exists and many nodes\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -16.83676,
    "time_improvement": 18.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024880504608154295,
            "num_nodes_avg": 79.0,
            "path_length_avg": 161.58002356858296,
            "smoothness_avg": 0.04753386476937059,
            "success_improvement": 0.0,
            "time_improvement": 1.1742824565988992,
            "length_improvement": 11.43542868273876,
            "smoothness_improvement": 644.0082050801128,
            "objective_score": 5.859411498927986
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05389125347137451,
            "num_nodes_avg": 239.4,
            "path_length_avg": 241.97552258061424,
            "smoothness_avg": 0.11471771730662579,
            "success_improvement": 0.0,
            "time_improvement": 67.34421829051321,
            "length_improvement": 19.221605683351697,
            "smoothness_improvement": 2851.7694941314153,
            "objective_score": 38.306434094481375
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05847077369689942,
            "num_nodes_avg": 194.0,
            "path_length_avg": 124.82579895963913,
            "smoothness_avg": 0.12100343184724591,
            "success_improvement": 0.0,
            "time_improvement": -14.235607137600228,
            "length_improvement": 17.096647896808832,
            "smoothness_improvement": 1439.1547215526987,
            "objective_score": 6.344421045845192
        }
    ],
    "smoothness_improvement": 1645.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a tuned hybrid bidirectional adaptive informed RRT* algorithm that balances exploration and exploitation by adaptively sampling inside a dynamic ellipsoid and globally, utilizing efficient neighbor search with an adaptive radius, lazy collision checking with caching, prioritized rewiring via a heap queue, aggressive pruning of non-promising nodes, and multi-scale incremental shortcut smoothing to optimize paths progressively during planning. Parameter tuning favors faster convergence, higher success rates, smoother and shorter paths, while reducing computational overhead and search time in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal positions, sampling mostly inside a dynamically shrinking informed ellipsoid guided by the current best path cost but maintaining a fraction of global uniform and edge-biased samples to prevent premature convergence. It uses linear KD-tree substitutes for nearest neighbor and radius searches with an adaptive radius decreasing over iterations and growing node counts. Collision checks for nodes and edges are lazy and cached for efficiency. Rewiring neighbors is prioritized using a min-heap to accelerate convergence. Periodic aggressive pruning removes nodes unlikely to yield better solutions. Path smoothing is performed incrementally with local shortcuts favored early and global shortcuts later, balancing runtime and path quality. The planner terminates when a high-quality collision-free path connecting start and goal is found or max iterations are exhausted.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5500, step_size: float=5.0,\n                 neighbor_min_radius: float=5.5, neighbor_max_radius: float=28.0,\n                 prune_interval: int=175, prune_threshold: int=320,\n                 smoothing_iters_local: int=70, smoothing_iters_global: int=50,\n                 collision_check_resolution: float=0.75,\n                 goal_sample_rate_ellipsoid: float=0.9,\n                 goal_sample_rate_global: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters_local = smoothing_iters_local\n        self.smoothing_iters_global = smoothing_iters_global\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate_ellipsoid = goal_sample_rate_ellipsoid\n        self.goal_sample_rate_global = goal_sample_rate_global\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_pos = map.start              # Tuple[float, ...]\n        goal_pos = map.goal                # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                res = to_p\n            else:\n                ratio = self.step_size / d\n                res = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0, min(res[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(1, n_nodes)\n            r_iter = self.neighbor_max_radius * (1.0 - (iteration / self.max_iter)**0.93)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        node_obstacle_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_obstacle_cache:\n                return node_obstacle_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_obstacle_cache[pos] = val\n            return val\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        def informed_sample(c_best, c_min, start, goal):\n            elite_prob = self.goal_sample_rate_ellipsoid\n            global_prob = self.goal_sample_rate_global\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            rand_val = random.random()\n            if rand_val < elite_prob:\n                center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n                a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n                I = np.eye(dim)\n\n                v = a1 - np.array([1] + [0]*(dim-1))\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    v /= norm_v\n                    rot = I - 2*np.outer(v, v)\n                else:\n                    rot = I\n\n                r1 = c_best / 2.0\n                r_others_val = max(r1*r1 - (c_min / 2.0)**2, 0)\n                r_others = math.sqrt(r_others_val) if r_others_val > 0 else 0.0\n                radii = np.array([r1] + [r_others] * (dim -1))\n\n                for _ in range(150):\n                    x_ball = np.random.uniform(-1,1,dim)\n                    norm_x = np.linalg.norm(x_ball)\n                    if norm_x <= 1.0 and norm_x > 1e-15:\n                        r_scale = random.uniform(0,1)**(1.0/dim)\n                        sample = rot @ (x_ball / norm_x * r_scale * radii) + center\n                        p = tuple(float(ci) for ci in sample)\n                        if in_bounds(p) and not is_in_obstacle_cached(p):\n                            return p\n                # fallback uniform\n                for _ in range(10):\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return p\n            elif rand_val < elite_prob + global_prob:\n                # Edge-biased global uniform sampling (~10%)\n                def edge_biased_sample(dim_idx):\n                    edge_zone = bounds[dim_idx]*0.15\n                    choice = random.random()\n                    if choice < 0.4:\n                        if random.random() < 0.5:\n                            return random.uniform(0, edge_zone)\n                        else:\n                            return random.uniform(bounds[dim_idx] - edge_zone, bounds[dim_idx])\n                    else:\n                        return random.uniform(0, bounds[dim_idx])\n                for _ in range(25):\n                    p = tuple(edge_biased_sample(d) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n            else:\n                # Occasional direct goal bias sampling (~<1%) for biasing growth\n                return goal_pos\n\n        class KDTree:\n            # Linear scan substitute for KD-tree approximation, suitable for moderate node counts\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                radius_sq = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sq_dist = 0.0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sq_dist += delta*delta\n                        if sq_dist > radius_sq:\n                            break\n                    if sq_dist <= radius_sq:\n                        results.append(n)\n                return results\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal, edges\n            to_remove = []\n            heuristic = dist\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                h = heuristic(node.position, goal_pos)\n                if node.cost + h - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rn in to_remove:\n                if rn.parent:\n                    try:\n                        rn.parent.children.remove(rn)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rn)\n                except ValueError:\n                    pass\n                if rn in tree_start:\n                    tree_start.remove(rn)\n                if rn in tree_goal:\n                    tree_goal.remove(rn)\n                edges = [e for e in edges if e[0] != rn and e[1] != rn]\n                removed += 1\n            return removed\n\n        def incremental_smooth_path(path, local_iters, global_iters):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            length = len(p)\n\n            for _ in range(local_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                if can_connect(p[i], p[i+2]):\n                    p = p[:i+1] + p[i+2:]\n                    length = len(p)\n\n            for _ in range(global_iters):\n                if length < 3:\n                    break\n                i = random.randint(0, length - 3)\n                j = random.randint(i+2, length -1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n                    length = len(p)\n\n            return p\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        def rewire_neighbors(new_node, near_nodes):\n            rewire_candidates = []\n            for neighbor in near_nodes:\n                if neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    heapq.heappush(rewire_candidates, (neighbor.cost - cost_through_new, neighbor))\n            while rewire_candidates:\n                _, neighbor = heapq.heappop(rewire_candidates)\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire_neighbors(new_node, near_nodes)\n\n            # Connect new_node to opposite tree incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            max_steps = max(1, int(dist(last_node_b.position, new_node.position) / self.step_size))\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                rewire_neighbors(new_node_b, near_b)\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    connection_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=connection_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    local_iters = max(1, int(self.smoothing_iters_local * (1.0 - iteration / self.max_iter)))\n                    global_iters = max(1, int(self.smoothing_iters_global * (iteration / self.max_iter)))\n\n                    smoothed_path = incremental_smooth_path(merged_path, local_iters, global_iters)\n\n                    if connection_cost + 1e-12 < c_best:\n                        c_best = connection_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_obstacle_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.1211,
    "time_improvement": 43.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.018509769439697267,
            "num_nodes_avg": 72.4,
            "path_length_avg": 159.35134583790244,
            "smoothness_avg": 0.048457371449595735,
            "success_improvement": -9.999999999999998,
            "time_improvement": 26.478932993927813,
            "length_improvement": 12.657002262583347,
            "smoothness_improvement": 658.4630900524904,
            "objective_score": -36.23260419904253
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.04888286590576172,
            "num_nodes_avg": 213.8,
            "path_length_avg": 240.27915772873408,
            "smoothness_avg": 0.09285033118422646,
            "success_improvement": -9.999999999999998,
            "time_improvement": 70.37908574161145,
            "length_improvement": 19.78790109806426,
            "smoothness_improvement": 2289.1058987604943,
            "objective_score": -13.483164564101234
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.035026717185974124,
            "num_nodes_avg": 146.2,
            "path_length_avg": 123.37098569335167,
            "smoothness_avg": 0.10644132878658166,
            "success_improvement": 0.0,
            "time_improvement": 31.56754989221306,
            "length_improvement": 18.06286559751364,
            "smoothness_improvement": 1253.9258454836888,
            "objective_score": 19.35246731458509
        }
    ],
    "smoothness_improvement": 1400.0,
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a streamlined bidirectional RRT* variant focusing on adaptive ellipsoidal informed sampling combined with balanced tree growth, dynamic neighbor radius for rewiring, lazy collision checking, periodic pruning of dead-end nodes, and iterative shortcut smoothing to efficiently discover short and smooth collision-free paths in 2D or 3D environments.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal by adaptively sampling mostly within an informed ellipsoidal region centered between them. Each iteration extends the smaller tree by steering towards sampled points, connects nodes with rewiring over a dynamically shrinking neighborhood radius, and attempts to connect opposite trees incrementally. Collision checks enforce safety of nodes and edges. Periodic pruning removes dead-end branches to maintain efficiency. Once connected, iterative shortcut smoothing refines the path for improved smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                  # Tuple[float, ...]\n        goal = map.goal                    # Tuple[float, ...]\n        obstacles = map.obstacles          # List of 2D or 3D rectangular obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def dynamic_radius(n):\n            if n <= 1:\n                return 20.0\n            return max(5.0, 20.0 * math.sqrt(math.log(n + 1) / (n + 1)))\n\n        def is_free_point(p):\n            if not in_bounds(p):\n                return False\n            if self._is_in_obstacle(p, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def ellipse_contains(pos, c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                return True\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            length = dist(start, goal) / 2.0\n            c = c_best / 2.0\n            if is_3d:\n                import numpy as np\n                focal_vec = np.array([goal[d] - start[d] for d in range(dim)])\n                norm_focal = np.linalg.norm(focal_vec)\n                if norm_focal < 1e-8:\n                    return True\n                focal_unit = focal_vec / norm_focal\n                pos_vec = np.array([pos[d] - center[d] for d in range(dim)])\n                proj = np.dot(pos_vec, focal_unit)\n                r1 = c\n                r2 = math.sqrt(max(c ** 2 - length ** 2, 1e-8))\n                val = (proj ** 2) / (r1 ** 2) + (np.linalg.norm(pos_vec) ** 2 - proj ** 2) / (r2 ** 2)\n                return val <= 1.0\n            else:\n                dx = pos[0] - center[0]\n                dy = pos[1] - center[1]\n                if length == 0:\n                    return True\n                cos_theta = (goal[0] - start[0]) / (2 * length)\n                sin_theta = (goal[1] - start[1]) / (2 * length)\n                x_rot = dx * cos_theta + dy * sin_theta\n                y_rot = -dx * sin_theta + dy * cos_theta\n                r1 = c\n                r2 = math.sqrt(max(c ** 2 - length ** 2, 1e-8))\n                val = (x_rot ** 2) / (r1 ** 2) + (y_rot ** 2) / (r2 ** 2)\n                return val <= 1.0\n\n        def sample_informed(c_best, c_min):\n            for _ in range(100):\n                if is_3d:\n                    import numpy as np\n                    while True:\n                        x = np.random.uniform(-1, 1, dim)\n                        if np.linalg.norm(x) <= 1:\n                            break\n                    length = dist(start, goal) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c ** 2 - length ** 2, 1e-8))\n                    radii = np.array([r1] + [r2] * (dim - 1))\n                    start_g = np.array([goal[d] - start[d] for d in range(dim)])\n                    norm_focal = np.linalg.norm(start_g)\n                    if norm_focal < 1e-8:\n                        center = np.array(start)\n                        sample = center + x * radii\n                        sample_t = tuple(float(v) for v in sample)\n                        if is_free_point(sample_t):\n                            return sample_t\n                        continue\n                    focal_unit = start_g / norm_focal\n                    x_axis = np.array([1] + [0] * (dim - 1))\n                    v = np.cross(x_axis, focal_unit)\n                    s = np.linalg.norm(v)\n                    c_rot = np.dot(x_axis, focal_unit)\n                    if s < 1e-8:\n                        R = np.eye(dim)\n                    else:\n                        vx = np.array([[0, -v[-1], v[1]],\n                                       [v[-1], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(dim) + vx + vx @ vx * ((1 - c_rot) / (s ** 2))\n                    center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n                    sample = center + R @ (x * radii)\n                    sample_t = tuple(float(v) for v in sample)\n                    if is_free_point(sample_t):\n                        return sample_t\n                else:\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1.0:\n                            break\n                    length = dist(start, goal) / 2.0\n                    c = c_best / 2.0\n                    r1 = c\n                    r2 = math.sqrt(max(c * c - length * length, 1e-8))\n                    sample_local = (x * r1, y * r2)\n                    center = ((start[0] + goal[0]) / 2.0, (start[1] + goal[1]) / 2.0)\n                    dx = (goal[0] - start[0]) / (2 * length) if length > 0 else 1.0\n                    dy = (goal[1] - start[1]) / (2 * length) if length > 0 else 0.0\n                    sample_x = dx * sample_local[0] - dy * sample_local[1] + center[0]\n                    sample_y = dy * sample_local[0] + dx * sample_local[1] + center[1]\n                    sample = (sample_x, sample_y)\n                    if is_free_point(sample):\n                        return sample\n            # fallback to uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def sample_free(c_best):\n            p_goal_bias = 0.1\n            if random.random() < p_goal_bias:\n                return goal if random.random() < 0.7 else start\n            if c_best < float('inf') and random.random() < 0.7:\n                return sample_informed(c_best, dist(start, goal))\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_point(p):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree_nodes, point):\n            return min(tree_nodes, key=lambda n: dist(n.position, point))\n\n        def near(tree_nodes, point, radius):\n            r2 = radius * radius\n            result = []\n            for node in tree_nodes:\n                if (dist(node.position, point) ** 2) <= r2:\n                    result.append(node)\n            return result\n\n        def rewire(tree, node, radius):\n            near_nodes = near(tree, node.position, radius)\n            for other in near_nodes:\n                if other is node.parent:\n                    continue\n                new_cost = node.cost + dist(node.position, other.position)\n                if new_cost + 1e-12 < other.cost and is_free_edge(node.position, other.position):\n                    try:\n                        if other.parent:\n                            other.parent.children.remove(other)\n                    except Exception:\n                        pass\n                    other.parent = node\n                    other.cost = new_cost\n                    node.children.append(other)\n\n        def try_extend(tree, sample, c_best):\n            nearest_node = nearest(tree, sample)\n            new_pos = steer(nearest_node.position, sample)\n            if not is_free_point(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n            radius = dynamic_radius(len(tree))\n            near_nodes = near(tree, new_pos, radius)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                tentative_cost = n.cost + dist(n.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and is_free_edge(n.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            rewire(tree, new_node, radius)\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_free_point(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if dist(new_pos, node.position) <= self.step_size:\n                    if is_free_edge(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node is root_start or node is root_goal:\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except Exception:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except Exception:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(pth):\n            length = 0.0\n            for i in range(len(pth) - 1):\n                length += dist(pth[i], pth[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(80):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if is_free_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        for itr in range(self.max_iter):\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample_pt = sample_free(c_best)\n            new_node = try_extend(tree_a, sample_pt, c_best)\n            if new_node is None:\n                if itr % 100 == 0 and len(nodes) > 150:\n                    prune_dead_ends()\n                continue\n\n            connected_node = try_connect(tree_b, new_node)\n            if connected_node:\n                success = True\n                path_from_start = new_node.path_from_root()\n                path_from_goal = connected_node.path_from_root()\n                raw_path = path_from_start + path_from_goal[::-1][1:]\n                raw_cost = path_length(raw_path)\n                if raw_cost < c_best:\n                    c_best = raw_cost\n                    best_path = shortcut_smoothing(raw_path)\n                break\n\n            if itr % 100 == 0 and len(nodes) > 150:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success,\n            path=best_path if success else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            inter = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(inter, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.50405,
    "time_improvement": 7.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03567192554473877,
            "num_nodes_avg": 83.3,
            "path_length_avg": 165.11680209666326,
            "smoothness_avg": 0.0368366901970954,
            "success_improvement": 0.0,
            "time_improvement": -41.68939471421375,
            "length_improvement": 9.496864327655757,
            "smoothness_improvement": 476.5741937376248,
            "objective_score": -8.224574580044848
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07538020610809326,
            "num_nodes_avg": 167.9,
            "path_length_avg": 240.23937456874984,
            "smoothness_avg": 0.10349022116411699,
            "success_improvement": 0.0,
            "time_improvement": 54.322837245017,
            "length_improvement": 19.80118186196177,
            "smoothness_improvement": 2562.877931546065,
            "objective_score": 33.07147720362778
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04636545181274414,
            "num_nodes_avg": 128.5,
            "path_length_avg": 126.59291903147064,
            "smoothness_avg": 0.11251955190719418,
            "success_improvement": 0.0,
            "time_improvement": 9.414820376853665,
            "length_improvement": 15.923010886313643,
            "smoothness_improvement": 1331.240394930118,
            "objective_score": 12.66525026496942
        }
    ],
    "smoothness_improvement": 1457.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines insights from bidirectional anytime informed RRT* frameworks with aggressive pruning, adaptive ellipsoidal sampling biased by current best path cost, KD-tree accelerated neighbor searches, lazy collision checking with caching, incremental multi-step tree connections, dynamic neighbor radius adjustment, and iterative shortcut smoothing. It balances exploration and exploitation by extending the smaller tree, focuses sampling adaptively near the best path, and periodically prunes non-promising nodes to reduce computational effort. These enhancements collectively minimize path length, reduce planning time, maintain robustness, and increase success rates in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, alternately extending the smaller tree. Sampling occurs adaptively inside an evolving informed ellipsoid defined by the best path cost to bias toward promising regions while also adding Gaussian noise near the best path for focused exploration. Nearest neighbors and near nodes are efficiently found using a KD-tree for rewiring. Collision checks for nodes and edges are cached to avoid redundancy. Incremental multi-step connection attempts link the trees when nearby. The neighbor radius shrinks adaptively over iterations and node count. Aggressive periodic pruning removes nodes unlikely to improve solutions. Once a path is found, iterative shortcut smoothing refines it to minimize length and improve smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=100, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(30):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-9 or not node.children:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialize roots and data structures\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node for cost improvement\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # After connection break to finalize\n                break\n\n            # Periodic aggressive pruning to maintain efficiency\n            if (it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        # Final smoothing after planning\n        if extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -16.35496,
    "time_improvement": 15.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022423768043518068,
            "num_nodes_avg": 73.2,
            "path_length_avg": 159.08325541871375,
            "smoothness_avg": 0.05169499873469844,
            "success_improvement": 0.0,
            "time_improvement": 10.932474970737628,
            "length_improvement": 12.803946869505214,
            "smoothness_improvement": 709.1389876845262,
            "objective_score": 9.386226803544963
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04431650638580322,
            "num_nodes_avg": 209.5,
            "path_length_avg": 234.06716239127854,
            "smoothness_avg": 0.10149634870757399,
            "success_improvement": 0.0,
            "time_improvement": 73.14610320892659,
            "length_improvement": 21.86164394407874,
            "smoothness_improvement": 2511.574157110932,
            "objective_score": 38.874030537048384
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0704848289489746,
            "num_nodes_avg": 212.5,
            "path_length_avg": 118.05567657650961,
            "smoothness_avg": 0.13047790770506343,
            "success_improvement": 0.0,
            "time_improvement": -37.707725071594,
            "length_improvement": 21.593040825098925,
            "smoothness_improvement": 1559.669355131075,
            "objective_score": 0.8046374191969603
        }
    ],
    "smoothness_improvement": 1593.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm enhanced with adaptive informed ellipsoidal sampling to focus sampling in promising regions, dynamic neighbor radius adjustment for optimal rewiring, aggressive pruning of non-promising and dead-end nodes, and collision caching for efficiency. It additionally applies iterative shortcut smoothing to minimize path length and increase smoothness. Balanced tree expansion ensures robust exploration from both start and goal. The algorithm carefully manages KD-tree-accelerated nearest neighbor and radius searches, rewiring to incrementally optimize paths, and verifies node and edge validity against obstacles to maintain robustness and high success rate in cluttered 2D and 3D spaces.",
    "planning_mechanism": "The planner alternately grows two trees from the start and goal, sampling adaptively within an ellipsoidal informed subset defined by the current best path cost. It extends nodes by steering towards sampled points with collision-safe edges, connects trees incrementally when close enough, and rewires locally to reduce path costs. Periodic pruning removes dead or high-cost nodes to boost efficiency. Finally, it applies repeated shortcut smoothing to enhance path quality and reduce length before returning the best found path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision validation\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incremental connection from tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning of non-promising nodes\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.62151,
    "time_improvement": 24.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02115006446838379,
            "num_nodes_avg": 74.1,
            "path_length_avg": 163.90198365749058,
            "smoothness_avg": 0.04104810378950062,
            "success_improvement": 0.0,
            "time_improvement": 15.991643654518517,
            "length_improvement": 10.162725564196343,
            "smoothness_improvement": 542.4919616897569,
            "objective_score": 9.542498017643608
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06202085018157959,
            "num_nodes_avg": 231.3,
            "path_length_avg": 236.5642809884764,
            "smoothness_avg": 0.10893751762208197,
            "success_improvement": 0.0,
            "time_improvement": 62.41803234281331,
            "length_improvement": 21.02803388076052,
            "smoothness_improvement": 2703.0407929385524,
            "objective_score": 36.44622044368886
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.055005645751953124,
            "num_nodes_avg": 182.2,
            "path_length_avg": 124.57990161362954,
            "smoothness_avg": 0.14408168487551007,
            "success_improvement": 0.0,
            "time_improvement": -7.46571220423807,
            "length_improvement": 17.25996120565506,
            "smoothness_improvement": 1732.708396612776,
            "objective_score": 9.87582056292347
        }
    ],
    "smoothness_improvement": 1659.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a Hybrid Bidirectional RRT* with Multi-Fidelity Sampling and Adaptive Rewiring. It combines coarse global exploration with fine local exploitation by adaptively switching between uniform, informed ellipsoid, and Gaussian samples near the current best path. The planner implements incremental multi-step connections, dynamically tuned neighbor radius shrinking with iteration and node count, and a lazy caching collision scheme for node and edge verification. Aggressive pruning discards nodes unable to improve current best cost while maintaining tree balance by extending the smaller tree first. After finding a solution, an iterative hierarchical shortcut smoothing is applied, mixing global long-range and local short-range shortcuts to optimize path smoothness and length. This synergy enhances path quality, success rate, smoothness, and significantly reduces planning time.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternating extensions on the smaller tree to maintain balance. Sampling leverages a multi-fidelity approach: uniform random when no solution exists, biased ellipsoid informed by the best path cost once a solution is found, and Gaussian perturbations around the best path points for local refinement. Neighbor radius dynamically shrinks to focus rewiring over time and network size. Incremental multi-step connections attempt to rapidly link trees with collision checks at each step. Aggressive pruning removes nodes unlikely to yield better solutions. Final path extraction includes iterative shortcut smoothing applying both long-range and local shortcuts validated by collision checks to ensure path quality and smoothness while reducing unnecessary nodes and edges for efficiency.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position: Tuple[float, ...] = position\n        self.parent: 'Node' = parent\n        self.cost: float = cost\n        self.children: List['Node'] = []\n        self.valid: bool = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_radius: float=5.0, max_radius: float=30.0,\n                 prune_interval: int=150, prune_threshold: int=300,\n                 smoothing_iters: int=150, collision_check_res: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_check_res = collision_check_res\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio*(to_p[d_] - from_p[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        # Lazy collision caches\n        node_coll_cache = {}\n        edge_coll_cache = {}\n\n        def is_in_obstacle_cached(pos: Tuple[float, ...]) -> bool:\n            if pos in node_coll_cache:\n                return node_coll_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_coll_cache[pos] = val\n            return val\n\n        def is_edge_in_obstacle_cached(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_coll_cache:\n                return edge_coll_cache[key]\n            val = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_res)\n            edge_coll_cache[key] = val\n            return val\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not is_in_obstacle_cached(pos))\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not (in_bounds(p1) and in_bounds(p2)):\n                return False\n            if is_edge_in_obstacle_cached(p1, p2):\n                return False\n            return True\n\n        # KDTree approximation by brute force search\n        class KDTree:\n            def __init__(self, p_nodes: List[Tuple[Tuple[float,...], Node]]):\n                self.points = [x[0] for x in p_nodes]\n                self.nodes = [x[1] for x in p_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_dist = float('inf')\n                best_node = None\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius*radius\n                res = []\n                for p,n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for i in range(dim):\n                        delta = p[i]-pt[i]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(n)\n                return res\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float,...], goal: Tuple[float,...]) -> Tuple[float,...]:\n            # Uniform random if no roadmap or early random exploration (10%)\n            if c_best == float('inf') or c_best < c_min*1.00001 or random.random() < 0.1:\n                attempts = 0\n                while attempts < 50:\n                    p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p): return p\n                    attempts += 1\n                return tuple(random.uniform(0,bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:,0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2*np.outer(u,u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n\n            for _ in range(200):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * (np.random.uniform(0,1) ** (1/dim))\n                sample = rot @ (x * radii) + center\n                sample_tup = tuple(float(c) for c in sample)\n                if in_bounds(sample_tup) and not is_in_obstacle_cached(sample_tup):\n                    return sample_tup\n            # fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0,bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        def sample_near_best_path(best_path: List[Tuple[float,...]]) -> Tuple[float,...]:\n            # Gaussian perturbation around random best path point (local refinement)\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_pt = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size*0.4, dim)\n                    s = tuple(base_pt[d]+noise[d] for d in range(dim))\n                    if in_bounds(s) and not is_in_obstacle_cached(s):\n                        return s\n            return None\n\n        def hybrid_sample(best_path: List[Tuple[float,...]], c_best: float, c_min: float) -> Tuple[float,...]:\n            s = sample_near_best_path(best_path)\n            if s is not None:\n                return s\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def prune_nodes(node_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            for node in node_list[:]:\n                if node in (root_s, root_g):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost - 1e-9:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except (ValueError, AttributeError):\n                            pass\n                    try:\n                        node_list.remove(node)\n                    except ValueError:\n                        pass\n                    removed += 1\n            return removed\n\n        def iterative_shortcut(path: List[Tuple[float,...]], iterations: int) -> List[Tuple[float,...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            length = len(smooth)\n            for _ in range(iterations):\n                if length < 3:\n                    break\n                # mix long-range and local shortcuts\n                # ~70% long-range, ~30% local adjacent shortcuts\n                if random.random() < 0.7:\n                    i = random.randint(0, length-3)\n                    j = random.randint(i+2, length-1)\n                    if can_connect(smooth[i], smooth[j]):\n                        smooth = smooth[:i+1] + smooth[j:]\n                        length = len(smooth)\n                else:\n                    if length >=4:\n                        li = random.randint(0, length-4)\n                        if can_connect(smooth[li], smooth[li+2]):\n                            smooth = smooth[:li+1] + smooth[li+2:]\n                            length = len(smooth)\n            return smooth\n\n        # Initialize roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start: List[Node] = [root_start]\n        tree_goal: List[Node] = [root_goal]\n        nodes: List[Node] = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float,...]] = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = hybrid_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not (can_add_node(new_pos) and can_connect(nearest_a.position, new_pos)):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes_a:\n                cand_cost = nn.cost + dist(nn.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Adaptive rewiring around new_node\n            for nbr in near_nodes_a:\n                if nbr is best_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, nbr.position)\n                if new_c + 1e-12 < nbr.cost and can_connect(new_node.position, nbr.position):\n                    try:\n                        edges.remove((nbr.parent, nbr))\n                    except ValueError:\n                        pass\n                    nbr.update_parent(new_node, new_c)\n                    edges.append((new_node, nbr))\n\n            # Incremental multi-step connect from other tree towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not (can_add_node(next_pos_b) and can_connect(last_node_b.position, next_pos_b)):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(it, len(nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_c_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_c_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_c_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if from_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = iterative_shortcut(merged, self.smoothing_iters)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Perform additional shortcut smoothing to refine path\n                best_path = iterative_shortcut(best_path, self.smoothing_iters)\n                break\n\n            # Periodic aggressive pruning to maintain efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_start = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_goal = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                node_coll_cache.clear()\n                edge_coll_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                pz = pos[2]\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -15.16895,
    "time_improvement": 13.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016820955276489257,
            "num_nodes_avg": 74.8,
            "path_length_avg": 156.59361635105472,
            "smoothness_avg": 0.047524099081534536,
            "success_improvement": 0.0,
            "time_improvement": 33.186926827050925,
            "length_improvement": 14.16855749334473,
            "smoothness_improvement": 643.855350858948,
            "objective_score": 16.009066301078963
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05062260627746582,
            "num_nodes_avg": 218.1,
            "path_length_avg": 233.87184772289825,
            "smoothness_avg": 0.09923651802094828,
            "success_improvement": 0.0,
            "time_improvement": 69.32487790360435,
            "length_improvement": 21.926845602205102,
            "smoothness_improvement": 2453.4270858538002,
            "objective_score": 37.44996792079132
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08303630352020264,
            "num_nodes_avg": 207.3,
            "path_length_avg": 120.10847105781843,
            "smoothness_avg": 0.11274926231375533,
            "success_improvement": 0.0,
            "time_improvement": -62.22981067882477,
            "length_improvement": 20.22967247418246,
            "smoothness_improvement": 1334.1622943461173,
            "objective_score": -7.952197237080351
        }
    ],
    "smoothness_improvement": 1477.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates adaptive bidirectional RRT* with informed ellipsoid sampling, lazy collision checking, incremental rewiring, dynamic neighbor radius adjustment, collision caching, aggressive pruning, and path shortcut smoothing. Designed for both 2D and 3D environments, it balances exploration and exploitation by alternating tree growth, focusing sampling in promising regions, and pruning nodes unlikely to improve the current best path. Lazy collision checks accelerate rewiring and connection attempts without compromising path quality or safety, while shortcut smoothing refines the final path for smoothness and shorter length.",
    "planning_mechanism": "The planner grows two balanced trees alternately from start and goal, sampling points adaptively within an informed ellipsoid guided by the best path found so far. It incrementally extends one tree toward sampled points and lazily rewires neighbors using a KD-tree for efficient radius searches. On connecting the two trees, it extracts and shortcuts the merged path with lazy collision verification. Regular pruning removes nodes that can't improve the best path, maintaining computational efficiency and robustness throughout planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 goal_sample_rate: float = 0.15, prune_interval: int = 150,\n                 prune_threshold: int = 250, shortcut_iter: int = 150,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.shortcut_iter = shortcut_iter\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            n = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n + 1) / n)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Collision caches to reduce repeated checks\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b)\n            key_rev = (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_m = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_m - 2 * np.outer(v, v)\n            else:\n                rot = id_m\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1.0 and norm_x > 1e-5:\n                    x_ball = x_ball / norm_x * random.uniform(0,1)**(1.0/dim)\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.shortcut_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if not is_edge_colliding_cached(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_nodes(current_best_cost):\n            removed_count = 0\n            to_remove = []\n            for node in all_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= current_best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                try:\n                    all_nodes.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                removed_count += 1\n            return removed_count\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        all_nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Goal biasing with some probability\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                growing_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                growing_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Checks before adding new node\n            if is_in_obstacle_cached(new_pos) or is_edge_colliding_cached(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(all_nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Lazy parent selection with edge collision checks\n            for node in near_nodes:\n                c_candidate = node.cost + dist(node.position, new_pos)\n                if c_candidate + 1e-12 < min_cost:\n                    if not is_edge_colliding_cached(node.position, new_pos):\n                        min_cost = c_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with lazy collision checks\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost:\n                    if not is_edge_colliding_cached(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, c_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Try to connect new_node to the other tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_b_to_new = dist(nearest_b.position, new_node.position)\n\n            connected = False\n            # Direct connection attempt if close enough and collision-free\n            if dist_b_to_new <= self.step_size and not is_edge_colliding_cached(new_node.position, nearest_b.position):\n                cost_connection = new_node.cost + dist(new_node.position, nearest_b.position)\n                connection_node = Node(nearest_b.position, parent=new_node, cost=cost_connection)\n                new_node.children.append(connection_node)\n                tree_a.append(connection_node)\n                all_nodes.append(connection_node)\n                edges.append((new_node, connection_node))\n\n                if growing_from_start:\n                    path_start = connection_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                else:\n                    path_start = nearest_b.path_from_root()\n                    path_goal = connection_node.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]\n                smoothed_path = shortcut_path(merged_path)\n\n                if cost_connection < c_best:\n                    c_best = cost_connection\n                    best_path = smoothed_path\n                    success_state = True\n\n                extracted_path = best_path\n                break\n\n            # Incremental connection attempt with limited extension from nearest_b\n            max_steps = max(1, int(dist_b_to_new / self.step_size))\n            last_node_b = nearest_b\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if is_in_obstacle_cached(next_pos_b) or is_edge_colliding_cached(last_node_b.position, next_pos_b):\n                    break\n\n                cost_new_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_new_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost:\n                        if not is_edge_colliding_cached(new_node_b.position, neighbor_b.position):\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                            neighbor_b.update_parent(new_node_b, c_via_new_b)\n                            edges.append((new_node_b, neighbor_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and not is_edge_colliding_cached(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    all_nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    if growing_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if cost_conn < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed_path\n                        success_state = True\n\n                    extracted_path = best_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected or success_state:\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(all_nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                node_collision_cache.clear()\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.20709,
    "time_improvement": -17.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.021147847175598145,
            "num_nodes_avg": 86.3,
            "path_length_avg": 162.56572098554295,
            "smoothness_avg": 0.046314173042240545,
            "success_improvement": 0.0,
            "time_improvement": 16.00045077294301,
            "length_improvement": 10.895152309127887,
            "smoothness_improvement": 624.9173809475498,
            "objective_score": 10.10375259844623
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08115475177764893,
            "num_nodes_avg": 312.1,
            "path_length_avg": 239.25070914664462,
            "smoothness_avg": 0.09683329512774458,
            "success_improvement": 0.0,
            "time_improvement": 50.82371093583519,
            "length_improvement": 20.131226837016815,
            "smoothness_improvement": 2391.5904298401856,
            "objective_score": 31.231310797354848
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11219837665557861,
            "num_nodes_avg": 328.8,
            "path_length_avg": 125.95408358694351,
            "smoothness_avg": 0.11443572889646611,
            "success_improvement": 0.0,
            "time_improvement": -119.2043796708446,
            "length_improvement": 16.347294970493675,
            "smoothness_improvement": 1355.6140247961841,
            "objective_score": -25.713784783173725
        }
    ],
    "smoothness_improvement": 1457.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines the bidirectional adaptive informed sampling technique with dynamic neighbor radius rewiring and efficient collision caching. It balances growth by always extending the smaller tree, uses KD-tree accelerated nearest neighbor searches, caches collision checks to minimize redundant computations, and prunes dead-end and non-improving nodes periodically. Iterative shortcut smoothing is applied upon path connection to enhance path quality and smoothness. The approach focuses on improving planning efficiency, robustness, success rate, and producing shorter, smoother paths with reduced search time in complex 2D/3D environments.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, always extending the smaller tree to balance exploration. Samples are generated with adaptive informed biasing near start and goal, avoiding obstacles efficiently. New nodes are connected using a dynamically shrinking neighbor radius to incrementally optimize costs via rewiring. Collision checks for nodes and edges are cached for efficiency. Dead-end and cost-ineffective nodes are pruned regularly to maintain a compact search space. Once a connection is found, iterative shortcut smoothing refines the path. The final output is the best feasible path found within max iterations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n    \n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=20.0,\n                 radius_min: float=4.0, prune_interval: int=100,\n                 prune_threshold: int=120, smoothing_iterations: int=50,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        edge_collision_cache = {}\n        node_collision_cache = {}\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            res = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = res\n            return res\n\n        def is_edge_in_obstacle_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            res = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = res\n            return res\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if is_in_obstacle_cached(p2):\n                return False\n            if is_edge_in_obstacle_cached(p1, p2):\n                return False\n            return True\n\n        # Adaptive informed sampling biased near start and goal with fallback uniform sampling\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias mixture toward goal and start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                for _ in range(15):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(sample):\n                        return sample\n                return goal_position  # fallback\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            clamped = tuple(max(0.0, min(bounds[d], new_pos[d])) for d in range(dim))\n            return clamped\n\n        # KDTree substitute: linear search for nearest node\n        def nearest(tree, point):\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = 0.0\n                for i in range(dim):\n                    diff = node.position[i] - pos[i]\n                    d_sq += diff * diff\n                    if d_sq > radius_sq:\n                        break\n                if d_sq <= radius_sq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=None, cost=new_cost)\n                last_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Final edge \n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=None, cost=final_cost)\n                        new_node.add_child(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes_and_nonimprovable(best_cost=float('inf')):\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Dead-end nodes (no children)\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n                else:\n                    # Prune nodes whose cost + heuristic cannot improve best_cost\n                    heuristic = dist(node.position, goal_position)\n                    if node.cost + heuristic - 1e-12 >= best_cost:\n                        try:\n                            if node.parent:\n                                node.parent.remove_child(node)\n                            nodes.remove(node)\n                            edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                            removed.append(node)\n                        except Exception:\n                            continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) -1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i+2, len(p)-1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        best_path = []\n        best_cost = float('inf')\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                root_start, root_goal = goal_root, start_root\n            else:\n                root_start, root_goal = start_root, goal_root\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                    new_path_cost = path_length(smoothed)\n                else:\n                    extracted_path = raw_path\n                    new_path_cost = path_length(raw_path)\n                if new_path_cost + 1e-12 < best_cost:\n                    best_cost = new_path_cost\n                    best_path = extracted_path\n                break\n\n            # Periodic pruning to reduce overhead and improve efficiency\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and best_cost < float('inf'):\n                prune_dead_nodes_and_nonimprovable(best_cost)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.90157,
    "time_improvement": 39.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012537288665771484,
            "num_nodes_avg": 81.9,
            "path_length_avg": 164.3737683314568,
            "smoothness_avg": 0.029628933487335973,
            "success_improvement": 0.0,
            "time_improvement": 50.2017114219803,
            "length_improvement": 9.90413290848889,
            "smoothness_improvement": 363.75714933567724,
            "objective_score": 18.86012575497025
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.040825486183166504,
            "num_nodes_avg": 257.4,
            "path_length_avg": 237.8634492941661,
            "smoothness_avg": 0.07093023317705174,
            "success_improvement": 0.0,
            "time_improvement": 75.26151130091444,
            "length_improvement": 20.59433410583502,
            "smoothness_improvement": 1725.0859886274663,
            "objective_score": 35.322750154578664
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05528502464294434,
            "num_nodes_avg": 245.3,
            "path_length_avg": 130.14303260308697,
            "smoothness_avg": 0.1369860486678642,
            "success_improvement": 0.0,
            "time_improvement": -8.011540747558735,
            "length_improvement": 13.565194490288098,
            "smoothness_improvement": 1642.4524277969049,
            "objective_score": 8.521838812774524
        }
    ],
    "smoothness_improvement": 1244.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a bidirectional informed RRT* algorithm with adaptive ellipsoidal sampling focused on promising regions, dynamic neighbor radius adjustment to optimize rewiring, collision caching for efficient obstacle checking, aggressive pruning of nodes unlikely to improve the path, and iterative shortcut smoothing to enhance path smoothness and minimize length. Balanced tree expansion and KD-tree based neighbor searches help maintain robustness and high success rates in cluttered 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two RRT* trees from start and goal positions sampling adaptively within shrinking ellipsoidal informed subsets based on the current best path cost. It steers toward sampled points using step-limited motions, chooses parents minimizing cost while ensuring collision-free connections, rewires neighbors for incremental path improvement, connects trees when nodes approach within step size, and prunes non-promising nodes periodically. After finding a solution, shortcut smoothing refines path quality before returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 0.5,\n                 goal_sample_rate: float = 0.18):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.92)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                trials = 0\n                while trials < 25:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    trials += 1\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim - 1))\n            v_norm = np.linalg.norm(v)\n            if v_norm > 1e-12:\n                v = v / v_norm\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min / 2.0)**2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            attempts = 0\n            while attempts < 150:\n                sample_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(sample_ball) <= 1:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + center\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                attempts += 1\n\n            for _ in range(15):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            rev_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if rev_key in edge_collision_cache:\n                return not edge_collision_cache[rev_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            path_mod = path\n            for _ in range(self.smoothing_iterations):\n                if len(path_mod) < 3:\n                    break\n                i = random.randint(0, len(path_mod) - 3)\n                j = random.randint(i + 2, len(path_mod) - 1)\n                p1, p2 = path_mod[i], path_mod[j]\n                if can_connect(p1, p2):\n                    path_mod = path_mod[:i + 1] + path_mod[j:]\n            return path_mod\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Balanced tree expansion: grow smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            # Choose parent minimizing cost + collision free edge\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Try incremental connection from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            dist_ab = dist(last_b.position, new_node.position)\n            max_steps = int(dist_ab / self.step_size) + 1\n\n            connected = False\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees can be connected\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic prune non-promising nodes and clear collision cache\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.58551,
    "time_improvement": 6.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.029527997970581053,
            "num_nodes_avg": 80.4,
            "path_length_avg": 154.60729097633933,
            "smoothness_avg": 0.04487608897652324,
            "success_improvement": 0.0,
            "time_improvement": -17.285627161532023,
            "length_improvement": 15.257293906566,
            "smoothness_improvement": 602.4082424695423,
            "objective_score": 0.8778118452013044
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.08322267532348633,
            "num_nodes_avg": 289.9,
            "path_length_avg": 240.41678765443652,
            "smoothness_avg": 0.08785297161601428,
            "success_improvement": 0.0,
            "time_improvement": 49.570638209652564,
            "length_improvement": 19.741956267407023,
            "smoothness_improvement": 2160.520237617789,
            "objective_score": 29.62218390446612
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.057939696311950686,
            "num_nodes_avg": 206.3,
            "path_length_avg": 123.67293022094937,
            "smoothness_avg": 0.12804280323061026,
            "success_improvement": 0.0,
            "time_improvement": -13.198029837509118,
            "length_improvement": 17.862328419336574,
            "smoothness_improvement": 1528.6950059567462,
            "objective_score": 7.2565317623983105
        }
    ],
    "smoothness_improvement": 1431.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional informed RRT* algorithm focused on balanced tree growth, adaptive informed sampling within an ellipsoidal domain between start and goal, and rewiring neighbors to optimize path cost. It includes collision checks for node validity and edges, pruning for efficiency, and iterative shortcut smoothing to refine the final path for smoothness and length reduction, achieving improved planning efficiency, path quality, and robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, extending the smaller one each iteration towards adaptively sampled points biased inside an informed ellipsoid shaped by the current best path cost. New nodes select parents minimizing cost, then neighbors are rewired to optimize local paths. Trees attempt incremental multi-step connections after each extension. Dead-end and suboptimal nodes are pruned periodically to reduce overhead. After a valid connection, the combined path is shortcut-smoothed before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0,\n                 prune_interval: int = 100, prune_threshold: int = 150,\n                 smoothing_iterations: int = 80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp inside bounds\n            clamped = tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def is_free(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_free(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.5)\n\n        def sample_informed(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # Uniform random with obstacle rejection\n                for _ in range(20):\n                    pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            import numpy as np\n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            unit_vec = np.array([goal[d]-start[d] for d in range(dim)])\n            norm_unit = np.linalg.norm(unit_vec)\n            if norm_unit < 1e-12:\n                return tuple(center.tolist())\n\n            unit_vec /= norm_unit\n            id_mat = np.eye(dim)\n            u = unit_vec - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2\n            r2 = math.sqrt(max(r1**2 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2]*(dim-1))\n            for _ in range(20):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-8 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                scale = np.random.uniform(0,1) ** (1/dim)\n                sample = rot @ (x * radii * scale) + center\n                p = tuple(float(v) for v in sample)\n                if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                idx = random.randint(0, len(best_path)-1)\n                base = best_path[idx]\n                noise = [random.gauss(0, self.step_size*0.4) for _ in range(dim)]\n                sample = tuple(base[d] + noise[d] for d in range(dim))\n                if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return sample_informed(c_best, c_min, start_pos, goal_pos)\n\n        class SimpleKDTree:\n            def __init__(self, nodes):\n                self.points = [n.position for n in nodes]\n                self.nodes = nodes\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best = self.nodes[i]\n                        best_dist = d\n                return best\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                res = []\n                for i, p in enumerate(self.points):\n                    dd = 0\n                    for d_ in range(dim):\n                        delta = p[d_]-pt[d_]\n                        dd += delta*delta\n                        if dd > r2:\n                            break\n                    if dd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def neighbor_radius(n_nodes, iter_):\n            if n_nodes <= 1:\n                return 30.0\n            from math import log, sqrt\n            r_iter = 30.0 * (1 - (iter_/self.max_iter) ** 0.95)\n            r_nodes = 5.0 + (30.0 - 5.0)*sqrt(log(n_nodes+1)/n_nodes)\n            return max(5.0, min(r_iter, r_nodes))\n\n        def prune(tree, best_cost, root_s, root_g):\n            to_remove = []\n            for node in tree:\n                if node in (root_s, root_g):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost - 1e-12:\n                    to_remove.append(node)\n            removed = 0\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    tree.remove(node)\n                    removed += 1\n                except ValueError:\n                    pass\n            return removed\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if edge_free(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        # Initialize roots and trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            # Choose smaller tree to extend\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            kdt_a = SimpleKDTree(tree_a)\n            nearest_a = kdt_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not is_free(new_pos) or not edge_free(nearest_a.position, new_pos):\n                if iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                    prune(tree_start, c_best, root_start, root_goal)\n                    prune(tree_goal, c_best, root_start, root_goal)\n                continue\n\n            radius_a = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdt_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-14 < min_cost and edge_free(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                c_new = new_node.cost + dist(new_node.position, node.position)\n                if c_new + 1e-14 < node.cost and edge_free(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, c_new)\n                    edges.append((new_node, node))\n\n            # Try incremental multi-step connection from tree_b\n            kdt_b = SimpleKDTree(tree_b)\n            nearest_b = kdt_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position)/self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not is_free(next_pos_b) or not edge_free(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdt_b.radius_search(next_pos_b, radius_b)\n                for nbr in near_nodes_b:\n                    if nbr is last_node_b:\n                        continue\n                    c_new_b = new_node_b.cost + dist(new_node_b.position, nbr.position)\n                    if c_new_b + 1e-14 < nbr.cost and edge_free(new_node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node_b, c_new_b)\n                        edges.append((new_node_b, nbr))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and edge_free(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-14 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            if iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune(tree_start, c_best, root_start, root_goal)\n                prune(tree_goal, c_best, root_start, root_goal)\n\n        extracted_path = best_path if success_state else []\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.42597,
    "time_improvement": 8.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03860907554626465,
            "num_nodes_avg": 78.6,
            "path_length_avg": 167.7462155673977,
            "smoothness_avg": 0.036372819775349785,
            "success_improvement": 0.0,
            "time_improvement": -53.355796220325715,
            "length_improvement": 8.055641138623452,
            "smoothness_improvement": 469.3136143265625,
            "objective_score": -12.049042566740209
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06197619438171387,
            "num_nodes_avg": 226.7,
            "path_length_avg": 241.06853788599037,
            "smoothness_avg": 0.09309291966124704,
            "success_improvement": 0.0,
            "time_improvement": 62.44509183686,
            "length_improvement": 19.524383280524088,
            "smoothness_improvement": 2295.3478750036516,
            "objective_score": 34.11514358218108
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04388895034790039,
            "num_nodes_avg": 129.5,
            "path_length_avg": 124.47848178669662,
            "smoothness_avg": 0.12532115354060774,
            "success_improvement": 0.0,
            "time_improvement": 14.253214509965392,
            "length_improvement": 17.327319425610728,
            "smoothness_improvement": 1494.0758227911972,
            "objective_score": 15.21180735206775
        }
    ],
    "smoothness_improvement": 1420.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This enhanced planner implements a Bidirectional Informed RRT* with progressive informed ellipsoidal sampling, adaptive step sizing, dynamic neighbor radius, KD-tree accelerated nearest and radius searches, lazy collision checking with caching, incremental multi-step connections between trees, aggressive iterative shortcut smoothing, and periodic pruning of non-promising nodes. The algorithm adaptively balances exploration and exploitation to reduce planning time, improve path quality and smoothness, and boost success rate and robustness in both 2D and 3D.\n\n<The planner grows two RRT* trees rooted at start and goal alternately. Sampling is biased using a dynamically shrinking ellipsoidal informed region shaped by the best current path cost. Adaptive step sizes allow fast early exploration and fine tuning near solutions. KD-trees speed nearest and neighbor lookup for rewiring to optimize path cost. Lazy collision checks with caching minimize expensive obstacle queries. Trees attempt multi-step incremental connections to close the gap. Periodic pruning removes nodes unlikely to improve the solution, maintaining manageable tree sizes and enhancing responsiveness. Iterative shortcut smoothing refines path quality after each solution improvement.> \n```python\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_step_size: float=1.0,\n                 max_step_size: float=10.0,\n                 neighbor_min_radius: float=5.0,\n                 neighbor_max_radius: float=30.0,\n                 pruning_interval: int=200,\n                 pruning_threshold: int=350,\n                 smoothing_iterations: int=200,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.pruning_interval = pruning_interval\n        self.pruning_threshold = pruning_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                new_p = to_p\n            else:\n                ratio = step / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def adaptive_step_size(iteration, c_best, c_min):\n            if c_best == float('inf'):\n                return self.max_step_size\n            ratio = max(0.0, min(1.0, (c_best - c_min) / c_best))\n            amplitude = self.min_step_size + (self.max_step_size - self.min_step_size) * (ratio ** 1.5)\n            decayed = self.min_step_size + (amplitude - self.min_step_size) * (1 - iteration / self.max_iter)\n            return max(self.min_step_size, min(self.max_step_size, decayed))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.neighbor_max_radius * (1 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        node_collision_cache = {",
    "planning_mechanism": "The planner grows two RRT* trees rooted at start and goal alternately. Sampling is biased using a dynamically shrinking ellipsoidal informed region shaped by the best current path cost. Adaptive step sizes allow fast early exploration and fine tuning near solutions. KD-trees speed nearest and neighbor lookup for rewiring to optimize path cost. Lazy collision checks with caching minimize expensive obstacle queries. Trees attempt multi-step incremental connections to close the gap. Periodic pruning removes nodes unlikely to improve the solution, maintaining manageable tree sizes and enhancing responsiveness. Iterative shortcut smoothing refines path quality after each solution improvement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision marking\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_step_size: float=1.0,\n                 max_step_size: float=10.0,\n                 neighbor_min_radius: float=5.0,\n                 neighbor_max_radius: float=30.0,\n                 pruning_interval: int=200,\n                 pruning_threshold: int=350,\n                 smoothing_iterations: int=200,\n                 collision_check_resolution: float=0.5,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_min_radius = neighbor_min_radius\n        self.neighbor_max_radius = neighbor_max_radius\n        self.pruning_interval = pruning_interval\n        self.pruning_threshold = pruning_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p, step):\n            d = dist(from_p, to_p)\n            if d <= step:\n                new_p = to_p\n            else:\n                ratio = step / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def adaptive_step_size(iteration, c_best, c_min):\n            if c_best == float('inf'):\n                return self.max_step_size\n            ratio = max(0.0, min(1.0, (c_best - c_min) / c_best))\n            amplitude = self.min_step_size + (self.max_step_size - self.min_step_size) * (ratio ** 1.5)\n            decayed = self.min_step_size + (amplitude - self.min_step_size) * (1 - iteration / self.max_iter)\n            return max(self.min_step_size, min(self.max_step_size, decayed))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.neighbor_max_radius * (1 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.neighbor_min_radius + (self.neighbor_max_radius - self.neighbor_min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.neighbor_min_radius, min(r_iter, r_nodes))\n\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for d in range(dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(n)\n                return result\n\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = val\n            return val\n\n        def is_edge_colliding_cached(a, b):\n            key = (a, b) if a < b else (b, a)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            val = self._is_edge_in_obstacle(a, b, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = val\n            return val\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle_cached(pos):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if (p1, p2) in edge_collision_cache:\n                return not edge_collision_cache[(p1, p2)]\n            if (p2, p1) in edge_collision_cache:\n                return not edge_collision_cache[(p2, p1)]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[(p1, p2)] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[(p1, p2)] = collision\n            return not collision\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    sp = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle_cached(sp):\n                        return sp\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            I = np.eye(dim)\n            u = a1 - I[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = I - 2 * np.outer(u, u)\n            else:\n                rot = I\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if 1e-10 < norm_x <= 1.0:\n                    x_ball /= norm_x\n                    radius_factor = random.uniform(0, 1) ** (1.0 / dim)\n                    sample = rot @ (x_ball * radius_factor * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle_cached(p):\n                        return p\n            # fallback uniform\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_tree(tree_nodes, best_cost, root_start, root_goal):\n            heuristic = lambda pos: dist(pos, goal)\n            to_remove = []\n            for node in tree_nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    tree_nodes.remove(node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        all_nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        for iter_id in range(self.max_iter):\n            step = adaptive_step_size(iter_id, c_best, c_min)\n\n            # Alternate growing smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                grow_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                grow_from_start = False\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iter_id, len(all_nodes))\n            near_nodes_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incremental multi-step connection from opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_b_new = dist(nearest_b.position, new_node.position)\n            max_steps = max(1, int(dist_b_new / step))\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position, step)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                r_b = neighbor_radius(iter_id, len(all_nodes))\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, r_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    c_new = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if c_new + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, c_new)\n                        edges.append((new_node_b, nbr_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= step and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist_to_new\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    all_nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success = True\n                    if grow_from_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Iterative shortcut smoothing for refinement\n                best_path = shortcut_path(best_path)\n                # Prune trees if grown too large\n                if len(all_nodes) > self.pruning_threshold:\n                    prune_tree(tree_start, c_best, root_start, root_goal)\n                    prune_tree(tree_goal, c_best, root_start, root_goal)\n                    edge_collision_cache.clear()\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for large trees with solution\n            if (iter_id > 0 and iter_id % self.pruning_interval == 0 and\n                len(all_nodes) > self.pruning_threshold and c_best < float('inf')):\n                prune_tree(tree_start, c_best, root_start, root_goal)\n                prune_tree(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if not success:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -16.16932,
    "time_improvement": 21.0,
    "length_improvement": 7.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03806147575378418,
            "num_nodes_avg": 65.8,
            "path_length_avg": 196.84514818424162,
            "smoothness_avg": 0.05343988334744417,
            "success_improvement": 0.0,
            "time_improvement": -51.18072207007057,
            "length_improvement": -7.893944930763289,
            "smoothness_improvement": 736.4502209515798,
            "objective_score": -13.25075450241593
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03228652477264404,
            "num_nodes_avg": 118.2,
            "path_length_avg": 247.4280470256803,
            "smoothness_avg": 0.11828130482946282,
            "success_improvement": 0.0,
            "time_improvement": 80.43575464999275,
            "length_improvement": 17.401396081374386,
            "smoothness_improvement": 2943.463167842356,
            "objective_score": 42.32832145048448
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03438637256622314,
            "num_nodes_avg": 108.9,
            "path_length_avg": 132.11058759296924,
            "smoothness_avg": 0.12001826072934034,
            "success_improvement": 0.0,
            "time_improvement": 32.81860493714447,
            "length_improvement": 12.258438150908745,
            "smoothness_improvement": 1426.6234176507073,
            "objective_score": 19.430386199578628
        }
    ],
    "smoothness_improvement": 1702.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved bidirectional RRT* planner incorporates adaptive sampling with informed sampling around an ellipse formed by start and goal to reduce random exploration, uses a kd-tree structure for efficient nearest neighbor and radius queries, applies early stopping when trees are close, and enables path smoothing with post-processing. Collision checks are minimized and efficient rewiring is performed using dynamic radius based on tree size. The approach better balances exploration and exploitation, accelerates convergence, and improves path quality while maintaining robustness and correctness.",
    "planning_mechanism": "The planner alternates growth between two trees, samples points biased towards the goal and within an informed ellipse region to focus search, uses kd-tree for efficient nearest node and neighbor queries, extends nodes by fixed step size ensuring collision safety, rewires nearby nodes to optimize tree costs, checks if trees can connect via an extend step, and reconstructs the final path with optional smoothing to minimize path length and sharp turns. Early termination upon connection and pruning reduce search time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: Optional['Node']=None, cost: float=0.0):\n        self.position = position      # Tuple[float, ...] (2D or 3D)\n        self.parent = parent          # Parent node or None\n        self.cost = cost              # Cost from root\n        self.children = []\n        self.valid = True             # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    @staticmethod\n    def smooth_path(path: List[Tuple[float, ...]], is_3d: bool, obstacles, collision_check, edge_check):\n        # Shortcut smoothing: attempt to connect non-adjacent nodes directly if collision free\n        if len(path) < 3:\n            return path[:]\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not edge_check(path[i], path[j], obstacles, is_3d):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed.append(path[i+1])\n                i += 1\n        return smoothed\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 18.0,\n                 radius_min: float = 3.0, search_radius_factor: float = 1.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.search_radius_factor = search_radius_factor  # Multiplier for informed sampling ellipse axis\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        ##########################\n        # KD-Tree implementation for fast nearest and radius queries\n        ##########################\n\n        class KDNode:\n            def __init__(self, points: List[Node], depth=0):\n                self.axis = depth % len(bounds)\n                points.sort(key=lambda n: n.position[self.axis])\n                median = len(points) // 2\n                self.location = points[median]\n                left_points = points[:median]\n                right_points = points[median + 1:]\n                self.left = KDNode(left_points, depth + 1) if left_points else None\n                self.right = KDNode(right_points, depth + 1) if right_points else None\n\n        def kd_build(tree_nodes: List[Node]) -> Optional[KDNode]:\n            if not tree_nodes:\n                return None\n            return KDNode(tree_nodes)\n\n        def kd_nearest(root: Optional[KDNode], point: Tuple[float, ...], best: Tuple[Optional[Node], float]) -> Tuple[Optional[Node], float]:\n            if root is None:\n                return best\n            node = root.location\n            dist = math.dist(point, node.position)\n            if dist < best[1]:\n                best = (node, dist)\n            axis = root.axis\n            diff = point[axis] - node.position[axis]\n            close, away = (root.left, root.right) if diff < 0 else (root.right, root.left)\n            best = kd_nearest(close, point, best)\n            if abs(diff) < best[1]:\n                best = kd_nearest(away, point, best)\n            return best\n\n        def kd_radius(root: Optional[KDNode], point: Tuple[float, ...], radius: float, results: List[Node]):\n            if root is None:\n                return\n            node = root.location\n            dist = math.dist(point, node.position)\n            if dist <= radius:\n                results.append(node)\n            axis = root.axis\n            diff = point[axis] - node.position[axis]\n            if diff <= radius:\n                kd_radius(root.left, point, radius, results)\n            if diff >= -radius:\n                kd_radius(root.right, point, radius, results)\n\n        ##########################\n        # Sampling with Informed Sampling\n        ##########################\n\n        def sample_informed(start: Tuple[float, ...], goal: Tuple[float, ...], c_best: float, bounds: Tuple[int, ...]) -> Tuple[float, ...]:\n            # If no solution yet, sample random free point or goal (goal bias)\n            if not math.isfinite(c_best):\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    while True:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n            else:\n                # Sample within an ellipse with foci start and goal, major axis c_best\n                dims = len(bounds)\n                # Compute center & rotation\n                c_min = math.dist(start, goal)\n                if c_best < c_min:\n                    c_best = c_min + 1e-6\n\n                center = tuple((s + g) / 2 for s, g in zip(start, goal))\n                diff = tuple(g - s for s, g in zip(start, goal))\n                # Rotation matrix to align x-axis to the line start->goal in dims\n                # For now we handle 2D and 3D separately for rotation matrix\n                # 2D rotation:\n                if dims == 2:\n                    dx, dy = diff\n                    angle = math.atan2(dy, dx)\n                    while True:\n                        # Sample in unit ball\n                        r1 = random.random()\n                        r2 = random.random()\n                        theta = 2 * math.pi * r2\n                        r = r1 ** 0.5\n                        x_ball = r * math.cos(theta)\n                        y_ball = r * math.sin(theta)\n                        # Scale to ellipse axes\n                        a = c_best / 2 * self.search_radius_factor\n                        b = math.sqrt(c_best ** 2 - c_min ** 2) / 2 * self.search_radius_factor\n                        # Rotate and translate\n                        x_rot = a * x_ball\n                        y_rot = b * y_ball\n                        px = center[0] + x_rot * math.cos(angle) - y_rot * math.sin(angle)\n                        py = center[1] + x_rot * math.sin(angle) + y_rot * math.cos(angle)\n                        p = (px, py)\n                        if 0 <= px <= bounds[0] and 0 <= py <= bounds[1] and not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n                else:\n                    # 3D: uniform sampling in unit ball (Marsaglia method)\n                    while True:\n                        while True:\n                            x1 = random.uniform(-1, 1)\n                            x2 = random.uniform(-1, 1)\n                            x3 = random.uniform(-1, 1)\n                            norm = x1 ** 2 + x2 ** 2 + x3 ** 2\n                            if 0 < norm <= 1:\n                                break\n                        norm = math.sqrt(norm)\n                        u1 = x1 / norm\n                        u2 = x2 / norm\n                        u3 = x3 / norm\n                        r = random.random() ** (1/3)\n                        x_ball = r * u1\n                        y_ball = r * u2\n                        z_ball = r * u3\n\n                        a = c_best / 2 * self.search_radius_factor\n                        b = math.sqrt(c_best ** 2 - c_min ** 2) / 2 * self.search_radius_factor\n                        c = b  # Approximate - ellipse minor axis same for 3rd dim\n\n                        # Rotation: align x-axis to diff vector normalized\n                        diff_norm = math.sqrt(sum(d ** 2 for d in diff))\n                        if diff_norm < 1e-8:\n                            return start\n                        ux, uy, uz = (d / diff_norm for d in diff)\n                        # Rodrigues rotation setup to rotate (1,0,0) to (ux, uy, uz)\n                        # Vector v = cross((1,0,0), u)\n                        vx, vy, vz = 0.0, -uz, uy\n                        s = math.sqrt(vx * vx + vy * vy + vz * vz)\n                        c_rodrigues = ux  # dot((1,0,0), u)\n\n                        def rodrigues_rotate(vec):\n                            # vec is (x_rot, y_rot, z_rot)\n                            if s < 1e-8:\n                                # No rotation needed\n                                return vec\n                            k = (vx / s, vy / s, vz / s)\n                            v = vec\n                            cos_theta = c_rodrigues\n                            sin_theta = s\n                            dot_kv = k[0]*v[0] + k[1]*v[1] + k[2]*v[2]\n                            cross_kv = (k[1]*v[2] - k[2]*v[1],\n                                        k[2]*v[0] - k[0]*v[2],\n                                        k[0]*v[1] - k[1]*v[0])\n                            rx = v[0]*cos_theta + cross_kv[0]*sin_theta + k[0]*dot_kv*(1 - cos_theta)\n                            ry = v[1]*cos_theta + cross_kv[1]*sin_theta + k[1]*dot_kv*(1 - cos_theta)\n                            rz = v[2]*cos_theta + cross_kv[2]*sin_theta + k[2]*dot_kv*(1 - cos_theta)\n                            return (rx, ry, rz)\n\n                        x_ell = a * x_ball\n                        y_ell = b * y_ball\n                        z_ell = c * z_ball\n                        rotated = rodrigues_rotate((x_ell, y_ell, z_ell))\n                        p = tuple(center[d] + rotated[d] for d in range(3))\n                        if all(0 <= p[d] <= bounds[d] for d in range(3)) and not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        ##########################\n        # Helper Functions\n        ##########################\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        ##########################\n        # Dynamic KD-Trees for nearest and radius queries\n        ##########################\n\n        # To avoid rebuilding kd-tree every iteration, update periodically\n        kd_tree_start = kd_build(tree_start)\n        kd_tree_goal = kd_build(tree_goal)\n        kd_update_freq = 25\n        iter_since_kd_start = 0\n        iter_since_kd_goal = 0\n\n        ##########################\n        # Extend and Rewire Functions\n        ##########################\n\n        def get_nearest(tree_nodes: List[Node], kd_root: Optional[KDNode], point: Tuple[float, ...]) -> Optional[Node]:\n            if kd_root:\n                node, dist = kd_nearest(kd_root, point, (None, float('inf')))\n                return node\n            else:\n                return min(tree_nodes, key=lambda n: distance(n.position, point))\n\n        def get_near_nodes(tree_nodes: List[Node], kd_root: Optional[KDNode], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            result: List[Node] = []\n            if kd_root:\n                kd_radius(kd_root, pos, radius, result)\n                return result\n            else:\n                return [n for n in tree_nodes if distance(n.position, pos) <= radius]\n\n        def try_extend(tree_nodes: List[Node], kd_root: Optional[KDNode], point: Tuple[float, ...]) -> Optional[Node]:\n            nearest_node = get_nearest(tree_nodes, kd_root, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree_nodes))\n            near = get_near_nodes(tree_nodes, kd_root, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_nodes.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree_nodes: List[Node], kd_root: Optional[KDNode], node: Node) -> Optional[Node]:\n            # Attempt to connect tree_nodes from nearest to node.position by iterative extend steps up to the node\n            nearest_node = get_nearest(tree_nodes, kd_root, node.position)\n            if nearest_node is None:\n                return None\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree_nodes.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree_nodes.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        ##########################\n        # Main Loop\n        ##########################\n\n        best_cost = float('inf')\n\n        for i in range(self.max_iter):\n            # Adaptive informed sampling (ellipse) if path found\n            sample_point = sample_informed(start_position, goal_position, best_cost, bounds)\n\n            # Balance tree sizes to grow smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                kd_tree_start, kd_tree_goal = kd_tree_goal, kd_tree_start\n                iter_since_kd_start, iter_since_kd_goal = iter_since_kd_goal, iter_since_kd_start\n\n            new_node_start = try_extend(tree_start, kd_tree_start, sample_point)\n            if new_node_start is None:\n                # Periodic kd-tree rebuild\n                iter_since_kd_start += 1\n                if iter_since_kd_start >= kd_update_freq:\n                    kd_tree_start = kd_build(tree_start)\n                    iter_since_kd_start = 0\n                continue\n\n            iter_since_kd_start += 1\n            if iter_since_kd_start >= kd_update_freq:\n                kd_tree_start = kd_build(tree_start)\n                iter_since_kd_start = 0\n\n            new_node_goal = try_connect(tree_goal, kd_tree_goal, new_node_start)\n            if new_node_goal:\n                # Found connection, update best cost and path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                candidate_path = path_start + path_goal[::-1][1:]\n                candidate_cost = 0.0\n                for p1, p2 in zip(candidate_path[:-1], candidate_path[1:]):\n                    candidate_cost += distance(p1, p2)\n                if candidate_cost < best_cost:\n                    best_cost = candidate_cost\n                    extracted_path = candidate_path\n                # Early stop as we found a path\n                break\n\n            iter_since_kd_goal += 1\n            if iter_since_kd_goal >= kd_update_freq:\n                kd_tree_goal = kd_build(tree_goal)\n                iter_since_kd_goal = 0\n\n        # Post smoothing to improve path\n        if success_state and extracted_path:\n            extracted_path = Node.smooth_path(extracted_path, is_3d, obstacles, self._is_in_obstacle, self._is_edge_in_obstacle)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.2572,
    "time_improvement": -73.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07701706886291504,
            "num_nodes_avg": 453.8,
            "path_length_avg": 155.964369857721,
            "smoothness_avg": 0.045398674156093076,
            "success_improvement": 0.0,
            "time_improvement": -205.91289096976791,
            "length_improvement": 14.513457467389701,
            "smoothness_improvement": 610.587835341691,
            "objective_score": -55.818236620743974
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11542694568634033,
            "num_nodes_avg": 655.6,
            "path_length_avg": 238.3884836725327,
            "smoothness_avg": 0.12638187522027253,
            "success_improvement": 0.0,
            "time_improvement": 30.05623549416805,
            "length_improvement": 20.419062518059594,
            "smoothness_improvement": 3151.896678602906,
            "objective_score": 28.860166544876865
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07293143272399902,
            "num_nodes_avg": 496.4,
            "path_length_avg": 125.88109780410441,
            "smoothness_avg": 0.1439255807647754,
            "success_improvement": 0.0,
            "time_improvement": -42.48770744558949,
            "length_improvement": 16.395768652245902,
            "smoothness_improvement": 1730.722763846638,
            "objective_score": -0.8135446839944773
        }
    ],
    "smoothness_improvement": 1831.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements an enhanced bidirectional informed RRT* algorithm that adaptively biases sampling inside a dynamically-adjusted ellipsoid informed by the current best path cost, accelerating convergence towards optimal paths. It leverages efficient KD-tree search for nearest neighbor and radius queries, caches collision checks to avoid redundant expensive computations, incrementally rewires the trees for cost improvements, prunes nodes that cannot improve the current best solution to reduce search space, and applies aggressive shortcut smoothing to yield shorter and smoother final paths. These strategies collectively improve planning efficiency, path quality, robustness, and success rate while reducing planning time and path length in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions alternately, sampling new points within an ellipsoid defined by the best known path cost to focus the search. Nodes are connected only after collision-free checks. KD-trees accelerate neighbor searches used in rewiring and extension. Periodic pruning discards nodes unlikely to improve the best solution, maintaining a smaller, relevant tree. After finding a path, shortcut smoothing reduces path length and improves smoothness by repeatedly attempting to connect distant nodes directly. This fully integrated approach advances the performance of bidirectional informed RRT* planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent                # Parent Node or None\n        self.cost = cost                    # Cost from root\n        self.children = []                  # List[Node]\n        self.valid = True                   # Validity flag for collision/caching\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n            a1 = tuple((goal[d] - start[d]) / c_min for d in range(dim))\n\n            a1_np = np.array(a1)\n            id_mat = np.eye(dim)\n            v = a1_np - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + np.array(center)\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not is_in_obstacle(pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            # Aggressive pruning of nodes unlikely to improve\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n            if connected:\n                extracted_path = best_path\n                # Continue search to refine better paths until max_iter\n                # To speed up, optionally break here:\n                # break\n\n        # If found path and smoothing is still beneficial, run final smoothing:\n        if success_state and best_path:\n            best_path = shortcut_path(best_path)\n            extracted_path = best_path\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 985.9953,
    "time_improvement": -3322.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.3649386405944823,
            "num_nodes_avg": 299.9,
            "path_length_avg": 164.2941080382762,
            "smoothness_avg": 0.04548271716313993,
            "success_improvement": 0.0,
            "time_improvement": -5321.555659094438,
            "length_improvement": 9.947795977479306,
            "smoothness_improvement": 611.9032909042851,
            "objective_score": -1591.4176220783143
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.4977046728134156,
            "num_nodes_avg": 1135.6,
            "path_length_avg": 235.61449302686083,
            "smoothness_avg": 0.09978807855626384,
            "success_improvement": 0.0,
            "time_improvement": -807.5446145755756,
            "length_improvement": 21.345100440478475,
            "smoothness_improvement": 2467.619135700466,
            "objective_score": -225.65626860607463
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.015557789802551,
            "num_nodes_avg": 1372.1,
            "path_length_avg": 121.75485343177525,
            "smoothness_avg": 0.11182958405648077,
            "success_improvement": 0.0,
            "time_improvement": -3837.838569275228,
            "length_improvement": 19.136223693704306,
            "smoothness_improvement": 1322.4640547971728,
            "objective_score": -1140.9120057698417
        }
    ],
    "smoothness_improvement": 1467.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a bidirectional Anytime RRT* planner with adaptive sampling focused dynamically on unexplored regions, combining a adaptive Gaussian mixture model to bias sampling towards promising regions near the current best path and unexplored areas. It integrates a lazy evaluation strategy for collision checking with caching, incremental neighbor radius shrinking for efficient rewiring, and bidirectional tree growth balancing exploration and exploitation. The path is improved iteratively via shortcut smoothing and partial path rewiring based on cost heuristics. Edge and node validity are maintained rigorously, avoiding obstacles and boundary violations. This approach accelerates convergence to high-quality, smooth paths, improves success rates, and reduces planning time in both 2D and 3D environments.",
    "planning_mechanism": "The planner maintains two trees growing from start and goal concurrently, sampling adaptively between known promising regions (using Gaussian mixture model around the current best path nodes) and random exploration. Each iteration extends the smaller tree toward a sampled point, choosing parents among neighbors with an adaptively shrinking radius to ensure local optimality. Lazy collision checking with caching avoids redundant computations. Upon successfully connecting the two trees, the planner extracts the path, followed by iterative path smoothing and partial rewiring to improve path cost and smoothness. The sampling distribution shifts progressively towards the current best path nodes and poorly explored regions, balancing speed and robustness. Periodic pruning removes nodes unlikely to contribute to better paths, maintaining computational efficiency.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position               # Tuple[float,...] (2D or 3D)\n        self.parent = parent                   # Node or None\n        self.cost = cost                      # Cost from root\n        self.children: List['Node'] = []\n        self.valid = True                     # For pruning or collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Adaptive neighbor radius bounds\n        self.min_neighbor_radius = 4.0\n        self.max_neighbor_radius = 25.0\n        # Sampling parameters\n        self.goal_sample_rate = 0.12\n        self.smoothed_trials = 120\n        self.collision_resolution = 1.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.lazy_collision_cache = {}\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                   # Tuple[int,...]\n        start_pos = map.start               # Tuple[float,...]\n        goal_pos = map.goal                 # Tuple[float,...]\n        obstacles = map.obstacles           # List of obstacle boxes\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        # Distance metric\n        def dist(a: Tuple[float,...], b: Tuple[float,...]) -> float:\n            return math.dist(a, b)\n\n        # Clamp a point inside bounds\n        def clamp_pos(p: Tuple[float,...]) -> Tuple[float,...]:\n            return tuple(max(0.0, min(p[d], bounds[d])) for d in range(dim))\n\n        # Steer from from_p towards to_p with step size limit\n        def steer(from_p: Tuple[float,...], to_p: Tuple[float,...]) -> Tuple[float,...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return clamp_pos(new_p)\n\n        # Node validity: no obstacle, in bounds\n        def valid_node(pos: Tuple[float,...]) -> bool:\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        # Edge validity: no collision between from_pos and to_pos\n        def valid_edge(from_pos: Tuple[float,...], to_pos: Tuple[float,...]) -> bool:\n            key = (from_pos, to_pos) if from_pos < to_pos else (to_pos, from_pos)\n            if key in self.lazy_collision_cache:\n                return not self.lazy_collision_cache[key]\n            if not (valid_node(from_pos) and valid_node(to_pos)):\n                self.lazy_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, self.collision_resolution)\n            self.lazy_collision_cache[key] = collision\n            return not collision\n\n        # KDTree helper for brute force nearest and radius search with caching\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p,_ in points_nodes]\n                self.nodes = [n for _,n in points_nodes]\n                self.dim = dim\n            def nearest(self, pt: Tuple[float,...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(p, pt)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n            def radius_search(self, pt: Tuple[float,...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sd += delta*delta\n                        if sd > r2:\n                            break\n                    if sd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Adaptive neighbor radius for rewiring: shrinks with iteration and node count\n        def neighbor_radius(iteration: int, n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Sampling:\n        # Mixture of Gaussians around nodes in best path and uniform exploration, adaptively shifting sampling towards the best path and poorly explored areas\n        def sample_configuration():\n            # Goal bias\n            if best_path_cost == float('inf') or random.random() < self.goal_sample_rate:\n                # uniform sampling until valid\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if valid_node(p):\n                        return p\n                # fallback uniform without validation\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Mixture components weights: 70% Gaussian around best path nodes, 30% uniform random sampling\n            if best_path_nodes and random.random() < 0.7:\n                # Pick a node from best path at random\n                base = best_path_nodes[random.randint(0, len(best_path_nodes)-1)]\n                # Gaussian noise with std proportional to step_size, clipped inside bounds and obstacles checked\n                std_dev = self.step_size * 0.5\n                for _ in range(30):\n                    sample = tuple(random.gauss(base[d], std_dev) for d in range(dim))\n                    if valid_node(sample):\n                        return clamp_pos(sample)\n            # Else uniform random valid sample near visiting unexplored regions\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if valid_node(p):\n                    return p\n            # Fallback uniform without validation\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Shortcut smoothing of paths: tries to shortcut between random pairs repeatedly to smooth and shorten paths\n        def shortcut_smooth(path: List[Tuple[float,...]], trials: int = None) -> List[Tuple[float,...]]:\n            if not path or len(path) < 3:\n                return path[:]\n            trials = trials if trials is not None else self.smoothed_trials\n            p = path[:]\n            for _ in range(trials):\n                if len(p) < 3: break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if valid_edge(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        # Prune nodes whose cost + heuristic exceeds best path cost\n        def prune_nodes():\n            nonlocal nodes, tree_start, tree_goal, edges\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_path_cost - 1e-9:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent and node in node.parent.children:\n                    node.parent.children.remove(node)\n                if node in tree_start:\n                    tree_start.remove(node)\n                if node in tree_goal:\n                    tree_goal.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                # Remove associated edges\n                edges = [e for e in edges if e[0] != node and e[1] != node]\n                removed += 1\n            return removed\n\n        # Rewire function: try to improve neighbors by connecting via new_node if cheaper and collision free\n        def rewire(tree: List[Node], kdtree: KDTree, new_node: Node, iteration: int):\n            r = neighbor_radius(iteration, len(nodes))\n            neighbors = kdtree.radius_search(new_node.position, r)\n            for nbr in neighbors:\n                if nbr is new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                if new_cost + 1e-12 < nbr.cost and valid_edge(new_node.position, nbr.position):\n                    if nbr.parent and nbr in nbr.parent.children:\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node, new_cost)\n                        edges.append((new_node, nbr))\n\n        # Initialize trees\n        root_start = Node(start_pos, parent=None, cost=0.0)\n        root_goal = Node(goal_pos, parent=None, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node,Node]] = []\n\n        best_path: List[Tuple[float,...]] = []\n        best_path_cost = float('inf')\n        best_path_nodes: List[Tuple[float,...]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float,...]] = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_configuration()\n\n            # Alternate growing the smaller tree to keep balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, root_a, tree_b, root_b = tree_start, root_start, tree_goal, root_goal\n            else:\n                tree_a, root_a, tree_b, root_b = tree_goal, root_goal, tree_start, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not valid_node(new_pos) or not valid_edge(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Choose best parent node among neighbors for minimum cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nbr in near_nodes:\n                c_cand = nbr.cost + dist(nbr.position, new_pos)\n                if c_cand + 1e-12 < min_cost and valid_edge(nbr.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper through new_node\n            rewire(tree_a, kdtree_a, new_node, iteration)\n\n            # Attempt to connect opposite tree incrementally towards new_node from nearest node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = int(dist(nearest_b.position, new_node.position)/self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not valid_node(next_pos_b) or not valid_edge(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors in tree_b\n                rewire(tree_b, kdtree_b, new_node_b, iteration)\n\n                # Check if can connect to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and valid_edge(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Iterative shortcut smoothing\n                    merged_path = shortcut_smooth(merged_path, trials=self.smoothed_trials)\n\n                    if final_cost + 1e-12 < best_path_cost:\n                        best_path_cost = final_cost\n                        best_path = merged_path\n                        best_path_nodes = merged_path[:]\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                # Periodically prune nodes far from optimal path\n                prune_nodes()\n                self.lazy_collision_cache.clear()\n                # Early stopping once first valid path is found and smoothed\n                break\n\n            # Periodic pruning to maintain search efficiency and remove useless nodes\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and best_path_cost < float('inf'):\n                prune_nodes()\n                self.lazy_collision_cache.clear()\n\n        # If no connection made, but best_path found, fallback to it\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        if is_3d:\n            pz = pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= (x + w) and y <= py <= (y + h) and z <= pz <= (z + d):\n                    return True\n        else:\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= (x + w) and y <= py <= (y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.01425,
    "time_improvement": 26.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023627471923828126,
            "num_nodes_avg": 20.8,
            "path_length_avg": 155.78558307558959,
            "smoothness_avg": 0.03836563083815027,
            "success_improvement": 0.0,
            "time_improvement": 6.151346068615967,
            "length_improvement": 14.611453335733792,
            "smoothness_improvement": 500.50543491787624,
            "objective_score": 7.27022166232093
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04648892879486084,
            "num_nodes_avg": 183.6,
            "path_length_avg": 236.128455137221,
            "smoothness_avg": 0.08544677790240304,
            "success_improvement": 0.0,
            "time_improvement": 71.82970866618943,
            "length_improvement": 21.17352509446115,
            "smoothness_improvement": 2098.6071402552925,
            "objective_score": 36.276653320025524
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05181684494018555,
            "num_nodes_avg": 151.3,
            "path_length_avg": 122.85256061329699,
            "smoothness_avg": 0.12083640305292445,
            "success_improvement": 0.0,
            "time_improvement": -1.2356835293745085,
            "length_improvement": 18.407178850936475,
            "smoothness_improvement": 1437.0301276177127,
            "objective_score": 10.495881349463506
        }
    ],
    "smoothness_improvement": 1345.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner merges the strengths of bidirectional anytime informed RRT* and refined bidirectional informed RRT*, employing adaptive ellipsoidal and Gaussian sampling within the informed subset, dynamic neighbor radius adjustment, KD-tree accelerated neighbor queries, lazy collision checking with caching, incremental multi-step connection attempts between trees, iterative rewiring, and aggressive pruning of non-promising nodes. Iterative shortcut smoothing is applied to the best found path for improved smoothness and path quality. This combination enhances planning efficiency, robustness, path smoothness, and shortens solution paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal points alternately extending the smaller tree using samples biased within an adaptive ellipsoid based on the current best path cost and Gaussian perturbations around it. It uses KD-tree structures for efficient nearest neighbor and radius searches to facilitate rewiring and local path optimization. Edges and nodes undergo lazy collision checking with caching to reduce redundant computations. Multi-step incremental extensions connect opposite trees whenever possible. Periodic pruning removes nodes unlikely to yield better solutions, maintaining a manageable search space. Upon connection, aggressive shortcut smoothing refines the resulting path before returning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For pruning, collision flag etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        c_min = dist(start_pos, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.random.uniform(0, 1) ** (1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Multi-step incremental connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing after each solution\n                best_path = shortcut_path(best_path)\n                # (Optionally can continue iterations for anytime improvement)\n                break\n\n            # Periodic pruning for efficiency, when solution exists and node count high\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                removed_s = prune_nodes(tree_start, c_best, root_start, root_goal)\n                removed_g = prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.64423,
    "time_improvement": 45.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013150334358215332,
            "num_nodes_avg": 55.8,
            "path_length_avg": 157.12065162822006,
            "smoothness_avg": 0.045336248226696935,
            "success_improvement": 0.0,
            "time_improvement": 47.76668522790549,
            "length_improvement": 13.87968110652201,
            "smoothness_improvement": 609.610733986566,
            "objective_score": 20.15399545960888
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05694284439086914,
            "num_nodes_avg": 224.6,
            "path_length_avg": 234.98989434230003,
            "smoothness_avg": 0.09345096239305244,
            "success_improvement": 0.0,
            "time_improvement": 65.49508544400035,
            "length_improvement": 21.553609459461182,
            "smoothness_improvement": 2304.56057238076,
            "objective_score": 35.482050386996136
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.039519309997558594,
            "num_nodes_avg": 161.9,
            "path_length_avg": 130.03894931800212,
            "smoothness_avg": 0.14516899865374094,
            "success_improvement": 0.0,
            "time_improvement": 22.790274768169596,
            "length_improvement": 13.634321652328016,
            "smoothness_improvement": 1746.538947614718,
            "objective_score": 18.29664149899007
        }
    ],
    "smoothness_improvement": 1554.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This improved planner combines the strengths of bidirectional incremental rewiring with adaptive informed sampling inside a shrinking informed ellipsoid, balanced tree growth by always extending the smaller tree, and extensive caching of collision checks. It uses dynamic neighbor radius rewiring to optimize path cost continually, aggressive pruning of non-improving and dead-end nodes to maintain a compact search tree, and iterative shortcut smoothing to yield high-quality, smooth, and efficient paths. The algorithm optimizes planning efficiency, path quality, robustness, and success rate while reducing computational overhead and producing shorter paths in complex 2D/3D environments.",
    "planning_mechanism": "The planner maintains two trees starting from start and goal, alternately extending the smaller tree by sampling adaptively within an informed ellipsoid biased towards the best-known path cost. New nodes are connected with step-size control and dynamically computed neighbor radii for rewiring to incrementally improve path costs. Node and edge collision checks are heavily cached to reduce redundant computations. Periodic pruning of dead-end and non-improving nodes keeps the search space minimal. Upon connection, iterative shortcut smoothing refines the path for smoothness and shorter length, resulting in an efficient, robust bidirectional informed RRT* style planner.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1,\n                 min_neighbor_radius: float = 4.0,\n                 max_neighbor_radius: float = 25.0,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 150,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                       # 2D or 3D bounds\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Collision caches\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def in_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _is_in_obstacle_cached(pos):\n            if pos in node_collision_cache:\n                return node_collision_cache[pos]\n            res = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[pos] = res\n            return res\n\n        def _is_edge_in_obstacle_cached(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            res = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = res\n            return res\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not _is_in_obstacle_cached(pos)\n\n        def can_connect(p1, p2):\n            if _is_in_obstacle_cached(p2):\n                return False\n            if _is_edge_in_obstacle_cached(p1, p2):\n                return False\n            return True\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds\n            new_p_clamped = tuple(max(0.0, min(bounds[d_], new_p[d_])) for d_ in range(dim))\n            return new_p_clamped\n\n        # Adaptive informed ellipsoid sampling around best cost\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # fallback uniform sampling with retries for collision-free samples\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not _is_in_obstacle_cached(p):\n                        return p\n                # final fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) * 0.5 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not _is_in_obstacle_cached(p):\n                        return p\n\n            # fallback uniform again\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not _is_in_obstacle_cached(p):\n                    return p\n            return p\n\n        # KDTree-like linear searches\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                # Never prune roots\n                if node is root_start or node is root_goal:\n                    continue\n                # Prune dead-end nodes without children\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                # Prune nodes with cost + heuristic no better than best_cost\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes.extend([root_start, root_goal])\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        for iteration in range(self.max_iter):\n            # Sample point with goal bias or informed ellipsoid sampling\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always expand the smaller tree to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n\n            # Build KDTree and find nearest node in tree_a\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Pick best parent to minimize cost\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for cost improvement\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Try to connect other tree to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                r_b = neighbor_radius(iteration, len(nodes))\n                near_b = kdtree_b.radius_search(next_pos_b, r_b)\n\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Merge paths\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to reduce tree size and improve efficiency\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n                node_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        pz = pos[2] if is_3d else None\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -25.21607,
    "time_improvement": 50.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017306184768676756,
            "num_nodes_avg": 80.1,
            "path_length_avg": 165.17399023395006,
            "smoothness_avg": 0.03426091513879722,
            "success_improvement": 0.0,
            "time_improvement": 31.259588395058923,
            "length_improvement": 9.465518603404837,
            "smoothness_improvement": 436.257720690194,
            "objective_score": 13.452268842649614
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05456652641296387,
            "num_nodes_avg": 258.5,
            "path_length_avg": 239.17056991212976,
            "smoothness_avg": 0.08885464179798098,
            "success_improvement": 0.0,
            "time_improvement": 66.93503193179217,
            "length_improvement": 20.157979620177844,
            "smoothness_improvement": 2186.293932873662,
            "objective_score": 35.043575167941526
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.024218153953552247,
            "num_nodes_avg": 151.2,
            "path_length_avg": 124.81053372699114,
            "smoothness_avg": 0.13247979829347062,
            "success_improvement": 0.0,
            "time_improvement": 52.68447216078791,
            "length_improvement": 17.106786337481363,
            "smoothness_improvement": 1585.1332556514217,
            "objective_score": 27.152365193989755
        }
    ],
    "smoothness_improvement": 1403.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a hybrid bidirectional informed RRT* variant combining adaptive informed ellipsoid sampling, incremental rewiring with dynamic neighbor radius, KD-tree accelerated nearest and radius searches, collision-check caching, aggressive node pruning, and iterative shortcut smoothing to enhance path quality, convergence speed, and computational efficiency in 2D/3D obstacle environments.",
    "planning_mechanism": "The algorithm grows two trees from start and goal alternately, sampling adaptively biased points inside a shrinking ellipsoid around the best solution. It extends with step-size control, reconnects neighbors within a dynamically changing radius for cost improvement, caches collision checks to avoid redundant calculations, prunes nodes unlikely to improve the best path periodically, and applies shortcut smoothing on the final path for further length and smoothness enhancement.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True                 # For collision validity if needed\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n        # Propagate cost update down children\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            import math\n            self.cost = self.parent.cost + math.dist(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 4.5,\n                 min_neighbor_radius: float = 6.0,\n                 max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.12,\n                 prune_interval: int = 150,\n                 prune_threshold: int = 250,\n                 smoothing_iterations: int = 100,\n                 collision_check_resolution: float = 0.75):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp to bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def within_ellipsoid_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sample with retries for collision-free\n                for _ in range(20):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(sample):\n                        return sample\n                # Fallback random\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            eye = np.eye(dim)\n            v = a1 - np.array([1.0] + [0.0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rotation = eye - 2 * np.outer(v, v)\n            else:\n                rotation = eye\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(200):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rotation @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            # Fallback uniform sampling if ellipsoid fails\n            for _ in range(20):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(sample):\n                    return sample\n            return sample\n\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_connect(p1, p2):\n            if is_in_obstacle(p2):\n                return False\n            if is_edge_in_obstacle(p1, p2):\n                return False\n            return True\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        class KDTreeSimple:\n            \"\"\"Simple linear KDTree substitute for moderate node counts.\"\"\"\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic - 1e-12 >= best_cost:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            # Sampling with goal bias and informed ellipsoid\n            if random.random() < self.goal_sample_rate:\n                q_rand = goal_pos\n            else:\n                q_rand = within_ellipsoid_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree growth, smaller first (for balanced expansion)\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTreeSimple([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(iteration, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                c_candidate = node.cost + dist(node.position, new_pos)\n                if c_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect opposite tree\n            kdtree_b = KDTreeSimple([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if iteration > 0 and iteration % self.prune_interval == 0 \\\n                    and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 24.85078,
    "time_improvement": -6.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.024851322174072266,
            "num_nodes_avg": 90.0,
            "path_length_avg": 157.52875046637044,
            "smoothness_avg": 0.03696276725421934,
            "success_improvement": -9.999999999999998,
            "time_improvement": 1.2901954990889788,
            "length_improvement": 13.655995666591872,
            "smoothness_improvement": 478.547573462326,
            "objective_score": -44.48900434964329
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07214851379394531,
            "num_nodes_avg": 304.0,
            "path_length_avg": 235.1675158752542,
            "smoothness_avg": 0.0803158156657887,
            "success_improvement": 0.0,
            "time_improvement": 56.281103790424005,
            "length_improvement": 21.49431427920873,
            "smoothness_improvement": 1966.5837862244875,
            "objective_score": 31.016112924091388
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.090191650390625,
            "num_nodes_avg": 294.5,
            "path_length_avg": 124.3565898535013,
            "smoothness_avg": 0.13839240497543173,
            "success_improvement": -9.999999999999998,
            "time_improvement": -76.20936563152708,
            "length_improvement": 17.40827424376893,
            "smoothness_improvement": 1660.3411762227393,
            "objective_score": -61.07944895959063
        }
    ],
    "smoothness_improvement": 1368.0,
    "success_rate": 0.9333333333333332
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional informed RRT* algorithm with adaptive ellipsoidal sampling and dynamic rewiring. It balances exploration and exploitation by alternating growth between start and goal trees, using KD-tree based nearest and radius searches, collision caching, and pruning of non-promising nodes. The search is focused within an informed ellipsoid that shrinks as better solutions are found, enhancing efficiency. After a successful connection, iterative shortcut smoothing refines the path to improve smoothness and reduce length, aiming for efficient, robust, and high-quality path planning in both 2D and 3D spaces.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal, sampling points within a dynamically shrinking informed ellipsoid guided by the current best cost. Each iteration extends the smaller tree by steering towards sampled points, connecting and rewiring neighbors to locally optimize costs. Connectivity between trees is attempted incrementally, verifying collision for nodes and edges. Periodic pruning removes nodes unlikely to improve the solution. Upon connecting trees, the resulting path undergoes iterative shortcut smoothing to improve quality. The procedure terminates upon success or reaching iteration limits, returning the best found path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For pruning or collision checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = 5.0\n        self.max_neighbor_radius = 30.0\n        self.prune_interval = 150\n        self.prune_threshold = 250\n        self.smoothing_iterations = 150\n        self.collision_check_resolution = 1.0\n        self.goal_sample_rate = 0.1\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            distance = dist(from_p, to_p)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n                self.dim = dim\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    squared_dist = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        squared_dist += delta * delta\n                        if squared_dist > r2:\n                            break\n                    if squared_dist <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not is_in_obstacle(pos))\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-15 or norm_x > 1:\n                    continue\n                radius_factor = np.random.uniform(0, 1) ** (1 / dim)\n                x_scaled = (x / norm_x) * radius_factor\n                sample = rot @ (x_scaled * radii) + center\n                p = tuple(float(coord) for coord in sample)\n                if in_bounds(p) and not is_in_obstacle(p):\n                    return p\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_nodes(nodes_list: List[Node], best_cost: float, root_start: Node, root_goal: Node) -> int:\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(rm_node)\n                except ValueError:\n                    pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growth of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius = neighbor_radius(len(nodes), iteration)\n            near_nodes = kdtree_a.radius_search(new_pos, radius)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better cost\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, node.position)\n                if cost_via_new + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, node))\n\n            # Incremental connection attempt from opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if cost_via_new_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.add_child(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    smoothed = shortcut_path(merged_path)\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = smoothed\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        if success_state and not best_path:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -25.84208,
    "time_improvement": 47.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01729872226715088,
            "num_nodes_avg": 67.0,
            "path_length_avg": 158.21086206071817,
            "smoothness_avg": 0.04896139505429347,
            "success_improvement": 0.0,
            "time_improvement": 31.289229557068225,
            "length_improvement": 13.282119492979986,
            "smoothness_improvement": 666.3521539707857,
            "objective_score": 15.374953535570395
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05201911926269531,
            "num_nodes_avg": 217.2,
            "path_length_avg": 233.41767108779877,
            "smoothness_avg": 0.10931443700084689,
            "success_improvement": 0.0,
            "time_improvement": 68.47865109939127,
            "length_improvement": 22.078462835750916,
            "smoothness_improvement": 2712.7392000382292,
            "objective_score": 38.52298389715871
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029991555213928222,
            "num_nodes_avg": 139.6,
            "path_length_avg": 121.25885586056822,
            "smoothness_avg": 0.12285795514957085,
            "success_improvement": 0.0,
            "time_improvement": 41.40485404513077,
            "length_improvement": 19.465641663633736,
            "smoothness_improvement": 1462.7441210716006,
            "objective_score": 23.62830515162398
        }
    ],
    "smoothness_improvement": 1614.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This enhanced bidirectional informed RRT* planner integrates adaptive ellipsoidal sampling focused on the current best path to minimize unnecessary exploration, employs a KD-tree for efficient nearest neighbor and radius queries, caches collision checks to reduce redundant computations, incrementally rewires for path cost improvement, prunes nodes unlikely to improve the solution periodically, and applies shortcut-based path smoothing to produce shorter and smoother paths quickly. The planner ensures valid node states and collision-free edges throughout, balances bidirectional growth with dynamic radius adjustment, and carefully manages adding/removing nodes and edges to maintain robustness and efficiency in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows start and goal trees alternately, samples within an adaptive ellipsoid around the best known path to bias towards promising regions, uses KD-tree for fast neighbor lookups, adds new nodes after collision tests, rewires neighbors to minimize path cost, attempts to connect trees incrementally checking collisions, prunes nodes that cannot yield better solutions to reduce search space, and smooths the final path by shortcutting segments while preserving feasibility. This combination achieves faster convergence to shorter, smooth, and feasible paths with efficient computation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start root\n        self.children = []\n        self.valid = True               # Collision valid flag\n    \n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n    \n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n    \n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iters: int = 100, collision_res: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n        self.collision_res = collision_res\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n        \n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # clamp inside bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(it, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (it / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_res)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n        \n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform random sampling fallback\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            \n            center = np.array([(start[d]+goal[d])/2 for d in range(dim)])\n            a1 = np.array([(goal[d]-start[d])/c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1.] + [0.]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2*np.outer(v,v)\n            else:\n                rot = id_mat\n            \n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(x_ball) <= 1:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            \n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n        \n        def prune_nodes(best_cost_val):\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost_val:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n            return len(to_remove)\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growing smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_step_cnt = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n            for _ in range(max_step_cnt):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Compose path from start to goal depending on which tree is which\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Prune unpromising nodes to reduce search space periodically\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.86188,
    "time_improvement": 56.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011800003051757813,
            "num_nodes_avg": 54.4,
            "path_length_avg": 153.69296191885746,
            "smoothness_avg": 0.0361555731901661,
            "success_improvement": 0.0,
            "time_improvement": 53.13022034842096,
            "length_improvement": 15.758452151442883,
            "smoothness_improvement": 465.9132335099274,
            "objective_score": 21.4203227023645
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04355149269104004,
            "num_nodes_avg": 199.2,
            "path_length_avg": 236.42757570091013,
            "smoothness_avg": 0.09479691689277514,
            "success_improvement": 0.0,
            "time_improvement": 73.60966860426899,
            "length_improvement": 21.07367004059368,
            "smoothness_improvement": 2339.192951110466,
            "objective_score": 37.99359934495176
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03035130500793457,
            "num_nodes_avg": 153.4,
            "path_length_avg": 127.34649230063846,
            "smoothness_avg": 0.10026194584538484,
            "success_improvement": 0.0,
            "time_improvement": 40.70200314137881,
            "length_improvement": 15.422523402235353,
            "smoothness_improvement": 1175.3245505862683,
            "objective_score": 21.171728375792057
        }
    ],
    "smoothness_improvement": 1327.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "The improved planner implements an optimized bidirectional RRT* algorithm with adaptive goal biasing and dynamic radius rewiring to accelerate convergence. It incorporates a KD-tree for efficient nearest neighbor searches, limiting costly linear scans, and integrates an early stopping criterion when the optimal path cost reduces below a threshold. Collision and edge checks are combined with fast pruning of suboptimal rewires to reduce unnecessary computations. These improvements enhance planning efficiency, robustness, and result in shorter, smoother paths with reduced search time.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal positions. Each iteration samples free points with adaptive goal bias to encourage goal-oriented exploration. Nodes extend toward sampled points within a fixed step, verified by collision checks. Using a dynamically decreasing rewiring radius computed from the tree size, nearby nodes are rewired to improve path quality locally. A KD-tree accelerates nearest and near-node queries. Upon connection of the two trees, the algorithm merges the two branches to form the final optimal path and stops early to avoid excess iterations, promoting fast convergence and better path smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision or validity state\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 35.0,\n                 radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Utility functions\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def is_within_bounds(p):\n            for d, val in enumerate(p):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Enhanced adaptive goal bias: 80% goal, 20% start\n                return goal_position if random.random() < 0.8 else start_position\n            else:\n                for _ in range(10):\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if (is_within_bounds(p) and\n                        not self._is_in_obstacle(p, obstacles, is_3d)):\n                        return p\n                # Fallback to goal if no free sample found quickly\n                return goal_position\n\n        # Use KD-tree structure for fast nearest neighbor & radius queries\n        # Local implementation of KD-tree for nodes positions:\n        class KDTree:\n            def __init__(self, points, leafsize=10):\n                from bisect import bisect_left\n                self.leafsize = leafsize\n                self.k = len(points[0]) if points else 0\n                self.points = points\n                self.idx_map = list(range(len(points)))\n                self.tree = self._build(list(range(len(points))), depth=0)\n\n            def _build(self, idxs, depth):\n                if len(idxs) <= self.leafsize:\n                    return idxs\n\n                axis = depth % self.k\n                idxs.sort(key=lambda i: self.points[i][axis])\n                median = len(idxs) // 2\n                return {\n                    'axis': axis,\n                    'median_val': self.points[idxs[median]][axis],\n                    'left': self._build(idxs[:median], depth + 1),\n                    'right': self._build(idxs[median:], depth + 1)\n                }\n\n            def _nn_search(self, query, node, depth, best):\n                if not node:\n                    return best\n                if isinstance(node, list):  # leaf\n                    for i in node:\n                        d = distance(self.points[i], query)\n                        if d < best[1]:\n                            best = (i, d)\n                    return best\n\n                axis = node['axis']\n                median_val = node['median_val']\n\n                next_branch = None\n                opposite_branch = None\n\n                if query[axis] <= median_val:\n                    next_branch = node['left']\n                    opposite_branch = node['right']\n                else:\n                    next_branch = node['right']\n                    opposite_branch = node['left']\n\n                best = self._nn_search(query, next_branch, depth + 1, best)\n                if abs(query[axis] - median_val) < best[1]:\n                    best = self._nn_search(query, opposite_branch, depth + 1, best)\n                return best\n\n            def nearest(self, query):\n                if not self.points:\n                    return None, float('inf')\n                idx, dist = self._nn_search(query, self.tree, 0, (None, float('inf')))\n                return idx, dist\n\n            def _radius_search(self, query, node, depth, radius, results):\n                if not node:\n                    return\n                if isinstance(node, list):  # leaf\n                    for i in node:\n                        if distance(self.points[i], query) <= radius:\n                            results.append(i)\n                    return\n\n                axis = node['axis']\n                median_val = node['median_val']\n\n                if query[axis] - radius <= median_val:\n                    self._radius_search(query, node['left'], depth + 1, radius, results)\n                if query[axis] + radius >= median_val:\n                    self._radius_search(query, node['right'], depth + 1, radius, results)\n\n            def radius_search(self, query, radius):\n                results = []\n                if not self.points:\n                    return results\n                self._radius_search(query, self.tree, 0, radius, results)\n                return results\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Dynamic radius shrinking as tree grows, ensuring minimum radius\n        def radius_by_nodes(n_nodes):\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        # Efficient insertion of new_node with rewiring for incremental optimization\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n\n            idx_near, _ = kd_tree.nearest(point)\n            nearest_node = tree[idx_near]\n\n            new_pos = steer(nearest_node.position, point)\n            if not is_within_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            idx_neighbors = kd_tree.radius_search(new_pos, radius)\n            near_nodes_list = [tree[i] for i in idx_neighbors]\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes_list:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new node for local cost improvement\n            for neighbor in near_nodes_list:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Connect a node from one tree to the other with incremental steering steps\n        def try_connect(tree, kd_tree, node):\n            if not tree:\n                return None\n\n            idx_near, _ = kd_tree.nearest(node.position)\n            nearest_node = tree[idx_near]\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_within_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Main bidirectional RRT* loop with KDTree accelerated nearest searches\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always grow smaller tree to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kd_start = KDTree([node.position for node in tree_start])\n            kd_goal = KDTree([node.position for node in tree_goal])\n\n            new_node_start = try_extend(tree_start, kd_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kd_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n            # Early stopping if path cost very low (heuristic)\n            if success_state:\n                best_cost = min(n.cost for n in tree_start + tree_goal)\n                if best_cost <= distance(start_position, goal_position) * 1.05:\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.4473,
    "time_improvement": 34.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014632773399353028,
            "num_nodes_avg": 80.6,
            "path_length_avg": 170.14303858031525,
            "smoothness_avg": 0.01717114245506675,
            "success_improvement": 0.0,
            "time_improvement": 41.878416309646916,
            "length_improvement": 6.741904465152252,
            "smoothness_improvement": 168.76566715444665,
            "objective_score": 14.755734121696758
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.09227571487426758,
            "num_nodes_avg": 248.6,
            "path_length_avg": 271.79478053196647,
            "smoothness_avg": 0.008389545132582861,
            "success_improvement": 0.0,
            "time_improvement": 44.08488561837734,
            "length_improvement": 9.267079079439917,
            "smoothness_improvement": 115.86903900646644,
            "objective_score": 15.658226696433516
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04339034557342529,
            "num_nodes_avg": 152.3,
            "path_length_avg": 138.45952732456806,
            "smoothness_avg": 0.01967577407983067,
            "success_improvement": 0.0,
            "time_improvement": 15.22734937312165,
            "length_improvement": 8.04177468520271,
            "smoothness_improvement": 150.27439398087498,
            "objective_score": 6.927931718881412
        }
    ],
    "smoothness_improvement": 145.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This enhanced planner integrates anytime informed bidirectional RRT* with adaptive lazy-collision checking and KD-tree accelerated neighbor searches to optimize path length and smoothness efficiently. It leverages informed ellipsoidal and adaptive sampling biased toward the best current path, incrementally extends the smaller tree, connects with multi-step attempts, rewires neighbors to reduce costs, and prunes nodes unlikely to improve solutions. The dynamic neighbor radius adapts during iterations to balance exploration and refinement. Shortcut smoothing iteratively improves the final path, producing reliable, shorter, and smoother paths with improved convergence and reduced search times in both 2D and 3D.",
    "planning_mechanism": "The planner grows two trees from start and goal, expanding the smaller tree per iteration with samples from an evolving informed ellipsoid or near the current best path. KD-tree radius searches find neighbors for selecting optimal parents and rewiring to minimize costs. Lazy collision checking with caching avoids repeated expensive collision tests. Incremental multi-step connections attempt to bridge the trees. Nodes and edges are pruned periodically to focus the search. After finding a connection, the path is extracted and shortcut-smoothed for better quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start root\n        self.children = []              # Children for rewiring/pruning\n        self.valid = True               # Node validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=120, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            const_factor = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(const_factor + 1) / const_factor)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        # Collision checks helpers\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        # KDTree helper (brute force)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        # Informed sampling inside evolving ellipsoid biased by current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1 / dim)  # uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling: near best known path with Gaussian noise, else informed_sample\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut smoothing: repeatedly attempt replacing path segments with direct edges\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        # Prunes nodes that cannot possibly improve the current best path\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                # If cost + heuristic exceeds or equals best_cost, remove\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                    removed += 1\n                except ValueError:\n                    pass\n            return removed\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Node and edge collision check before insertion\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Choose parent minimizing cost + collision check edges lazily\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors in tree_a for better costs if possible\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Extend tree_b towards new_node incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                # Rewire neighbors in tree_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if can connect directly to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    # Check for improvement of best cost\n                    total_cost = cost_connect\n                    if total_cost + 1e-12 < c_best:\n                        c_best = total_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -26.2438,
    "time_improvement": 50.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.020569372177124023,
            "num_nodes_avg": 61.9,
            "path_length_avg": 154.03020272765778,
            "smoothness_avg": 0.040166827685072855,
            "success_improvement": 0.0,
            "time_improvement": 18.298161679754234,
            "length_improvement": 15.573605120216843,
            "smoothness_improvement": 528.6980769337713,
            "objective_score": 11.247659912638495
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04323298931121826,
            "num_nodes_avg": 208.8,
            "path_length_avg": 231.89131765643864,
            "smoothness_avg": 0.0955741600289277,
            "success_improvement": 0.0,
            "time_improvement": 73.8026679534253,
            "length_improvement": 22.588003544786474,
            "smoothness_improvement": 2359.1919768292737,
            "objective_score": 38.45436097913125
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021471095085144044,
            "num_nodes_avg": 113.2,
            "path_length_avg": 123.0169277834726,
            "smoothness_avg": 0.13293073421380192,
            "success_improvement": 0.0,
            "time_improvement": 58.0514601076565,
            "length_improvement": 18.298014002829397,
            "smoothness_improvement": 1590.8691272734086,
            "objective_score": 29.029386469229877
        }
    ],
    "smoothness_improvement": 1493.0,
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an Efficient Bidirectional RRT* with Adaptive Sampling and Lazy Collision Checking. It integrates dynamic step size adaptation based on progress, a novel adaptive informed sampling that progressively contracts the sampling region around a corridor found by the current best solution, and lazy collision checking to defer expensive checks until necessary. The planner balances growth between start and goal trees by always expanding the smaller tree, employs incremental rewiring with radius tuning based on logarithmic scaling, aggressive node pruning to discard nodes unlikely to contribute better solutions, and applies post-processing shortcut smoothing iteratively for refined path quality and smoothness. This combination enhances convergence speed, path optimality, robustness against complex obstacles, and reduces computational overhead.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal positions and alternately grows the smaller tree towards adaptively sampled points within a contracting ellipsoidal region centered on the best path found so far. Nodes are steered with dynamically adjusted step sizes, and near neighbors within a logarithmic-radius are rewired incrementally for cost improvements. Lazy collision checking postpones edge validation until a connection attempt, reducing redundant computations. When the two trees connect, the solution path is extracted, aggressively pruned of unpromising nodes, and smoothed via randomized shortcutting. This mechanism iteratively focuses exploration on promising subspaces, balancing exploration and exploitation for efficient, high-quality path planning in both 2D and 3D environments.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter:int=5000, init_step_size:float=5.0,\n                 min_step_size:float=1.0, max_neighbor_radius:float=25.0,\n                 prune_interval:int=100, prune_threshold:int=200,\n                 smoothing_iterations:int=100, collision_check_resolution:float=0.5):\n        self.max_iter = max_iter\n        self.init_step_size = init_step_size\n        self.min_step_size = min_step_size\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a,b):\n            return math.dist(a,b)\n\n        def steer(from_p, to_p, step_sz):\n            d = dist(from_p, to_p)\n            if d <= step_sz:\n                new_p = to_p\n            else:\n                ratio = step_sz / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp inside bounds\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def heuristic(p1,p2):\n            return dist(p1,p2)\n\n        # Adaptive neighbor radius scaling: r(n) ~ gamma * (log(n)/n)^(1/dim)\n        def neighbor_radius(n_nodes):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            gamma_rrt_star = 40.0\n            r = gamma_rrt_star * (math.log(n_nodes) / n_nodes) ** (1/dim)\n            return min(r, self.max_neighbor_radius)\n\n        # Adaptive step size reducing as best cost improves\n        def adaptive_step_size(iteration, best_cost, c_min):\n            if best_cost == float('inf'):\n                return self.init_step_size\n            # Shrink step size as solution improves, but with minimum bound\n            factor = max(0.3, min(1.0, 2*c_min / best_cost))\n            adapt = self.init_step_size * factor\n            return max(self.min_step_size, adapt)\n\n        # Lazy collision cache: edge_key -> bool (True if collision)\n        edge_collision_cache = {}\n\n        def is_in_obstacle(pos):\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else None\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    if x <= px <= x+w and y <= py <= y+h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return True\n\n            distance = dist(p1, p2)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps+1):\n                interp = tuple(p1[d] + (p2[d]-p1[d])*(i/steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    edge_collision_cache[key] = True\n                    return True\n            edge_collision_cache[key] = False\n            return False\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def can_connect_nodes(p1,p2):\n            # Lazy checking: only check edge collision, assuming nodes are valid\n            if not can_add_node(p2):\n                return False\n            return not is_edge_in_obstacle(p1,p2)\n\n        # KDTree linear search for nearest and radius (sufficient here)\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p,n in zip(self.points, self.nodes):\n                    d_ = dist(pt,p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius*radius\n                results = []\n                for p,n in zip(self.points,self.nodes):\n                    sqd=0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta*delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Adaptive informed sampling inside ellipsoid contracting on best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0,bounds[d_]) for d_ in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0,bounds[d_]) for d_ in range(dim))\n\n            center = tuple((start[d_] + goal[d_]) / 2.0 for d_ in range(dim))\n            c_min_inv = 1.0 / c_min\n            a1 = tuple((goal[d_] - start[d_]) * c_min_inv for d_ in range(dim))\n\n            # Rotation using Householder to align x-axis to a1 vector\n            import numpy as np\n            a1_np = np.array(a1)\n            dim_eye = np.eye(dim)\n            v = a1_np - np.array([1.] + [0.]*(dim-1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = dim_eye - 2 * np.outer(v,v)\n            else:\n                rot = dim_eye\n\n            r1 = c_best / 2.0\n            try:\n                r_others = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            except:\n                r_others = 0.0\n            radii = np.array([r1] + [r_others]*(dim-1))\n\n            for _ in range(200):\n                sample_ball = np.random.uniform(-1,1,dim)\n                if np.linalg.norm(sample_ball) <= 1.0:\n                    sample_scaled = sample_ball * radii\n                    point = rot @ sample_scaled + np.array(center)\n                    p = tuple(float(c) for c in point)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # fallback uniform\n            for _ in range(20):\n                p = tuple(random.uniform(0,bounds[d_]) for d_ in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Shortcut smoothing by randomized edge shortcutting\n        def shortcut_path(path):\n            if len(path)<3:\n                return path[:]\n            p = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(p) < 3:\n                    break\n                i = random.randint(0,len(p)-3)\n                j = random.randint(i+2,len(p)-1)\n                if can_connect_nodes(p[i], p[j]):\n                    p = p[:i+1] + p[j:]\n            return p\n\n        def prune_nodes(best_cost):\n            removed = 0\n            nonlocal nodes, tree_start, tree_goal\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                h = heuristic(node.position, goal_pos)\n                if node.cost + h >= best_cost - 1e-9:\n                    to_remove.append(node)\n            for rmn in to_remove:\n                if rmn.parent:\n                    rmn.parent.remove_child(rmn)\n                if rmn in tree_start:\n                    tree_start.remove(rmn)\n                if rmn in tree_goal:\n                    tree_goal.remove(rmn)\n                try:\n                    nodes.remove(rmn)\n                except ValueError:\n                    pass\n                removed +=1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, parent=None, cost=0.0)\n        root_goal = Node(goal_pos, parent=None, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            step_sz = adaptive_step_size(iteration, c_best, c_min)\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always expand smaller tree for balance\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand, step_sz)\n\n            # Node validity checks\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect_nodes(nearest_a.position, new_pos):\n                continue\n\n            nodes_count = len(nodes)\n            r = neighbor_radius(nodes_count)\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            # Select best parent minimizing cost + lazy collision checking on edges\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes:\n                candi_cost = node.cost + dist(node.position, new_pos)\n                if candi_cost + 1e-12 < min_cost and can_connect_nodes(node.position, new_pos):\n                    min_cost = candi_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=None, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Incremental rewiring of neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect_nodes(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from other tree toward new_node\n            kdtree_b = KDTree([(n.position,n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n\n            dist_ab = dist(last_node_b.position, new_node.position)\n            max_steps = int(dist_ab / step_sz) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position, step_sz)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect_nodes(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=None, cost=cost_b)\n                last_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new_b + 1e-12 < neighbor_b.cost and can_connect_nodes(new_node_b.position, neighbor_b.position):\n                        if neighbor_b.parent:\n                            try:\n                                edges.remove((neighbor_b.parent, neighbor_b))\n                            except ValueError:\n                                pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees connected\n                if dist(new_node_b.position, new_node.position) <= step_sz and can_connect_nodes(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=None, cost=final_cost)\n                    new_node_b.add_child(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Assemble path from start to goal\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed_path = shortcut_path(merged_path)\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = smoothed_path\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic aggressive pruning of unpromising nodes\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                cnt_removed = prune_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not best_path:\n            best_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 3.37716,
    "time_improvement": 9.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.04170048236846924,
            "num_nodes_avg": 109.8,
            "path_length_avg": 167.36828562726927,
            "smoothness_avg": 0.03552723057739846,
            "success_improvement": -9.999999999999998,
            "time_improvement": -65.63490800822757,
            "length_improvement": 8.262790527490983,
            "smoothness_improvement": 456.0783071522912,
            "objective_score": -65.7575227612086
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05342180728912353,
            "num_nodes_avg": 231.0,
            "path_length_avg": 240.05498764678754,
            "smoothness_avg": 0.10114419062413275,
            "success_improvement": 0.0,
            "time_improvement": 67.62868248580388,
            "length_improvement": 19.86273552379606,
            "smoothness_improvement": 2502.512875974774,
            "objective_score": 36.77371623037425
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0377314567565918,
            "num_nodes_avg": 149.0,
            "path_length_avg": 124.61075769459396,
            "smoothness_avg": 0.1260929672517372,
            "success_improvement": 0.0,
            "time_improvement": 26.283242066900552,
            "length_improvement": 17.23946806588718,
            "smoothness_improvement": 1503.8932362274015,
            "objective_score": 18.85233241438461
        }
    ],
    "smoothness_improvement": 1487.0,
    "success_rate": 0.9666666666666667
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines adaptive bidirectional informed RRT* sampling with lazy collision checking inspired by bidirectional PRM*, dynamic neighbor radius adjustment, incremental multi-step tree connection attempts, aggressive pruning of nodes unlikely to improve the best path, and adaptive sampling biased around the current best trajectory. The algorithm balances exploration and exploitation in complex environments, leveraging collision caching and KD-tree accelerated searches to enhance planning efficiency, path quality, robustness, and convergence speed. Final paths are smoothed using iterative shortcutting for improved quality and smoothness.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, extending the smaller tree each iteration with informed and adaptive sampling strategies. Nodes are connected to cost-optimal parents within a radius that dynamically shrinks over iterations. Lazy collision checking with caching avoids redundant checks, while incremental multi-step connections attempt robust bridging between the two trees. Periodic pruning removes non-promising nodes to maintain efficiency. Upon successful tree connection, the path is extracted and shortcut-smoothed to produce a high-quality, short, and smooth trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []                # Children nodes (for rewiring/pruning)\n        self.valid = True                 # Validity flag for collision pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=150, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            return tuple(max(0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.92)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p,n in points_nodes]\n                self.nodes = [n for p,n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Adapted ellipsoidal sampling biased by current best cost with fallback uniform sampling\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(25):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                # fallback uniform\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(250):\n                sample = np.random.uniform(-1,1,dim)\n                norm_s = np.linalg.norm(sample)\n                if norm_s < 1e-12 or norm_s > 1:\n                    continue\n                sample /= norm_s\n                sample *= np.power(random.uniform(0,1), 1/dim)\n                p = tuple(float(coord) for coord in rot @ (sample * radii) + center)\n                if in_bounds(p) and not is_in_obstacle(p):\n                    return p\n\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            # Sample near best path with higher probability to focus exploration\n            if best_path and random.random() < 0.8:\n                for _ in range(50):\n                    base = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.4, dim)\n                    candidate = tuple(base[d] + noise[d] for d in range(dim))\n                    if in_bounds(candidate) and not is_in_obstacle(candidate):\n                        return candidate\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth_path = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p1, p2 = smooth_path[i], smooth_path[j]\n                if can_connect(p1, p2):\n                    smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            return smooth_path\n\n        def prune_nodes(t_nodes, best_cost, root_s, root_g):\n            removed = 0\n            heur = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in t_nodes:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heur(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    t_nodes.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Grow smaller tree for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for n in near_nodes_a:\n                candidate_cost = n.cost + dist(n.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(n.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost if possible\n            for n in near_nodes_a:\n                if n is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_via_new + 1e-12 < n.cost and can_connect(new_node.position, n.position):\n                    try:\n                        edges.remove((n.parent, n))\n                    except ValueError:\n                        pass\n                    n.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, n))\n\n            # Incremental multi-step connection attempt from opposite tree\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire neighbors in tree_b\n                for nbr in near_nodes_b:\n                    if nbr is last_node_b:\n                        continue\n                    cost_v_nb = new_node_b.cost + dist(new_node_b.position, nbr.position)\n                    if cost_v_nb + 1e-12 < nbr.cost and can_connect(new_node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node_b, cost_v_nb)\n                        edges.append((new_node_b, nbr))\n\n                # Check connection possibility to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    total_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=total_cost)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n                    if total_cost + 1e-12 < c_best:\n                        c_best = total_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of nodes unlikely to improve solution\n            if (iteration > 0 and iteration % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        if is_3d:\n            py, pz = pos[1], pos[2]\n            for obs in obstacles:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            return False\n        else:\n            py = pos[1]\n            for obs in obstacles:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n            return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -24.30825,
    "time_improvement": 46.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.018428635597229005,
            "num_nodes_avg": 72.7,
            "path_length_avg": 161.30685573518426,
            "smoothness_avg": 0.04332782970408787,
            "success_improvement": 0.0,
            "time_improvement": 26.801197768105723,
            "length_improvement": 11.58515630084591,
            "smoothness_improvement": 578.1746227571065,
            "objective_score": 13.248263704386432
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04436683654785156,
            "num_nodes_avg": 215.4,
            "path_length_avg": 238.3295650143303,
            "smoothness_avg": 0.09439478188461296,
            "success_improvement": 0.0,
            "time_improvement": 73.11560529545486,
            "length_improvement": 20.438731262047092,
            "smoothness_improvement": 2328.845727704314,
            "objective_score": 37.66665647956744
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03151414394378662,
            "num_nodes_avg": 143.3,
            "path_length_avg": 119.2363637646497,
            "smoothness_avg": 0.10721770411870217,
            "success_improvement": 0.0,
            "time_improvement": 38.430139722418375,
            "length_improvement": 20.808884613018495,
            "smoothness_improvement": 1263.8012824021955,
            "objective_score": 22.00982525134019
        }
    ],
    "smoothness_improvement": 1390.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an advanced bidirectional RRT* planner integrating adaptive informed sampling, incremental rewiring, dynamic neighbor radius adjustment, collision caching, and aggressive pruning. It alternates tree expansions biased within an ellipsoidal informed domain shaped by the current best path cost, employs KD-tree accelerated nearest neighbor queries, incrementally connects two trees, and applies multiple rounds of shortcut smoothing to generate short, smooth, and collision-free paths efficiently in both 2D and 3D environments. The planner focuses on reducing search space, pruning unpromising branches, and caching collision results to improve planning efficiency, success rate, robustness, and path quality.",
    "planning_mechanism": "The planner grows two bidirectional trees rooted at start and goal, extending the smaller tree each iteration with samples biased towards an evolving informed ellipsoid around the best path cost found so far. Using KD-trees for neighbor searches, it rewires locally within a dynamically shrinking radius. Incremental multi-step connections between trees allow for improved bridging chances. Collision checks are cached and rigorously applied to new nodes and edges to enforce validity. Periodic pruning discards nodes unlikely to yield better paths maximizing efficiency. Upon success, the final path is extracted and refined with multiple shortcut smoothing iterations to enhance path smoothness and reduce length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_radius: float = 5.0, max_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_iterations: int = 150, collision_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_resolution = collision_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within map bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def is_in_obstacle(p: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(p, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_dist = float('inf')\n                best_node = None\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = self.nodes[i]\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and (not is_in_obstacle(pos))\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Bias sampling towards goal with some probability to improve convergence\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-15 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * (np.random.uniform(0, 1) ** (1 / dim))\n                sample = rot @ (x * radii) + center\n                sample_tuple = tuple(float(s) for s in sample)\n                if in_bounds(sample_tuple) and not is_in_obstacle(sample_tuple):\n                    return sample_tuple\n\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample) and not is_in_obstacle(sample):\n                        return sample\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_radius\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(max(n_nodes, 1) + 1) / max(n_nodes, 1))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(node_list: List[Node], best_cost: float, root_s: Node, root_g: Node) -> int:\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for n in node_list:\n                if n in (root_s, root_g):\n                    continue\n                if n.cost + heuristic(n.position) >= best_cost - 1e-9:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    try:\n                        n.parent.children.remove(n)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(n)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        edge_collision_cache = {}\n\n        for itr in range(self.max_iter):\n            # Alternate extension of smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), itr)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                c_cand = node.cost + dist(node.position, new_pos)\n                if c_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = c_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_c = new_node.cost + dist(new_node.position, node.position)\n                if new_c + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_c)\n                    edges.append((new_node, node))\n\n            # Incrementally connect tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), itr)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Do not break immediately, allow few more iterations for further smoothing and rewiring\n                # but here breaking to reduce unnecessary iterations for speed\n                break\n\n            # Periodic pruning for efficiency\n            if (itr > 0 and itr % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        # Final aggressive shortcut smoothing to refine path quality\n        if success_state and len(extracted_path) > 2:\n            for _ in range(self.smoothing_iterations):\n                if len(extracted_path) < 3:\n                    break\n                i = random.randint(0, len(extracted_path) - 3)\n                j = random.randint(i + 2, len(extracted_path) - 1)\n                p1, p2 = extracted_path[i], extracted_path[j]\n                if can_connect(p1, p2):\n                    extracted_path = extracted_path[:i + 1] + extracted_path[j:]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -20.20681,
    "time_improvement": 33.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024172520637512206,
            "num_nodes_avg": 84.2,
            "path_length_avg": 159.34047215461607,
            "smoothness_avg": 0.04273233651572029,
            "success_improvement": 0.0,
            "time_improvement": 3.986404839558925,
            "length_improvement": 12.662962300697147,
            "smoothness_improvement": 568.8538612249979,
            "objective_score": 6.572783218132097
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.041777729988098145,
            "num_nodes_avg": 190.6,
            "path_length_avg": 238.4106751266964,
            "smoothness_avg": 0.09164838803724577,
            "success_improvement": 0.0,
            "time_improvement": 74.68449251168593,
            "length_improvement": 20.411654371914157,
            "smoothness_improvement": 2258.179035864025,
            "objective_score": 37.77857380720874
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04027848243713379,
            "num_nodes_avg": 164.2,
            "path_length_avg": 125.7581699673844,
            "smoothness_avg": 0.11134476810098834,
            "success_improvement": 0.0,
            "time_improvement": 21.30706325797874,
            "length_improvement": 16.47741146820078,
            "smoothness_improvement": 1316.2972316287003,
            "objective_score": 16.26908742917728
        }
    ],
    "smoothness_improvement": 1381.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified yet efficient bidirectional RRT* with informed sampling and adaptive neighbor radius. It balances exploration and exploitation by sampling within an ellipsoid informed by the current best path cost, pruning nodes unlikely to improve solutions, and incrementally rewiring nodes to optimize paths. Collision caching and edge validation ensure correctness, while shortcut smoothing refines final paths for smoothness and reduced length. The approach is generalized for both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two balanced trees rooted at start and goal points, alternately sampling informed nodes within a progressively shrinking ellipsoid around the current best path. It connects nodes only if both points are collision-free and the connecting edge is obstacle-free. Neighborhood radius adapts with iterations and node count for efficient rewiring. Aggressive pruning removes unpromising nodes. Upon connecting the two trees, shortcut smoothing improves path quality before returning the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_radius = 5.0\n        self.max_radius = 30.0\n        self.prune_interval = 200\n        self.prune_threshold = 300\n        self.smooth_iter = 100\n        self.collision_res = 1.0\n        self.goal_sample_rate = 0.15\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_radius * (1.0 - (iteration / self.max_iter) ** 0.95)\n            r_nodes = self.min_radius + (self.max_radius - self.min_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(1, int(distance / self.collision_res))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.points = [p for p, _ in points_nodes]\n                self.nodes = [n for _, n in points_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r_sq = radius * radius\n                found = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0\n                    for i_ in range(dim):\n                        delta = p[i_] - pt[i_]\n                        sqd += delta * delta\n                        if sqd > r_sq:\n                            break\n                    if sqd <= r_sq:\n                        found.append(n)\n                return found\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n\n            v = a1 - np.array([1] + [0] * (dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_other = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_other] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 1 and norm_x > 1e-15:\n                    r_scale = random.uniform(0, 1) ** (1 / dim)\n                    sample = rot @ (x_ball / norm_x * r_scale * radii) + center\n                    p = tuple(float(c) for c in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not is_edge_in_obstacle(p1, p2)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            p = path[:]\n            for _ in range(self.smooth_iter):\n                if len(p) < 3:\n                    break\n                i = random.randint(0, len(p) - 3)\n                j = random.randint(i + 2, len(p) - 1)\n                if can_connect(p[i], p[j]):\n                    p = p[:i + 1] + p[j:]\n            return p\n\n        def prune_nodes(best_cost):\n            nonlocal nodes, tree_start, tree_goal, edges\n            heuristic = lambda pos: dist(pos, goal)\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for rm in to_remove:\n                if rm.parent:\n                    try:\n                        rm.parent.children.remove(rm)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm)\n                except ValueError:\n                    pass\n                if rm in tree_start:\n                    tree_start.remove(rm)\n                if rm in tree_goal:\n                    tree_goal.remove(rm)\n                edges = [e for e in edges if e[0] != rm and e[1] != rm]\n            return len(to_remove)\n\n        root_start = Node(start, cost=0.0)\n        root_goal = Node(goal, cost=0.0)\n\n        nodes = [root_start, root_goal]\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        edges = []\n\n        c_best = float('inf')\n        c_min = dist(start, goal)\n        best_path = []\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start, goal)\n\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n                grow_from_start = True\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n                grow_from_start = False\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos):\n                continue\n            if not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = radius(it, len(nodes))\n            near_nodes = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for nn in near_nodes:\n                cost_candidate = nn.cost + dist(nn.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(nn.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = nn\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near_nodes:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Connect to other tree incrementally\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n\n            max_steps = max(1, int(dist(last_b.position, new_node.position) / self.step_size))\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b):\n                    break\n                if not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for nb in near_b:\n                    if nb is last_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, nb.position)\n                    if c_via_new_b + 1e-12 < nb.cost and can_connect(new_node_b.position, nb.position):\n                        try:\n                            edges.remove((nb.parent, nb))\n                        except ValueError:\n                            pass\n                        nb.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, nb))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_conn = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_conn)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if grow_from_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    smoothed = shortcut_path(merged_path)\n\n                    if cost_conn + 1e-12 < c_best:\n                        c_best = cost_conn\n                        best_path = smoothed\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(c_best)\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -10.00148,
    "time_improvement": -3.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03758563995361328,
            "num_nodes_avg": 114.4,
            "path_length_avg": 164.87609763646893,
            "smoothness_avg": 0.03695049683322197,
            "success_improvement": 0.0,
            "time_improvement": -49.29069551613504,
            "length_improvement": 9.628798256494528,
            "smoothness_improvement": 478.3555147280715,
            "objective_score": -10.469671429901247
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03824889659881592,
            "num_nodes_avg": 194.0,
            "path_length_avg": 235.86580007707084,
            "smoothness_avg": 0.10018231004641738,
            "success_improvement": 0.0,
            "time_improvement": 76.82281376841378,
            "length_improvement": 21.261206913646003,
            "smoothness_improvement": 2477.762995895581,
            "objective_score": 39.68790049273124
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06934762001037598,
            "num_nodes_avg": 215.2,
            "path_length_avg": 120.28893211358888,
            "smoothness_avg": 0.12437222632548386,
            "success_improvement": 0.0,
            "time_improvement": -35.48593552906894,
            "length_improvement": 20.10981883357177,
            "smoothness_improvement": 1482.0055386573426,
            "objective_score": 0.7862108012803857
        }
    ],
    "smoothness_improvement": 1479.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates the advantages of bidirectional RRT* with informed ellipsoidal sampling, adaptive neighbor radius tuning, efficient nearest neighbor querying using a KD-tree, and collision caching to minimize both path length and planning time efficiently. It alternately grows two trees rooted at start and goal, focusing sampling within the current best solution's ellipsoid to accelerate convergence. Incremental rewiring optimizes path cost, while periodic pruning eliminates nodes unlikely to improve the solution, maintaining a balanced search tree size. Shortcut smoothing refines the final path for smoothness and shorter length, ensuring robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal alternately, using informed sampling inside an adaptive ellipsoid defined by the best found path cost to bias exploration towards promising regions. Nearest neighbor and radius searches use a KD-tree for efficient rewiring and extending nodes. It performs thorough collision checks including caching to avoid redundant computations. Pruning removes nodes that cannot yield better solutions to accelerate convergence and reduce memory footprint. Once a connection between trees is found, shortcut smoothing refines the path to minimize length and increase smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start/root\n        self.children = []\n        self.valid = True               # For collision checks etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                # Sample uniformly inside unit ball\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p  # fallback\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate growing smaller tree first for balanced search\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.40965,
    "time_improvement": 28.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02277235984802246,
            "num_nodes_avg": 71.5,
            "path_length_avg": 159.81325103846498,
            "smoothness_avg": 0.040307385638470986,
            "success_improvement": 0.0,
            "time_improvement": 9.547863374130177,
            "length_improvement": 12.403824702798728,
            "smoothness_improvement": 530.8981141309332,
            "objective_score": 7.999614523453465
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05872015953063965,
            "num_nodes_avg": 242.2,
            "path_length_avg": 239.38252222917103,
            "smoothness_avg": 0.08731944031723526,
            "success_improvement": 0.0,
            "time_improvement": 64.41810891265764,
            "length_improvement": 20.087223836040284,
            "smoothness_improvement": 2146.7920930131436,
            "objective_score": 34.07683790607107
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04556460380554199,
            "num_nodes_avg": 171.2,
            "path_length_avg": 128.2781545245216,
            "smoothness_avg": 0.11632018345021566,
            "success_improvement": 0.0,
            "time_improvement": 10.97945433914594,
            "length_improvement": 14.80375771411987,
            "smoothness_improvement": 1379.5841476239123,
            "objective_score": 13.152508582687318
        }
    ],
    "smoothness_improvement": 1352.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This algorithm implements an optimized bidirectional RRT* planner that grows two trees from the start and goal positions respectively. It introduces several efficiency improvements: adaptive goal biasing focused on both goals, dynamic nearest neighbor search optimized with spatial caching, and early pruning of nodes that cannot improve the current best path to reduce unnecessary exploration. The rewiring radius dynamically shrinks with the tree size to balance exploration and optimization. When trees meet, the optimal connecting path is reconstructed with a minimal-cost criterion. The planner applies rigorous collision checks on nodes and edges, pruning suboptimal rewires and focusing search around promising regions to reduce planning time while enhancing path quality and robustness.",
    "planning_mechanism": "The planner alternates growth between start and goal trees, sampling points biased towards both endpoints with adjustable probability. Each iteration extends the smaller tree to maintain balance. Nodes are added by steering towards sampled points respecting step size limits, followed by local rewiring considering neighbors within a radius that shrinks as the tree grows. Collision checks ensure safety. Upon connecting the trees, the shortest combined path is constructed. Early path cost bounds prune expansions far from improving solutions, accelerating convergence to shorter and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = float('inf')\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as the tree grows (RRT* typical)\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def sample_free():\n            # Adaptive dual goal bias to encourage convergence\n            p = random.random()\n            if p < self.goal_sample_rate:\n                # 70% goal, 30% start bias\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        pt = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(pt, obstacles, is_3d):\n                        return pt\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Use a simple linear search; can be optimized with spatial structures if desired\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = distance(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            # Return nodes within radius\n            r2 = radius * radius\n            res = []\n            for node in tree:\n                dx = tuple(node.position[d] - pos[d] for d in range(len(pos)))\n                dist_sq = sum(x * x for x in dx)\n                if dist_sq <= r2:\n                    res.append(node)\n            return res\n\n        def try_extend(tree, point, opposite_tree):\n            nonlocal best_path_cost\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Boundary check\n            for i, val in enumerate(new_pos):\n                if val < 0 or val > bounds[i]:\n                    return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            if min_cost >= best_path_cost:\n                # Prune: no improvement possible with this node beyond best known path cost\n                return None\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Attempt to connect to opposite tree to detect path completion faster\n            connect_node = try_connect(opposite_tree, new_node)\n            if connect_node:\n                # Update best path and record\n                path_start = new_node.path_from_root()\n                path_goal = connect_node.path_from_root()\n                candidate_cost = new_node.cost + connect_node.cost + distance(new_node.position, connect_node.position)\n                if candidate_cost < best_path_cost:\n                    best_path_cost = candidate_cost\n                    # Merge paths with no duplication on connection node\n                    extracted = path_start + path_goal[::-1][1:]\n                    nonlocal extracted_path\n                    extracted_path = extracted\n                return new_node\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                # Boundary check\n                for i, val in enumerate(new_pos):\n                    if val < 0 or val > bounds[i]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                if new_cost >= best_path_cost:\n                    # Prune extension as no improvement possible\n                    return None\n\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        if final_node.cost >= best_path_cost:\n                            return None\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for itr in range(self.max_iter):\n            if best_path_cost < float('inf'):\n                # Bias samples closer to the current best path region\n                # Sample near the best path nodes occasionally\n                if random.random() < 0.2 and extracted_path:\n                    sample_idx = random.randint(0, len(extracted_path)-1)\n                    near_pos = extracted_path[sample_idx]\n                    # Add small noise\n                    noise_scale = self.step_size * 0.5\n                    noisy_sample = tuple(\n                        max(0, min(bounds[d], near_pos[d] + random.uniform(-noise_scale, noise_scale)))\n                        for d in range(len(bounds))\n                    )\n                    rand_point = noisy_sample\n                else:\n                    rand_point = sample_free()\n            else:\n                rand_point = sample_free()\n\n            # Alternate growth by smaller tree to balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, tree_goal)\n            if new_node_start is None:\n                continue\n\n            # Early success recognition if path found\n            if extracted_path:\n                success_state = True\n                break\n\n        if extracted_path:\n            success_state = True\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.01164,
    "time_improvement": 34.0,
    "length_improvement": 6.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010438799858093262,
            "num_nodes_avg": 77.6,
            "path_length_avg": 176.49403005694555,
            "smoothness_avg": 0.013629801721385938,
            "success_improvement": 0.0,
            "time_improvement": 58.536938759275884,
            "length_improvement": 3.260825398911123,
            "smoothness_improvement": 113.33599452785373,
            "objective_score": 18.77992668020426
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05906569957733154,
            "num_nodes_avg": 272.8,
            "path_length_avg": 285.16151941812575,
            "smoothness_avg": 0.007138797337359048,
            "success_improvement": 0.0,
            "time_improvement": 64.2087265062408,
            "length_improvement": 4.804876898993612,
            "smoothness_improvement": 83.68639735813456,
            "objective_score": 20.64202531846163
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.061423635482788085,
            "num_nodes_avg": 246.7,
            "path_length_avg": 134.9994120219157,
            "smoothness_avg": 0.0164531089446407,
            "success_improvement": 0.0,
            "time_improvement": -20.004676667157316,
            "length_improvement": 10.339818516239427,
            "smoothness_improvement": 109.28233133365508,
            "objective_score": -3.387027640231034
        }
    ],
    "smoothness_improvement": 102.0,
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner enhances bidirectional RRT* by incorporating adaptive informed ellipsoidal sampling to concentrate exploration in promising regions defined by the current best path cost, effectively improving convergence speed and path quality. It employs dynamic neighbor radius adjustment for efficient rewiring, KD-tree based nearest and radius searches for speed, collision caching to avoid redundant checks, incremental rewiring for continuous path optimality, balanced expansion of the two trees, and periodic pruning of non-promising nodes to maintain computational efficiency. The final discovered path undergoes repeated shortcut smoothing to yield smoother and shorter trajectories.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling within an informed ellipsoid shaped by the current best cost to bias towards better paths. Each iteration attempts to extend one tree towards a sampled point, rewiring neighbours to lower costs and then incrementally connects the other tree toward the newly added node. Collision checks ensure validity of nodes and edges before additions. Periodic pruning removes dead ends and nodes unlikely to improve paths. Once a connection between the trees is found, shortcut smoothing iteratively refines the resulting path for smoothness and minimal length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0,\n                 max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 300,\n                 smoothing_iterations: int = 120,\n                 collision_check_resolution: float = 1.0,\n                 goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> \"PlannerResult\":\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            return tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            # Occasionally sample goal to increase success rate\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < self.goal_sample_rate:\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 ** 2 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x) <= 1:\n                    sample = rot @ (x * radii) + center\n                    sample_t = tuple(float(coord) for coord in sample)\n                    if in_bounds(sample_t) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n            # Fallback uniform sample\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            reverse_key = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if reverse_key in edge_collision_cache:\n                return not edge_collision_cache[reverse_key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        # KD-tree substitute for nearest and radius searches, brute-force for correctness and clarity\n        class KDTree:\n            def __init__(self, pts_nodes):\n                self.points = [pn[0] for pn in pts_nodes]\n                self.nodes = [pn[1] for pn in pts_nodes]\n\n            def nearest(self, pt):\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        diff = p[d_] - pt[d_]\n                        sqd += diff * diff\n                        if sqd > r2:\n                            break\n                    else:\n                        res.append(n)\n                return res\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        def prune_nonpromising_nodes(nodes_list, tree_s, tree_g, best_cost):\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_start, root_goal):\n                    continue\n                if not node.children:\n                    to_remove.append(node)\n                    continue\n                h_cost = dist(node.position, goal_pos)\n                if node.cost + h_cost >= best_cost:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                if node in tree_s:\n                    try:\n                        tree_s.remove(node)\n                    except ValueError:\n                        pass\n                if node in tree_g:\n                    try:\n                        tree_g.remove(node)\n                    except ValueError:\n                        pass\n            return len(to_remove)\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Alternate tree expansion for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(itr, len(nodes))\n            near_a = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors in tree_a to reduce costs\n            for neighbor in near_a:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            # Incrementally connect tree_b to new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_b = nearest_b\n            connected = False\n\n            max_steps = int(dist(last_b.position, new_node.position) / self.step_size) + 1\n            for _ in range(max_steps):\n                next_pos_b = steer(last_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_b.position, next_pos_b):\n                    break\n\n                cost_b = last_b.cost + dist(last_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_b, cost=cost_b)\n                last_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_b:\n                        continue\n                    cost_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    # Extract and merge paths according to expansion order\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged)\n\n                    connected = True\n                    break\n\n                last_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning for efficiency & robustness\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nonpromising_nodes(nodes, tree_start, tree_goal, c_best)\n                edge_collision_cache.clear()\n\n        if success_state and extracted_path:\n            # Final smoothing to enhance path quality\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.10726,
    "time_improvement": 25.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.026071906089782715,
            "num_nodes_avg": 91.4,
            "path_length_avg": 164.97891845860107,
            "smoothness_avg": 0.0436745873227192,
            "success_improvement": 0.0,
            "time_improvement": -3.5579811432965576,
            "length_improvement": 9.57244053458371,
            "smoothness_improvement": 583.6021324849077,
            "objective_score": 3.7651044263523135
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.045095968246459964,
            "num_nodes_avg": 204.4,
            "path_length_avg": 232.4444468383273,
            "smoothness_avg": 0.09545445904408897,
            "success_improvement": 0.0,
            "time_improvement": 72.67378284647674,
            "length_improvement": 22.403353102931302,
            "smoothness_improvement": 2356.1119842722387,
            "objective_score": 38.06336539589047
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.048159027099609376,
            "num_nodes_avg": 179.1,
            "path_length_avg": 123.52753874425007,
            "smoothness_avg": 0.11994319073532374,
            "success_improvement": 0.0,
            "time_improvement": 5.9106737940813066,
            "length_improvement": 17.95889051536211,
            "smoothness_improvement": 1425.6685328679066,
            "objective_score": 12.493322905636347
        }
    ],
    "smoothness_improvement": 1455.0,
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional informed RRT* planner combines adaptive ellipsoidal and path-informed sampling with lazy collision checking and dynamic neighbor radius tuning. It balances exploration by incrementally extending the smaller tree, uses KD-tree accelerated nearest neighbor searches for rewiring, aggressively prunes nodes unlikely to improve the solution, and applies path shortcut smoothing. Collision checks for nodes and edges are cached to minimize redundant computations, improving efficiency, robustness, and convergence speed while producing high quality, smooth, and shorter paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two trees rooted at start and goal, sampling nodes with a blend of ellipsoidal informed and adaptive path-focused strategies. It selects optimal parents from neighbors found via KD-tree radius search, rewires to minimize path cost, and incrementally attempts multi-step connections between trees. Cached lazy collision checks ensure feasibility of nodes and edges. Periodic pruning removes nodes that cannot enhance the current best path. Once a feasible path is found, iterative shortcut smoothing improves path quality and smoothness, ensuring efficient convergence and strong success rates.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position           # Tuple[float, ...]\n        self.parent = parent               # Node or None\n        self.cost = cost                   # Cost from root\n        self.children: List[Node] = []    # Children nodes for rewiring/pruning\n        self.valid = True                  # Validity flag for collision, etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 150, collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            # Clamp to bounds:\n            new_p_clamped = tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n            return new_p_clamped\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.92)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos: Tuple[float, ...]) -> bool:\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        # KDTree helper (brute-force)\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                r2 = radius * radius\n                results = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        results.append(n)\n                return results\n\n        # Edge collision cache for lazy collision checking\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Sample inside an ellipsoid defined by current best cost\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.15:\n                # Uniform with obstacle rejection fallback\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1**2 - (c_min/2)**2, 0.0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0, 1), 1.0/dim)  # uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # fallback uniform with obstacle rejection\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        # Adaptive sampling favors points near current best path with Gaussian noise\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path)-1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        # Shortcut path smoothing by iterative edge checking and segment replacement\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth)-3)\n                j = random.randint(i+2, len(smooth)-1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        # Prune nodes that cannot possibly lead to a better path than current best cost\n        def prune_nodes(nodes_list: List[Node], best_cost: float, goal_pos: Tuple[float, ...]) -> int:\n            removed = 0\n            to_remove = []\n            heuristic = lambda pos: dist(pos, goal_pos)\n            for node in nodes_list:\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    # Keep roots always\n                    if node.parent is None:\n                        continue\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                    removed += 1\n                except ValueError:\n                    pass\n            return removed\n\n        # Initialize trees and roots\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Expand the smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                candidate_cost = node.cost + dist(node.position, new_pos)\n                if candidate_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = candidate_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors in tree_a to improve path cost\n            for neighbor in near_nodes_a:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt incremental extension from tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            dist_between = dist(nearest_b.position, new_node.position)\n            max_steps = int(dist_between / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                # Rewire neighbors in tree_b\n                for nbr in near_nodes_b:\n                    if nbr is last_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nbr.position)\n                    if cost_via_new_b + 1e-12 < nbr.cost and can_connect(new_node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(new_node_b, cost_via_new_b)\n                        edges.append((new_node_b, nbr))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning of nodes unlikely to improve best path\n            if (iteration > 0 and iteration % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                removed_start = prune_nodes(tree_start, c_best, goal_pos)\n                removed_goal = prune_nodes(tree_goal, c_best, goal_pos)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple[float, ...]], is_3d: bool) -> bool:\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles: List[Tuple[float, ...]],\n                             is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -12.71566,
    "time_improvement": 6.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027538871765136717,
            "num_nodes_avg": 84.9,
            "path_length_avg": 169.25053364520397,
            "smoothness_avg": 0.045389309816580535,
            "success_improvement": 0.0,
            "time_improvement": -9.384789632979913,
            "length_improvement": 7.231100562732467,
            "smoothness_improvement": 610.441263093331,
            "objective_score": 1.6829895381191748
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.045506405830383304,
            "num_nodes_avg": 205.4,
            "path_length_avg": 237.45112798545443,
            "smoothness_avg": 0.10116803959172835,
            "success_improvement": 0.0,
            "time_improvement": 72.42507532377847,
            "length_improvement": 20.731978826693805,
            "smoothness_improvement": 2503.1265270887257,
            "objective_score": 38.38955099791593
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07368133068084717,
            "num_nodes_avg": 213.0,
            "path_length_avg": 119.95983034433478,
            "smoothness_avg": 0.12098486531401464,
            "success_improvement": 0.0,
            "time_improvement": -43.95279919956328,
            "length_improvement": 20.32839255856814,
            "smoothness_improvement": 1438.9185566204358,
            "objective_score": -1.9255684650531766
        }
    ],
    "smoothness_improvement": 1517.0,
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a hybrid bidirectional informed RRT* algorithm combining adaptive ellipsoidal informed sampling, dynamic neighbor radius adjustment with KD-tree accelerated queries, lazy collision checking, incremental multi-step tree connection, iterative rewiring, aggressive pruning, and iterative shortcut smoothing. It aims to improve planning efficiency, path quality, and robustness in both 2D and 3D environments while balancing tree growth and maintaining manageable search space size.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, extending the smaller tree using samples biased within the current informed ellipsoid or via Gaussian perturbations around the best path. It uses KD-trees to efficiently find neighbors for rewiring within a dynamically adjusted radius. Lazy caching reduces collision checking overhead. Multi-step incremental connections between trees help to quickly find path connections. Periodic pruning discards nodes that cannot improve the solution. Once a connection is found, aggressive iterative shortcut smoothing refines the path for smoothness and shorter lengths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D:(x,y), 3D:(x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For pruning, collision flags etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def _update_cost_recursive(self):\n        if self.parent:\n            import math\n            self.cost = self.parent.cost + math.dist(self.parent.position, self.position)\n        for child in self.children:\n            child._update_cost_recursive()\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float = 5.0, max_neighbor_radius: float = 30.0,\n                 prune_interval: int = 200, prune_threshold: int = 300,\n                 smoothing_trials: int = 120,\n                 collision_check_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(n_nodes + 1) / n_nodes)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not is_in_obstacle(pos)\n\n        c_min = dist(start_pos, goal_pos)\n\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            val = max(r1 * r1 - (c_min / 2) ** 2, 0)\n            r_others = math.sqrt(val) if val > 0 else 0.0\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.random.uniform(0, 1) ** (1 / dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            for _ in range(30):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            if best_path and random.random() < 0.7:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.4, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i + 1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            h = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + h(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                except ValueError:\n                    pass\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Extend smaller tree first\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cand_cost = node.cost + dist(node.position, new_pos)\n                if cand_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cand_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Multi-step incremental connect from tree_b towards new_node.position\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                dist_to_new = dist(new_node_b.position, new_node.position)\n                if dist_to_new <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist_to_new\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                # Aggressive iterative shortcut smoothing after each solution\n                best_path = shortcut_path(best_path)\n                break\n\n            # Periodic pruning for efficiency, when solution exists and node count high\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -21.04493,
    "time_improvement": 33.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01807081699371338,
            "num_nodes_avg": 76.0,
            "path_length_avg": 162.76556030857844,
            "smoothness_avg": 0.04680911967099628,
            "success_improvement": 0.0,
            "time_improvement": 28.222458341382843,
            "length_improvement": 10.785617209515417,
            "smoothness_improvement": 632.6643704813841,
            "objective_score": 13.787182796724856
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.058680033683776854,
            "num_nodes_avg": 223.1,
            "path_length_avg": 233.32725716536592,
            "smoothness_avg": 0.10243440429111432,
            "success_improvement": 0.0,
            "time_improvement": 64.44242345002048,
            "length_improvement": 22.10864560547946,
            "smoothness_improvement": 2535.7110029295513,
            "objective_score": 36.43301117074979
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.047423267364501955,
            "num_nodes_avg": 172.3,
            "path_length_avg": 123.70759420053871,
            "smoothness_avg": 0.12016248130576894,
            "success_improvement": 0.0,
            "time_improvement": 7.34814340040282,
            "length_improvement": 17.839306254614662,
            "smoothness_improvement": 1428.4578927376235,
            "objective_score": 12.914593734731897
        }
    ],
    "smoothness_improvement": 1532.0,
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced anytime informed bidirectional RRT* with adaptive lazy-collision checking, dynamic neighbor radius, and KD-tree accelerated neighbor searches. It incrementally expands the smaller tree, samples adaptively within an evolving ellipsoid biased by the current best path, attempts multi-step tree connections, rewires nodes for cost improvements, and prunes suboptimal nodes periodically. Final paths are refined via iterative shortcut smoothing to achieve reliable, shorter, and smoother trajectories in 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal, adaptively sampling points informed by the best cost to limit search areas. It chooses parents and rewires neighbors using radius searches in KD-trees, validates nodes and edges lazily for collision, and connects trees incrementally via multi-step extensions. Periodic pruning removes nodes unlikely to improve the solution, and shortcut smoothing refines the resulting path. This approach balances exploration and exploitation to improve efficiency, path quality, and success rates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []              # Children nodes\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=120, collision_check_resolution:float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d] + ratio * (to_p[d] - from_p[d]) for d in range(dim))\n            # Keep within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(n_nodes, iteration):\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d_ = dist(pt, p)\n                    if d_ < best_dist:\n                        best_dist = d_\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                res = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        res.append(self.nodes[i])\n                return res\n\n        def informed_sample(c_best, c_min, start, goal):\n            # Sample inside ellipsoid or uniformly biased by c_best and c_min\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(20):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u = u / norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                x = np.random.uniform(-1, 1, dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x = x / norm_x\n                x = x * np.power(np.random.uniform(0,1), 1 / dim)  # uniform in unit ball\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n\n            # fallback random sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path, c_best, c_min):\n            # Sample near best path with Gaussian noise or by informed_sample\n            if best_path and random.random() < 0.75:\n                for _ in range(50):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size * 0.5, dim)\n                    sample_point = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_point) and not is_in_obstacle(sample_point):\n                        return sample_point\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                p1, p2 = smooth[i], smooth[j]\n                if can_connect(p1, p2):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(nodes_list, best_cost, root_s, root_g):\n            removed = 0\n            heuristic = lambda pos: dist(pos, goal_pos)\n            to_remove = []\n            for node in nodes_list:\n                if node in (root_s, root_g):\n                    continue\n                if node.cost + heuristic(node.position) >= best_cost - 1e-12:\n                    to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    nodes_list.remove(node)\n                    removed += 1\n                except ValueError:\n                    pass\n            return removed\n\n\n        # Initialization\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path = []\n        success_state = False\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Expand the smaller tree\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(n.position, n) for n in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            radius_a = neighbor_radius(len(nodes), it)\n            near_nodes_a = kdtree_a.radius_search(new_pos, radius_a)\n\n            # Choose parent minimizing cost + collision check edges lazily\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near_nodes_a:\n                cost_cand = node.cost + dist(node.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors in tree_a\n            for node in near_nodes_a:\n                if node is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, node.position)\n                if new_cost + 1e-12 < node.cost and can_connect(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, new_cost)\n                    edges.append((new_node, node))\n\n            # Incrementally extend tree_b towards new_node\n            kdtree_b = KDTree([(n.position, n) for n in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                radius_b = neighbor_radius(len(nodes), it)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                # Rewire neighbors in tree_b\n                for nbr_b in near_nodes_b:\n                    if nbr_b is last_node_b:\n                        continue\n                    new_cost_b = new_node_b.cost + dist(new_node_b.position, nbr_b.position)\n                    if new_cost_b + 1e-12 < nbr_b.cost and can_connect(new_node_b.position, nbr_b.position):\n                        try:\n                            edges.remove((nbr_b.parent, nbr_b))\n                        except ValueError:\n                            pass\n                        nbr_b.update_parent(new_node_b, new_cost_b)\n                        edges.append((new_node_b, nbr_b))\n\n                # Check if can connect directly to new_node\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    cost_connect = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=new_node_b, cost=cost_connect)\n                    new_node_b.children.append(connect_node)\n                    tree_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((new_node_b, connect_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n                    if cost_connect + 1e-12 < c_best:\n                        c_best = cost_connect\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to improve efficiency\n            if (it > 0 and it % self.prune_interval == 0 and\n                len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, root_start, root_goal)\n                prune_nodes(tree_goal, c_best, root_start, root_goal)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -18.97527,
    "time_improvement": 25.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02153470516204834,
            "num_nodes_avg": 72.8,
            "path_length_avg": 157.9554081096825,
            "smoothness_avg": 0.041946982679749494,
            "success_improvement": 0.0,
            "time_improvement": 14.46384535836448,
            "length_improvement": 13.422137851469524,
            "smoothness_improvement": 556.5613682689038,
            "objective_score": 9.806388019147768
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.054689550399780275,
            "num_nodes_avg": 215.8,
            "path_length_avg": 236.00915846332614,
            "smoothness_avg": 0.11417016487033456,
            "success_improvement": 0.0,
            "time_improvement": 66.86048468711468,
            "length_improvement": 21.213349757971624,
            "smoothness_improvement": 2837.6805755595633,
            "objective_score": 38.48921823552655
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05455374717712402,
            "num_nodes_avg": 189.2,
            "path_length_avg": 123.97390774898051,
            "smoothness_avg": 0.11906607793239954,
            "success_improvement": 0.0,
            "time_improvement": -6.582828247069636,
            "length_improvement": 17.662433476228045,
            "smoothness_improvement": 1414.5117227564435,
            "objective_score": 8.630196834906936
        }
    ],
    "smoothness_improvement": 1603.0,
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements an efficient bidirectional RRT*-based algorithm with adaptive informed sampling within an ellipsoidal region shaped by the current best path cost. It balances growth between trees from start and goal, uses dynamic neighbor radius tuning, caches collision checks, rewires neighbors incrementally for cost improvement, prunes nodes unlikely to improve paths, and applies iterative shortcut smoothing for path quality. The planner ensures thorough collision checking both for nodes and edges, maintains search within bounds, and focuses sampling adaptively around promising regions for improved efficiency, robustness, and path smoothness.",
    "planning_mechanism": "The planner alternately grows two trees rooted at start and goal positions, sampling new nodes primarily inside a shrinking ellipsoid defined by the best path cost or near the current best path with small Gaussian perturbations. Nodes are added only if collision-free, connected via checked edges to neighbors within a dynamic radius. Rewiring optimizes path costs incrementally. Trees attempt multi-step connections to each other every iteration. Periodic pruning removes nodes unlikely to yield better paths. After finding a feasible path, repeated shortcutting improves smoothness and path length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child: 'Node'):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except (ValueError, AttributeError):\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0, max_neighbor_radius: float=30.0,\n                 prune_interval: int=200, prune_threshold: int=300,\n                 smoothing_trials: int=120, collision_check_resolution: float=1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n        self.collision_check_resolution = collision_check_resolution\n\n    def plan(self, map) -> PlannerResult:\n        bounds: Tuple[float, ...] = map.size\n        start_pos: Tuple[float, ...] = map.start\n        goal_pos: Tuple[float, ...] = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(p: Tuple[float, ...]) -> bool:\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                new_p = to_p\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_p[d_] + ratio * (to_p[d_] - from_p[d_]) for d_ in range(dim))\n            return tuple(max(0.0, min(new_p[d_], bounds[d_])) for d_ in range(dim))\n\n        def neighbor_radius(n_nodes: int, iteration: int) -> float:\n            if n_nodes <= 1:\n                return self.max_neighbor_radius\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(p: Tuple[float, ...]) -> bool:\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = p\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = p\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_p: Tuple[float, ...], to_p: Tuple[float, ...]) -> bool:\n            distance = dist(from_p, to_p)\n            steps = max(1, int(distance / self.collision_check_resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_p[d] + (to_p[d] - from_p[d]) * (i / steps) for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        edge_collision_cache = {}\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(p: Tuple[float, ...]) -> bool:\n            return in_bounds(p) and not is_in_obstacle(p)\n\n        class KDTree:\n            def __init__(self, points_nodes: List[Tuple[Tuple[float, ...], Node]]):\n                self.dim = dim\n                self.points = [pn[0] for pn in points_nodes]\n                self.nodes = [pn[1] for pn in points_nodes]\n\n            def nearest(self, pt: Tuple[float, ...]) -> Node:\n                best_node = None\n                best_dist = float('inf')\n                for p, n in zip(self.points, self.nodes):\n                    d = dist(p, pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = n\n                return best_node\n\n            def radius_search(self, pt: Tuple[float, ...], radius: float) -> List[Node]:\n                radius_sq = radius * radius\n                result = []\n                for p, n in zip(self.points, self.nodes):\n                    sqd = 0.0\n                    for d_ in range(self.dim):\n                        delta = p[d_] - pt[d_]\n                        sqd += delta * delta\n                        if sqd > radius_sq:\n                            break\n                    else:\n                        result.append(n)\n                return result\n\n        def informed_sample(c_best: float, c_min: float, start: Tuple[float, ...], goal: Tuple[float, ...]) -> Tuple[float, ...]:\n            # Sample uniformly if no solution yet or cost near optimal\n            if c_best == float('inf') or c_best < c_min * 1.00001 or random.random() < 0.1:\n                for _ in range(30):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = np.array([(start[d] + goal[d]) / 2.0 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            u = a1 - id_mat[:, 0]\n            norm_u = np.linalg.norm(u)\n            if norm_u > 1e-10:\n                u /= norm_u\n                rot = id_mat - 2 * np.outer(u, u)  # Householder reflection\n            else:\n                rot = id_mat\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(r1*r1 - (c_min/2)**2, 0))\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n            for _ in range(150):\n                # Uniform sampling inside unit ball\n                x = np.random.uniform(-1,1,dim)\n                norm_x = np.linalg.norm(x)\n                if norm_x < 1e-10 or norm_x > 1:\n                    continue\n                x /= norm_x\n                x *= np.power(random.uniform(0,1), 1.0/dim)\n                p = rot @ (x * radii) + center\n                p_tuple = tuple(float(coord) for coord in p)\n                if in_bounds(p_tuple) and not is_in_obstacle(p_tuple):\n                    return p_tuple\n            # Fallback uniform sampling\n            for _ in range(20):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        def adaptive_sample(best_path: List[Tuple[float, ...]], c_best: float, c_min: float) -> Tuple[float, ...]:\n            if best_path and random.random() < 0.75:\n                for _ in range(30):\n                    base_point = best_path[random.randint(0, len(best_path) - 1)]\n                    noise = np.random.normal(0, self.step_size*0.5, dim)\n                    sample_pt = tuple(base_point[d] + noise[d] for d in range(dim))\n                    if in_bounds(sample_pt) and not is_in_obstacle(sample_pt):\n                        return sample_pt\n            return informed_sample(c_best, c_min, start_pos, goal_pos)\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path[:]\n            smooth = path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth) < 3:\n                    break\n                i = random.randint(0, len(smooth) - 3)\n                j = random.randint(i + 2, len(smooth) - 1)\n                if can_connect(smooth[i], smooth[j]):\n                    smooth = smooth[:i+1] + smooth[j:]\n            return smooth\n\n        def prune_nodes(node_list: List[Node], best_cost: float, goal_pos: Tuple[float, ...]) -> int:\n            removed = 0\n            to_remove = []\n            for n in node_list:\n                if n.parent is None:\n                    continue\n                # Heuristic: straight-line distance to goal\n                h = dist(n.position, goal_pos)\n                if n.cost + h >= best_cost - 1e-12:\n                    to_remove.append(n)\n            for n in to_remove:\n                if n.parent:\n                    try:\n                        n.parent.children.remove(n)\n                    except (ValueError, AttributeError):\n                        pass\n                try:\n                    node_list.remove(n)\n                    removed += 1\n                except ValueError:\n                    pass\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n        nodes = [root_start, root_goal]\n        edges: List[Tuple[Node, Node]] = []\n\n        c_min = dist(start_pos, goal_pos)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success_state = False\n\n        for iteration in range(self.max_iter):\n            q_rand = adaptive_sample(best_path, c_best, c_min)\n\n            # Alternate expanding smaller tree\n            if len(tree_start) <= len(tree_goal):\n                T_a, T_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                T_a, T_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in T_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r_a = neighbor_radius(len(nodes), iteration)\n            near_nodes_a = kdtree_a.radius_search(new_pos, r_a)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for n in near_nodes_a:\n                cost_cand = n.cost + dist(n.position, new_pos)\n                if cost_cand + 1e-12 < min_cost and can_connect(n.position, new_pos):\n                    min_cost = cost_cand\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            T_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve cost\n            for n in near_nodes_a:\n                if n is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, n.position)\n                if cost_via_new + 1e-12 < n.cost and can_connect(new_node.position, n.position):\n                    try:\n                        edges.remove((n.parent, n))\n                    except ValueError:\n                        pass\n                    n.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, n))\n\n            # Extend opposite tree toward new_node incrementally\n            kdtree_b = KDTree([(node.position, node) for node in T_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            max_steps = int(dist(nearest_b.position, new_node.position) / self.step_size) + 1\n            last_node_b = nearest_b\n            connected = False\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(node_b)\n                T_b.append(node_b)\n                nodes.append(node_b)\n                edges.append((last_node_b, node_b))\n\n                radius_b = neighbor_radius(len(nodes), iteration)\n                near_nodes_b = kdtree_b.radius_search(next_pos_b, radius_b)\n                for nbr in near_nodes_b:\n                    if nbr is last_node_b:\n                        continue\n                    cost_via_b = node_b.cost + dist(node_b.position, nbr.position)\n                    if cost_via_b + 1e-12 < nbr.cost and can_connect(node_b.position, nbr.position):\n                        try:\n                            edges.remove((nbr.parent, nbr))\n                        except ValueError:\n                            pass\n                        nbr.update_parent(node_b, cost_via_b)\n                        edges.append((node_b, nbr))\n\n                if dist(node_b.position, new_node.position) <= self.step_size and can_connect(node_b.position, new_node.position):\n                    connect_cost = node_b.cost + dist(node_b.position, new_node.position)\n                    connect_node = Node(new_node.position, parent=node_b, cost=connect_cost)\n                    node_b.children.append(connect_node)\n                    T_b.append(connect_node)\n                    nodes.append(connect_node)\n                    edges.append((node_b, connect_node))\n\n                    success_state = True\n\n                    if T_a is tree_start:\n                        path_start = connect_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connect_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if connect_cost + 1e-12 < c_best:\n                        c_best = connect_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = node_b\n\n            if connected:\n                break\n\n            # Prune nodes periodically to focus search\n            if (iteration > 0 and iteration % self.prune_interval == 0\n                and len(nodes) > self.prune_threshold and c_best < float('inf')):\n                prune_nodes(tree_start, c_best, goal_pos)\n                prune_nodes(tree_goal, c_best, goal_pos)\n                edge_collision_cache.clear()\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": -17.397,
    "time_improvement": 22.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024315524101257324,
            "num_nodes_avg": 86.7,
            "path_length_avg": 163.90813407712338,
            "smoothness_avg": 0.04138095604633246,
            "success_improvement": 0.0,
            "time_improvement": 3.4183930512782608,
            "length_improvement": 10.159354421735967,
            "smoothness_improvement": 547.7018223094196,
            "objective_score": 5.79589791127777
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04515397548675537,
            "num_nodes_avg": 198.3,
            "path_length_avg": 238.238857007528,
            "smoothness_avg": 0.10207962635027515,
            "success_improvement": 0.0,
            "time_improvement": 72.63863295378287,
            "length_improvement": 20.469012205602915,
            "smoothness_improvement": 2526.5823109755374,
            "objective_score": 38.51830388213313
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05607919692993164,
            "num_nodes_avg": 188.8,
            "path_length_avg": 122.05429354910082,
            "smoothness_avg": 0.11726916566471783,
            "success_improvement": 0.0,
            "time_improvement": -9.563132211802728,
            "length_improvement": 18.937349825582782,
            "smoothness_improvement": 1391.655131345799,
            "objective_score": 7.876805958304733
        }
    ],
    "smoothness_improvement": 1489.0,
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of bidirectional informed RRT* with adaptive ellipsoidal sampling, efficient nearest neighbor and radius search using KD-tree, collision caching, incremental rewiring, path pruning, and smoothing. It adaptively focuses sampling within ellipsoids constrained by the current best path cost to accelerate convergence. Caching of collision checks and pruning of nodes that cannot improve the solution improve efficiency. The planner grows two trees alternately from start and goal, rewires locally to optimize path costs, and smooths the final path for enhanced quality and reduced length, while ensuring nodes and edges do not cross obstacles or boundaries.",
    "planning_mechanism": "The planner initializes two trees rooted at the start and goal, alternately sampling points biased within an ellipsoid defined by the best path cost. It grows the smaller tree first by extending towards sampled points with a fixed step size. KD-tree enables efficient nearest and neighbor queries for rewiring. Collision checks with caching prevent redundant computations. Nodes unlikely to contribute to better solutions are periodically pruned. Upon connection of the two trees, the path is constructed and refined by shortcut smoothing for improved smoothness and reduced length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=300,\n                 smoothing_iterations: int=100,\n                 collision_check_resolution: float=1.0,\n                 goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.collision_check_resolution = collision_check_resolution\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / d\n                new_p = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n            # Clamp within bounds\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter) ** 0.9)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def is_in_obstacle(pos):\n            return self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_edge_in_obstacle(p1, p2):\n            return self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.collision_check_resolution)\n\n        class KDTree:\n            def __init__(self, points_nodes):\n                self.dim = dim\n                self.points = [p for p, n in points_nodes]\n                self.nodes = [n for p, n in points_nodes]\n\n            def nearest(self, pt):\n                best = None\n                best_dist = float('inf')\n                for i, p in enumerate(self.points):\n                    d = dist(pt, p)\n                    if d < best_dist:\n                        best_dist = d\n                        best = self.nodes[i]\n                return best\n\n            def radius_search(self, pt, radius):\n                r2 = radius * radius\n                result = []\n                for i, p in enumerate(self.points):\n                    sqd = 0.0\n                    for d in range(self.dim):\n                        delta = p[d] - pt[d]\n                        sqd += delta * delta\n                        if sqd > r2:\n                            break\n                    if sqd <= r2:\n                        result.append(self.nodes[i])\n                return result\n\n        # Ellipsoidal informed sampling focusing around best known cost\n        def informed_sample(c_best, c_min, start, goal):\n            import numpy as np\n            if c_best == float('inf') or c_best < c_min * 1.00001:\n                # Uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                for _ in range(10):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not is_in_obstacle(p):\n                        return p\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(start[d] + goal[d]) / 2 for d in range(dim)])\n            a1 = np.array([(goal[d] - start[d]) / c_min for d in range(dim)])\n            id_mat = np.eye(dim)\n            v = a1 - np.array([1] + [0]*(dim - 1))\n            norm_v = np.linalg.norm(v)\n            if norm_v > 1e-10:\n                v /= norm_v\n                rot = id_mat - 2 * np.outer(v, v)\n            else:\n                rot = id_mat\n            r1 = c_best / 2.0\n            r_others = math.sqrt(max(r1 * r1 - (c_min / 2) ** 2, 0))\n            radii = np.array([r1] + [r_others] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.uniform(-1, 1, dim)\n                if np.linalg.norm(x_ball) <= 1.0:\n                    sample = rot @ (x_ball * radii) + center\n                    p = tuple(float(coord) for coord in sample)\n                    if in_bounds(p) and not is_in_obstacle(p):\n                        return p\n            # Fallback uniform sampling\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not is_in_obstacle(p):\n                    return p\n            return p\n\n        edge_collision_cache = {}\n\n        def can_connect(p1, p2):\n            key = (p1, p2)\n            key_rev = (p2, p1)\n            if key in edge_collision_cache:\n                return not edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return not edge_collision_cache[key_rev]\n            if not in_bounds(p1) or not in_bounds(p2):\n                edge_collision_cache[key] = True\n                return False\n            collision = is_edge_in_obstacle(p1, p2)\n            edge_collision_cache[key] = collision\n            return not collision\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if is_in_obstacle(pos):\n                return False\n            return True\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_useless_nodes(best_cost):\n            removed = 0\n            to_remove = []\n            for node in nodes:\n                if node in (root_start, root_goal):\n                    continue\n                heuristic = dist(node.position, goal_pos)\n                if node.cost + heuristic >= best_cost:\n                    to_remove.append(node)\n            for rm_node in to_remove:\n                if rm_node.parent:\n                    try:\n                        rm_node.parent.children.remove(rm_node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(rm_node)\n                except ValueError:\n                    pass\n                if rm_node in tree_start:\n                    tree_start.remove(rm_node)\n                if rm_node in tree_goal:\n                    tree_goal.remove(rm_node)\n                removed += 1\n            return removed\n\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        nodes = [root_start, root_goal]\n        edges = []\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        c_best = float('inf')\n        c_min = dist(start_pos, goal_pos)\n        best_path = []\n\n        success_state = False\n        extracted_path = []\n\n        for it in range(self.max_iter):\n            q_rand = informed_sample(c_best, c_min, start_pos, goal_pos)\n\n            # Always extend the smaller tree for balanced growth\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = root_start, root_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = root_goal, root_start\n\n            kdtree_a = KDTree([(node.position, node) for node in tree_a])\n            nearest_a = kdtree_a.nearest(q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_a.position, new_pos):\n                continue\n\n            r = neighbor_radius(it, len(nodes))\n            near = kdtree_a.radius_search(new_pos, r)\n\n            min_cost = nearest_a.cost + dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring to improve path costs locally\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                c_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if c_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, c_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt connection from other tree to new_node\n            kdtree_b = KDTree([(node.position, node) for node in tree_b])\n            nearest_b = kdtree_b.nearest(new_node.position)\n            last_node_b = nearest_b\n            connected = False\n            max_steps = int(dist(last_node_b.position, new_node.position) / self.step_size) + 1\n\n            for _ in range(max_steps):\n                next_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(next_pos_b) or not can_connect(last_node_b.position, next_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                near_b = kdtree_b.radius_search(next_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    c_via_new_b = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if c_via_new_b + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, c_via_new_b)\n                        edges.append((new_node_b, neighbor_b))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    if final_cost + 1e-12 < c_best:\n                        c_best = final_cost\n                        best_path = shortcut_path(merged_path)\n\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                extracted_path = best_path\n                break\n\n            # Periodic pruning to enhance efficiency\n            if it > 0 and it % self.prune_interval == 0 and len(nodes) > self.prune_threshold and c_best < float('inf'):\n                prune_useless_nodes(c_best)\n                edge_collision_cache.clear()\n\n        if success_state and not extracted_path:\n            extracted_path = best_path if best_path else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px = pos[0]\n        py = pos[1]\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                pz = pos[2]\n                if (x <= px <= x + w) and (y <= py <= y + h) and (z <= pz <= z + d):\n                    return True\n            else:\n                x, y, w, h = obs\n                if (x <= px <= x + w) and (y <= py <= y + h):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -14.294,
    "time_improvement": 13.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.025380206108093262,
            "num_nodes_avg": 71.1,
            "path_length_avg": 160.2081177658318,
            "smoothness_avg": 0.04285002550308042,
            "success_improvement": 0.0,
            "time_improvement": -0.8105389956475871,
            "length_improvement": 12.18739199246528,
            "smoothness_improvement": 570.6959494429104,
            "objective_score": 5.047796447013332
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06816267967224121,
            "num_nodes_avg": 255.0,
            "path_length_avg": 240.95636092680706,
            "smoothness_avg": 0.09389179871655402,
            "success_improvement": 0.0,
            "time_improvement": 58.69634783513212,
            "length_improvement": 19.56183117833422,
            "smoothness_improvement": 2315.903608506025,
            "objective_score": 33.10078862873661
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06097874641418457,
            "num_nodes_avg": 214.7,
            "path_length_avg": 128.20711327034715,
            "smoothness_avg": 0.1258476055468169,
            "success_improvement": 0.0,
            "time_improvement": -19.135487332939576,
            "length_improvement": 14.85093993252154,
            "smoothness_improvement": 1500.7722534515328,
            "objective_score": 4.7334030538800995
        }
    ],
    "smoothness_improvement": 1462.0,
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved bidirectional RRT* planner integrates adaptive goal and start bias sampling with dynamic neighbor radius rewiring to minimize path cost. It balances tree growth by always extending the smaller tree, employs efficient collision and edge feasibility checks, and utilizes a priority queue to prioritize rewiring for better cost reduction. Periodic pruning of dead-end nodes maintains manageable tree sizes. After successfully connecting the trees, it applies iterative shortcut smoothing with a sampling-based approach to produce shorter and smoother paths faster. These enhancements collectively improve planning time, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree toward samples biased toward the goal or start to enhance connection probability. New nodes are connected optimally via dynamic neighborhood rewiring with collision-free edge checks. Periodic pruning removes dead-ends, and after path completion, shortcut smoothing refines path quality efficiently. This approach effectively balances exploration and exploitation, improving convergence speed and path optimality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 18.0,\n                 radius_min: float = 5.0, prune_interval: int = 150,\n                 prune_threshold: int = 150, smoothing_iterations: int = 40,\n                 smoothing_attempts: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.smoothing_attempts = smoothing_attempts\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive bias towards goal and start for faster connections\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                for _ in range(30):  # Limit sampling attempts to avoid loop\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback to goal if stuck (very rare)\n                return goal_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Use min(dist) for nearest\n            best_node = tree[0]\n            min_dist = dist(tree[0].position, point)\n            for node in tree[1:]:\n                cur_dist = dist(node.position, point)\n                if cur_dist < min_dist:\n                    min_dist = cur_dist\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                dx = tuple(node.position[d] - pos[d] for d in range(len(pos)))\n                dist_sq = sum(x * x for x in dx)\n                if dist_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            # Edge collision check with adaptive resolution for speed-efficiency\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=min(self.step_size * 0.5, 1.0))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Efficient rewiring using a queue to limit cost propagation\n            # Only rewire neighbors if cost reduces and edge is collision-free\n            queue = deque()\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n                    queue.append(neighbor)\n\n            while queue:\n                current = queue.popleft()\n                # Propagate rewiring cost downstream children if better cost\n                for child in current.children[:]:  # Copy to avoid mutation issues\n                    cost_via_current = current.cost + dist(current.position, child.position)\n                    if cost_via_current + 1e-12 < child.cost and can_connect(current.position, child.position):\n                        try:\n                            edges.remove((child.parent, child))\n                        except ValueError:\n                            pass\n                        child.update_parent(current, cost_via_current)\n                        edges.append((current, child))\n                        queue.append(child)\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Only prune if too many nodes present\n            if len(nodes) <= self.prune_threshold:\n                return removed\n\n            # Collect dead-end leaf nodes excluding roots\n            to_remove = [node for node in nodes if node not in (start_root, goal_root)\n                         and not node.children and node.valid]\n\n            # Prune up to 25% or 50 nodes at once for efficiency\n            max_prune = max(50, len(nodes) // 4)\n            to_remove = to_remove[:max_prune]\n\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    node.valid = False\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n\n            for _ in range(self.smoothing_attempts):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    # Remove nodes between i+1 and j-1 to shortcut path\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree to balance exploration/exploitation\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -21.08724,
    "time_improvement": 33.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022742700576782227,
            "num_nodes_avg": 81.2,
            "path_length_avg": 158.9885889580809,
            "smoothness_avg": 0.03933550360616804,
            "success_improvement": 0.0,
            "time_improvement": 9.665670420582511,
            "length_improvement": 12.855835056664144,
            "smoothness_improvement": 515.6860498497797,
            "objective_score": 8.04929838675648
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.06336371898651123,
            "num_nodes_avg": 228.6,
            "path_length_avg": 238.34145512298292,
            "smoothness_avg": 0.09977368425533109,
            "success_improvement": 0.0,
            "time_improvement": 61.60431160459332,
            "length_improvement": 20.43476200154105,
            "smoothness_improvement": 2467.24875996967,
            "objective_score": 34.90448968153456
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03628880977630615,
            "num_nodes_avg": 161.2,
            "path_length_avg": 127.4220791307348,
            "smoothness_avg": 0.14155632402086066,
            "success_improvement": 0.0,
            "time_improvement": 29.10177247548476,
            "length_improvement": 15.372322228743426,
            "smoothness_improvement": 1700.5859929443836,
            "objective_score": 20.307926153116032
        }
    ],
    "smoothness_improvement": 1561.0,
    "success_rate": 1.0
}
