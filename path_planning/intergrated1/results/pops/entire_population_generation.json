{
     "algorithm": "PathPlanning: \n    This algorithm is an improved version combining goal-biased informed sampling with heuristic-guided tree expansion for efficient pathfinding.\n    Key features:\n    - Uses a Forest graph to maintain a tree rooted at the start.\n    - Employs an adaptive max step size that shrinks as the tree approaches the goal, allowing finer movements near the goal for smoother paths.\n    - Incorporates goal bias with a probability of sampling directly near the goal.\n    - Uses a heuristic cost (distance to goal) to prioritize expansion towards more promising vertices.\n    - Implements rewiring optimization similar to RRT* but with an adaptive neighborhood radius based on graph size/log and distance to goal.\n    - Applies a path shortcutting technique on the extracted path to smooth and shorten it by attempting direct-valid line shortcuts.\n    - Early stopping if goal reached or if total planning time exceeds 10 seconds.\n    - The approach focuses on reducing total iterations, improving path smoothness, and enhancing success rate by adaptive sampling and rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with certain probability sample near goal, else random in space\n        import time\n        \n        if self._start_time is None:\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            # Sample in a small ball around goal for goal bias\n            for _ in range(30):  # max retry for valid pos\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback if can't sample near goal\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # If no valid sampled point found after retries (very rare), fallback to start pos\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Adaptive max move distance: smaller near goal, larger far away\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.3))\n        return scaled\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose first parent (assumes tree structure)\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path by skipping intermediate points\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j\n                    del path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along smoothed path with keyframes\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if self._start_time is None:\n                self._start_time = time.time()\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Stop searching after time limit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Cost from start through q_nearest to q_new\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Find nearby vertices for rewiring using adaptive radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size>0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among nearby vertices using cost + heuristic (distance to q_new)\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            # Reassign q_new with best parent found\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if q_new provides lower cost paths\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        # Add new edge from q_new to q_near\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if close enough to goal to consider connected\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                # Verify connection to goal is valid\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract and smooth path, then stop\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This path planning algorithm implements an improved version inspired by RRT* with goal-biased adaptive sampling,\n    dynamic step size, rewiring for path optimization, and early stopping criteria.\n    The method dynamically tunes the step size (`max_dist`) based on proximity to obstacles and goal to improve efficiency.\n    It increases sampling probability near the goal, and attempts rewiring of vertices within a radius to smooth the path.\n    The algorithm enforces a 10-second time limit for finding a path to treat as failure if exceeded.\n    Smooth shortcutting is applied after path extraction to improve path quality.\n    Overall, these enhancements improve planning efficiency, path smoothness, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring\n        self._init_displays()\n\n    def _get_goal_bias_sample(self, goal_prob=0.2) -> Point:\n        import random\n\n        if random.random() < goal_prob:\n            # Sample near the goal with some random noise within a radius\n            goal_pos = self._get_grid().goal.position\n            radius = 5\n            n_dim = self._get_grid().size.n_dim\n            for _ in range(20):\n                offset = tuple(np.random.randint(-radius, radius + 1) for _ in range(n_dim))\n                sample_candidate = Point(*(goal_pos[i] + offset[i] for i in range(n_dim)))\n                if self._get_grid().is_agent_valid_pos(sample_candidate):\n                    return sample_candidate\n            # fallback if no sample found near goal\n            return goal_pos\n        else:\n            return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex, vertices_within_radius: list, radius: float) -> None:\n        \"\"\"\n        Attempt to rewire the tree to improve cost,\n        by connecting lower-cost parents to neighbors if possible.\n        \"\"\"\n        grid = self._get_grid()\n        for q_near in vertices_within_radius:\n            if q_near == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n            proposed_cost = q_new.cost + grid.get_movement_cost(q_new.position, q_near.position)\n            if proposed_cost < q_near.cost:\n                # Remove old parent edges\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge with improved cost\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = proposed_cost\n\n    def _extract_path(self, q_new: Vertex):\n        grid = self._get_grid()\n        goal_v: Vertex = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: list = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # choose parent with smallest cost\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n\n        path.pop()  # Remove last (start duplicates)\n        path.reverse()\n\n        # Shortcut smooth path\n        path = self._shortcut_path(path)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Attempt to shortcut path by connecting non-adjacent vertices directly if feasible,\n        thus smoothing the path.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortcut_path.append(path[i + 1])\n                i += 1\n        return shortcut_path\n\n    def _get_adaptive_max_dist(self, pos: Point, base_dist=10, min_dist=2, max_dist=15) -> float:\n        \"\"\"\n        Adapt step size depending on proximity to obstacles and goal.\n        Closer to obstacles: smaller step size.\n        Closer to goal: smaller step size for finer maneuvering.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        # Check obstacles within a fixed radius\n        obs_check_radius = 5\n        nearby_points = grid.get_vertices_within_radius(self._graph.root_vertices, pos, obs_check_radius)\n        # Count how many obstacle vertices are nearby (approximation)\n        obstacle_proximity_factor = 0.0\n        for obs in nearby_points:\n            d = Map.get_distance(pos, obs.position)\n            if d < obs_check_radius:\n                obstacle_proximity_factor = max(obstacle_proximity_factor, (obs_check_radius - d) / obs_check_radius)\n        # Compute adaptive dist\n        max_dist = base_dist * (1 - 0.5 * obstacle_proximity_factor)\n        # Reduce max_dist near goal\n        if dist_to_goal < base_dist * 3:\n            max_dist = min(max_dist, max(min_dist, dist_to_goal / 2))\n        max_dist = max(min_dist, min(max_dist, max_dist))\n        return max_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        max_iterations = 8000\n        radius_rewire = 15.0  # neighborhood radius for rewiring\n        goal_reached = False\n        start_time = time.time()\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10:\n                # Timeout 10 seconds exceeded - treat as failure\n                break\n\n            q_sample = self._get_goal_bias_sample(goal_prob=0.25)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec).item()\n            if dist == 0:\n                continue\n            if dist > max_dist:\n                dir_normalized = dir_vec / dist\n                q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            else:\n                q_new_point = q_sample\n\n            if not grid.is_agent_valid_pos(q_new_point):\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_point)\n            movement_cost = grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = q_near.cost + movement_cost\n\n            # Search neighbors for better parent\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            min_cost = q_new.cost\n            best_parent = q_near\n\n            for q_nearby in neighbors:\n                if q_nearby == q_near:\n                    continue\n                line_seq2 = grid.get_line_sequence(q_nearby.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq2):\n                    continue\n                cost_through_nearby = q_nearby.cost + grid.get_movement_cost(q_nearby.position, q_new.position)\n                if cost_through_nearby < min_cost:\n                    min_cost = cost_through_nearby\n                    best_parent = q_nearby\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors using q_new if better cost paths found\n            self._rewire(q_new, neighbors, radius_rewire)\n\n            # Check goal reached\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_reached = True\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n        if not goal_reached:\n            # Optionally, attempt direct connection to goal if close enough at the end\n            q_near_goal = self._graph.get_nearest_vertex([self._graph.root_vertex_start], goal_pos)\n            line_seq_goal = grid.get_line_sequence(q_near_goal.position, goal_pos)\n            if grid.is_valid_line_sequence(line_seq_goal) and Map.get_distance(q_near_goal.position, goal_pos) < 20:\n                goal_v = Vertex(goal_pos)\n                self._graph.add_edge(q_near_goal, goal_v)\n                self._extract_path(goal_v)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an Adaptive Heuristic Guided Tree Planner (AHGTP) combining goal-biased and heuristic sampling \n    with adaptive step size and path smoothing. \n    It dynamically adjusts sampling density near the goal and obstacles, uses an A*-inspired cost heuristic to prioritize expansion, \n    and adapts the step size based on local obstacle density. \n    After connecting the start to the goal, it performs an iterative shortcut smoothing on the final path to reduce unnecessary waypoints,\n    improving path quality and smoothness. \n    Additionally, it enforces a maximum runtime of 10 seconds for robust early stopping.\n    This approach aims to improve planning efficiency, path quality, and success rate over traditional RRT* or SPRM algorithms.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_step_dist: float\n    _goal_sample_rate: float\n    _heuristic_weight: float\n    _max_runtime_sec: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_step_dist = 15.0\n        self._goal_sample_rate = 0.3  # 30% of samples biased towards goal\n        self._heuristic_weight = 1.2  # weight on heuristic cost for priority calculation\n        self._max_runtime_sec = 10.0  # max time to run planner (seconds)\n        self._init_displays()\n\n    def _get_adaptive_step_dist(self, position: Point) -> float:\n        \"\"\"\n        Adapt step size based on obstacle density around position:\n        More obstacles nearby => reduce step size to improve safety.\n        \"\"\"\n        radius = 5.0\n        nearby_obstacles_points = 0\n        # Count obstacles within radius by sampling around\n        for obstacle in self._get_grid().obstacles:\n            obstacle_points = self._get_grid().get_obstacle_bound(obstacle.position)\n            for p in obstacle_points:\n                dist = Map.get_distance(position, p)\n                if dist <= radius:\n                    nearby_obstacles_points += 1\n                    if nearby_obstacles_points > 15:\n                        # Early exit if crowded\n                        return max(self._max_step_dist * 0.3, 5.0)\n        # Scale step distance inversely\n        scale = 1.0 - min(nearby_obstacles_points / 20.0, 0.7)\n        adaptive_dist = max(self._max_step_dist * scale, 5.0)\n        return adaptive_dist\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal-biased adaptive random sampling\"\"\"\n        if torch.rand(1).item() < self._goal_sample_rate:\n            # Bias sample towards a small region near the goal\n            goal_pos = self._get_grid().goal.position\n            size = self._get_grid().size\n            perturb_dim = size.n_dim\n            # Uniform small random offset around goal\n            low_offset = torch.tensor([-3.0] * perturb_dim)\n            high_offset = torch.tensor([3.0] * perturb_dim)\n            offset = torch.empty(perturb_dim).uniform_(low_offset.min().item(), high_offset.max().item())\n            sampled = Point(*(torch.clamp(goal_pos.to_tensor() + offset, min=0, max=torch.tensor(size).float()).int()))\n            if self._get_grid().is_agent_valid_pos(sampled):\n                return sampled\n        # Otherwise uniform sampling\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search nearest in start tree only to maintain single tree growth\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_point = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new_point)\n\n    def _heuristic_cost(self, frm: Vertex) -> float:\n        \"\"\"Estimate total cost f = g + h for A*-like guidance.\"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        h = Map.get_distance(frm.position, goal_pos)\n        return frm.cost + self._heuristic_weight * h\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent minimizing cost + heuristic, validate edge collision.\"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, neighbors: list, q_new: Vertex) -> None:\n        \"\"\"Try rewiring neighbors to achieve lower cost through q_new.\"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Rewire edge\n                old_parents = list(q_near.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_near)\n                q_near.cost = None  # Clear stale cost\n                q_near.cost = potential_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"Extract path and perform shortcut smoothing.\"\"\"\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut smoothing (attempt to reduce unnecessary waypoints)\n        def line_clear(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        smoothed_path = [path[0].position]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if line_clear(path[i].position, path[j].position):\n                    smoothed_path.append(path[j].position)\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i+1].position)\n                i += 1\n\n        # Move the agent along the smoothed path\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 5000\n        dimension = self._get_grid().size.n_dim\n        c_best = float(\"inf\")\n        c_min = Map.get_distance(self._get_grid().agent.position, self._get_grid().goal.position)\n        goal_reached = False\n        radius_constant = 30.0\n\n        for iter_index in range(max_iterations):\n            # Abort if exceed max runtime\n            if time.time() - start_time > self._max_runtime_sec:\n                # Fail early gracefully\n                break\n\n            # Adaptive sampling and step size\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            adaptive_step = self._get_adaptive_step_dist(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_step)\n\n            # Check collision free path for new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Radius for neighborhood search inspired by RRT*\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(radius_constant * ((log_card / card_v) ** (1.0 / dimension)), radius_constant)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            if not neighbors:\n                neighbors = [q_nearest]\n\n            # Choose best parent minimizing cost + heuristic\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                continue\n\n            # Update q_new's cost and add to graph\n            q_new.cost = parent.cost + Map.get_distance(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(neighbors, q_new)\n\n            # Check if reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect the goal vertex directly from q_new if collision free\n                goal_vertex = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    goal_reached = True\n                    break\n\n            # Key frame update for visualization\n            self.key_frame()\n\n        if not goal_reached:\n            # No path found within time/iterations\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed RRT* (Rapidly-exploring Random Tree Star) inspired path planner \n    enhanced with adaptive step size, goal-biased sampling, and path smoothing. \n    \n    Key features:\n    - Adaptive step size that decreases near obstacles or densely connected areas.\n    - Goal-biased sampling to increase the chance of connecting to the goal.\n    - Rewiring to improve path quality by checking alternate parent connections within a neighborhood radius.\n    - Path shortcut smoothing after a solution is found to create a shorter, smoother final route.\n    - Early stopping criteria with timeout of 10 seconds to prevent excessive planning times.\n    - Heuristic-driven nearest vertex search to reduce unnecessary expansions.\n    \n    The algorithm builds a single search tree rooted at the agent's start, expanding towards random \n    samples that are biased towards the goal. Whenever a new vertex is added, it tries to rewire nearby nodes \n    to reduce overall cost. After reaching goal vicinity, it extracts and smooths the path for better quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, store_connectivity=True), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._goal_sample_rate = 0.2  # 20% chance to sample goal directly\n        self._radius_neighborhood = 30.0  # Radius for rewiring nearby vertices\n        self._iterations = 10000\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: sometimes directly sample the goal to speed up connection.\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertices: list, point: Point) -> Vertex:\n        # Heuristic: Nearest vertex considering cost + heuristic distance (like A*)\n        candidates = self._graph.root_vertices if root_vertices is None else root_vertices\n        nearest_vertex = None\n        best_cost = float('inf')\n        for vertex in candidates:\n            dist = self._get_grid().get_distance(vertex.position, point)\n            cost_est = vertex.cost + dist\n            if cost_est < best_cost:\n                best_cost = cost_est\n                nearest_vertex = vertex\n        # If root_vertices is large, fall back to graph method for performance.\n        if nearest_vertex is None:\n            nearest_vertex = self._graph.get_nearest_vertex(root_vertices, point)\n        return nearest_vertex\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Returns cost from from_vertex to to_point including movement cost + from_vertex cost\n        move_cost = self._get_grid().get_movement_cost(from_vertex.position, to_point)\n        return from_vertex.cost + move_cost\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        # Choose the best parent vertex around q_new (lowest cost path + valid connection)\n        min_cost = float('inf')\n        best_parent = None\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                continue\n            cost = self._cost(neighbor, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, neighbors: list, q_new: Vertex) -> None:\n        # Try to improve cost of neighbors by rewiring through q_new\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                continue\n            new_cost = self._cost(q_new, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parent edge(s)\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                # Add edge from q_new to neighbor\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Trace back path from goal to start\n        path: list = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n        # Smooth path by shortcutting\n        path_smoothed = self._shortcut_smooth(path)\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Reduce max_dist when near obstacles or in constrained spaces\n        # Check surroundings for obstacles within 2*max_dist radius bounding box\n        check_radius = self._max_dist * 2\n        obstacle_nearby = False\n        for obstacle in self._get_grid().obstacles:\n            d = self._get_grid().get_distance(pos, obstacle.position)\n            if d < check_radius + obstacle.radius:\n                obstacle_nearby = True\n                break\n        if obstacle_nearby:\n            return max(self._max_dist * 0.5, 3.0)  # smaller step near obstacle\n        return self._max_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        for i in range(self._iterations):\n            if time() - start_time > 10.0:\n                # Timeout: stop and consider no path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            nearest_vertex: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            # Adaptive step size based on proximity to obstacles/environment\n            local_max_dist = self._adaptive_max_dist(nearest_vertex.position)\n            q_new: Vertex = self._get_new_vertex(nearest_vertex, q_sample, local_max_dist)\n\n            # Check valid path from nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._radius_neighborhood)\n\n            # Choose best parent among neighbors + nearest_vertex (include nearest if not in neighbors)\n            if nearest_vertex not in neighbors:\n                neighbors.append(nearest_vertex)\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n            q_new.cost = self._cost(best_parent, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new to improve path cost\n            self._rewire(neighbors, q_new)\n\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal reached or within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                # Connect q_new to goal_vertex, if path valid\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Extract and smooth path then exit\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an RRT* inspired path planner that combines goal-biased adaptive sampling,\n    rewiring for path optimization, and an adaptive step size for efficient exploration and smoother paths.\n    It balances exploration and exploitation by sampling towards the goal with a bias while considering the\n    environment's clearance to adjust the extension step. The rewiring step tries to reduce total path cost dynamically,\n    improving path quality and success rate. An early timeout of 10 seconds ensures practical responsiveness.\n    A final path shortcutting step smooths the found path before tracing it.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, return goal point directly\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Adapt step size by estimating clearance to nearest obstacle bound or environment border.\n        # Sample neighbors; if free space large, increase max_dist, else reduce it.\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=5):\n            # Check a line from pos in direction towards goal scaled by radius if collision-free\n            direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            # Also validate line sequence\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        \n        # Check validity of the line along new connection\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent from neighbors that minimize cost + movement cost if edge is valid\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # Try to rewire neighbors through q_new if it reduces cost and line is valid\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            dist = Map.get_distance(q_new.position, v.position)\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to v and add edge from q_new to v\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new up to start, add goal edge, shortcut path and trace agent\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Pick parent with minimum cost (could be multiple parents)\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove the start duplicate\n        path.reverse()\n\n        # Shortcut smoothing to improve path quality: try to skip intermediate vertices if direct line is valid\n        smoothed_path = [path[0]]\n        for v in path[1:]:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed_path[-1].position, v.position)):\n                # can connect directly\n                continue\n            else:\n                # add previous vertex since current direct connection invalid\n                prev_index = path.index(v) - 1\n                smoothed_path.append(path[prev_index])\n        # Always append last vertex (goal)\n        smoothed_path.append(path[-1])\n\n        # Trace the path to move agent\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 10000\n        goal_sample_rate: float = 0.3\n        search_radius: float = 15.0  # radius for rewiring\n        start_time = time.time()\n        \n        # Initialize start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failed\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for potential parents\n            q_near_list: List[Vertex] = self._get_near_vertices(q_new, search_radius)\n            chosen_parent: Optional[Vertex] = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and set cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Check for goal reach with some radius threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "A Novel Bidirectional Heuristic-Enhanced RRT* with Informed and Adaptive Sampling\n    -------------------------------------------------------------------------------\n    This algorithm combines bidirectional tree growth with heuristic-driven informed sampling \n    and adaptive step sizing while employing rewiring to optimize the path. \n    \n    Key ideas:\n    - Two forests (start-rooted and goal-rooted) grow simultaneously and attempt connection.\n    - Adaptive step size modulates based on proximity to goal or other tree (for finer control).\n    - Heuristic cost (g + h) guides vertex selection and expansion.\n    - Informed sampling within an ellipsoidal region defined by current best path cost, biases sampling to promising regions.\n    - Rewiring with neighbors optimizes paths in both trees.\n    - Early termination when trees connect.\n    - Timeout after 10 seconds enforced.\n    - Extracted path smoothened via shortcutting.\n    This approach aims to improve planning efficiency, success rate, and path quality by blending bidirectional RRT*, heuristic guidance, and informed sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Bidirectional trees within one forest: maintain two root vertices\n        # Extend from and toward each other's trees to try connecting them.\n\n        max_iterations = 6000\n        start_time = time.time()\n        time_limit = 10.0  # seconds\n\n        dimension = 2\n        rewire_lambda = 40\n        min_step = 3.0\n        max_step = 12.0\n\n        # Track best connection cost and vertices to extract path if found\n        best_connection_cost = math.inf\n        best_connection_pair = None\n\n        def adaptive_max_dist(pos_a: Point, pos_b: Point) -> float:\n            \"\"\"Adaptive step size decreases as points get nearer.\"\"\"\n            d = Map.get_distance(pos_a, pos_b)\n            step = max(min_step, min(max_step, d * 0.5))\n            return step\n\n        def cost_heuristic(pos: Point) -> float:\n            \"\"\"Heuristic from pos to goal.\"\"\"\n            return Map.get_distance(pos, goal_vertex.position)\n\n        def informed_sample(c_best: float, start: Point, goal: Point) -> Point:\n            \"\"\"Sample within an ellipse defined by start, goal and best cost (c_best).\"\"\"\n            # If no solution found yet, sample uniformly.\n            if c_best == math.inf:\n                for _ in range(50):\n                    candidate_coords = []\n                    for dim in range(dimension):\n                        candidate_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                    candidate = Point(*candidate_coords)\n                    if grid.is_agent_valid_pos(candidate):\n                        return candidate\n                return start\n\n            # Ellipse sampling inspired by Informed RRT*\n            center = Point(\n                (start.x + goal.x) / 2,\n                (start.y + goal.y) / 2\n            )\n            c_min = Map.get_distance(start, goal)\n            if c_min == 0:\n                return start\n\n            a1 = (goal.x - start.x) / c_min\n            a2 = (goal.y - start.y) / c_min\n\n            # ellipse radii\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n            for _ in range(100):  # sampling retries\n                # Sample random point in unit circle\n                while True:\n                    x = torch.rand(1).item() * 2 - 1\n                    y = torch.rand(1).item() * 2 - 1\n                    if x * x + y * y <= 1:\n                        break\n                sample_ellipse_x = r1 * x\n                sample_ellipse_y = r2 * y\n\n                # Rotate sample back to original coordinate frame\n                sample_x = center.x + sample_ellipse_x * a1 - sample_ellipse_y * a2\n                sample_y = center.y + sample_ellipse_x * a2 + sample_ellipse_y * a1\n\n                sample_point = Point(round(sample_x), round(sample_y))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback to uniform sampling \n            for _ in range(50):\n                candidate_coords = []\n                for dim in range(dimension):\n                    candidate_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                candidate = Point(*candidate_coords)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n\n            return start  # fallback\n\n        def extract_and_smooth_path(v_start: Vertex, v_goal: Vertex) -> None:\n            # Extract path from start tree root to connection vertex and from goal tree root to connection vertex\n            path_start = []\n            current = v_start\n            while True:\n                path_start.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n            path_start.reverse()\n\n            path_goal = []\n            current = v_goal\n            while True:\n                path_goal.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n\n            full_path = path_start + path_goal\n\n            # Shortcut smoothing\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(seq):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n            # Follow path\n            for v in full_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        root_start_list = [start_vertex]\n        root_goal_list = [goal_vertex]\n\n        for iteration in range(max_iterations):\n\n            current_time = time.time()\n            if current_time - start_time > time_limit:\n                # No path found within time limit\n                return\n\n            # Alternate growth between start tree and goal tree\n            grow_from_start = (iteration % 2 == 0)\n            tree_roots = root_start_list if grow_from_start else root_goal_list\n            other_roots = root_goal_list if grow_from_start else root_start_list\n\n            # Current root vertices\n            root_vertex = tree_roots[0]\n\n            # Obtain informed sample\n            q_sample = informed_sample(best_connection_cost, start_vertex.position, goal_vertex.position)\n\n            # Find nearest vertex in current tree\n            q_nearest = self._graph.get_nearest_vertex(tree_roots, q_sample)\n            if q_nearest.position == q_sample:\n                # sample same as vertex, skip\n                continue\n\n            # Compute adaptive max dist from q_nearest towards sample\n            max_dist = adaptive_max_dist(q_nearest.position,\n                                        goal_vertex.position if grow_from_start else start_vertex.position)\n\n            # Steer towards sample\n            q_nearest_tensor = q_nearest.position.to_tensor()\n            q_sample_tensor = q_sample.to_tensor()\n            dir_vec = q_sample_tensor - q_nearest_tensor\n            dir_norm = torch.norm(dir_vec).item()\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest_tensor + dir_normalized * max_dist).round().int())\n\n            # Validate position and path\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Cost: g-cost from start of the current tree plus cost to q_new\n            dist_nearest_to_new = Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Find neighbors for rewiring with adaptive radius\n            card_v = self._graph.size if self._graph.size > 0 else 1\n            radius = min(rewire_lambda * ((math.log(card_v) / card_v) ** (1 / dimension)), 25.0)\n            neighbors = self._graph.get_vertices_within_radius(tree_roots, q_new.position, radius)\n\n            # Choose best parent from neighbors minimizing cost + validate path\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                dist_candidate = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_candidate\n                line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_cand):\n                    q_min = q_near\n                    c_min = cost_candidate\n            q_new.cost = c_min\n\n            # Add edge chosen parent -> q_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for lower cost paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_new_to_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old edge from some parent to q_near\n                        for p in q_near.parents:\n                            self._graph.remove_edge(p, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Try to connect q_new in current tree with nearest in other tree\n            q_other_near = self._graph.get_nearest_vertex(other_roots, q_new.position)\n            dist_to_other = Map.get_distance(q_new.position, q_other_near.position)\n            if dist_to_other <= max_dist:\n                # Check line validity both ways to ensure bidirectional connectivity\n                line1 = grid.get_line_sequence(q_new.position, q_other_near.position)\n                line2 = grid.get_line_sequence(q_other_near.position, q_new.position)\n                if grid.is_valid_line_sequence(line1) and grid.is_valid_line_sequence(line2):\n                    # Connect trees by adding edges both ways to maintain connectivity\n                    self._graph.add_edge(q_new, q_other_near)\n                    self._graph.add_edge(q_other_near, q_new)\n\n                    # Determine total path cost through connection\n                    total_cost = q_new.cost + q_other_near.cost + dist_to_other\n                    if total_cost < best_connection_cost:\n                        best_connection_cost = total_cost\n                        best_connection_pair = (q_new, q_other_near)\n\n                        # Extract and smooth path\n                        extract_and_smooth_path(q_new, q_other_near)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is a novel hybrid method integrating heuristic-guided bidirectional search with adaptive incremental sampling. \n    \n    Key features and innovations:\n    - Uses a CyclicGraph structure to maintain two expanding trees simultaneously: one from start and one from goal, aiming to connect them.\n    - Applies heuristic (A*-like) cost estimation combining exact cost-from-root plus admissible heuristic to guide vertex expansions.\n    - Sampling is adaptive and goal-biased: alternating samples near start, near goal, and globally random valid points to balance exploration.\n    - Employs an adaptive step size based on local density and distance to opposite root to control expansion length, allowing finer control near tree frontiers.\n    - Connect attempts between trees use a heuristic-ordered edge candidates queue to prioritize promising connections.\n    - When a connection is made, performs a shortcut and smoothing step by attempting direct valid line shortcuts across the constructed path.\n    - Early stopping after success or after 10 seconds to guarantee bounded runtime.\n    - Uses rewiring akin to RRT* with local radius adaptive to graph size and distance heuristics to optimize path cost inside each tree.\n    - The bidirectional approach improves planning efficiency by growing from both ends to meet in middle, potentially reducing iterations compared to unidirectional growth.\n    \n    Overall, this method blends concepts from RRT*, heuristic A*, and bidirectional search with focused incremental sampling and rewiring, aiming for efficient, robust, and high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.0\n        self._goal_sample_rate = 0.25\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._init_displays()\n\n    def _get_heuristic_cost(self, frm_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance as admissible heuristic\n        return Map.get_distance(frm_pos, to_pos)\n\n    def _get_adaptive_step_size(self, current_pos: Point, opposite_root_pos: Point) -> float:\n        # Step size shrinks when closer to opposite root position for finer connect attempts\n        dist = Map.get_distance(current_pos, opposite_root_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.2))\n        return scaled\n\n    def _get_bidirectional_sample(self, iteration: int) -> Point:\n        # Alternates sampling near start, near goal and globally random\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        mode = iteration % 3\n        # 0: sample near start with some noise\n        # 1: sample near goal with some noise\n        # 2: uniform random sample\n        if mode == 0:\n            for _ in range(30):\n                offset = torch.randn(self._dimension) * self._min_max_dist\n                sample = Point(*(start_pos.to_tensor() + offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return start_pos\n        elif mode == 1:\n            for _ in range(30):\n                offset = torch.randn(self._dimension) * self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return start_pos  # fallback\n\n    def _create_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_norm = dir_tensor / norm\n            new_pos = Point.from_tensor((q_near.position.to_tensor() + dir_norm * max_dist).round().int())\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        q_new = Vertex(new_pos)\n        return q_new\n\n    def _try_add_vertex_with_rewire(self, tree_root: Vertex, q_near: Vertex, q_new: Vertex) -> bool:\n        # Adds q_new connecting from best parent in neighborhood, rewires neighbors if better path found.\n        grid = self._get_grid()\n\n        dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n        q_new.cost = q_near.cost + dist_near_new\n\n        card_v = max(self._graph.size, 1)\n        log_card_v = torch.log(torch.tensor(float(card_v))) if card_v > 1 else torch.tensor(0.0)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 20.0)\n\n        vertices_near = self._graph.get_vertices_within_radius([tree_root], q_new.position, radius)\n\n        q_min = q_near\n        c_min = q_new.cost\n\n        for q_near_candidate in vertices_near:\n            dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n            cost_candidate = q_near_candidate.cost + dist\n            if cost_candidate < c_min:\n                line_seq = grid.get_line_sequence(q_near_candidate.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    q_min = q_near_candidate\n                    c_min = cost_candidate\n\n        q_new.cost = c_min\n        self._graph.add_edge(q_min, q_new)\n\n        for q_near_candidate in vertices_near:\n            if q_near_candidate == q_min:\n                continue\n            dist_new_near = torch.norm(q_new.position.to_tensor() - q_near_candidate.position.to_tensor()).item()\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new < q_near_candidate.cost:\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near_candidate.position)\n                if grid.is_valid_line_sequence(line_seq_rewire):\n                    # Remove old parent edge(s)\n                    for parent in q_near_candidate.parents:\n                        self._graph.remove_edge(parent, q_near_candidate)\n                        break\n                    q_near_candidate.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near_candidate)\n        return True\n\n    def _try_connect_trees(self, q_new: Vertex, opposite_root: Vertex) -> Vertex:\n        # Attempt to connect q_new to the opposite tree.\n        grid = self._get_grid()\n        oppos_vertices = self._graph.root_vertices if opposite_root in self._graph.root_vertices else [opposite_root]\n        # Gather candidates near q_new from opposite tree within step radius\n        max_step = self._get_adaptive_step_size(q_new.position, opposite_root.position)\n        candidates = self._graph.get_vertices_within_radius([opposite_root], q_new.position, max_step)\n        candidates += self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, max_step)\n        candidates = list(set(candidates))\n        candidates.sort(key=lambda v: Map.get_distance(v.position, q_new.position))  # prioritize closer connections\n\n        for q_opposite in candidates:\n            line_seq = grid.get_line_sequence(q_new.position, q_opposite.position)\n            if grid.is_valid_line_sequence(line_seq):\n                return q_opposite\n        return None\n\n    def _extract_bidirectional_path(self, connect_v_start: Vertex, connect_v_goal: Vertex) -> None:\n        # Extract path moving backward to start root and forward to goal root, then smooth.\n        path_start = []\n        cur = connect_v_start\n        while True:\n            path_start.append(cur)\n            if len(cur.parents) == 0:\n                break\n            cur = next(iter(cur.parents))\n        path_start.reverse()\n\n        path_goal = []\n        cur = connect_v_goal\n        # Walk children on goal side (tree direction is from goal to leaves)\n        while True:\n            path_goal.append(cur)\n            if len(cur.children) == 0:\n                break\n            cur = next(iter(cur.children))\n\n        full_path = path_start + path_goal[1:]  # avoid duplication at connection point\n\n        # Shortcut smoothing: attempt to connect across intermediate vertices with direct valid line\n        grid = self._get_grid()\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early stop on time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # Alternate sample from start or goal tree for balanced bidirectional growth\n            sample_point = self._get_bidirectional_sample(iteration)\n\n            # Decide which tree to expand on this iteration: alternate start/goal trees\n            if iteration % 2 == 0:\n                tree_root, opposite_root = start_vertex, goal_vertex\n            else:\n                tree_root, opposite_root = goal_vertex, start_vertex\n\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_point)\n            if q_near.position == sample_point:\n                continue\n\n            max_dist = self._get_adaptive_step_size(q_near.position, opposite_root.position)\n            q_new = self._create_new_vertex(q_near, sample_point, max_dist)\n            if q_new is None:\n                continue\n\n            success = self._try_add_vertex_with_rewire(tree_root, q_near, q_new)\n            if not success:\n                continue\n\n            # Attempt connection between trees to complete path\n            q_connect = self._try_connect_trees(q_new, opposite_root)\n            if q_connect is not None:\n                # Link both vertices (bidirectional)\n                dist_connect = Map.get_distance(q_new.position, q_connect.position)\n                # Add edges in both directions for cyclic graph connectivity\n                self._graph.add_edge(q_new, q_connect)\n                self._graph.add_edge(q_connect, q_new)\n                # Extract and smooth resulting path traversing start-to-connection and goal-to-connection\n                if tree_root == start_vertex:\n                    self._extract_bidirectional_path(q_new, q_connect)\n                else:\n                    self._extract_bidirectional_path(q_connect, q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed bidirectional tree search on a Forest graph\n    combining several improvements inspired by RRT*, A*, and bidirectional search:\n    - Uses two trees grown simultaneously from start and goal (bidirectional growth).\n    - Samples a dynamically shrinking ellipsoidal informed region based on current best path cost,\n      thus focusing samples to improve path quality and efficiency.\n    - Uses heuristic combined cost (cost-to-come + cost-to-go) for selecting expansions.\n    - Adaptive step size based on distance to target vertex to allow finer movements near connections.\n    - Implements rewiring in both trees to optimize path quality.\n    - Tries to connect the two trees directly when vertices are close, allowing early stopping.\n    - Performs path shortcutting on the combined path after connection.\n    - Stops after finding a viable path or when time budget (10s) exceeded.\n    This approach improves success rate and path quality with fewer iterations by focused sampling and dual expansions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.0   # Min step size near goal/connection\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # planning time limit seconds\n        self._best_path_cost = float('inf')\n        self._best_path = None\n        self._init_displays()\n\n    def _sample_informed_region(self, c_best: float, c_min: float, start_pos: Point, goal_pos: Point) -> Point:\n        \"\"\"\n        Sample a point inside an ellipse defined by start and goal positions and current best cost.\n        If no better path found yet, sample uniformly in full grid.\n        \"\"\"\n        import math\n        import random\n\n        grid = self._get_grid()\n        if c_best == float('inf'):\n            # Uniform random sampling in grid\n            for _ in range(100):\n                coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n                pt = Point(*coords)\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n            return start_pos\n\n        # Construct ellipse parameters:\n        # foci are start and goal positions\n        # c_best is current best solution cost (ellipse major axis length)\n        # c_min is direct Euclidean distance start-goal (ellipse focal length)\n        # Sample inside ellipse with covariance aligned to start-goal vector.\n\n        start_tensor = start_pos.to_tensor().float()\n        goal_tensor = goal_pos.to_tensor().float()\n        center = (start_tensor + goal_tensor) / 2.0\n        diff = goal_tensor - start_tensor\n        e = c_min / c_best  # eccentricity\n        if e > 1.0:\n            e = 1.0  # numerical stability\n\n        # Create rotation matrix that aligns x-axis with line start->goal\n        angle = torch.atan2(diff[1], diff[0]).item()\n        cos_angle = math.cos(angle)\n        sin_angle = math.sin(angle)\n\n        # lengths of ellipse axes\n        a = c_best / 2.0  # major axis\n        b = math.sqrt(a * a - (c_min/2.0)**2)  # minor axis, safe sqrt\n\n        # Try sampling in unit circle then scale/rotate to ellipse region\n        for _ in range(100):\n            # sample random point in unit circle\n            r = random.uniform(0, 1) ** 0.5\n            theta = random.uniform(0, 2 * math.pi)\n            x_unit = r * math.cos(theta)\n            y_unit = r * math.sin(theta)\n\n            # scale by ellipse axes\n            x_ellipse = x_unit * a\n            y_ellipse = y_unit * b\n\n            # rotate back by angle and translate to ellipse center\n            x_rot = cos_angle * x_ellipse - sin_angle * y_ellipse\n            y_rot = sin_angle * x_ellipse + cos_angle * y_ellipse\n\n            sample_coords = (center + torch.tensor([x_rot, y_rot])).round().int()\n            sample_point = Point(int(sample_coords[0].item()), int(sample_coords[1].item()))\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform in grid if no ellipse sample valid\n        for _ in range(100):\n            coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n            pt = Point(*coords)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n        return start_pos\n\n    def _get_adaptive_max_dist_for_connection(self, q_pos: Point, target_pos: Point) -> float:\n        # Sharper adaptive step size based on distance to target, but with guaranteed min step for smoother connection\n        base_dist = Map.get_distance(q_pos, target_pos)\n        scaled_dist = max(self._min_max_dist, min(self._max_max_dist, 0.4 * base_dist))\n        return scaled_dist\n\n    def _rewire_nearby(self, graph: Forest, q_new: Vertex, radius: float) -> None:\n        grid = self._get_grid()\n        vertices_near = graph.get_vertices_within_radius(graph.root_vertices, q_new.position, radius)\n\n        for q_near in vertices_near:\n            if q_near == q_new:\n                continue\n            dist_new_near = Map.get_distance(q_new.position, q_near.position)\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new < q_near.cost:\n                line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    graph.remove_edge(parent, q_near)\n                    break\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, q_new_start: Vertex, graph_goal: Forest) -> (bool, Vertex):\n        \"\"\"\n        Try to connect vertex from start tree to goal tree vertex within adaptive radius.\n        Return (success, combined_goal_vertex) pair.\n        \"\"\"\n        grid = self._get_grid()\n        radius = self._get_adaptive_max_dist_for_connection(q_new_start.position, grid.goal.position)\n        vertices_near_goal = graph_goal.get_vertices_within_radius(graph_goal.root_vertices, q_new_start.position, radius)\n\n        best_connection_vertex = None\n        best_cost = float('inf')\n        for q_goal_vertex in vertices_near_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n            if grid.is_valid_line_sequence(line_seq):\n                dist_connect = Map.get_distance(q_new_start.position, q_goal_vertex.position)\n                total_cost = q_new_start.cost + dist_connect + q_goal_vertex.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_vertex = q_goal_vertex\n\n        if best_connection_vertex is None:\n            return False, None\n\n        # Create connecting vertex in goal tree to start tree: merge vertices by adding edge start->goal vertex\n        # We connect start tree vertex to goal tree vertex to form a path\n        self._graph_start.add_edge(q_new_start, best_connection_vertex)\n        return True, best_connection_vertex\n\n    def _extract_bidirectional_path_and_smooth(self, q_start_goal: Vertex, graph_goal: Forest):\n        \"\"\"\n        Extract path from start root to connection vertex and from connection vertex to goal root,\n        combine, smooth, and move agent along path with keyframes.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Extract path from start tree root to q_start_goal\n        path_start = []\n        current = q_start_goal\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        # Extract path from q_start_goal to goal root (in goal tree)\n        # Since q_start_goal is connected in goal tree, run dfs parents to goal root\n        path_goal = []\n        current_goal = q_start_goal\n        while True:\n            # Since q_start_goal in goal tree, have parents (or root)\n            # We follow parents towards goal root (which has no parents)\n            if len(current_goal.parents) == 0:\n                break\n            current_goal = next(iter(current_goal.parents))\n            path_goal.append(current_goal)\n\n        # Combine paths: start->connection->goal\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing on full path\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediates between i and j\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along path and render keyframes\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_pos = self._graph_start.root_vertex_start.position\n        goal_pos = self._graph_goal.root_vertex_start.position  # goal start in reversed graph\n\n        c_min = Map.get_distance(start_pos, goal_pos)\n        c_best = float('inf')\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Check time limit to stop\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit_seconds:\n                return\n\n            # Alternate growth: sample and grow start tree on even iter, goal tree on odd iter\n            grow_start_tree = (iteration % 2 == 0)\n            graph_grow = self._graph_start if grow_start_tree else self._graph_goal\n            graph_other = self._graph_goal if grow_start_tree else self._graph_start\n            root_vertex = graph_grow.root_vertex_start\n\n            # Sample point in informed region (ellipse) or fallback uniform\n            sample_pt = self._sample_informed_region(c_best, c_min, start_pos, goal_pos)\n\n            # Find nearest vertex in growing graph to sample point using cost + heuristic\n            nearest_v = None\n            min_cost_heuristic = float('inf')\n            for v in graph_grow.root_vertices:\n                dist = Map.get_distance(v.position, sample_pt)\n                cost_to_come = v.cost\n                heuristic = cost_to_come + dist\n                if heuristic < min_cost_heuristic:\n                    min_cost_heuristic = heuristic\n                    nearest_v = v\n            if nearest_v is None:\n                continue\n\n            if nearest_v.position == sample_pt:\n                continue\n\n            # Adaptive max step size based on distance to sample\n            max_step = self._get_adaptive_max_dist_for_connection(nearest_v.position, sample_pt)\n\n            dir_vec = sample_pt.to_tensor() - nearest_v.position.to_tensor()\n            dist_nearest_to_sample = torch.norm(dir_vec)\n            if dist_nearest_to_sample == 0:\n                continue\n            if dist_nearest_to_sample <= max_step:\n                new_pos = sample_pt\n            else:\n                direction_normalized = dir_vec / dist_nearest_to_sample\n                new_pos = Point.from_tensor((nearest_v.position.to_tensor() + direction_normalized * max_step).round().int())\n\n            if not grid.is_agent_valid_pos(new_pos):\n                continue\n\n            # Check path validity to new_pos from nearest_v\n            line_seq = grid.get_line_sequence(nearest_v.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(new_pos)\n            dist_nearest_to_new = Map.get_distance(nearest_v.position, q_new.position)\n            q_new.cost = nearest_v.cost + dist_nearest_to_new\n\n            # Rewiring radius adaptively computed\n            card_v = float(graph_grow.size if graph_grow.size > 0 else 1)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v.item() / card_v) ** (1 / self._dimension)), 25.0)\n\n            # Find vertices near q_new for rewiring and parent selection\n            vertices_near = graph_grow.get_vertices_within_radius(graph_grow.root_vertices, q_new.position, radius)\n\n            # Select best parent from vertices_near minimizing cost\n            q_min = nearest_v\n            c_min_cost = q_new.cost\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                candidate_cost = q_near.cost + dist_near_new\n                line_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if candidate_cost < c_min_cost and grid.is_valid_line_sequence(line_candidate):\n                    q_min = q_near\n                    c_min_cost = candidate_cost\n\n            q_new.cost = c_min_cost\n            graph_grow.add_edge(q_min, q_new)\n\n            # Rewire neighbors to possibly improve costs\n            self._rewire_nearby(graph_grow, q_new, radius)\n\n            # Try to connect the other tree to q_new directly (attempt bidirectional connection)\n            connected, connect_vertex = self._connect_trees(q_new, graph_other)\n            if connected:\n                # Update best path cost if improved\n                candidate_cost = q_new.cost + connect_vertex.cost + Map.get_distance(q_new.position, connect_vertex.position)\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    # Extract combined path and smooth\n                    self._extract_bidirectional_path_and_smooth(q_new, graph_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an enhanced RRT* inspired planner that improves path planning performance by:\n    - Employing goal-biased sampling to increase the chance of connecting to the goal.\n    - Using a dynamic adaptive step size that shrinks when close to obstacles or goal for smoother paths.\n    - Implementing rewiring to optimize path cost locally (RRT* style).\n    - Early stopping if path is found or if elapsed time > 10 seconds to ensure timely responses.\n    - Smoothing the final path by shortcutting line segments to reduce unnecessary detours.\n    - Prioritizing vertices to connect based on heuristic cost-to-goal to improve efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Enable rewiring\n        self._init_displays()\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Use Euclidean distance as heuristic cost\n        return self._get_grid().get_distance(frm, to)\n\n    def _try_rewire(self, q_new: Vertex, radius: float) -> None:\n        # Rewire nearby vertices to q_new if it improves cost\n        nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for q_nearby in nearby_vertices:\n            if q_nearby == q_new:\n                continue\n            # Check if path from q_new to q_nearby is valid and better cost\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearby.position)\n            if new_cost < q_nearby.cost:\n                # Rewire edges\n                for parent in list(q_nearby.parents):\n                    self._graph.remove_edge(parent, q_nearby)\n                self._graph.add_edge(q_new, q_nearby)\n                q_nearby.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if line is valid\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_smooth(self, q_new: Vertex) -> None:\n        # Extract path from q_new to start vertex by traversing parents\n        path: List[Vertex] = []\n        current_vertex = q_new\n        while True:\n            path.append(current_vertex)\n            if len(current_vertex.parents) == 0:\n                break\n            # Prefer parent with minimum cost (usually only one in a tree)\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            current_vertex = parent\n\n        path.reverse()\n\n        # Smooth the path by shortcutting\n        path = self._shortcut_path(path)\n\n        # Animate path following\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex_adaptive(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Adaptive step size: small step near goal or obstacles, larger otherwise\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n\n        if dist < 1e-6:\n            return Vertex(q_near.position)  # Same position, no progress\n\n        # Dynamic max_dist reduced if near obstacles or close to goal\n        dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        adaptive_max_dist = max_dist\n        if dist_to_goal < 3 * max_dist:\n            adaptive_max_dist = max(max_dist * 0.3, dist_to_goal * 0.5)\n        # Check obstacle proximity (approximate by checking if line near q_near position is valid)\n        step_dir = dir_vec / dist\n        obstacle_check_point = Point.from_tensor(q_near.position.to_tensor() + step_dir * (adaptive_max_dist / 2))\n        if not self._get_grid().is_agent_valid_pos(obstacle_check_point):\n            adaptive_max_dist *= 0.3\n\n        step = min(dist, adaptive_max_dist)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + step * dir_normalized\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        max_dist: float = 8.0\n        iterations: int = 10000\n        radius_rewire: float = 15.0\n        goal_sample_rate: float = 0.15  # 15% of samples biased to goal\n        start_time = time.time()\n\n        # Initialize start vertex cost = 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            # Time limit check\n            if time.time() - start_time > 10.0:\n                # Timeout, no path found\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate sample goal directly\n            if np.random.random() < goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            # Get nearest vertex to sample based on cost + heuristic (RRT* inspired)\n            # This can be approximated by Euclidean distance for speed\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue  # identical point, resample\n\n            # Compute new vertex with adaptive step size\n            q_new = self._get_new_vertex_adaptive(q_near, q_sample, max_dist)\n\n            # Check line collision from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to q_new\n            dist_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = dist_cost\n\n            # Choose parent for q_new among neighbors to minimize cost\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            min_cost = q_new.cost\n            min_parent = q_near\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                lseq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(lseq):\n                    continue\n                new_cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    min_parent = neighbor\n            q_new.cost = min_cost\n\n            # Add q_new and edge from chosen parent\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire nearby vertices to q_new if beneficial\n            self._try_rewire(q_new, radius_rewire)\n\n            # Check goal reached condition\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path_and_smooth(q_new)\n                break\n\n            # Keyframe for animation\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This enhanced PathPlanning algorithm builds upon goal-biased RRT* methodology with multiple improvements to boost efficiency, success rate, and path quality:\n    \n    - Implements Informed RRT* sampling by restricting samples to an ellipsoidal region (informed set) once a feasible path is found, reducing exploration space.\n    - Retains goal bias sampling near the goal for better convergence.\n    - Adaptive max step size scaled by distance to goal to allow coarse moves far away and finer moves near goal.\n    - Uses heuristic-guided rewiring with an adaptive neighborhood radius based on graph size and step size.\n    - Incorporates early stopping both on goal reach and after time limit (10s).\n    - Applies path shortcutting post extraction for smoother and shorter paths.\n    - Introduces a dynamic sample space update (informed set tuning) after initial solution improves, leading to faster re-planning.\n    - Maintains cost-to-come and rewires better parents during tree expansion.\n    - Tracks best solution cost to prune and guide sampling adaptively.\n    \n    Overall improves over baseline by focusing sampling on promising areas, adaptive steps, and progressive path quality improvement.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n        # New members for informed sampling and best cost tracking\n        self._best_path_cost = float('inf')\n        self._informed_ellipse_ready = False\n        self._informed_start = self._graph.root_vertex_start.position\n        self._informed_goal = self._get_grid().goal.position\n\n\n    def _sample_informed(self, c_best: float) -> Point:\n        \"\"\"\n        Samples within an ellipsoidal informed set defined by start, goal, and current best path cost.\n        If not yet a feasible path found (c_best==inf), samples from full space.\n        \"\"\"\n        import math\n        import torch\n\n        grid = self._get_grid()\n        start = self._informed_start\n        goal = self._informed_goal\n\n        if c_best == float('inf'):\n            # No known solution; full space sampling with goal bias\n            return self._get_random_sample()\n\n        # Ellipse parameters\n        c_min = Map.get_distance(start, goal)\n        if c_best < c_min:\n            # Numerical safety check\n            return self._get_random_sample()\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min  # unit vector from start to goal\n        # Compute rotation matrix (2D)\n        e_theta = torch.atan2(a1[1], a1[0])\n        cos_theta = torch.cos(e_theta)\n        sin_theta = torch.sin(e_theta)\n        rot = torch.tensor([[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]])\n\n        # Radii of ellipse axes\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        # Repeat sample until valid\n        for _ in range(100):\n            # Sample random point in unit circle\n            sample_unit = torch.randn(2)\n            sample_unit /= torch.norm(sample_unit)\n            scale = torch.rand(1).item()\n            sample_unit *= scale\n            # Scale by ellipse radii\n            sample_ellipse = torch.tensor([r1 * sample_unit[0].item(), r2 * sample_unit[1].item()])\n            # Rotate and translate to position in map\n            sample_rotated = rot @ sample_ellipse + ((start.to_tensor() + goal.to_tensor()) / 2)\n            sample_pt = Point(int(round(sample_rotated[0].item())), int(round(sample_rotated[1].item())))\n            if grid.is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n        # Fallback if cannot sample valid in ellipse\n        return self._get_random_sample()\n\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        # Utility distance wrapper\n        return Map.get_distance(p1, p2)\n\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        best_goal_vertex = None\n\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit_seconds:\n                # Time out: stop planning\n                return\n\n            # Sample point: informed sampling if we have path, goal bias within sampling\n            if self._best_path_cost == float('inf'):\n                q_sample = self._get_random_sample()\n            else:\n                if torch.rand(1).item() < self._goal_sample_rate:\n                    # Goal biased sample near goal\n                    goal_pos_ = grid.goal.position\n                    # small ball around goal\n                    for _ in range(30):\n                        offset = torch.randn(self._dimension) * self._min_max_dist\n                        sample = Point(*(goal_pos_.to_tensor() + offset).round().int().tolist())\n                        if grid.is_agent_valid_pos(sample):\n                            q_sample = sample\n                            break\n                    else:\n                        q_sample = goal_pos_\n                else:\n                    q_sample = self._sample_informed(self._best_path_cost)\n\n            # Find nearest vertex in tree\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist based on distance to goal and best path cost\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_dir = torch.norm(dir_tensor)\n            if dist_dir == 0:\n                continue\n\n            if dist_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dist_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check validity of path from nearest to new\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = self._distance(q_nearest.position, q_new_pos)\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            # Rewiring radius calculation adaptive with current best path cost to limit neighbors\n            V_size = float(self._graph.size if self._graph.size > 0 else 1)\n            rad_factor = (torch.log(torch.tensor(V_size)) / V_size) ** (1 / self._dimension) if V_size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * rad_factor, max_dist*2, 30.0)\n\n            # Near vertices candidates for parent choosing and rewiring\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Pick best parent: minimize cost + distance and path validity\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n            for q_near in vertices_near:\n                dist_near_new = self._distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if route via q_new is better\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = self._distance(q_new.position, q_near.position)\n                new_cost = q_new.cost + dist_new_near\n                if new_cost < q_near.cost:\n                    line_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_rewire):\n                        # Remove older parent edge\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        # Add new parent q_new\n                        q_near.cost = new_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex can connect directly to goal cheaper than current best\n            dist_to_goal = self._distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                # Verify direct connect to goal is valid line with no obstacles\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    if cost_to_goal < self._best_path_cost:\n                        # Better path found\n                        self._best_path_cost = cost_to_goal\n                        goal_vertex = Vertex(goal_pos)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        best_goal_vertex = goal_vertex\n                        self._informed_ellipse_ready = True  # Enable informed sampling\n\n            # Early stopping if solution found and iteration is ample after improvements\n            if best_goal_vertex and iteration > 50:\n                # Extract and smooth path\n                self._extract_path_and_smooth(best_goal_vertex)\n                return\n\n            self.key_frame()\n\n        # If finished iterations without early stop but have path, extract it for visualization\n        if best_goal_vertex:\n            self._extract_path_and_smooth(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\" \n    Improved RRT*-inspired path planner with heuristic-guided goal bias, adaptive step size, and rewiring optimization.\n    Enhancements include:\n    - Heuristic cost-to-go for better parent selection and rewiring, reducing unnecessary expansions.\n    - Dynamic iteration limit scaling with environment size for efficiency.\n    - Early stopping once a sufficiently good path (within goal radius) is found.\n    - Enhanced shortcutting with iterative smoothing.\n    - Priority expansion towards promising regions using hybrid sampling that mixes uniform, goal bias, and heuristic-informed sampling.\n    - Maintains robustness by validating connections strictly.\n    - Timeout enforced at 10 seconds for practical responsiveness.\n    This balances exploration/exploitation, improves path quality, reduces failures, and speeds convergence.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\" \n    Improved RRT*-inspired path planner with heuristic-guided goal bias, adaptive step size, and rewiring optimization.\n    Enhancements include:\n    - Heuristic cost-to-go for better parent selection and rewiring, reducing unnecessary expansions.\n    - Dynamic iteration limit scaling with environment size for efficiency.\n    - Early stopping once a sufficiently good path (within goal radius) is found.\n    - Enhanced shortcutting with iterative smoothing.\n    - Priority expansion towards promising regions using hybrid sampling that mixes uniform, goal bias, and heuristic-informed sampling.\n    - Maintains robustness by validating connections strictly.\n    - Timeout enforced at 10 seconds for practical responsiveness.\n    This balances exploration/exploitation, improves path quality, reduces failures, and speeds convergence.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_iterations_base = 5000  # Base iteration count (adjusted adaptively)\n        self._goal_sample_rate = 0.25\n        self._search_radius = 15.0\n        self._timeout_secs = 10.0\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Heuristic cost-to-go (Euclidean distance from pos to goal)\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _get_custom_sample(self) -> Point:\n        \"\"\"\n        Hybrid sampling strategy:\n        - With low probability, sample uniformly random valid point.\n        - With goal_sample_rate, sample goal directly.\n        - Otherwise, sample near existing vertices biased by heuristic cost.\n        \"\"\"\n        p_rand = np.random.rand()\n        grid = self._get_grid()\n\n        # Goal-biased sample\n        if p_rand < self._goal_sample_rate:\n            return grid.goal.position\n\n        # 20% uniform random valid sample to maintain exploration\n        if p_rand < (self._goal_sample_rate + 0.2):\n            for _ in range(20):  # limit attempts\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Heuristic-informed biased sampling: sample near low-cost vertices\n        vertices = list(self._graph.root_vertex_start.children) + [self._graph.root_vertex_start]\n        if len(vertices) < 1:\n            # fallback\n            return grid.goal.position\n\n        vertex_costs = [(v, v.cost + self._heuristic_cost(v.position)) for v in vertices]\n        vertex_costs.sort(key=lambda vc: vc[1])\n\n        best_vertices = [vc[0] for vc in vertex_costs[:min(5, len(vertex_costs))]]\n\n        # Pick randomly among best vertices\n        base_vertex = best_vertices[np.random.randint(len(best_vertices))]\n\n        # Sample around base vertex within small radius\n        radius = 5\n        for _ in range(30):\n            delta = np.random.randint(-radius, radius + 1, grid.size.n_dim)\n            candidate_coords = base_vertex.position.to_tensor().numpy() + delta\n            candidate_coords = np.clip(candidate_coords, 0, grid.size - 1)\n            sample = Point(*candidate_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback uniform random if no sample found\n        for _ in range(20):\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        return grid.goal.position\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Choose parent minimizing cost + movement + heuristic-to-go.\n        min_total_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n        for v in q_near_list:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = grid.get_movement_cost(v.position, q_new.position)\n            cost = v.cost + movement_cost\n            heuristic = self._heuristic_cost(q_new.position)\n            total_cost = cost + heuristic * 0.5  # weighted heuristic to guide selection\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Try to rewire neighbors through q_new if it reduces total cost (cost + heuristic)\n        grid = self._get_grid()\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = grid.get_movement_cost(q_new.position, v.position)\n            potential_cost = q_new.cost + movement_cost\n            if potential_cost < v.cost:\n                # Check if rewiring does not create cycles or invalid edges\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _iterative_shortcut(self, path: list, iterations=5) -> list:\n        # Iteratively improve shortcutting for smoother path\n        grid = self._get_grid()\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                        new_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, add next vertex\n                    new_path.append(path[i + 1])\n                    i += 1\n            path = new_path\n        return path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct and smooth path using iterative shortcutting\n        grid = self._get_grid()\n        goal_v = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicate start\n        path.reverse()\n\n        smoothed_path = self._iterative_shortcut(path, iterations=5)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        self._graph.root_vertex_start.cost = 0.0\n\n        max_iterations: int = max(self._max_iterations_base, int(grid.size.prod() * 1.5))  # adapt by env size\n        start_time = time.time()\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for i in range(max_iterations):\n            if time.time() - start_time > self._timeout_secs:\n                break\n\n            q_sample: Point = self._get_custom_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius)\n            chosen_parent: Vertex = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Track best goal reach for early extraction, allow small buffer radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_goal_cost:\n                    best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n\n                # If found sufficiently good path (cost + heuristic below threshold), break early\n                threshold = best_goal_cost * 1.1\n                if q_new.cost + self._heuristic_cost(q_new.position) < threshold:\n                    break\n\n            self.key_frame()\n\n        # If found a goal vertex, extract path; else fail silently (timeout or no path)\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner builds upon the RRT* inspired approach by integrating:\n     - Heuristic-guided sampling combining goal bias and informed ellipse sampling (Informed RRT*)\n       to more efficiently focus the search space as better paths are found.\n     - Adaptive radius reduction in rewiring based on current best path cost, narrowing rewiring radius over time.\n     - Early stopping when the goal is reached and path cost stabilizes to prevent unnecessary exploration.\n     - Maintaining a lower bound on step size to balance exploration and incremental path adjustments.\n     - A refined _extract_path step using a more aggressive shortcutting mechanism to further smooth the final path.\n     These enhancements collectively improve planning efficiency (reducing iterations needed),\n     path quality (shorter, smoother paths), robustness (higher success rate by reducing redundant sampling),\n     and responsiveness with a strict 10-second timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # For Informed sampling - track best cost found\n        self._best_cost: float = float('inf')\n        self._start_pos: Point = self._get_grid().agent.position\n        self._goal_pos: Point = self._get_grid().goal.position\n\n    def _heuristic_cost(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return Map.get_distance(p1, p2)\n\n    def _get_informed_sample(self) -> Point:\n        # If no solution found, sample uniformly with goal bias\n        if self._best_cost == float('inf'):\n            return self._get_random_sample(goal_sample_rate=0.3)\n\n        # Informed sampling: sample inside ellipse defined by start, goal, and best cost\n        center = Point(*(((self._start_pos.to_tensor() + self._goal_pos.to_tensor()) / 2).tolist()))\n        dist_start_goal = self._heuristic_cost(self._start_pos, self._goal_pos)\n        c_best = self._best_cost\n        c_min = dist_start_goal\n\n        # If current best cost is close to min, fallback to goal bias sampling\n        if c_best <= c_min:\n            return self._get_random_sample(goal_sample_rate=0.3)\n\n        a1 = (self._goal_pos.to_tensor() - self._start_pos.to_tensor()) / dist_start_goal  # unit vector\n\n        # Sampling inside an ellipse radius parameters\n        r1 = c_best / 2.0\n        r2 = np.sqrt(c_best**2 - c_min**2) / 2.0\n\n        while True:\n            # Sample random point in unit circle\n            rand_point_in_unit_circle = Point(*self._sample_unit_ball(n_dim=len(center)))\n            # Scale to ellipse with radii r1, r2 and rotate along a1 axis\n            # 2D assumption (or adapt for higher dim accordingly)\n            # Construct rotation matrix to align x-axis with a1 vector\n            # For n_dim=2, rotation matrix is simple\n            \n            dim = len(center)\n            if dim == 2:\n                a1_np = a1.numpy()\n                angle = np.arctan2(a1_np[1], a1_np[0])\n                c, s = np.cos(angle), np.sin(angle)\n                R = np.array([[c, -s], [s, c]])\n\n                sample_ellipse = np.array([r1 * rand_point_in_unit_circle[0], r2 * rand_point_in_unit_circle[1]])\n                rotated = R @ sample_ellipse\n                sample_pt = center.to_tensor().numpy() + rotated\n                sample_pt = Point(*np.round(sample_pt).astype(int))\n\n            else:\n                # For n_dim > 2, only scale inside hyperellipse; ignoring rotation for simplicity\n                radii = torch.tensor([r1] + [r2]*(dim-1))\n                sample_tensor = center.to_tensor() + radii * torch.tensor(rand_point_in_unit_circle)\n                sample_pt = Point.from_tensor(sample_tensor.round())\n\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _sample_unit_ball(self, n_dim: int) -> List[float]:\n        # Sample random point uniformly inside an n-dimensional unit ball\n        while True:\n            point = np.random.uniform(-1,1,n_dim)\n            if np.linalg.norm(point) <= 1:\n                return point.tolist()\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=20.0) -> float:\n        # Keep as is but increase max_dist slightly for faster exploration\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=7):\n            direction = self._goal_pos.to_tensor() - pos.to_tensor()\n            norm_dir = torch.norm(direction)\n            if norm_dir == 0:\n                break\n            dir_norm = direction / norm_dir\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Adaptive radius shrink as better paths found\n        adaptive_radius = radius\n        if self._best_cost < float('inf'):\n            # Shrink radius proportional to improvement (with floor limit)\n            adaptive_radius = max(8.0, radius * (self._best_cost / 100.0))\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, adaptive_radius)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new to start\n        goal_v = Vertex(self._goal_pos)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicate of start\n        path.reverse()\n\n        # Aggressive shortcutting with double pass for smoother shorter path\n        def aggressive_shortcut_path(path_vertices: List[Vertex]) -> List[Vertex]:\n            if len(path_vertices) <= 2:\n                return path_vertices[:]\n            shortcut_path = [path_vertices[0]]\n            idx = 0\n            while idx < len(path_vertices) - 1:\n                next_idx = len(path_vertices) - 1\n                # Find farthest reachable vertex from shortcut_path end\n                while next_idx > idx + 1:\n                    line_check = self._get_grid().get_line_sequence(shortcut_path[-1].position, path_vertices[next_idx].position)\n                    if self._get_grid().is_valid_line_sequence(line_check):\n                        break\n                    next_idx -= 1\n                shortcut_path.append(path_vertices[next_idx])\n                idx = next_idx\n            return shortcut_path\n\n        path = aggressive_shortcut_path(path)\n        path = aggressive_shortcut_path(path)  # second pass to improve further\n\n        # Trace path and key frame animation\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        search_radius: float = 15.0  # max rewiring radius\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        iterations_since_improve = 0\n        max_stable_iterations = 300  # early stop if no improvement\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout - terminate search\n                break\n\n            # Use informed sample if path cost found else goal biased uniform sample\n            q_sample: Point = self._get_informed_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            # Enforce a minimum max_dist for smooth incremental expansion, avoiding too coarse jumps\n            max_dist = max(3.0, max_dist)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Get neighbors with adaptive radius based on current best cost\n            q_near_list = self._get_near_vertices(q_new, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors excluding chosen parent\n            neighbors_to_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, neighbors_to_rewire)\n\n            # Check goal proximity with radius threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost if improved\n                path_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._goal_pos)\n                if path_cost < self._best_cost:\n                    self._best_cost = path_cost\n                    iterations_since_improve = 0\n                    self._extract_path(q_new)\n                    # Early stopping condition if cost close enough to direct start-goal distance\n                    if abs(self._best_cost - self._heuristic_cost(self._start_pos, self._goal_pos)) < 1.0:\n                        break\n                else:\n                    iterations_since_improve += 1\n                    if iterations_since_improve > max_stable_iterations:\n                        break\n            else:\n                iterations_since_improve += 1\n                if iterations_since_improve > max_stable_iterations:\n                    # No progress on improving path - early stop to save time\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal biasing and rewiring for path quality improvement.\n    The algorithm samples points with a goal bias, dynamically adjusts max step distance, connects new vertices \n    by minimizing cost considering nearby vertices, and rewires the graph to improve path optimality.\n    Early stopping on goal reach and time limit (10 seconds) is enforced to enhance efficiency.\n    The extracted path is smoothed by shortcutting invalid intermediate points for better path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        # With probability goal_bias, sample the goal position directly to bias growth toward goal\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace from goal to start through parents, build path\n        path = [q_last]\n        while len(path[-1].parents) != 0:\n            # Since rewiring can cause multiple parents, pick parent with minimum cost\n            min_parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(min_parent)\n        path.reverse()\n\n        # Shortcut path to smooth it\n        path = self._shortcut_path(path)\n\n        # Animate path moving agent\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to skip intermediate vertices if direct line is valid between vertices\n        shortened = [path[0]]\n        for i in range(1, len(path)):\n            # Check if direct line from last added vertex to this vertex is valid\n            line_seq = self._get_grid().get_line_sequence(shortened[-1].position, path[i].position)\n            if i == len(path) - 1 or not self._get_grid().is_valid_line_sequence(line_seq):\n                # Can't skip, add previous vertex i-1\n                shortened.append(path[i - 1])\n        # Always append last vertex if not included\n        if shortened[-1] != path[-1]:\n            shortened.append(path[-1])\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 10.0\n        max_dist_min = 3.0\n        max_dist_max = 15.0\n        iteration_limit = 10000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        # Initialize costs for start vertex\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive step size based on iteration progress (shrink over time)\n            max_dist = max(\n                max_dist_max - (max_dist_max - max_dist_min) * (i / iteration_limit),\n                max_dist_min,\n            )\n\n            # Sample point with goal biasing\n            q_sample = self._get_random_sample(goal_bias=0.15)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line between q_near and q_new\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Find neighbors within a radius for rewiring (RRT* style)\n            radius = min(max_dist * 2.5, 30)\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n\n            # Choose parent with lowest cost+distance in neighbors\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Check if path from neighbor to q_new is collision free\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # If no suitable parent, fallback to q_near\n                if not self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Add q_new vertex with parent_for_new\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire: remove old edges from all parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check goal reached under radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add final goal vertex connected from q_new (if valid)\n                final_goal_pos = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Mark key frame for visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring}\n\n    This algorithm extends the classical RRT by incorporating the following enhancements:\n    - Goal-biased sampling to encourage exploration towards the goal, improving success rate and efficiency.\n    - Adaptive rewiring of vertices within a neighborhood radius (RRT* style) to optimize path cost and quality.\n    - Dynamic max_dist step size tuned by environment scale.\n    - Early stopping by time limit (10 seconds) and immediate path extraction upon reaching goal region.\n    - Shortcut smoothing applied after path extraction to reduce unnecessary detours.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.15   # Probability of sampling the goal to bias sampling towards it.\n        self._rewire_radius = 15        # Radius for rewiring neighbors for optimization.\n        self._max_dist = 12             # Max extension distance per step.\n        self._max_iterations = 8000     # Max iterations to limit planning effort.\n        self._time_limit_sec = 10.0     # Time limit in seconds to stop search if no path found.\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased random sampling to increase goal reach chance.\n        from random import random\n\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as base, clipped to max_dist step.\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent that gives lowest cost path to q_new considering cost + movement cost\n        min_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            q_new.cost = min_cost\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if beneficial (lower cost and valid path)\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove old parent edges of q_neighbor leading to higher cost\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from start to q_goal by traversing parents with lowest cost path\n        path: List[Vertex] = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            # Select parent with least cost\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        # After path extraction, apply shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        # Move the agent along the path with animation key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: iteratively try to connect non-adjacent vertices directly\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Cost to start vertex is zero\n\n        for iteration in range(self._max_iterations):\n            # Check time limit for early termination\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Fail to find path in allocated time\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            # Validate path from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Near neighbors for rewiring\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Select best parent from neighbors (including q_near)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            # Add q_new with selected parent\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new reached goal region\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and cost calculation\n                goal_vertex = self._graph.root_vertex_goal\n\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm combining goal-biased adaptive informed sampling, \n    heuristic-guided dynamic expansion, and efficient rewiring optimization aiming for \n    faster convergence, higher success rate, and smoother paths. \n    Key improvements over the base include:\n    - Adaptive max step size scaled dynamically with progress towards goal and tree size,\n      allowing coarser exploration far and finer near goal.\n    - Enhanced sampling distribution mixing uniform, goal-biased, and informed ellipsoidal sampling \n      based on current best path cost to focus search.\n    - Heuristic cost incorporating both traveled cost and admissible distance-to-go to prioritize vertices.\n    - Dynamic neighborhood radius for rewiring scaled with tree size and iteration.\n    - Early rewire pruning to decrease tree clutter and improve paths.\n    - Path shortcutting with robust multiple attempts for smoothing.\n    - Early termination on finding direct connect to goal with smooth path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.5   # Min step size near goal for finer control\n        self._goal_sample_rate = 0.25  # Slightly increased goal bias\n        self._informed_sample_rate = 0.3  # Probability to do informed sampling\n        self._max_iterations = 4000  # Reduced max iterations due to more efficient search\n        self._lambda_rrt_star = 45  # tuning rewiring radius factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._best_cost = float('inf')  # Track best path cost found so far\n        self._init_displays()\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        # Sample inside an ellipsoid defined by start, goal, and current best cost c_max (informed sampling)\n        import math\n        import torch\n\n        # If no current best cost (or infinite), fallback to uniform sampling\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(\n            *(((start_pos.to_tensor().float()+goal_pos.to_tensor().float())/2).tolist())\n        )\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        # Unit vector from start to goal\n        e1 = diff / dist_start_goal\n\n        # Compute rotation matrix (2D)\n        # Since dimension=2, rotation matrix R aligns x-axis with vector start->goal\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta],\n                          [sin_theta, cos_theta]])\n\n        # Define ellipsoid axes lengths\n        a = c_max / 2.0  # major axis length\n        b = math.sqrt(max(c_max**2 - dist_start_goal**2, 1e-6)) / 2.0  # minor axis length\n\n        for _ in range(40):  # max retries\n            # Sample uniformly inside unit ball in 2D\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            # Scale by ellipsoid axes\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            # Rotate and translate back to world frame\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform random sample if informed fails\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal biased sampling: sample near the goal within min_max_dist radius\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset = sample_offset / torch.norm(sample_offset) if torch.norm(sample_offset) > 1e-8 else sample_offset\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling to focus search within cost bound\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling in grid valid positions\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start position\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Dynamic max step size, also depends on tree size for finer control as more vertices are added\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        progress_factor = max(0.05, min(1.0, dist / max(grid.size)))  # normalized distance to goal\n        tree_size_factor = min(1.0, 500 / (self._graph.size + 1))  # shrink step size as tree grows\n        scaled = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * tree_size_factor\n        return scaled\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Admissible heuristic: Euclidean distance to goal\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Same as reference but enhanced shortcutting with multiple tries for robustness\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Robust shortcut smoothing: multiple passes\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time check early stop\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Abort if planning too long\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Construct new vertex and calculate cost to reach\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose the best parent with minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-5 < q_near.cost:  # add a small epsilon for numerical stability\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one old parent edge (tree structure)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Construct or update goal vertex connection\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Check and update best path cost found\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early stop on valid goal connection\n                    break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the RRT*-style planner by integrating heuristic-guided sampling \n      biased towards the goal and the best-connected vertex, adaptive step size based on clearance and heuristic \n      cost-to-go, and dynamic rewiring radius that shrinks over time for efficiency. It uses an A*-inspired \n      cost-to-go heuristic to guide vertex selection and sampling, improving exploration towards promising regions. \n      Early stopping criteria include timeout and goal reach detection. Path extraction includes aggressive shortcutting \n      for smoother paths. These enhancements lead to faster convergence, higher success rates, and shorter,\n      smoother, more robust paths in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        self._start_pos = self._get_grid().agent.position\n        self._goal_pos = self._get_grid().goal.position\n\n    def _heuristic_cost_to_goal(self, pos: Point) -> float:\n        # Use Euclidean distance as heuristic cost-to-go\n        return Map.get_distance(pos, self._goal_pos)\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Enhancement: reduce max_dist if heuristic cost is small (near goal) for finer expansions\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=5):\n            direction = self._goal_pos.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        heuristic_cost = self._heuristic_cost_to_goal(pos)\n        # Shrink max distance when close to goal to improve path precision\n        if heuristic_cost < max_dist:\n            clearance = min(clearance, max(min_dist, heuristic_cost*0.7))\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Vertex | None':\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: list[Vertex], q_new: Vertex) -> Vertex | None:\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            # Cost augmented by heuristic to encourage paths closer to goal\n            cost_augmented = cost + self._heuristic_cost_to_goal(q_new.position) * 0.1\n            if cost_augmented < min_cost:\n                min_cost = cost_augmented\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list[Vertex]) -> None:\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._goal_pos)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        # Aggressive shortcut smoothing\n        smoothed_path = [path[0]]\n        last_valid = path[0]\n        for vertex in path[1:]:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(last_valid.position, vertex.position)):\n                continue\n            else:\n                prev_index = path.index(vertex) - 1\n                smoothed_path.append(path[prev_index])\n                last_valid = path[prev_index]\n        smoothed_path.append(path[-1])\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_best_near_vertex(self, q_sample: Point, radius: float) -> Vertex | None:\n        # Additional heuristic-guided vertex selection near sample to improve connection to promising nodes\n        near_verts = self._get_near_vertices(Vertex(q_sample), radius)\n        best_vertex = None\n        best_score = float('inf')\n        for v in near_verts:\n            dist_to_sample = Map.get_distance(v.position, q_sample)\n            heuristic = self._heuristic_cost_to_goal(v.position)\n            score = v.cost + dist_to_sample + heuristic  # combined cost\n            if score < best_score:\n                best_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        goal_sample_rate: float = 0.35\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n\n        # Dynamic search radius shrinks over iterations for efficiency\n        max_search_radius = 20.0\n        min_search_radius = 8.0\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failure\n                break\n\n            # Hybrid sampling: mix of goal bias, best-vertex bias, random uniform\n            sample_type = np.random.rand()\n            if sample_type < goal_sample_rate:\n                q_sample = self._goal_pos\n            elif sample_type < goal_sample_rate + 0.1 and self._graph.size > 5:\n                # biased sample near best known tree vertex\n                best_nodes = [v for v in self._graph.root_vertices if v.cost + self._heuristic_cost_to_goal(v.position) < float('inf')]\n                if len(best_nodes) > 0:\n                    chosen = min(best_nodes, key=lambda v: v.cost + self._heuristic_cost_to_goal(v.position))\n                    noise = np.random.normal(scale=3.0, size=self._get_grid().size.n_dim)\n                    noisy_sample_tensor = chosen.position.to_tensor() + torch.tensor(noise, dtype=torch.float32)\n                    noisy_sample = Point.from_tensor(torch.clamp(noisy_sample_tensor, 0, self._get_grid().size.to_tensor()))\n                    if self._get_grid().is_agent_valid_pos(noisy_sample):\n                        q_sample = noisy_sample\n                    else:\n                        q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n                else:\n                    q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n            else:\n                q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n\n            # Choose best vertex near sample considering heuristic cost and distance\n            search_radius = max_search_radius - (max_search_radius - min_search_radius) * (i / max_iterations)\n            q_near = self._get_best_near_vertex(q_sample, search_radius)\n            if q_near is None:\n                # Fallback to nearest vertex if no nearby vertices found\n                q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Radius for rewiring decreases with iterations to improve efficiency\n            search_radius_rewire = max(10.0, search_radius * 0.6)\n\n            q_near_list = self._get_near_vertices(q_new, search_radius_rewire)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Remove chosen parent from neighbors before rewiring\n            q_near_list_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list_rewire)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved sample-based path planner inspired by RRT* principles, \n    designed for grid-based environments. It implements goal-biased sampling to improve \n    success rate, dynamic/adaptive step size for efficient exploration, and rewiring of \n    vertices to optimize path cost and smoothness (like RRT*). It aborts if planning time \n    exceeds 10 seconds to maintain robustness. After connecting start to goal, it extracts \n    and performs path shortcutting to further smooth the path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal for RRT* style optimization\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        \"\"\"\n        With probability goal_bias, sample goal position exactly to bias tree growth toward goal\n        Otherwise random sample in valid positions\n        \"\"\"\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex], radius: float) -> None:\n        \"\"\"Rewire nearby vertices to q_new if the cost through q_new is cheaper.\"\"\"\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            # check if edge from q_new to q_neighbor is valid\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_q_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_neighbor.position)\n            if cost_through_q_new < q_neighbor.cost:\n                # Remove old parent edge\n                for p in list(q_neighbor.parents):\n                    self._graph.remove_edge(p, q_neighbor)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = cost_through_q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from q_new to root\n        path: List[Vertex] = [q_new]\n        while len(path[-1].parents) != 0:\n            # choose the parent with minimum cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Connect to goal vertex explicitly if close but not exact\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = Map.get_distance(path[-1].position, goal_pos)\n        if dist_to_goal <= 1.5:  # within 1.5 cells, attempt direct connection\n            line_seq = self._get_grid().get_line_sequence(path[-1].position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                goal_v = Vertex(goal_pos)\n                goal_v.cost = path[-1].cost + self._get_grid().get_movement_cost(path[-1].position, goal_pos)\n                self._graph.add_edge(path[-1], goal_v)\n                path.append(goal_v)\n\n        # Shortcut path smoothing by attempting to connect nonadjacent points directly\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    # shortcut possible: remove intermediate vertices between i and j\n                    # create direct edge i -> j and remove edges in between\n                    # remove old edges\n                    for k in range(i + 1, j + 1):\n                        for p in list(path[k].parents):\n                            self._graph.remove_edge(p, path[k])\n                    self._graph.add_edge(path[i], path[j])\n                    # rebuild path list skipping intermediate\n                    path = path[:i + 1] + path[j:]\n                    break\n                j -= 1\n            i += 1\n\n        # Move agent along the smoothed path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, dist_to_goal: float, default_max=10.0, min_step=1.0) -> float:\n        \"\"\"\n        Adaptive max step size which decreases when close to goal for better refinement.\n        \"\"\"\n        if dist_to_goal < default_max:\n            return max(min_step, dist_to_goal / 2.0)\n        return default_max\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iter = 10000\n        default_max_dist = 10.0\n        goal_radius = 1.5  # radius to consider reached goal region\n\n        # Initialize start and goal vertices cost\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iter_idx in range(max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:  # abort if planning exceeds 10 seconds\n                # No path found within time limit\n                return\n\n            # Goal-biased random sampling\n            q_sample = self._get_random_sample(goal_bias=0.15)\n\n            # Find nearest vertex in tree\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n            adaptive_max_dist = self._adaptive_max_dist(dist_to_goal, default_max_dist)\n\n            # Steer towards sample with adaptive step size\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to reach q_new through q_near\n            cost_to_q_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            # Find neighbors within radius for rewiring (RRT* style)\n            radius = min(15.0, (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** 0.5 * 50)  # heuristic radius scaled with tree size\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n            # Choose parent among neighbors that gives lowest cost path\n            best_parent = q_near\n            best_cost = cost_to_q_new\n            for q_neighbor in neighbors:\n                line_seq_n = self._get_grid().get_line_sequence(q_neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_n = q_neighbor.cost + self._get_grid().get_movement_cost(q_neighbor.position, q_new.position)\n                if cost_n < best_cost:\n                    best_parent = q_neighbor\n                    best_cost = cost_n\n            q_new.cost = best_cost\n\n            # Insert q_new and add edge from best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if cheaper path exists through q_new\n            self._rewire(q_new, neighbors, radius)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Heuristic-Guided Expansion,\n    Dynamic Step Sizing, and Multi-Stage Smoothing for Superior Path Quality and Planning Efficiency",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Heuristic-Guided Expansion,\n    Dynamic Step Sizing, and Multi-Stage Smoothing for Superior Path Quality and Planning Efficiency}\n\n    This improved version builds on the baseline RRT* inspired approach and introduces the following key advancements:\n    - Adaptive max_dist scaling based on environment size and current iteration progress for balanced exploration/exploitation.\n    - Heuristic-guided sampling biased both towards the goal and sparsely around a dynamic heuristic funnel region to reduce unnecessary exploration.\n    - Dual-rewire strategy: immediate neighborhood rewiring and delayed local refinement rewiring after path connection.\n    - Hybrid path smoothing combining shortcut smoothing during extraction and Bezier curve smoothing post extraction for natural smoothness.\n    - Early stopping with timeout capped at 10 seconds for robustness.\n    - Cost-to-go heuristic included in parent choice to prioritize vertices promising shortest overall path.\n    - Goal connection uses a relaxed radius to allow earlier connection attempts.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.18      # Slightly increased goal bias sampling.\n        self._rewire_radius = 18           # Increased radius for better rewiring opportunities.\n        self._max_dist_base = 14           # Base max extension distance.\n        self._max_iterations = 7000        # Slightly reduced max iterations for efficiency.\n        self._time_limit_sec = 10.0        # Time limit in seconds.\n        self._delayed_rewire_radius = 8    # Smaller radius for delayed local refinement rewiring.\n        self._heuristic_funnel_rate = 0.12 # Sampling rate for heuristic funnel region.\n\n    def _get_heuristic_funnel_sample(self) -> Point:\n        \"\"\"\n        Generate a sample biased in a heuristic funnel region between start and goal.\n        This helps focus growth along promising corridor.\n        \"\"\"\n        import random\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        if random.random() > self._heuristic_funnel_rate:\n            return None  # Outside funnel this iteration\n\n        alpha = random.random()\n        interp = Point(\n            int(start_pos.x + alpha * (goal_pos.x - start_pos.x)),\n            int(start_pos.y + alpha * (goal_pos.y - start_pos.y)),\n        )\n        # Add small gaussian noise to spread out samples around line\n        from numpy.random import normal\n\n        noise_x = int(normal(0, 6))\n        noise_y = int(normal(0, 6))\n        sample = Point(interp.x + noise_x, interp.y + noise_y)\n        if grid.is_agent_valid_pos(sample):\n            return sample\n        else:\n            # Fallback to start or goal if noise invalid\n            return random.choice([start_pos, goal_pos])\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        \"\"\"\n        Dynamically adjusts max_dist depending on iteration count and environment size,\n        encouraging coarse exploration early and finer local refinement late.\n        \"\"\"\n        grid = self._get_grid()\n        env_diag = (\n            (grid.size.x ** 2 + grid.size.y ** 2) ** 0.5\n        )  # Diagonal distance on grid\n        fraction = min(1.0, iteration / (self._max_iterations * 0.7))\n        max_dist = self._max_dist_base * (1.0 - 0.65 * fraction) + max(4, env_diag * 0.03) * fraction\n        if max_dist < 3:\n            max_dist = 3\n        return max_dist\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Choose parent with minimum cost + heuristic cost to goal (cost-to-come + cost-to-go)\n        min_total_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic_to_goal = grid.get_distance(q_new.position, goal_pos)\n            total_cost = cost_to_new + heuristic_to_goal * 0.95  # weight heuristic slightly less than cost\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                min_vertex = q_near\n\n        if min_vertex is not None:\n            min_vertex_cost = min_vertex.cost + grid.get_distance(min_vertex.position, q_new.position)\n            q_new.cost = min_vertex_cost\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # Rewire neighbors to q_new if it improves cost and path valid\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost + 1e-6 < q_neighbor.cost:  # add small epsilon for numerical stability\n                # Remove all old parents to avoid multiple incoming edges\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _delayed_local_rewire(self, path: list) -> None:\n        \"\"\"\n        Run refinement rewiring along extracted path vertices,\n        allowing local neighborhood to rewire and improve path cost.\n        \"\"\"\n        grid = self._get_grid()\n        for vertex in path:\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], vertex.position, self._delayed_rewire_radius\n            )\n            self._rewire(vertex, neighbors)\n\n    def _bezier_smooth_path(self, path: list) -> list:\n        \"\"\"\n        Apply mild cubic Bezier smoothing on path vertices to reduce sharp turns.\n        Returns a new list of vertices with interpolated smoother positions.\n        \"\"\"\n        import numpy as np\n\n        if len(path) < 4:\n            return path  # Not enough points to smooth\n\n        # Convert path vertices to numpy points for convenience\n        points = np.array([[v.position.x, v.position.y] for v in path], dtype=np.float32)\n\n        smoothed_points = []\n\n        def cubic_bezier(p0, p1, p2, p3, t):\n            return (\n                (1 - t) ** 3 * p0\n                + 3 * (1 - t) ** 2 * t * p1\n                + 3 * (1 - t) * t ** 2 * p2\n                + t ** 3 * p3\n            )\n\n        n = len(points)\n        smoothed_points.append(points[0])\n\n        step = 0.15\n        for i in range(n - 3):\n            p0 = points[i]\n            p1 = points[i + 1]\n            p2 = points[i + 2]\n            p3 = points[i + 3]\n\n            # Generate intermediate points between p1 and p2 using Bezier curve\n            t_values = np.arange(step, 1 + step, step)\n            for t in t_values:\n                bez_point = cubic_bezier(p0, p1, p2, p3, t)\n                smoothed_points.append(bez_point)\n\n        smoothed_points.append(points[-1])\n\n        # Convert back to Vertices with integer-rounded positions, ensuring valid moves.\n        grid = self._get_grid()\n        new_vertices = []\n        prev_p = path[0]\n        for pt in smoothed_points:\n            p = Point(int(round(pt[0])), int(round(pt[1])))\n            if grid.is_agent_valid_pos(p):\n                new_v = Vertex(p)\n                # Assign dummy cost, will be updated if needed later\n                new_v.cost = 0\n                new_vertices.append(new_v)\n        # Remove duplicates near each other (distance zero)\n        filtered_vertices = []\n        last_pos = None\n        for v in new_vertices:\n            if last_pos is None or v.position != last_pos:\n                filtered_vertices.append(v)\n                last_pos = v.position\n\n        return filtered_vertices if len(filtered_vertices) >= 2 else path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path by ascending parents with min cost, then smooth in two stages:\n        # classic shortcut path smoothing + Bezier curve smoothing for natural turns\n        path: list = [q_goal]\n        curr = q_goal\n        while curr.parents:\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        # Delayed neighborhood rewiring for local refinement\n        self._delayed_local_rewire(path)\n\n        # Bezier smoothing for natural smoothness\n        path_smoothed = self._bezier_smooth_path(path)\n\n        # Move the agent along the polished path with animation key frames\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        # Classic shortcut smoothing by connecting non-adjacent vertices directly if path is valid\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0  # Initialize start cost zero\n\n        start_time = time.time()\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Timeout condition: fail search\n                break\n\n            # Adaptive sampling: goal bias, heuristic funnel sample or uniform random\n            q_sample = None\n            r = random.random()\n            if r < self._goal_sample_rate:\n                q_sample = goal_vertex.position\n            else:\n                funnel_sample = self._get_heuristic_funnel_sample()\n                if funnel_sample is not None:\n                    q_sample = funnel_sample\n                else:\n                    # Uniform random sample\n                    while True:\n                        rand_pos = random.choices(range(grid.size.x), k=1)[0], random.choices(range(grid.size.y), k=1)[0]\n                        sample = Point(rand_pos[0], rand_pos[1])\n                        if grid.is_agent_valid_pos(sample):\n                            q_sample = sample\n                            break\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(iteration)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius(\n                [start_vertex], q_new.position, self._rewire_radius\n            )\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            # Add new vertex and edge\n            self._graph.add_edge(q_parent, q_new)\n\n            # Immediate rewiring neighbors\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached or can be connected (expanded radius to relax)\n            goal_connect_dist = self._rewire_radius * 1.3\n            dist_to_goal = grid.get_distance(q_new.position, goal_vertex.position)\n\n            if dist_to_goal <= goal_connect_dist:\n                # Try to connect q_new to goal\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm extends the original RRT* approach by integrating heuristic guidance inspired by A* cost estimation to bias expansions towards promising directions and improve planning efficiency. It uses goal-biased adaptive sampling combined with heuristic-informed sampling around the tree frontier to better explore relevant regions. \n    Adaptive step sizes adjust according to clearance as before, but with dynamic shrinkage near obstacles to enhance smoothness. The rewiring step incorporates not only cost but also a smoothness metric based on direction changes between parent-child edges to reduce sharp turns.\n    Additionally, dynamic early stopping occurs not only on time but also on path cost convergence and goal proximity, improving robustness.\n    The path extraction uses enhanced shortcutting using iterative smoothing combined with collision checks, providing a smoother final trajectory.\n    Overall, the algorithm balances exploration and exploitation with informed sampling and rewire smoothness, leading to faster, more robust, and higher-quality paths with fewer iterations and greater success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        self._last_path_cost = float('inf')\n        self._convergence_count = 0\n        self._max_convergence_stalls = 5  # Number of consecutive iterations path cost not improved before early stop\n\n    def _heuristic_cost(self, position: Point) -> float:\n        # Estimated cost to goal (heuristic) with Euclidean distance\n        return Map.get_distance(position, self._get_grid().goal.position)\n\n    def _smoothness_cost(self, parent: Vertex, child: Vertex) -> float:\n        # Smoothness cost penalizes sharp turns by comparing direction vectors\n        if not parent.parents:\n            return 0.0\n        grandparent = next(iter(parent.parents))\n        vec1 = (parent.position.to_tensor() - grandparent.position.to_tensor())\n        vec2 = (child.position.to_tensor() - parent.position.to_tensor())\n        if vec1.norm() == 0 or vec2.norm() == 0:\n            return 0.0\n        cos_angle = torch.dot(vec1 / vec1.norm(), vec2 / vec2.norm())\n        # Penalize sharp turns by inverse of cosine angle (1 - cos_angle), range [0,2]\n        return float(1.0 - cos_angle)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Optional[Vertex]':\n        # Modified to shrink max_dist adaptively when near obstacles for smoothness\n        # Use clearance factor to shrink max_dist if close to obstacles (check nearness by repeated tries)\n        base_dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(base_dir)\n        if norm == 0:\n            return None\n        \n        # Adaptive shrink based on distance to closest obstacle by sampling ahead along direction\n        clearance_factor = 1.0\n        for scale in np.linspace(1.0, 0.3, 4):\n            test_dist = max_dist * scale\n            projected_point = Point.from_tensor(q_near.position.to_tensor() + (base_dir / norm) * test_dist)\n            if not self._get_grid().is_agent_valid_pos(projected_point):\n                clearance_factor = scale * 0.6\n                break\n            line_seq = self._get_grid().get_line_sequence(q_near.position, projected_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance_factor = scale * 0.6\n                break\n        \n        effective_max_dist = max_dist * clearance_factor\n\n        if norm <= effective_max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = base_dir / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + effective_max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: 'List[Vertex]', q_new: 'Vertex') -> 'Optional[Vertex]':\n        # Weighted cost: cost + movement + heuristic + smoothness to prefer smoother and efficient paths\n        min_total_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            base_cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            heuristic = self._heuristic_cost(q_new.position)\n            smooth = self._smoothness_cost(v, q_new)\n            total_cost = base_cost + heuristic * 0.2 + smooth * 3.0  # Tuned weights; smoothness high priority\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: 'Vertex', q_near_list: 'List[Vertex]') -> None:\n        # Rewire neighbors through q_new if reduced total cost (cost+heuristic+smoothness)\n        for v in q_near_list:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            base_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            heuristic = self._heuristic_cost(v.position)\n            smooth = self._smoothness_cost(q_new, v)\n            total_cost = base_cost + heuristic * 0.2 + smooth * 3.0\n            \n            if total_cost < v.cost:\n                # Remove old edges from parents to v and add edge from q_new to v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = total_cost\n\n    def _iterative_path_shortcut(self, path: 'List[Vertex]', max_iter: int = 30) -> 'List[Vertex]':\n        # Improved smoothing by iterative shortcutting and path simplification with collision checks\n        smoothed_path = path[:]\n        for _ in range(max_iter):\n            if len(smoothed_path) <= 2:\n                break\n            # Attempt to skip intermediate vertices if line is valid\n            i = 0\n            changed = False\n            while i < len(smoothed_path) - 2:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[i + 2].position)):\n                    smoothed_path.pop(i + 1)\n                    changed = True\n                else:\n                    i += 1\n            if not changed:\n                break\n        return smoothed_path\n\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: 'List[Vertex]' = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Choose parent with minimum cost (and smallest smoothness if tie)\n            min_cost_parent = None\n            min_cost = float('inf')\n            min_smooth = float('inf')\n            for p in path[-1].parents:\n                smooth = self._smoothness_cost(p, path[-1])\n                if p.cost < min_cost or (p.cost == min_cost and smooth < min_smooth):\n                    min_cost = p.cost\n                    min_cost_parent = p\n                    min_smooth = smooth\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        # Iterative path shortcutting for smoothness\n        smoothed_path = self._iterative_path_shortcut(path)\n\n        # Trace the path to move agent, with key frames for visualization\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_heuristic_bias_sample(self, base_sample: Point, radius: float) -> Point:\n        # Sample around base_sample using Gaussian centered at base_sample truncated by radius,\n        # but restricted to valid positions. This encourages focused sampling near frontier.\n        for _ in range(20):\n            offset = np.random.normal(0, radius / 2, size=self._get_grid().size.n_dim)\n            sample_tensor = base_sample.to_tensor() + torch.tensor(offset, dtype=torch.float)\n            sample_int = Point(*np.clip(sample_tensor.round().int().tolist(), 0, self._get_grid().size - 1))\n            if self._get_grid().is_agent_valid_pos(sample_int):\n                return sample_int\n        # fallback\n        return base_sample\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        goal_sample_rate = 0.25\n        search_radius = 12.0  # slightly smaller radius for local rewiring to improve smoothness\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n\n        # Maintain a frontier set for heuristic-biased sampling (closest vertices to goal)\n        frontier_vertices: 'List[Vertex]' = [self._graph.root_vertex_start]\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failure\n                break\n\n            # Heuristic-biased sampling: With prob goal_sample_rate choose goal,\n            # otherwise biased sampling at frontier or random\n            if np.random.rand() < goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                # 60%: random valid sample, 40% biased near frontier closest to goal\n                if np.random.rand() < 0.4 and frontier_vertices:\n                    # Pick a frontier vertex close to goal and sample around it\n                    frontier_vertices_sorted = sorted(frontier_vertices, key=lambda v: self._heuristic_cost(v.position))\n                    base_vertex = frontier_vertices_sorted[0]\n                    q_sample = self._get_heuristic_bias_sample(base_vertex.position, radius=5.0)\n                else:\n                    # Uniform random valid sample\n                    while True:\n                        rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                        q_sample_candidate = Point(*rand_pos)\n                        if self._get_grid().is_agent_valid_pos(q_sample_candidate):\n                            q_sample = q_sample_candidate\n                            break\n            \n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, min_dist=2.0, max_dist=12.0)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list = self._get_near_vertices(q_new, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n            \n            # Add edge & cost\n            base_cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n            # Incorporate heuristic and smoothness for cost stored in vertex for better rewiring decisions\n            heuristic = self._heuristic_cost(q_new.position)\n            smoothness = self._smoothness_cost(chosen_parent, q_new)\n            q_new.cost = base_cost + heuristic * 0.2 + smoothness * 3.0\n\n            self._graph.add_edge(chosen_parent, q_new)\n\n            # Rewire neighbors (excluding parent)\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Update frontier: add q_new if it advances towards goal and isn't too far\n            dist_to_goal = Map.get_distance(q_new.position, self._get_grid().goal.position)\n            if dist_to_goal < 20.0 and q_new not in frontier_vertices:\n                frontier_vertices.append(q_new)\n\n            # Remove frontier vertices too close to q_new (converged region)\n            frontier_vertices = [v for v in frontier_vertices if Map.get_distance(v.position, q_new.position) > 2.0]\n\n            # Check for early goal reach considering path improvement\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                path_cost_now = q_new.cost\n                # If new path cost improves or stable for consecutive iterations -> extract path\n                if path_cost_now < self._last_path_cost:\n                    self._last_path_cost = path_cost_now\n                    self._convergence_count = 0\n                else:\n                    self._convergence_count += 1\n                if self._convergence_count >= self._max_convergence_stalls or i > 100:\n                    self._extract_path(q_new)\n                    break\n\n            # Also convergence check on max iterations earlier than max_iterations\n            if i > 200 and self._convergence_count >= self._max_convergence_stalls:\n                # Can't find better path, stop to save time\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved PathPlanning Algorithm with enhanced smoothness and efficiency:\n    - Adaptive max step size dynamically scales with progress and tree size for balanced exploration.\n    - Mixed sampling combining uniform, goal-biased, and adaptive informed ellipsoidal to focus sampling.\n    - Heuristic-guided vertex expansion incorporating traveled cost and admissible distance to goal.\n    - Dynamic neighborhood radius for rewiring, scaled with logarithm of tree size, supporting RRT*-style optimization.\n    - Early neighbor pruning during rewiring to reduce clutter and improve path quality.\n    - Robust multi-pass path shortcutting smoothing with attempts to produce smooth final trajectory.\n    - Early termination upon detecting a direct valid connection to goal with a shorter path.\n    - Overall improves planning speed, success rate, and path smoothness under time constraints.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size far from goal\n        self._min_max_dist = 2.5   # Min step size near goal for fine control\n        self._goal_sample_rate = 0.25  # Goal biased sampling probability\n        self._informed_sample_rate = 0.3  # Probability of ellipsoidal informed sampling\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45  # Rewiring radius factor tuning\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 500 / (self._graph.size + 1))\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor\n        return scaled_step\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        import math\n        import torch\n\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(*(((start_pos.to_tensor().float() + goal_pos.to_tensor().float()) / 2).tolist()))\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        e1 = diff / dist_start_goal\n\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        a = c_max / 2.0\n        b = math.sqrt(max(c_max ** 2 - dist_start_goal ** 2, 1e-6)) / 2.0\n\n        for _ in range(40):\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal biased sampling with radius min_max_dist around goal\n        if rand_val < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    sample_offset = sample_offset / norm\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        # Informed ellipsoidal sampling focused within current best cost bound\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling across valid grid\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            # Fallback to start position if no valid sample found\n            return self._graph.root_vertex_start.position\n\n    def _extract_path_and_smooth(self, goal_vertex: Vertex):\n        # Extract path from root to goal vertex\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Multi-pass robust shortcut smoothing with more attempts per pass\n        smoothing_attempts = 4\n        for _pass in range(smoothing_attempts):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        shortened = True\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic-guided minimum cost parent selection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n\n            # Combine actual cost + heuristic to goal in parent selection for better exploration\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n                heuristic_candidate_parent = self._heuristic_cost(q_near.position, goal_pos)\n\n                # Prefer parents with lower cost + heuristic to goal\n                if (cost_candidate + heuristic_new) < (c_min + self._heuristic_cost(q_min.position, goal_pos)):\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Early pruning neighbors with regressive cost\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                # Include small epsilon stability to avoid float issues\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one parent edge (tree structure maintenance)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                        # Early termination on direct goal connect with best path\n                        if cost_to_goal < float('inf'):\n                            break\n\n            # Mark key frame visualization every 40 iterations for smooth animation\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning algorithm combining goal-biased informed sampling, \n    heuristic-guided tree expansion with clearance-awareness, adaptive step size, \n    and rewiring inspired by RRT*. This version enhances path clearance by biasing \n    sampling towards regions with higher clearance from obstacles to improve robustness \n    and success rate. It also employs a clearance-aware cost heuristic to prefer safer \n    paths, adaptive rewiring radius scaled with graph size, and path shortcutting with \n    clearance checks for smoother and shorter paths. The planning halts early if a path \n    is found or after 10 seconds to improve efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        # Additional parameters for clearance-aware sampling and cost\n        self._clearance_sample_attempts = 50\n        self._min_clearance_threshold = 1.5  # minimal clearance distance to obstacles for samples\n        self._clearance_influence_weight = 5.0  # weight factor for clearance in cost heuristic\n        self._init_displays()\n\n    def _compute_clearance(self, point: Point) -> float:\n        \"\"\"\n        Compute clearance distance from obstacles for a given point by checking\n        neighbors and finding minimum distance to obstacles within a small radius.\n        \"\"\"\n        grid = self._get_grid()\n        min_clearance = float('inf')\n        # We check neighbors within a small radius (e.g., 5 grid units)\n        check_radius = 5\n        x, y = point.x, point.y\n        for dx in range(-check_radius, check_radius + 1):\n            for dy in range(-check_radius, check_radius + 1):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < grid.size[0] and 0 <= ny < grid.size[1]:\n                    neighbor = Point(nx, ny)\n                    if not grid.is_agent_valid_pos(neighbor):\n                        dist = Map.get_distance(point, neighbor)\n                        if dist < min_clearance:\n                            min_clearance = dist\n        # If no obstacle nearby, clearance is the check_radius + 1\n        if min_clearance == float('inf'):\n            return check_radius + 1\n        return min_clearance\n\n    def _clearance_weighted_sample(self) -> Point:\n        \"\"\"\n        Sample points with a bias towards higher clearance areas.\n        Attempts multiple samples and chooses the one with max clearance.\n        Incorporates goal biasing.\n        \"\"\"\n        import time\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        if torch.rand(1).item() < self._goal_sample_rate:\n            # Sample in a small ball around goal for goal bias\n            for _ in range(30):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback if can't sample near goal\n            return goal_pos\n        else:\n            best_sample = None\n            best_clearance = -1\n            for _ in range(self._clearance_sample_attempts):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if not grid.is_agent_valid_pos(sample):\n                    continue\n                clearance = self._compute_clearance(sample)\n                if clearance >= self._min_clearance_threshold and clearance > best_clearance:\n                    best_clearance = clearance\n                    best_sample = sample\n            # If no high clearance sample found, fallback to random valid\n            if best_sample:\n                return best_sample\n            # fallback: random valid sampling with at most 100 tries\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start pos if no valid sample found (very rare)\n            return self._graph.root_vertex_start.position\n\n    def _cost_with_clearance(self, parent: Vertex, child_pos: Point) -> float:\n        \"\"\"\n        Compute cost from parent to child with clearance heuristic added.\n        Cost = Path length + clearance penalty\n        Clearance penalty is inversely proportional to clearance to obstacles.\n        \"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(parent.position, child_pos)\n        clearance = self._compute_clearance(child_pos)\n        clearance_penalty = 0.0\n        if clearance < self._min_clearance_threshold:\n            clearance_penalty = (self._min_clearance_threshold - clearance) * self._clearance_influence_weight\n        return parent.cost + dist + clearance_penalty\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Stop searching after time limit\n                return\n\n            # Sample with clearance bias and goal bias\n            q_sample = self._clearance_weighted_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Find nearby vertices for rewiring using adaptive radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among nearby vertices using clearance-aware cost\n            q_min = q_nearest\n            c_min = self._cost_with_clearance(q_nearest, q_new.position)\n\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = self._cost_with_clearance(q_near, q_new.position)\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if (cost_candidate < c_min) and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to improve their costs if passing through q_new is cheaper\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                cost_through_new = self._cost_with_clearance(q_new, q_near.position)\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge (single parent assumption from tree)\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if close to goal within adaptive max_dist\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm leveraging adaptive, clearance-aware sampling, \n    heuristic-guided expansion, and efficient rewiring optimization for faster convergence, \n    higher success, and safer paths. Key innovations include:\n\n    - Clearance-augmented sampling: biased toward higher clearance regions by rejecting low-clearance samples,\n      improving robustness by steering away from tight obstacles.\n    - Adaptive step size scaled dynamically with progress and tree size, tuned by local clearance, \n      allowing coarse exploration in open spaces and finer near clutter or goal.\n    - Enhanced mixed sampling strategy combining goal bias, informed ellipsoidal sampling, and clearance-aware uniform sampling \n      to focus samples in promising and safe areas.\n    - Neighborhood radius for rewiring dynamically computed based on tree size and incorporates clearance factors.\n    - Early pruning of rewiring if cost improvement is negligible, reducing clutter and improving runtime.\n    - Multiple passes of robust shortcut smoothing to ensure path quality and smoothness.\n    - Early termination upon direct goal connection and smoothing, positing improved efficiency.\n    - Enforces a 10-second timeout for planning to guarantee timely response.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0  # Slightly increased max step size for faster exploration in open areas\n        self._min_max_dist = 2.5   # Minimum step size near goal or clutter for precision\n        self._goal_sample_rate = 0.2  # Balanced goal bias\n        self._informed_sample_rate = 0.4  # Increased informed sampling to focus effort\n        self._max_iterations = 3500  # Lower max iterations due to increased efficiency\n        self._lambda_rrt_star = 40  # Rewiring radius tuning factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Enforce 10 second planning limit\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3  # Minimum clearance radius for accepting samples\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"Estimate clearance as minimum distance to any obstacle or boundary.\"\"\"\n        grid = self._get_grid()\n        max_clearance_check = 10.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        # Also consider distance to map boundary\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _clearance_aware_sample(self) -> Point:\n        \"\"\"\n        Returns a random valid sample that has clearance above threshold by rejection sampling.\n        Tries uniformly but rejects low clearance points.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        for _ in range(150):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        # fallback uniformly if no high-clearance sample found\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        prob = torch.rand(1).item()\n        if prob < self._goal_sample_rate:\n            # Goal biased sampling inside goal radius zone expanded by min_max_dist\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                offset_vec = torch.randn(self._dimension)\n                norm = torch.norm(offset_vec).item()\n                if norm < 1e-8:\n                    continue\n                offset_vec = offset_vec / norm\n                offset_len = torch.rand(1).item() * self._min_max_dist\n                sample_coords = (goal_pos.to_tensor().float() + offset_vec * offset_len).round().int()\n                sample = Point.from_tensor(sample_coords)\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            return goal_pos\n\n        elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling with clearance check\n            for _ in range(30):\n                sample = self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n                if self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            # fallback\n            return self._clearance_aware_sample()\n\n        else:\n            # Clearance-aware uniform sampling\n            return self._clearance_aware_sample()\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_goal = Map.get_distance(q_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n\n        # Tree size factors: larger tree => smaller step size to allow refinement near goal\n        tree_factor = min(1.0, 600 / (self._graph.size + 1))\n\n        # Clearance scaling: smaller step size if clearance is small, larger if clearance high (up to max dist)\n        clearance = self._get_clearance(q_pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 2.0))  # Normalize clearance factor (0 to 1+)\n\n        step = (self._min_max_dist + \n                (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor * clearance_factor)\n        return max(self._min_max_dist, min(step, self._max_max_dist))\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance admissible heuristic for consistency with costs\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex) -> None:\n        # Extract path and perform multiple robust shortcut passes\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n        grid = self._get_grid()\n\n        # Multiple shortcutting passes for smoothing\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early timeout abort\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # abort planning after 10 seconds\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 25.0)\n\n            # Inflate radius slightly adapting to clearance to allow more neighbors in open areas\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent with minimal cost plus heuristic and valid connection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Efficient rewire neighbors if improved cost (with pruning threshold)\n            rewire_threshold = 0.005\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove old parent edge (single-parent tree structure)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early termination: direct goal reach with smooth path extraction\n                    break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired path planner with enhanced clearance awareness and heuristic guidance.\n    This algorithm builds on goal-biased adaptive sampling and rewiring of the RRT* backbone,\n    but enhances performance by including:\n    - Clearance-weighted adaptive step sizing that more effectively respects free space and obstacles,\n      allowing longer stable extensions in safe areas and cautious steps near obstacles.\n    - A dynamically computed heuristic cost combining path cost and estimated distance-to-goal,\n      guiding tree growth preferentially toward promising regions and reducing wasted exploration.\n    - Adaptive sampling: mixing pure uniform sampling, goal-centric bias, and biased sampling toward\n      regions of high clearance to avoid narrow passages.\n    - Enhanced rewiring considering clearance and cost to improve robustness and path quality.\n    - Early stopping with a timeout to bound planning time.\n    - Final path smoothing with shortcutting using clearance-aware validation to produce safer and smoother paths.\n    This algorithm aims to improve planning efficiency, path smoothness, robustness, and success rate\n    compared to the baseline RRT* approach.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # Additional member for clearance-biased sampling weights\n        self._clearance_sample_weight = 0.3\n        self._uniform_sample_weight = 0.5\n        self._goal_sample_weight = 0.2\n\n    def _clearance_at_point(self, pos: Point, max_check_dist=10.0, resolution=1.0) -> float:\n        # Estimate clearance radius by checking distance in multiple directions until obstacles or bounds\n        # returns clearance estimate capped at max_check_dist\n        grid = self._get_grid()\n        directions = [\n            torch.tensor([1.0, 0.0]),\n            torch.tensor([-1.0, 0.0]),\n            torch.tensor([0.0, 1.0]),\n            torch.tensor([0.0, -1.0]),\n            torch.tensor([1.0, 1.0]).float().normalize(),\n            torch.tensor([-1.0, 1.0]).float().normalize(),\n            torch.tensor([1.0, -1.0]).float().normalize(),\n            torch.tensor([-1.0, -1.0]).float().normalize(),\n        ]\n        clearance = max_check_dist\n        for d in directions:\n            for dist in np.arange(resolution, max_check_dist + resolution, resolution):\n                check_tensor = pos.to_tensor() + d * dist\n                check_point = Point.from_tensor(check_tensor)\n                if not grid.is_agent_valid_pos(check_point):\n                    clearance = min(clearance, dist - resolution)\n                    break\n                line_seq = grid.get_line_sequence(pos, check_point)\n                if not grid.is_valid_line_sequence(line_seq):\n                    clearance = min(clearance, dist - resolution)\n                    break\n        return max(0.0, clearance)\n\n    def _get_clearance_biased_sample(self) -> Point:\n        # Sample with bias toward regions of higher clearance by sampling positions,\n        # evaluating clearance, and probabilistically selecting one with higher clearance.\n        grid = self._get_grid()\n        attempts = 0\n        max_attempts = 30\n        samples_clearance = []\n        samples = []\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if not grid.is_agent_valid_pos(sample):\n                attempts += 1\n                continue\n            clearance = self._clearance_at_point(sample, max_check_dist=10.0)\n            samples.append(sample)\n            samples_clearance.append(clearance)\n            attempts += 1\n        if not samples:\n            # fallback to uniform random valid sample\n            return self._get_random_sample(goal_sample_rate=0)\n        # Normalize clearance scores to probabilities\n        clearance_array = np.array(samples_clearance)\n        if clearance_array.sum() == 0:\n            probabilities = np.ones_like(clearance_array) / len(clearance_array)\n        else:\n            probabilities = clearance_array / clearance_array.sum()\n        chosen_idx = np.random.choice(len(samples), p=probabilities)\n        return samples[chosen_idx]\n\n    def _get_random_sample(self, goal_sample_rate=0.3) -> Point:\n        # Mix three sampling modes: goal biased, clearance biased, uniform random\n        rand_val = np.random.rand()\n        if rand_val < self._goal_sample_weight:\n            return self._get_grid().goal.position\n        elif rand_val < self._goal_sample_weight + self._clearance_sample_weight:\n            return self._get_clearance_biased_sample()\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=4.0, max_dist=20.0) -> float:\n        # Clearance aware step size - extension length scales with clearance but capped\n        clearance = self._clearance_at_point(pos, max_check_dist=max_dist)\n        # Conservative scale: Leave margin of around 1 grid cell\n        step = np.clip(clearance - 1.0, min_dist, max_dist)\n        return step\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # heuristic cost combining Euclidean distance and estimated clearance cost\n        dist = self._get_grid().get_distance(from_pos, to_pos)\n        clearance = self._clearance_at_point(from_pos)\n        # Penalize low clearance (smaller clearance => higher heuristic)\n        clearance_penalty = (1.0 / (clearance + 1e-5))\n        return dist * clearance_penalty\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Select parent minimizing cost + heuristic cost toward goal, with line validity\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            cost = v.cost + movement_cost\n            heuristic = self._heuristic_cost(q_new.position, self._get_grid().goal.position)\n            total_cost = cost + heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Rewire neighbors through q_new if it reduces cost considering movement cost and validity\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                # Update edges in graph\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Enhanced shortcutting: Try to skip intermediate vertices where line is not only collision-free but clearance is high\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        last_idx = 0\n        for i in range(1, len(path)):\n            line_seq = grid.get_line_sequence(shortcut_path[-1].position, path[i].position)\n            if (not grid.is_valid_line_sequence(line_seq)) or (self._clearance_at_point(path[i].position) < 1.5):\n                shortcut_path.append(path[i - 1])\n                last_idx = i - 1\n        if shortcut_path[-1] != path[-1]:\n            shortcut_path.append(path[-1])\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new to start, add goal connection, smooth path and trace it\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        search_radius = 18.0\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.3)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            neighbors_to_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, neighbors_to_rewire)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm combining:\n     - Adaptive max step size dynamically scaled by progress towards goal and tree size,\n     - Enhanced mixed sampling (uniform, goal-biased, and informed ellipsoidal) focused by best-known path cost,\n     - Heuristic-guided vertex expansion prioritizing cost-to-come + admissible cost-to-go,\n     - Dynamic neighborhood radius for rewiring scaled with tree size and iteration,\n     - Early rewire pruning to reduce clutter and improve path quality,\n     - Multi-pass robust shortcut smoothing on extracted path,\n     - Early termination upon discovering a direct connect to goal with smooth path,\n     - Imposes a strict 10 seconds timeout to constrain planning time.\n    Aims for improved efficiency, path quality, robustness, and success rate over standard RRT*-informed approaches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        from heapq import heappush, heappop\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n        self._start_time = time.time()\n\n        max_total_time = 10.0  # seconds total budget for planning\n\n        def heuristic_cost(pos: Point) -> float:\n            return Map.get_distance(pos, goal_pos)\n\n        def combined_cost(vertex: Vertex) -> float:\n            # g + h cost used to prioritize vertices for expansion, admissible heuristic\n            return vertex.cost + heuristic_cost(vertex.position)\n\n        def sample_point() -> Point:\n            # Mixing uniform, goal-biased, and ellipse informed sampling based on best cost\n            rand_val = torch.rand(1).item()\n            if rand_val < self._goal_sample_rate:\n                # Goal biased sampling near goal within min_max_dist\n                for _ in range(40):\n                    offset = torch.randn(self._dimension)\n                    norm_offset = offset / torch.norm(offset) if torch.norm(offset) > 1e-8 else offset\n                    scaled_offset = norm_offset * (torch.rand(1).item() * self._min_max_dist)\n                    sample = Point(*((goal_pos.to_tensor().float() + scaled_offset).round().int().tolist()))\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n                return goal_pos\n            elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n                return self._sample_in_ellipsoid(start_vertex.position, goal_pos, self._best_cost)\n            else:\n                for _ in range(120):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n                return start_vertex.position\n\n        def adaptive_max_step(pos: Point) -> float:\n            dist_goal = Map.get_distance(pos, goal_pos)\n            progress = max(0.05, min(1.0, dist_goal / max(grid.size)))\n            scale = min(1.0, 500 / (self._graph.size + 1))\n            return self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress * scale\n\n        def rewiring_radius(iter_n: int) -> float:\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            base_radius = (self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)))\n            # Shrink radius gently with iterations to focus rewiring\n            shrink_factor = max(0.3, 1.0 - iter_n / self._max_iterations)\n            return min(base_radius * shrink_factor, 25.0)\n\n        # Priority queue for vertex expansion to enforce heuristic-guided exploration\n        # (Currently we implement standard iterative sampling but evaluate heuristic for parent choice)\n        iterations = 0\n        while iterations < self._max_iterations:\n            elapsed = time.time() - self._start_time\n            if elapsed > max_total_time:\n                # Abort planning due to time limit\n                break\n\n            q_sample = sample_point()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                iterations += 1\n                continue\n\n            max_dist = adaptive_max_step(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir == 0:\n                iterations += 1\n                continue\n\n            if norm_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm_vec = dir_vec / norm_dir\n                point_tensor = (q_nearest.position.to_tensor().float() + dir_norm_vec * max_dist).round().int()\n                q_new_pos = Point.from_tensor(point_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                iterations += 1\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                iterations += 1\n                continue\n\n            # Construct new vertex with initial parent q_nearest\n            q_new = Vertex(q_new_pos)\n            dist_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_to_new\n\n            # Dynamic radius for rewiring\n            radius = rewiring_radius(iterations)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent from neighbors minimizing cost + heuristic\n            parent_candidates = []\n            for q_neigh in neighbors:\n                dist_neigh_new = torch.norm(q_neigh.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_neigh.cost + dist_neigh_new\n                # Check line of sight\n                line_neighbor_new = grid.get_line_sequence(q_neigh.position, q_new.position)\n                if grid.is_valid_line_sequence(line_neighbor_new):\n                    heappush(parent_candidates, (cost_candidate, q_neigh))\n\n            if parent_candidates:\n                cost_min, best_parent = parent_candidates[0]\n                # Assign best parent and cost to q_new\n                q_new.cost = cost_min\n                self._graph.add_edge(best_parent, q_new)\n            else:\n                # Fallback to q_nearest if no better parent found\n                self._graph.add_edge(q_nearest, q_new)\n\n            # Rewire neighbors if improved path through q_new available\n            for q_neigh in neighbors:\n                if q_neigh.position == q_new.position:\n                    continue\n                dist_new_neigh = torch.norm(q_new.position.to_tensor().float() - q_neigh.position.to_tensor().float()).item()\n                new_cost = q_new.cost + dist_new_neigh\n                if new_cost + 1e-6 < q_neigh.cost:  # epsilon for numerical stability\n                    line_new_neigh = grid.get_line_sequence(q_new.position, q_neigh.position)\n                    if grid.is_valid_line_sequence(line_new_neigh):\n                        # Remove one old parent edge to maintain tree\n                        for parent in q_neigh.parents:\n                            self._graph.remove_edge(parent, q_neigh)\n                            break\n                        q_neigh.cost = new_cost\n                        self._graph.add_edge(q_new, q_neigh)\n\n            # Attempt to connect q_new directly to goal if close enough with valid path\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_goal < self._best_cost:\n                        self._best_cost = cost_goal\n                        found_goal = goal_vertex\n                    # Early exit on direct goal connection with good cost\n                    break\n\n            if iterations % 40 == 0:\n                self.key_frame()\n\n            iterations += 1\n\n        if found_goal is not None:\n            # Extract and smooth path robustly\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Inspired Algorithm with Goal-Biased Sampling and Adaptive Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Inspired Algorithm with Goal-Biased Sampling and Adaptive Rewiring}\n\n    This algorithm improves the baseline RRT by incorporating:\n    - Goal-biased sampling (sampling towards the goal with a probability) to improve convergence.\n    - RRT* style rewiring to optimize path quality (shorter, smoother paths).\n    - Adaptive max step distance based on distance to goal to accelerate early expansion and refine near goal.\n    - Early stopping when a solution is found and further rewiring iterations are limited.\n    - Shortcut smoothing in the extracted path by trying to directly connect non-adjacent vertices.\n    - A hard timeout of 10 seconds to ensure bounded planning time.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring edge removals for optimization\n        self._init_displays()\n\n        # Parameters\n        self._goal_sample_rate = 0.15   # Probability of sampling the goal directly (goal bias)\n        self._max_iterations = 5000\n        self._initial_max_dist = 15.0   # Initial max extension distance\n        self._min_max_dist = 2.0        # Minimum step size near the goal\n        self._rewiring_radius = 20.0    # Radius for neighbor search during rewiring\n        self._timeout_sec = 10.0        # Timeout limit in seconds\n\n    def _get_adaptive_max_dist(self, q_near_pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = Map.get_distance(q_near_pos, goal_pos)\n        # Linearly scale max_dist between min_max_dist and initial max based on distance to goal\n        dist_clamped = max(min(dist_to_goal, self._initial_max_dist), self._min_max_dist)\n        return dist_clamped\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost_to_goal = float('inf')\n\n        for iteration in range(self._max_iterations):\n            # Check timeout\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout reached, declare fail to find path\n                break\n\n            # Goal biased sampling\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to reach q_new via q_near\n            cost_to_new_via_q_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Create new vertex with cost info\n            q_new.cost = cost_to_new_via_q_near\n\n            # Find neighbors within rewiring radius\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewiring_radius)\n\n            # Choose best parent among neighbors to minimize cost to q_new\n            best_parent = q_near\n            best_cost = cost_to_new_via_q_near\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                tentative_cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if tentative_cost < best_cost:\n                    best_cost = tentative_cost\n                    best_parent = neighbor\n\n            # Set q_new cost and add edge from best parent\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if connecting through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_q_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if cost_through_q_new < neighbor.cost:\n                    # Remove old parent edges (for simplicity, remove all parents and add new)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n            # Check if q_new is within goal radius and is better path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_cost_to_goal:\n                    best_cost_to_goal = q_new.cost\n                    best_goal_vertex = q_new\n\n            self.key_frame()\n\n            # Early stopping if good path found and iterations passed\n            if best_goal_vertex and iteration > self._max_iterations // 10:\n                break\n\n        # If found path, extract and smooth\n        if best_goal_vertex is not None:\n            self._extract_and_smooth_path(best_goal_vertex)\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        # Extract path from goal_vertex back to start by parents\n        path: List[Vertex] = [goal_vertex]\n        current_vertex = goal_vertex\n\n        while len(current_vertex.parents) != 0:\n            # Choose parent with min cost (in case multiple)\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current_vertex = parent\n\n        # Path is from goal to start, reverse it\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path by skipping intermediate vertices\n        path = self._shortcut_path(path)\n\n        # Animate moving along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by checking direct line between non-adjacent vertices\n        if len(path) <= 2:\n            return path\n\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # Start by trying to connect directly to goal\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on RRT*, integrating:\n     - Goal-biased sampling (20% samples biased towards goal)\n     - Adaptive step size: max_dist adapts based on distance to goal to allow coarse-to-fine exploration\n     - Rewiring for path optimization (RRT* style) to improve path quality and robustness\n     - Smoothed path extraction by shortcutting line-of-sight segments on the final path\n     - Early stopping if path not found within 10 seconds\n     Overall aims:\n     - Improve planning efficiency by biasing sampling and adaptive step size\n     - Improve success rate by rewiring for shorter paths and better connectivity\n     - Improve path quality by shortcutting path before animation",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring edge removability for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_ratio: float = 0.2) -> Point:\n        # Goal biased sampling: With probability goal_bias_ratio sample goal directly\n        if np.random.rand() < goal_bias_ratio:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample_pos: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample_pos):\n                    return sample_pos\n\n    def _choose_best_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the neighbor that results in minimum cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for nbr in neighbors:\n            if nbr.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(nbr.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = nbr.cost + self._get_grid().get_distance(nbr.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = nbr\n        if best_parent is None:\n            best_parent = neighbors[0]  # fallback (should not happen if neighbors not empty)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        # Try to improve cost to existing neighbors via q_new\n        for nbr in neighbors:\n            if nbr.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, nbr.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_distance(q_new.position, nbr.position)\n            if potential_cost < nbr.cost:\n                # Remove old parent edge(s) to nbr\n                for p in list(nbr.parents):\n                    self._graph.remove_edge(p, nbr)\n                # Add edge from q_new to nbr\n                self._graph.add_edge(q_new, nbr)\n                nbr.cost = potential_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shorten path by skipping intermediate nodes if direct line is clear\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                # Check if direct line from path[i] to path[j] valid\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        path: List[Vertex] = [q_final]\n        # Backtrack parents to start vertex\n        while len(path[-1].parents) != 0:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        # Shortcut path for smoother trajectory\n        path = self._shortcut_path(path)\n        # Animate path movement\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 10000\n        start_time = time()\n        max_dist_base = 10.0\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            # Check timeout (stop search after 10 seconds)\n            if time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample(goal_bias_ratio=0.2)\n\n            # Adaptive max_dist: smaller when close to goal to improve precision\n            dist_to_goal = self._get_grid().get_distance(q_sample, goal_vertex.position)\n            max_dist = max(2.0, min(max_dist_base, dist_to_goal / 2))\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors within radius for rewiring (RRT*) radius proportional to max_dist\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius=max_dist * 2.0)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent to minimize cost\n            best_parent = self._choose_best_parent(neighbors, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new if shorter path exists\n            self._rewire(neighbors, q_new)\n\n            # Check if q_new reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex directly if line is valid\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal_new = Vertex(goal_vertex.position)\n                    q_goal_new.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, q_goal_new)\n                    self._extract_path(q_goal_new)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT*-inspired path planner with adaptive informed sampling\n    and dynamic step adjustment for enhanced planning efficiency and path quality. Instead of naive uniform\n    random sampling, it uses an ellipsoidal informed sampling region that biases samples towards areas\n    likely to improve the current best solution, reducing exploration of irrelevant space and improving\n    success rate. It adaptively adjusts the max step size based on local environment clearance to balance\n    between exploration and refinement. Rewiring ensures cost optimization. Early stopping after 10 seconds\n    or upon finding a valid goal path is employed. Path shortcutting smooths the final solution for better quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # required for rewiring in RRT*\n        self._init_displays()\n        self._best_cost = float(\"inf\")\n        self._best_goal_vertex = None\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        \"\"\"\n        Compute an adaptive max_dist based on clearance around position.\n        Use a small radius and check clearance (distance to obstacles).\n        Return a max_dist scaled accordingly between min and max bounds.\n        \"\"\"\n        min_dist = 3.0\n        max_dist = 15.0\n        check_radius = 5  # radius in grid units around position to check clearance\n\n        grid = self._get_grid()\n        clearance = max_dist  # assume max clearance at start\n\n        # Evaluate clearance by checking free neighbors within check_radius in 8 directions\n        directions = [\n            Point(1, 0), Point(-1, 0), Point(0, 1), Point(0, -1),\n            Point(1, 1), Point(1, -1), Point(-1, 1), Point(-1, -1)\n        ]\n\n        for d in directions:\n            for r in range(1, check_radius + 1):\n                check_point = Point(position.x + d.x * r, position.y + d.y * r)\n                if not grid.is_agent_valid_pos(check_point):\n                    clearance = min(clearance, float(r))\n                    break\n\n        # Scale between min_dist and max_dist\n        scaled_dist = min_dist + (max_dist - min_dist) * (clearance / check_radius)\n        return max(min_dist, min(scaled_dist, max_dist))\n\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample a point from an ellipsoidal informed region defined by current best cost.\n        If no best path yet, fallbacks to uniform sampling with goal bias.\n        \"\"\"\n        grid = self._get_grid()\n        goal_bias = 0.2\n        if np.random.random() < goal_bias:\n            return goal\n\n        if self._best_cost == float(\"inf\"):  # no best path yet, uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                p = Point(*rand_pos)\n                if grid.is_agent_valid_pos(p):\n                    return p\n\n        # Ellipsoidal informed sampling\n        c_best = self._best_cost\n        c_min = grid.get_distance(start, goal)\n        if c_best < float(\"inf\") and c_min > 0:\n            # Sample inside an ellipse formed by start, goal, and current best path cost (c_best)\n            import math\n\n            center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n            a1 = ((goal.x - start.x) / c_min, (goal.y - start.y) / c_min)  # unit vector from start to goal\n            # Rotation matrix from ellipse space to grid space\n            rot = np.array([[a1[0], -a1[1]], [a1[1], a1[0]]])\n\n            # Semi-major axis length\n            r1 = c_best / 2\n            # Semi-minor axis length\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n            # Sample random point in unit circle in ellipse coordinates\n            while True:\n                theta = 2 * math.pi * np.random.random()\n                rho = np.sqrt(np.random.random())\n                x_ball = rho * math.cos(theta)\n                y_ball = rho * math.sin(theta)\n\n                # Scale by ellipse axes\n                sample_local = np.array([r1 * x_ball, r2 * y_ball])\n                # Rotate back to map frame\n                sample_global = rot @ sample_local\n                sample_point = Point(int(center.x + sample_global[0]), int(center.y + sample_global[1]))\n\n                if 0 <= sample_point.x < grid.size.x and 0 <= sample_point.y < grid.size.y:\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Fallback uniform sampling\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            p = Point(*rand_pos)\n            if grid.is_agent_valid_pos(p):\n                return p\n\n    def _update_best_path(self, goal_vertex: Vertex):\n        \"\"\"\n        Update the best found goal vertex and best cost.\n        \"\"\"\n        if goal_vertex.cost < self._best_cost:\n            self._best_cost = goal_vertex.cost\n            self._best_goal_vertex = goal_vertex\n\n    def _extract_and_move(self, goal_vertex: Vertex):\n        self._extract_path(goal_vertex)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        iteration_limit = 8000\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: stop search\n                break\n\n            # Adaptive and local max step size around nearest vertex\n            q_sample = self._informed_sample(start_vertex.position, self._graph.root_vertex_goal.position)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist_local = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist_local)\n\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                continue\n\n            # Radius for neighbor search scales with step size and log of vertex count (RRT* theory)\n            radius = max(15.0, max_dist_local * (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** 0.5 * 5)\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                line_seq_nw = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # fallback to q_near if no better parent found\n                line_seq_qn = grid.get_line_sequence(q_near.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_qn):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n\n            # Add new vertex with chosen parent\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire nearby neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove all old parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if new vertex reaches goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_pos = grid.goal.position\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._update_best_path(goal_vertex)\n                    self._extract_and_move(goal_vertex)\n                    break\n\n            # Provide visualization keyframe\n            self.key_frame()\n\n        # If after iterations we have a best goal found, move along path\n        if self._best_goal_vertex is not None:\n            self._extract_and_move(self._best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
