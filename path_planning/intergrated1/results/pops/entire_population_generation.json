{
     "algorithm": "PathPlanning: \n    This algorithm is an improved version combining goal-biased informed sampling with heuristic-guided tree expansion for efficient pathfinding.\n    Key features:\n    - Uses a Forest graph to maintain a tree rooted at the start.\n    - Employs an adaptive max step size that shrinks as the tree approaches the goal, allowing finer movements near the goal for smoother paths.\n    - Incorporates goal bias with a probability of sampling directly near the goal.\n    - Uses a heuristic cost (distance to goal) to prioritize expansion towards more promising vertices.\n    - Implements rewiring optimization similar to RRT* but with an adaptive neighborhood radius based on graph size/log and distance to goal.\n    - Applies a path shortcutting technique on the extracted path to smooth and shorten it by attempting direct-valid line shortcuts.\n    - Early stopping if goal reached or if total planning time exceeds 10 seconds.\n    - The approach focuses on reducing total iterations, improving path smoothness, and enhancing success rate by adaptive sampling and rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with certain probability sample near goal, else random in space\n        import time\n        \n        if self._start_time is None:\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            # Sample in a small ball around goal for goal bias\n            for _ in range(30):  # max retry for valid pos\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback if can't sample near goal\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # If no valid sampled point found after retries (very rare), fallback to start pos\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Adaptive max move distance: smaller near goal, larger far away\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.3))\n        return scaled\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose first parent (assumes tree structure)\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path by skipping intermediate points\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j\n                    del path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along smoothed path with keyframes\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if self._start_time is None:\n                self._start_time = time.time()\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Stop searching after time limit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Cost from start through q_nearest to q_new\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Find nearby vertices for rewiring using adaptive radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size>0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among nearby vertices using cost + heuristic (distance to q_new)\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            # Reassign q_new with best parent found\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if q_new provides lower cost paths\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        # Add new edge from q_new to q_near\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if close enough to goal to consider connected\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                # Verify connection to goal is valid\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract and smooth path, then stop\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This path planning algorithm implements an improved version inspired by RRT* with goal-biased adaptive sampling,\n    dynamic step size, rewiring for path optimization, and early stopping criteria.\n    The method dynamically tunes the step size (`max_dist`) based on proximity to obstacles and goal to improve efficiency.\n    It increases sampling probability near the goal, and attempts rewiring of vertices within a radius to smooth the path.\n    The algorithm enforces a 10-second time limit for finding a path to treat as failure if exceeded.\n    Smooth shortcutting is applied after path extraction to improve path quality.\n    Overall, these enhancements improve planning efficiency, path smoothness, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring\n        self._init_displays()\n\n    def _get_goal_bias_sample(self, goal_prob=0.2) -> Point:\n        import random\n\n        if random.random() < goal_prob:\n            # Sample near the goal with some random noise within a radius\n            goal_pos = self._get_grid().goal.position\n            radius = 5\n            n_dim = self._get_grid().size.n_dim\n            for _ in range(20):\n                offset = tuple(np.random.randint(-radius, radius + 1) for _ in range(n_dim))\n                sample_candidate = Point(*(goal_pos[i] + offset[i] for i in range(n_dim)))\n                if self._get_grid().is_agent_valid_pos(sample_candidate):\n                    return sample_candidate\n            # fallback if no sample found near goal\n            return goal_pos\n        else:\n            return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex, vertices_within_radius: list, radius: float) -> None:\n        \"\"\"\n        Attempt to rewire the tree to improve cost,\n        by connecting lower-cost parents to neighbors if possible.\n        \"\"\"\n        grid = self._get_grid()\n        for q_near in vertices_within_radius:\n            if q_near == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n            proposed_cost = q_new.cost + grid.get_movement_cost(q_new.position, q_near.position)\n            if proposed_cost < q_near.cost:\n                # Remove old parent edges\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge with improved cost\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = proposed_cost\n\n    def _extract_path(self, q_new: Vertex):\n        grid = self._get_grid()\n        goal_v: Vertex = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: list = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # choose parent with smallest cost\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n\n        path.pop()  # Remove last (start duplicates)\n        path.reverse()\n\n        # Shortcut smooth path\n        path = self._shortcut_path(path)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Attempt to shortcut path by connecting non-adjacent vertices directly if feasible,\n        thus smoothing the path.\n        \"\"\"\n        if len(path) < 3:\n            return path\n        grid = self._get_grid()\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortcut_path.append(path[i + 1])\n                i += 1\n        return shortcut_path\n\n    def _get_adaptive_max_dist(self, pos: Point, base_dist=10, min_dist=2, max_dist=15) -> float:\n        \"\"\"\n        Adapt step size depending on proximity to obstacles and goal.\n        Closer to obstacles: smaller step size.\n        Closer to goal: smaller step size for finer maneuvering.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        # Check obstacles within a fixed radius\n        obs_check_radius = 5\n        nearby_points = grid.get_vertices_within_radius(self._graph.root_vertices, pos, obs_check_radius)\n        # Count how many obstacle vertices are nearby (approximation)\n        obstacle_proximity_factor = 0.0\n        for obs in nearby_points:\n            d = Map.get_distance(pos, obs.position)\n            if d < obs_check_radius:\n                obstacle_proximity_factor = max(obstacle_proximity_factor, (obs_check_radius - d) / obs_check_radius)\n        # Compute adaptive dist\n        max_dist = base_dist * (1 - 0.5 * obstacle_proximity_factor)\n        # Reduce max_dist near goal\n        if dist_to_goal < base_dist * 3:\n            max_dist = min(max_dist, max(min_dist, dist_to_goal / 2))\n        max_dist = max(min_dist, min(max_dist, max_dist))\n        return max_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n\n        max_iterations = 8000\n        radius_rewire = 15.0  # neighborhood radius for rewiring\n        goal_reached = False\n        start_time = time.time()\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10:\n                # Timeout 10 seconds exceeded - treat as failure\n                break\n\n            q_sample = self._get_goal_bias_sample(goal_prob=0.25)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist = torch.norm(dir_vec).item()\n            if dist == 0:\n                continue\n            if dist > max_dist:\n                dir_normalized = dir_vec / dist\n                q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            else:\n                q_new_point = q_sample\n\n            if not grid.is_agent_valid_pos(q_new_point):\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_point)\n            movement_cost = grid.get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = q_near.cost + movement_cost\n\n            # Search neighbors for better parent\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            min_cost = q_new.cost\n            best_parent = q_near\n\n            for q_nearby in neighbors:\n                if q_nearby == q_near:\n                    continue\n                line_seq2 = grid.get_line_sequence(q_nearby.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq2):\n                    continue\n                cost_through_nearby = q_nearby.cost + grid.get_movement_cost(q_nearby.position, q_new.position)\n                if cost_through_nearby < min_cost:\n                    min_cost = cost_through_nearby\n                    best_parent = q_nearby\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors using q_new if better cost paths found\n            self._rewire(q_new, neighbors, radius_rewire)\n\n            # Check goal reached\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_reached = True\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n        if not goal_reached:\n            # Optionally, attempt direct connection to goal if close enough at the end\n            q_near_goal = self._graph.get_nearest_vertex([self._graph.root_vertex_start], goal_pos)\n            line_seq_goal = grid.get_line_sequence(q_near_goal.position, goal_pos)\n            if grid.is_valid_line_sequence(line_seq_goal) and Map.get_distance(q_near_goal.position, goal_pos) < 20:\n                goal_v = Vertex(goal_pos)\n                self._graph.add_edge(q_near_goal, goal_v)\n                self._extract_path(goal_v)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an Adaptive Heuristic Guided Tree Planner (AHGTP) combining goal-biased and heuristic sampling \n    with adaptive step size and path smoothing. \n    It dynamically adjusts sampling density near the goal and obstacles, uses an A*-inspired cost heuristic to prioritize expansion, \n    and adapts the step size based on local obstacle density. \n    After connecting the start to the goal, it performs an iterative shortcut smoothing on the final path to reduce unnecessary waypoints,\n    improving path quality and smoothness. \n    Additionally, it enforces a maximum runtime of 10 seconds for robust early stopping.\n    This approach aims to improve planning efficiency, path quality, and success rate over traditional RRT* or SPRM algorithms.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    _graph: Forest\n    _max_step_dist: float\n    _goal_sample_rate: float\n    _heuristic_weight: float\n    _max_runtime_sec: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_step_dist = 15.0\n        self._goal_sample_rate = 0.3  # 30% of samples biased towards goal\n        self._heuristic_weight = 1.2  # weight on heuristic cost for priority calculation\n        self._max_runtime_sec = 10.0  # max time to run planner (seconds)\n        self._init_displays()\n\n    def _get_adaptive_step_dist(self, position: Point) -> float:\n        \"\"\"\n        Adapt step size based on obstacle density around position:\n        More obstacles nearby => reduce step size to improve safety.\n        \"\"\"\n        radius = 5.0\n        nearby_obstacles_points = 0\n        # Count obstacles within radius by sampling around\n        for obstacle in self._get_grid().obstacles:\n            obstacle_points = self._get_grid().get_obstacle_bound(obstacle.position)\n            for p in obstacle_points:\n                dist = Map.get_distance(position, p)\n                if dist <= radius:\n                    nearby_obstacles_points += 1\n                    if nearby_obstacles_points > 15:\n                        # Early exit if crowded\n                        return max(self._max_step_dist * 0.3, 5.0)\n        # Scale step distance inversely\n        scale = 1.0 - min(nearby_obstacles_points / 20.0, 0.7)\n        adaptive_dist = max(self._max_step_dist * scale, 5.0)\n        return adaptive_dist\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Goal-biased adaptive random sampling\"\"\"\n        if torch.rand(1).item() < self._goal_sample_rate:\n            # Bias sample towards a small region near the goal\n            goal_pos = self._get_grid().goal.position\n            size = self._get_grid().size\n            perturb_dim = size.n_dim\n            # Uniform small random offset around goal\n            low_offset = torch.tensor([-3.0] * perturb_dim)\n            high_offset = torch.tensor([3.0] * perturb_dim)\n            offset = torch.empty(perturb_dim).uniform_(low_offset.min().item(), high_offset.max().item())\n            sampled = Point(*(torch.clamp(goal_pos.to_tensor() + offset, min=0, max=torch.tensor(size).float()).int()))\n            if self._get_grid().is_agent_valid_pos(sampled):\n                return sampled\n        # Otherwise uniform sampling\n        while True:\n            sample_coords = [torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)]\n            sample = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        # Search nearest in start tree only to maintain single tree growth\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> list:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        q_new_point = Point.from_tensor(q_new_tensor)\n        return Vertex(q_new_point)\n\n    def _heuristic_cost(self, frm: Vertex) -> float:\n        \"\"\"Estimate total cost f = g + h for A*-like guidance.\"\"\"\n        goal_pos = self._graph.root_vertex_goal.position\n        h = Map.get_distance(frm.position, goal_pos)\n        return frm.cost + self._heuristic_weight * h\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent minimizing cost + heuristic, validate edge collision.\"\"\"\n        min_cost = float(\"inf\")\n        best_parent = None\n        for q_near in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + Map.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, neighbors: list, q_new: Vertex) -> None:\n        \"\"\"Try rewiring neighbors to achieve lower cost through q_new.\"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            potential_cost = q_new.cost + Map.get_distance(q_new.position, q_near.position)\n            if potential_cost < q_near.cost:\n                # Rewire edge\n                old_parents = list(q_near.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, q_near)\n                q_near.cost = None  # Clear stale cost\n                q_near.cost = potential_cost\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"Extract path and perform shortcut smoothing.\"\"\"\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            current = next(iter(current.parents))\n            path.append(current)\n        path.reverse()\n\n        # Shortcut smoothing (attempt to reduce unnecessary waypoints)\n        def line_clear(p1: Point, p2: Point) -> bool:\n            line_seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        smoothed_path = [path[0].position]\n        i = 0\n        n = len(path)\n        while i < n - 1:\n            j = n - 1\n            while j > i + 1:\n                if line_clear(path[i].position, path[j].position):\n                    smoothed_path.append(path[j].position)\n                    i = j\n                    break\n                j -= 1\n            else:\n                smoothed_path.append(path[i+1].position)\n                i += 1\n\n        # Move the agent along the smoothed path\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            grid = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 5000\n        dimension = self._get_grid().size.n_dim\n        c_best = float(\"inf\")\n        c_min = Map.get_distance(self._get_grid().agent.position, self._get_grid().goal.position)\n        goal_reached = False\n        radius_constant = 30.0\n\n        for iter_index in range(max_iterations):\n            # Abort if exceed max runtime\n            if time.time() - start_time > self._max_runtime_sec:\n                # Fail early gracefully\n                break\n\n            # Adaptive sampling and step size\n            q_sample = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            adaptive_step = self._get_adaptive_step_dist(q_nearest.position)\n            q_new = self._get_new_vertex(q_nearest, q_sample, adaptive_step)\n\n            # Check collision free path for new edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Radius for neighborhood search inspired by RRT*\n            card_v = torch.tensor(float(self._graph.size + 1))\n            log_card = torch.log(card_v)\n            radius = min(radius_constant * ((log_card / card_v) ** (1.0 / dimension)), radius_constant)\n\n            neighbors = self._get_vertices_within_radius(q_new, radius)\n            if not neighbors:\n                neighbors = [q_nearest]\n\n            # Choose best parent minimizing cost + heuristic\n            parent = self._choose_parent(neighbors, q_new)\n            if parent is None:\n                continue\n\n            # Update q_new's cost and add to graph\n            q_new.cost = parent.cost + Map.get_distance(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(neighbors, q_new)\n\n            # Check if reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect the goal vertex directly from q_new if collision free\n                goal_vertex = self._graph.root_vertex_goal\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + Map.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    goal_reached = True\n                    break\n\n            # Key frame update for visualization\n            self.key_frame()\n\n        if not goal_reached:\n            # No path found within time/iterations\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed RRT* (Rapidly-exploring Random Tree Star) inspired path planner \n    enhanced with adaptive step size, goal-biased sampling, and path smoothing. \n    \n    Key features:\n    - Adaptive step size that decreases near obstacles or densely connected areas.\n    - Goal-biased sampling to increase the chance of connecting to the goal.\n    - Rewiring to improve path quality by checking alternate parent connections within a neighborhood radius.\n    - Path shortcut smoothing after a solution is found to create a shorter, smoother final route.\n    - Early stopping criteria with timeout of 10 seconds to prevent excessive planning times.\n    - Heuristic-driven nearest vertex search to reduce unnecessary expansions.\n    \n    The algorithm builds a single search tree rooted at the agent's start, expanding towards random \n    samples that are biased towards the goal. Whenever a new vertex is added, it tries to rewire nearby nodes \n    to reduce overall cost. After reaching goal vicinity, it extracts and smooths the path for better quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position, store_connectivity=True), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._max_dist = 15.0\n        self._goal_sample_rate = 0.2  # 20% chance to sample goal directly\n        self._radius_neighborhood = 30.0  # Radius for rewiring nearby vertices\n        self._iterations = 10000\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: sometimes directly sample the goal to speed up connection.\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, root_vertices: list, point: Point) -> Vertex:\n        # Heuristic: Nearest vertex considering cost + heuristic distance (like A*)\n        candidates = self._graph.root_vertices if root_vertices is None else root_vertices\n        nearest_vertex = None\n        best_cost = float('inf')\n        for vertex in candidates:\n            dist = self._get_grid().get_distance(vertex.position, point)\n            cost_est = vertex.cost + dist\n            if cost_est < best_cost:\n                best_cost = cost_est\n                nearest_vertex = vertex\n        # If root_vertices is large, fall back to graph method for performance.\n        if nearest_vertex is None:\n            nearest_vertex = self._graph.get_nearest_vertex(root_vertices, point)\n        return nearest_vertex\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Returns cost from from_vertex to to_point including movement cost + from_vertex cost\n        move_cost = self._get_grid().get_movement_cost(from_vertex.position, to_point)\n        return from_vertex.cost + move_cost\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        # Choose the best parent vertex around q_new (lowest cost path + valid connection)\n        min_cost = float('inf')\n        best_parent = None\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                continue\n            cost = self._cost(neighbor, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, neighbors: list, q_new: Vertex) -> None:\n        # Try to improve cost of neighbors by rewiring through q_new\n        for neighbor in neighbors:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                continue\n            new_cost = self._cost(q_new, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parent edge(s)\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                # Add edge from q_new to neighbor\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        # Trace back path from goal to start\n        path: list = [goal_vertex]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n        # Smooth path by shortcutting\n        path_smoothed = self._shortcut_smooth(path)\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_smooth(self, path: list) -> list:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Reduce max_dist when near obstacles or in constrained spaces\n        # Check surroundings for obstacles within 2*max_dist radius bounding box\n        check_radius = self._max_dist * 2\n        obstacle_nearby = False\n        for obstacle in self._get_grid().obstacles:\n            d = self._get_grid().get_distance(pos, obstacle.position)\n            if d < check_radius + obstacle.radius:\n                obstacle_nearby = True\n                break\n        if obstacle_nearby:\n            return max(self._max_dist * 0.5, 3.0)  # smaller step near obstacle\n        return self._max_dist\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        for i in range(self._iterations):\n            if time() - start_time > 10.0:\n                # Timeout: stop and consider no path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            nearest_vertex: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            # Adaptive step size based on proximity to obstacles/environment\n            local_max_dist = self._adaptive_max_dist(nearest_vertex.position)\n            q_new: Vertex = self._get_new_vertex(nearest_vertex, q_sample, local_max_dist)\n\n            # Check valid path from nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._radius_neighborhood)\n\n            # Choose best parent among neighbors + nearest_vertex (include nearest if not in neighbors)\n            if nearest_vertex not in neighbors:\n                neighbors.append(nearest_vertex)\n            best_parent = self._choose_parent(neighbors, q_new)\n            if best_parent is None:\n                self.key_frame()\n                continue\n            q_new.cost = self._cost(best_parent, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new to improve path cost\n            self._rewire(neighbors, q_new)\n\n            self._graph.root_vertices.append(q_new)\n\n            # Check if goal reached or within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                # Connect q_new to goal_vertex, if path valid\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Extract and smooth path then exit\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an RRT* inspired path planner that combines goal-biased adaptive sampling,\n    rewiring for path optimization, and an adaptive step size for efficient exploration and smoother paths.\n    It balances exploration and exploitation by sampling towards the goal with a bias while considering the\n    environment's clearance to adjust the extension step. The rewiring step tries to reduce total path cost dynamically,\n    improving path quality and success rate. An early timeout of 10 seconds ensures practical responsiveness.\n    A final path shortcutting step smooths the found path before tracing it.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, return goal point directly\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Adapt step size by estimating clearance to nearest obstacle bound or environment border.\n        # Sample neighbors; if free space large, increase max_dist, else reduce it.\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=5):\n            # Check a line from pos in direction towards goal scaled by radius if collision-free\n            direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            # Also validate line sequence\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        \n        # Check validity of the line along new connection\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent from neighbors that minimize cost + movement cost if edge is valid\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # Try to rewire neighbors through q_new if it reduces cost and line is valid\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            dist = Map.get_distance(q_new.position, v.position)\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to v and add edge from q_new to v\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new up to start, add goal edge, shortcut path and trace agent\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Pick parent with minimum cost (could be multiple parents)\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove the start duplicate\n        path.reverse()\n\n        # Shortcut smoothing to improve path quality: try to skip intermediate vertices if direct line is valid\n        smoothed_path = [path[0]]\n        for v in path[1:]:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed_path[-1].position, v.position)):\n                # can connect directly\n                continue\n            else:\n                # add previous vertex since current direct connection invalid\n                prev_index = path.index(v) - 1\n                smoothed_path.append(path[prev_index])\n        # Always append last vertex (goal)\n        smoothed_path.append(path[-1])\n\n        # Trace the path to move agent\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 10000\n        goal_sample_rate: float = 0.3\n        search_radius: float = 15.0  # radius for rewiring\n        start_time = time.time()\n        \n        # Initialize start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failed\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for potential parents\n            q_near_list: List[Vertex] = self._get_near_vertices(q_new, search_radius)\n            chosen_parent: Optional[Vertex] = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and set cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Check for goal reach with some radius threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "A Novel Bidirectional Heuristic-Enhanced RRT* with Informed and Adaptive Sampling\n    -------------------------------------------------------------------------------\n    This algorithm combines bidirectional tree growth with heuristic-driven informed sampling \n    and adaptive step sizing while employing rewiring to optimize the path. \n    \n    Key ideas:\n    - Two forests (start-rooted and goal-rooted) grow simultaneously and attempt connection.\n    - Adaptive step size modulates based on proximity to goal or other tree (for finer control).\n    - Heuristic cost (g + h) guides vertex selection and expansion.\n    - Informed sampling within an ellipsoidal region defined by current best path cost, biases sampling to promising regions.\n    - Rewiring with neighbors optimizes paths in both trees.\n    - Early termination when trees connect.\n    - Timeout after 10 seconds enforced.\n    - Extracted path smoothened via shortcutting.\n    This approach aims to improve planning efficiency, success rate, and path quality by blending bidirectional RRT*, heuristic guidance, and informed sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import math\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Bidirectional trees within one forest: maintain two root vertices\n        # Extend from and toward each other's trees to try connecting them.\n\n        max_iterations = 6000\n        start_time = time.time()\n        time_limit = 10.0  # seconds\n\n        dimension = 2\n        rewire_lambda = 40\n        min_step = 3.0\n        max_step = 12.0\n\n        # Track best connection cost and vertices to extract path if found\n        best_connection_cost = math.inf\n        best_connection_pair = None\n\n        def adaptive_max_dist(pos_a: Point, pos_b: Point) -> float:\n            \"\"\"Adaptive step size decreases as points get nearer.\"\"\"\n            d = Map.get_distance(pos_a, pos_b)\n            step = max(min_step, min(max_step, d * 0.5))\n            return step\n\n        def cost_heuristic(pos: Point) -> float:\n            \"\"\"Heuristic from pos to goal.\"\"\"\n            return Map.get_distance(pos, goal_vertex.position)\n\n        def informed_sample(c_best: float, start: Point, goal: Point) -> Point:\n            \"\"\"Sample within an ellipse defined by start, goal and best cost (c_best).\"\"\"\n            # If no solution found yet, sample uniformly.\n            if c_best == math.inf:\n                for _ in range(50):\n                    candidate_coords = []\n                    for dim in range(dimension):\n                        candidate_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                    candidate = Point(*candidate_coords)\n                    if grid.is_agent_valid_pos(candidate):\n                        return candidate\n                return start\n\n            # Ellipse sampling inspired by Informed RRT*\n            center = Point(\n                (start.x + goal.x) / 2,\n                (start.y + goal.y) / 2\n            )\n            c_min = Map.get_distance(start, goal)\n            if c_min == 0:\n                return start\n\n            a1 = (goal.x - start.x) / c_min\n            a2 = (goal.y - start.y) / c_min\n\n            # ellipse radii\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n            for _ in range(100):  # sampling retries\n                # Sample random point in unit circle\n                while True:\n                    x = torch.rand(1).item() * 2 - 1\n                    y = torch.rand(1).item() * 2 - 1\n                    if x * x + y * y <= 1:\n                        break\n                sample_ellipse_x = r1 * x\n                sample_ellipse_y = r2 * y\n\n                # Rotate sample back to original coordinate frame\n                sample_x = center.x + sample_ellipse_x * a1 - sample_ellipse_y * a2\n                sample_y = center.y + sample_ellipse_x * a2 + sample_ellipse_y * a1\n\n                sample_point = Point(round(sample_x), round(sample_y))\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # fallback to uniform sampling \n            for _ in range(50):\n                candidate_coords = []\n                for dim in range(dimension):\n                    candidate_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                candidate = Point(*candidate_coords)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n\n            return start  # fallback\n\n        def extract_and_smooth_path(v_start: Vertex, v_goal: Vertex) -> None:\n            # Extract path from start tree root to connection vertex and from goal tree root to connection vertex\n            path_start = []\n            current = v_start\n            while True:\n                path_start.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n            path_start.reverse()\n\n            path_goal = []\n            current = v_goal\n            while True:\n                path_goal.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n\n            full_path = path_start + path_goal\n\n            # Shortcut smoothing\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(seq):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n            # Follow path\n            for v in full_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        root_start_list = [start_vertex]\n        root_goal_list = [goal_vertex]\n\n        for iteration in range(max_iterations):\n\n            current_time = time.time()\n            if current_time - start_time > time_limit:\n                # No path found within time limit\n                return\n\n            # Alternate growth between start tree and goal tree\n            grow_from_start = (iteration % 2 == 0)\n            tree_roots = root_start_list if grow_from_start else root_goal_list\n            other_roots = root_goal_list if grow_from_start else root_start_list\n\n            # Current root vertices\n            root_vertex = tree_roots[0]\n\n            # Obtain informed sample\n            q_sample = informed_sample(best_connection_cost, start_vertex.position, goal_vertex.position)\n\n            # Find nearest vertex in current tree\n            q_nearest = self._graph.get_nearest_vertex(tree_roots, q_sample)\n            if q_nearest.position == q_sample:\n                # sample same as vertex, skip\n                continue\n\n            # Compute adaptive max dist from q_nearest towards sample\n            max_dist = adaptive_max_dist(q_nearest.position,\n                                        goal_vertex.position if grow_from_start else start_vertex.position)\n\n            # Steer towards sample\n            q_nearest_tensor = q_nearest.position.to_tensor()\n            q_sample_tensor = q_sample.to_tensor()\n            dir_vec = q_sample_tensor - q_nearest_tensor\n            dir_norm = torch.norm(dir_vec).item()\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest_tensor + dir_normalized * max_dist).round().int())\n\n            # Validate position and path\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Cost: g-cost from start of the current tree plus cost to q_new\n            dist_nearest_to_new = Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Find neighbors for rewiring with adaptive radius\n            card_v = self._graph.size if self._graph.size > 0 else 1\n            radius = min(rewire_lambda * ((math.log(card_v) / card_v) ** (1 / dimension)), 25.0)\n            neighbors = self._graph.get_vertices_within_radius(tree_roots, q_new.position, radius)\n\n            # Choose best parent from neighbors minimizing cost + validate path\n            q_min = q_nearest\n            c_min = q_new.cost\n            for q_near in neighbors:\n                dist_candidate = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_candidate\n                line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_cand):\n                    q_min = q_near\n                    c_min = cost_candidate\n            q_new.cost = c_min\n\n            # Add edge chosen parent -> q_new\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for lower cost paths through q_new\n            for q_near in neighbors:\n                if q_near == q_min:\n                    continue\n                dist_new_to_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old edge from some parent to q_near\n                        for p in q_near.parents:\n                            self._graph.remove_edge(p, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Try to connect q_new in current tree with nearest in other tree\n            q_other_near = self._graph.get_nearest_vertex(other_roots, q_new.position)\n            dist_to_other = Map.get_distance(q_new.position, q_other_near.position)\n            if dist_to_other <= max_dist:\n                # Check line validity both ways to ensure bidirectional connectivity\n                line1 = grid.get_line_sequence(q_new.position, q_other_near.position)\n                line2 = grid.get_line_sequence(q_other_near.position, q_new.position)\n                if grid.is_valid_line_sequence(line1) and grid.is_valid_line_sequence(line2):\n                    # Connect trees by adding edges both ways to maintain connectivity\n                    self._graph.add_edge(q_new, q_other_near)\n                    self._graph.add_edge(q_other_near, q_new)\n\n                    # Determine total path cost through connection\n                    total_cost = q_new.cost + q_other_near.cost + dist_to_other\n                    if total_cost < best_connection_cost:\n                        best_connection_cost = total_cost\n                        best_connection_pair = (q_new, q_other_near)\n\n                        # Extract and smooth path\n                        extract_and_smooth_path(q_new, q_other_near)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is a novel hybrid method integrating heuristic-guided bidirectional search with adaptive incremental sampling. \n    \n    Key features and innovations:\n    - Uses a CyclicGraph structure to maintain two expanding trees simultaneously: one from start and one from goal, aiming to connect them.\n    - Applies heuristic (A*-like) cost estimation combining exact cost-from-root plus admissible heuristic to guide vertex expansions.\n    - Sampling is adaptive and goal-biased: alternating samples near start, near goal, and globally random valid points to balance exploration.\n    - Employs an adaptive step size based on local density and distance to opposite root to control expansion length, allowing finer control near tree frontiers.\n    - Connect attempts between trees use a heuristic-ordered edge candidates queue to prioritize promising connections.\n    - When a connection is made, performs a shortcut and smoothing step by attempting direct valid line shortcuts across the constructed path.\n    - Early stopping after success or after 10 seconds to guarantee bounded runtime.\n    - Uses rewiring akin to RRT* with local radius adaptive to graph size and distance heuristics to optimize path cost inside each tree.\n    - The bidirectional approach improves planning efficiency by growing from both ends to meet in middle, potentially reducing iterations compared to unidirectional growth.\n    \n    Overall, this method blends concepts from RRT*, heuristic A*, and bidirectional search with focused incremental sampling and rewiring, aiming for efficient, robust, and high-quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.0\n        self._goal_sample_rate = 0.25\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._init_displays()\n\n    def _get_heuristic_cost(self, frm_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance as admissible heuristic\n        return Map.get_distance(frm_pos, to_pos)\n\n    def _get_adaptive_step_size(self, current_pos: Point, opposite_root_pos: Point) -> float:\n        # Step size shrinks when closer to opposite root position for finer connect attempts\n        dist = Map.get_distance(current_pos, opposite_root_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.2))\n        return scaled\n\n    def _get_bidirectional_sample(self, iteration: int) -> Point:\n        # Alternates sampling near start, near goal and globally random\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        mode = iteration % 3\n        # 0: sample near start with some noise\n        # 1: sample near goal with some noise\n        # 2: uniform random sample\n        if mode == 0:\n            for _ in range(30):\n                offset = torch.randn(self._dimension) * self._min_max_dist\n                sample = Point(*(start_pos.to_tensor() + offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return start_pos\n        elif mode == 1:\n            for _ in range(30):\n                offset = torch.randn(self._dimension) * self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return start_pos  # fallback\n\n    def _create_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            new_pos = q_sample\n        else:\n            dir_norm = dir_tensor / norm\n            new_pos = Point.from_tensor((q_near.position.to_tensor() + dir_norm * max_dist).round().int())\n        if not self._get_grid().is_agent_valid_pos(new_pos):\n            return None\n        line_seq = self._get_grid().get_line_sequence(q_near.position, new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        q_new = Vertex(new_pos)\n        return q_new\n\n    def _try_add_vertex_with_rewire(self, tree_root: Vertex, q_near: Vertex, q_new: Vertex) -> bool:\n        # Adds q_new connecting from best parent in neighborhood, rewires neighbors if better path found.\n        grid = self._get_grid()\n\n        dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n        q_new.cost = q_near.cost + dist_near_new\n\n        card_v = max(self._graph.size, 1)\n        log_card_v = torch.log(torch.tensor(float(card_v))) if card_v > 1 else torch.tensor(0.0)\n        radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 20.0)\n\n        vertices_near = self._graph.get_vertices_within_radius([tree_root], q_new.position, radius)\n\n        q_min = q_near\n        c_min = q_new.cost\n\n        for q_near_candidate in vertices_near:\n            dist = torch.norm(q_near_candidate.position.to_tensor() - q_new.position.to_tensor()).item()\n            cost_candidate = q_near_candidate.cost + dist\n            if cost_candidate < c_min:\n                line_seq = grid.get_line_sequence(q_near_candidate.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    q_min = q_near_candidate\n                    c_min = cost_candidate\n\n        q_new.cost = c_min\n        self._graph.add_edge(q_min, q_new)\n\n        for q_near_candidate in vertices_near:\n            if q_near_candidate == q_min:\n                continue\n            dist_new_near = torch.norm(q_new.position.to_tensor() - q_near_candidate.position.to_tensor()).item()\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new < q_near_candidate.cost:\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near_candidate.position)\n                if grid.is_valid_line_sequence(line_seq_rewire):\n                    # Remove old parent edge(s)\n                    for parent in q_near_candidate.parents:\n                        self._graph.remove_edge(parent, q_near_candidate)\n                        break\n                    q_near_candidate.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near_candidate)\n        return True\n\n    def _try_connect_trees(self, q_new: Vertex, opposite_root: Vertex) -> Vertex:\n        # Attempt to connect q_new to the opposite tree.\n        grid = self._get_grid()\n        oppos_vertices = self._graph.root_vertices if opposite_root in self._graph.root_vertices else [opposite_root]\n        # Gather candidates near q_new from opposite tree within step radius\n        max_step = self._get_adaptive_step_size(q_new.position, opposite_root.position)\n        candidates = self._graph.get_vertices_within_radius([opposite_root], q_new.position, max_step)\n        candidates += self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, max_step)\n        candidates = list(set(candidates))\n        candidates.sort(key=lambda v: Map.get_distance(v.position, q_new.position))  # prioritize closer connections\n\n        for q_opposite in candidates:\n            line_seq = grid.get_line_sequence(q_new.position, q_opposite.position)\n            if grid.is_valid_line_sequence(line_seq):\n                return q_opposite\n        return None\n\n    def _extract_bidirectional_path(self, connect_v_start: Vertex, connect_v_goal: Vertex) -> None:\n        # Extract path moving backward to start root and forward to goal root, then smooth.\n        path_start = []\n        cur = connect_v_start\n        while True:\n            path_start.append(cur)\n            if len(cur.parents) == 0:\n                break\n            cur = next(iter(cur.parents))\n        path_start.reverse()\n\n        path_goal = []\n        cur = connect_v_goal\n        # Walk children on goal side (tree direction is from goal to leaves)\n        while True:\n            path_goal.append(cur)\n            if len(cur.children) == 0:\n                break\n            cur = next(iter(cur.children))\n\n        full_path = path_start + path_goal[1:]  # avoid duplication at connection point\n\n        # Shortcut smoothing: attempt to connect across intermediate vertices with direct valid line\n        grid = self._get_grid()\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early stop on time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # Alternate sample from start or goal tree for balanced bidirectional growth\n            sample_point = self._get_bidirectional_sample(iteration)\n\n            # Decide which tree to expand on this iteration: alternate start/goal trees\n            if iteration % 2 == 0:\n                tree_root, opposite_root = start_vertex, goal_vertex\n            else:\n                tree_root, opposite_root = goal_vertex, start_vertex\n\n            q_near = self._graph.get_nearest_vertex([tree_root], sample_point)\n            if q_near.position == sample_point:\n                continue\n\n            max_dist = self._get_adaptive_step_size(q_near.position, opposite_root.position)\n            q_new = self._create_new_vertex(q_near, sample_point, max_dist)\n            if q_new is None:\n                continue\n\n            success = self._try_add_vertex_with_rewire(tree_root, q_near, q_new)\n            if not success:\n                continue\n\n            # Attempt connection between trees to complete path\n            q_connect = self._try_connect_trees(q_new, opposite_root)\n            if q_connect is not None:\n                # Link both vertices (bidirectional)\n                dist_connect = Map.get_distance(q_new.position, q_connect.position)\n                # Add edges in both directions for cyclic graph connectivity\n                self._graph.add_edge(q_new, q_connect)\n                self._graph.add_edge(q_connect, q_new)\n                # Extract and smooth resulting path traversing start-to-connection and goal-to-connection\n                if tree_root == start_vertex:\n                    self._extract_bidirectional_path(q_new, q_connect)\n                else:\n                    self._extract_bidirectional_path(q_connect, q_new)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an informed bidirectional tree search on a Forest graph\n    combining several improvements inspired by RRT*, A*, and bidirectional search:\n    - Uses two trees grown simultaneously from start and goal (bidirectional growth).\n    - Samples a dynamically shrinking ellipsoidal informed region based on current best path cost,\n      thus focusing samples to improve path quality and efficiency.\n    - Uses heuristic combined cost (cost-to-come + cost-to-go) for selecting expansions.\n    - Adaptive step size based on distance to target vertex to allow finer movements near connections.\n    - Implements rewiring in both trees to optimize path quality.\n    - Tries to connect the two trees directly when vertices are close, allowing early stopping.\n    - Performs path shortcutting on the combined path after connection.\n    - Stops after finding a viable path or when time budget (10s) exceeded.\n    This approach improves success rate and path quality with fewer iterations by focused sampling and dual expansions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.0   # Min step size near goal/connection\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # planning time limit seconds\n        self._best_path_cost = float('inf')\n        self._best_path = None\n        self._init_displays()\n\n    def _sample_informed_region(self, c_best: float, c_min: float, start_pos: Point, goal_pos: Point) -> Point:\n        \"\"\"\n        Sample a point inside an ellipse defined by start and goal positions and current best cost.\n        If no better path found yet, sample uniformly in full grid.\n        \"\"\"\n        import math\n        import random\n\n        grid = self._get_grid()\n        if c_best == float('inf'):\n            # Uniform random sampling in grid\n            for _ in range(100):\n                coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n                pt = Point(*coords)\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n            return start_pos\n\n        # Construct ellipse parameters:\n        # foci are start and goal positions\n        # c_best is current best solution cost (ellipse major axis length)\n        # c_min is direct Euclidean distance start-goal (ellipse focal length)\n        # Sample inside ellipse with covariance aligned to start-goal vector.\n\n        start_tensor = start_pos.to_tensor().float()\n        goal_tensor = goal_pos.to_tensor().float()\n        center = (start_tensor + goal_tensor) / 2.0\n        diff = goal_tensor - start_tensor\n        e = c_min / c_best  # eccentricity\n        if e > 1.0:\n            e = 1.0  # numerical stability\n\n        # Create rotation matrix that aligns x-axis with line start->goal\n        angle = torch.atan2(diff[1], diff[0]).item()\n        cos_angle = math.cos(angle)\n        sin_angle = math.sin(angle)\n\n        # lengths of ellipse axes\n        a = c_best / 2.0  # major axis\n        b = math.sqrt(a * a - (c_min/2.0)**2)  # minor axis, safe sqrt\n\n        # Try sampling in unit circle then scale/rotate to ellipse region\n        for _ in range(100):\n            # sample random point in unit circle\n            r = random.uniform(0, 1) ** 0.5\n            theta = random.uniform(0, 2 * math.pi)\n            x_unit = r * math.cos(theta)\n            y_unit = r * math.sin(theta)\n\n            # scale by ellipse axes\n            x_ellipse = x_unit * a\n            y_ellipse = y_unit * b\n\n            # rotate back by angle and translate to ellipse center\n            x_rot = cos_angle * x_ellipse - sin_angle * y_ellipse\n            y_rot = sin_angle * x_ellipse + cos_angle * y_ellipse\n\n            sample_coords = (center + torch.tensor([x_rot, y_rot])).round().int()\n            sample_point = Point(int(sample_coords[0].item()), int(sample_coords[1].item()))\n\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform in grid if no ellipse sample valid\n        for _ in range(100):\n            coords = [random.randint(0, grid.size[i] - 1) for i in range(self._dimension)]\n            pt = Point(*coords)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n        return start_pos\n\n    def _get_adaptive_max_dist_for_connection(self, q_pos: Point, target_pos: Point) -> float:\n        # Sharper adaptive step size based on distance to target, but with guaranteed min step for smoother connection\n        base_dist = Map.get_distance(q_pos, target_pos)\n        scaled_dist = max(self._min_max_dist, min(self._max_max_dist, 0.4 * base_dist))\n        return scaled_dist\n\n    def _rewire_nearby(self, graph: Forest, q_new: Vertex, radius: float) -> None:\n        grid = self._get_grid()\n        vertices_near = graph.get_vertices_within_radius(graph.root_vertices, q_new.position, radius)\n\n        for q_near in vertices_near:\n            if q_near == q_new:\n                continue\n            dist_new_near = Map.get_distance(q_new.position, q_near.position)\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new < q_near.cost:\n                line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                # Remove old parent edge\n                for parent in list(q_near.parents):\n                    graph.remove_edge(parent, q_near)\n                    break\n                q_near.cost = cost_through_new\n                graph.add_edge(q_new, q_near)\n\n    def _connect_trees(self, q_new_start: Vertex, graph_goal: Forest) -> (bool, Vertex):\n        \"\"\"\n        Try to connect vertex from start tree to goal tree vertex within adaptive radius.\n        Return (success, combined_goal_vertex) pair.\n        \"\"\"\n        grid = self._get_grid()\n        radius = self._get_adaptive_max_dist_for_connection(q_new_start.position, grid.goal.position)\n        vertices_near_goal = graph_goal.get_vertices_within_radius(graph_goal.root_vertices, q_new_start.position, radius)\n\n        best_connection_vertex = None\n        best_cost = float('inf')\n        for q_goal_vertex in vertices_near_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, q_goal_vertex.position)\n            if grid.is_valid_line_sequence(line_seq):\n                dist_connect = Map.get_distance(q_new_start.position, q_goal_vertex.position)\n                total_cost = q_new_start.cost + dist_connect + q_goal_vertex.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_connection_vertex = q_goal_vertex\n\n        if best_connection_vertex is None:\n            return False, None\n\n        # Create connecting vertex in goal tree to start tree: merge vertices by adding edge start->goal vertex\n        # We connect start tree vertex to goal tree vertex to form a path\n        self._graph_start.add_edge(q_new_start, best_connection_vertex)\n        return True, best_connection_vertex\n\n    def _extract_bidirectional_path_and_smooth(self, q_start_goal: Vertex, graph_goal: Forest):\n        \"\"\"\n        Extract path from start root to connection vertex and from connection vertex to goal root,\n        combine, smooth, and move agent along path with keyframes.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Extract path from start tree root to q_start_goal\n        path_start = []\n        current = q_start_goal\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        # Extract path from q_start_goal to goal root (in goal tree)\n        # Since q_start_goal is connected in goal tree, run dfs parents to goal root\n        path_goal = []\n        current_goal = q_start_goal\n        while True:\n            # Since q_start_goal in goal tree, have parents (or root)\n            # We follow parents towards goal root (which has no parents)\n            if len(current_goal.parents) == 0:\n                break\n            current_goal = next(iter(current_goal.parents))\n            path_goal.append(current_goal)\n\n        # Combine paths: start->connection->goal\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing on full path\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediates between i and j\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along path and render keyframes\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_pos = self._graph_start.root_vertex_start.position\n        goal_pos = self._graph_goal.root_vertex_start.position  # goal start in reversed graph\n\n        c_min = Map.get_distance(start_pos, goal_pos)\n        c_best = float('inf')\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Check time limit to stop\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit_seconds:\n                return\n\n            # Alternate growth: sample and grow start tree on even iter, goal tree on odd iter\n            grow_start_tree = (iteration % 2 == 0)\n            graph_grow = self._graph_start if grow_start_tree else self._graph_goal\n            graph_other = self._graph_goal if grow_start_tree else self._graph_start\n            root_vertex = graph_grow.root_vertex_start\n\n            # Sample point in informed region (ellipse) or fallback uniform\n            sample_pt = self._sample_informed_region(c_best, c_min, start_pos, goal_pos)\n\n            # Find nearest vertex in growing graph to sample point using cost + heuristic\n            nearest_v = None\n            min_cost_heuristic = float('inf')\n            for v in graph_grow.root_vertices:\n                dist = Map.get_distance(v.position, sample_pt)\n                cost_to_come = v.cost\n                heuristic = cost_to_come + dist\n                if heuristic < min_cost_heuristic:\n                    min_cost_heuristic = heuristic\n                    nearest_v = v\n            if nearest_v is None:\n                continue\n\n            if nearest_v.position == sample_pt:\n                continue\n\n            # Adaptive max step size based on distance to sample\n            max_step = self._get_adaptive_max_dist_for_connection(nearest_v.position, sample_pt)\n\n            dir_vec = sample_pt.to_tensor() - nearest_v.position.to_tensor()\n            dist_nearest_to_sample = torch.norm(dir_vec)\n            if dist_nearest_to_sample == 0:\n                continue\n            if dist_nearest_to_sample <= max_step:\n                new_pos = sample_pt\n            else:\n                direction_normalized = dir_vec / dist_nearest_to_sample\n                new_pos = Point.from_tensor((nearest_v.position.to_tensor() + direction_normalized * max_step).round().int())\n\n            if not grid.is_agent_valid_pos(new_pos):\n                continue\n\n            # Check path validity to new_pos from nearest_v\n            line_seq = grid.get_line_sequence(nearest_v.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(new_pos)\n            dist_nearest_to_new = Map.get_distance(nearest_v.position, q_new.position)\n            q_new.cost = nearest_v.cost + dist_nearest_to_new\n\n            # Rewiring radius adaptively computed\n            card_v = float(graph_grow.size if graph_grow.size > 0 else 1)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v.item() / card_v) ** (1 / self._dimension)), 25.0)\n\n            # Find vertices near q_new for rewiring and parent selection\n            vertices_near = graph_grow.get_vertices_within_radius(graph_grow.root_vertices, q_new.position, radius)\n\n            # Select best parent from vertices_near minimizing cost\n            q_min = nearest_v\n            c_min_cost = q_new.cost\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                candidate_cost = q_near.cost + dist_near_new\n                line_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if candidate_cost < c_min_cost and grid.is_valid_line_sequence(line_candidate):\n                    q_min = q_near\n                    c_min_cost = candidate_cost\n\n            q_new.cost = c_min_cost\n            graph_grow.add_edge(q_min, q_new)\n\n            # Rewire neighbors to possibly improve costs\n            self._rewire_nearby(graph_grow, q_new, radius)\n\n            # Try to connect the other tree to q_new directly (attempt bidirectional connection)\n            connected, connect_vertex = self._connect_trees(q_new, graph_other)\n            if connected:\n                # Update best path cost if improved\n                candidate_cost = q_new.cost + connect_vertex.cost + Map.get_distance(q_new.position, connect_vertex.position)\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    # Extract combined path and smooth\n                    self._extract_bidirectional_path_and_smooth(q_new, graph_other)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an enhanced RRT* inspired planner that improves path planning performance by:\n    - Employing goal-biased sampling to increase the chance of connecting to the goal.\n    - Using a dynamic adaptive step size that shrinks when close to obstacles or goal for smoother paths.\n    - Implementing rewiring to optimize path cost locally (RRT* style).\n    - Early stopping if path is found or if elapsed time > 10 seconds to ensure timely responses.\n    - Smoothing the final path by shortcutting line segments to reduce unnecessary detours.\n    - Prioritizing vertices to connect based on heuristic cost-to-goal to improve efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Enable rewiring\n        self._init_displays()\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Use Euclidean distance as heuristic cost\n        return self._get_grid().get_distance(frm, to)\n\n    def _try_rewire(self, q_new: Vertex, radius: float) -> None:\n        # Rewire nearby vertices to q_new if it improves cost\n        nearby_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for q_nearby in nearby_vertices:\n            if q_nearby == q_new:\n                continue\n            # Check if path from q_new to q_nearby is valid and better cost\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearby.position)\n            if new_cost < q_nearby.cost:\n                # Rewire edges\n                for parent in list(q_nearby.parents):\n                    self._graph.remove_edge(parent, q_nearby)\n                self._graph.add_edge(q_new, q_nearby)\n                q_nearby.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by skipping intermediate vertices if line is valid\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortcut_path.append(path[next_idx])\n            idx = next_idx\n        return shortcut_path\n\n    def _extract_path_and_smooth(self, q_new: Vertex) -> None:\n        # Extract path from q_new to start vertex by traversing parents\n        path: List[Vertex] = []\n        current_vertex = q_new\n        while True:\n            path.append(current_vertex)\n            if len(current_vertex.parents) == 0:\n                break\n            # Prefer parent with minimum cost (usually only one in a tree)\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            current_vertex = parent\n\n        path.reverse()\n\n        # Smooth the path by shortcutting\n        path = self._shortcut_path(path)\n\n        # Animate path following\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_new_vertex_adaptive(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Adaptive step size: small step near goal or obstacles, larger otherwise\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n\n        if dist < 1e-6:\n            return Vertex(q_near.position)  # Same position, no progress\n\n        # Dynamic max_dist reduced if near obstacles or close to goal\n        dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n        adaptive_max_dist = max_dist\n        if dist_to_goal < 3 * max_dist:\n            adaptive_max_dist = max(max_dist * 0.3, dist_to_goal * 0.5)\n        # Check obstacle proximity (approximate by checking if line near q_near position is valid)\n        step_dir = dir_vec / dist\n        obstacle_check_point = Point.from_tensor(q_near.position.to_tensor() + step_dir * (adaptive_max_dist / 2))\n        if not self._get_grid().is_agent_valid_pos(obstacle_check_point):\n            adaptive_max_dist *= 0.3\n\n        step = min(dist, adaptive_max_dist)\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + step * dir_normalized\n        q_new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(q_new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        max_dist: float = 8.0\n        iterations: int = 10000\n        radius_rewire: float = 15.0\n        goal_sample_rate: float = 0.15  # 15% of samples biased to goal\n        start_time = time.time()\n\n        # Initialize start vertex cost = 0\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            # Time limit check\n            if time.time() - start_time > 10.0:\n                # Timeout, no path found\n                break\n\n            # Goal-biased sampling: with probability goal_sample_rate sample goal directly\n            if np.random.random() < goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            # Get nearest vertex to sample based on cost + heuristic (RRT* inspired)\n            # This can be approximated by Euclidean distance for speed\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue  # identical point, resample\n\n            # Compute new vertex with adaptive step size\n            q_new = self._get_new_vertex_adaptive(q_near, q_sample, max_dist)\n\n            # Check line collision from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to q_new\n            dist_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = dist_cost\n\n            # Choose parent for q_new among neighbors to minimize cost\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius_rewire)\n            min_cost = q_new.cost\n            min_parent = q_near\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                lseq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(lseq):\n                    continue\n                new_cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if new_cost < min_cost:\n                    min_cost = new_cost\n                    min_parent = neighbor\n            q_new.cost = min_cost\n\n            # Add q_new and edge from chosen parent\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire nearby vertices to q_new if beneficial\n            self._try_rewire(q_new, radius_rewire)\n\n            # Check goal reached condition\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path_and_smooth(q_new)\n                break\n\n            # Keyframe for animation\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This enhanced PathPlanning algorithm builds upon goal-biased RRT* methodology with multiple improvements to boost efficiency, success rate, and path quality:\n    \n    - Implements Informed RRT* sampling by restricting samples to an ellipsoidal region (informed set) once a feasible path is found, reducing exploration space.\n    - Retains goal bias sampling near the goal for better convergence.\n    - Adaptive max step size scaled by distance to goal to allow coarse moves far away and finer moves near goal.\n    - Uses heuristic-guided rewiring with an adaptive neighborhood radius based on graph size and step size.\n    - Incorporates early stopping both on goal reach and after time limit (10s).\n    - Applies path shortcutting post extraction for smoother and shorter paths.\n    - Introduces a dynamic sample space update (informed set tuning) after initial solution improves, leading to faster re-planning.\n    - Maintains cost-to-come and rewires better parents during tree expansion.\n    - Tracks best solution cost to prune and guide sampling adaptively.\n    \n    Overall improves over baseline by focusing sampling on promising areas, adaptive steps, and progressive path quality improvement.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n        # New members for informed sampling and best cost tracking\n        self._best_path_cost = float('inf')\n        self._informed_ellipse_ready = False\n        self._informed_start = self._graph.root_vertex_start.position\n        self._informed_goal = self._get_grid().goal.position\n\n\n    def _sample_informed(self, c_best: float) -> Point:\n        \"\"\"\n        Samples within an ellipsoidal informed set defined by start, goal, and current best path cost.\n        If not yet a feasible path found (c_best==inf), samples from full space.\n        \"\"\"\n        import math\n        import torch\n\n        grid = self._get_grid()\n        start = self._informed_start\n        goal = self._informed_goal\n\n        if c_best == float('inf'):\n            # No known solution; full space sampling with goal bias\n            return self._get_random_sample()\n\n        # Ellipse parameters\n        c_min = Map.get_distance(start, goal)\n        if c_best < c_min:\n            # Numerical safety check\n            return self._get_random_sample()\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min  # unit vector from start to goal\n        # Compute rotation matrix (2D)\n        e_theta = torch.atan2(a1[1], a1[0])\n        cos_theta = torch.cos(e_theta)\n        sin_theta = torch.sin(e_theta)\n        rot = torch.tensor([[cos_theta, -sin_theta],\n                            [sin_theta, cos_theta]])\n\n        # Radii of ellipse axes\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        # Repeat sample until valid\n        for _ in range(100):\n            # Sample random point in unit circle\n            sample_unit = torch.randn(2)\n            sample_unit /= torch.norm(sample_unit)\n            scale = torch.rand(1).item()\n            sample_unit *= scale\n            # Scale by ellipse radii\n            sample_ellipse = torch.tensor([r1 * sample_unit[0].item(), r2 * sample_unit[1].item()])\n            # Rotate and translate to position in map\n            sample_rotated = rot @ sample_ellipse + ((start.to_tensor() + goal.to_tensor()) / 2)\n            sample_pt = Point(int(round(sample_rotated[0].item())), int(round(sample_rotated[1].item())))\n            if grid.is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n        # Fallback if cannot sample valid in ellipse\n        return self._get_random_sample()\n\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        # Utility distance wrapper\n        return Map.get_distance(p1, p2)\n\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        best_goal_vertex = None\n\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit_seconds:\n                # Time out: stop planning\n                return\n\n            # Sample point: informed sampling if we have path, goal bias within sampling\n            if self._best_path_cost == float('inf'):\n                q_sample = self._get_random_sample()\n            else:\n                if torch.rand(1).item() < self._goal_sample_rate:\n                    # Goal biased sample near goal\n                    goal_pos_ = grid.goal.position\n                    # small ball around goal\n                    for _ in range(30):\n                        offset = torch.randn(self._dimension) * self._min_max_dist\n                        sample = Point(*(goal_pos_.to_tensor() + offset).round().int().tolist())\n                        if grid.is_agent_valid_pos(sample):\n                            q_sample = sample\n                            break\n                    else:\n                        q_sample = goal_pos_\n                else:\n                    q_sample = self._sample_informed(self._best_path_cost)\n\n            # Find nearest vertex in tree\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max dist based on distance to goal and best path cost\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_dir = torch.norm(dir_tensor)\n            if dist_dir == 0:\n                continue\n\n            if dist_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dist_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check validity of path from nearest to new\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = self._distance(q_nearest.position, q_new_pos)\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            # Rewiring radius calculation adaptive with current best path cost to limit neighbors\n            V_size = float(self._graph.size if self._graph.size > 0 else 1)\n            rad_factor = (torch.log(torch.tensor(V_size)) / V_size) ** (1 / self._dimension) if V_size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * rad_factor, max_dist*2, 30.0)\n\n            # Near vertices candidates for parent choosing and rewiring\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Pick best parent: minimize cost + distance and path validity\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n            for q_near in vertices_near:\n                dist_near_new = self._distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if route via q_new is better\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = self._distance(q_new.position, q_near.position)\n                new_cost = q_new.cost + dist_new_near\n                if new_cost < q_near.cost:\n                    line_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_rewire):\n                        # Remove older parent edge\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        # Add new parent q_new\n                        q_near.cost = new_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex can connect directly to goal cheaper than current best\n            dist_to_goal = self._distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                # Verify direct connect to goal is valid line with no obstacles\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    if cost_to_goal < self._best_path_cost:\n                        # Better path found\n                        self._best_path_cost = cost_to_goal\n                        goal_vertex = Vertex(goal_pos)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n                        best_goal_vertex = goal_vertex\n                        self._informed_ellipse_ready = True  # Enable informed sampling\n\n            # Early stopping if solution found and iteration is ample after improvements\n            if best_goal_vertex and iteration > 50:\n                # Extract and smooth path\n                self._extract_path_and_smooth(best_goal_vertex)\n                return\n\n            self.key_frame()\n\n        # If finished iterations without early stop but have path, extract it for visualization\n        if best_goal_vertex:\n            self._extract_path_and_smooth(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\" \n    Improved RRT*-inspired path planner with heuristic-guided goal bias, adaptive step size, and rewiring optimization.\n    Enhancements include:\n    - Heuristic cost-to-go for better parent selection and rewiring, reducing unnecessary expansions.\n    - Dynamic iteration limit scaling with environment size for efficiency.\n    - Early stopping once a sufficiently good path (within goal radius) is found.\n    - Enhanced shortcutting with iterative smoothing.\n    - Priority expansion towards promising regions using hybrid sampling that mixes uniform, goal bias, and heuristic-informed sampling.\n    - Maintains robustness by validating connections strictly.\n    - Timeout enforced at 10 seconds for practical responsiveness.\n    This balances exploration/exploitation, improves path quality, reduces failures, and speeds convergence.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    {\"\"\" \n    Improved RRT*-inspired path planner with heuristic-guided goal bias, adaptive step size, and rewiring optimization.\n    Enhancements include:\n    - Heuristic cost-to-go for better parent selection and rewiring, reducing unnecessary expansions.\n    - Dynamic iteration limit scaling with environment size for efficiency.\n    - Early stopping once a sufficiently good path (within goal radius) is found.\n    - Enhanced shortcutting with iterative smoothing.\n    - Priority expansion towards promising regions using hybrid sampling that mixes uniform, goal bias, and heuristic-informed sampling.\n    - Maintains robustness by validating connections strictly.\n    - Timeout enforced at 10 seconds for practical responsiveness.\n    This balances exploration/exploitation, improves path quality, reduces failures, and speeds convergence.\n    \"\"\"}\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n        self._max_iterations_base = 5000  # Base iteration count (adjusted adaptively)\n        self._goal_sample_rate = 0.25\n        self._search_radius = 15.0\n        self._timeout_secs = 10.0\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Heuristic cost-to-go (Euclidean distance from pos to goal)\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _get_custom_sample(self) -> Point:\n        \"\"\"\n        Hybrid sampling strategy:\n        - With low probability, sample uniformly random valid point.\n        - With goal_sample_rate, sample goal directly.\n        - Otherwise, sample near existing vertices biased by heuristic cost.\n        \"\"\"\n        p_rand = np.random.rand()\n        grid = self._get_grid()\n\n        # Goal-biased sample\n        if p_rand < self._goal_sample_rate:\n            return grid.goal.position\n\n        # 20% uniform random valid sample to maintain exploration\n        if p_rand < (self._goal_sample_rate + 0.2):\n            for _ in range(20):  # limit attempts\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Heuristic-informed biased sampling: sample near low-cost vertices\n        vertices = list(self._graph.root_vertex_start.children) + [self._graph.root_vertex_start]\n        if len(vertices) < 1:\n            # fallback\n            return grid.goal.position\n\n        vertex_costs = [(v, v.cost + self._heuristic_cost(v.position)) for v in vertices]\n        vertex_costs.sort(key=lambda vc: vc[1])\n\n        best_vertices = [vc[0] for vc in vertex_costs[:min(5, len(vertex_costs))]]\n\n        # Pick randomly among best vertices\n        base_vertex = best_vertices[np.random.randint(len(best_vertices))]\n\n        # Sample around base vertex within small radius\n        radius = 5\n        for _ in range(30):\n            delta = np.random.randint(-radius, radius + 1, grid.size.n_dim)\n            candidate_coords = base_vertex.position.to_tensor().numpy() + delta\n            candidate_coords = np.clip(candidate_coords, 0, grid.size - 1)\n            sample = Point(*candidate_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        # Fallback uniform random if no sample found\n        for _ in range(20):\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        return grid.goal.position\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Choose parent minimizing cost + movement + heuristic-to-go.\n        min_total_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n        for v in q_near_list:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = grid.get_movement_cost(v.position, q_new.position)\n            cost = v.cost + movement_cost\n            heuristic = self._heuristic_cost(q_new.position)\n            total_cost = cost + heuristic * 0.5  # weighted heuristic to guide selection\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Try to rewire neighbors through q_new if it reduces total cost (cost + heuristic)\n        grid = self._get_grid()\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = grid.get_movement_cost(q_new.position, v.position)\n            potential_cost = q_new.cost + movement_cost\n            if potential_cost < v.cost:\n                # Check if rewiring does not create cycles or invalid edges\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _iterative_shortcut(self, path: list, iterations=5) -> list:\n        # Iteratively improve shortcutting for smoother path\n        grid = self._get_grid()\n        for _ in range(iterations):\n            if len(path) <= 2:\n                break\n            new_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(path[i].position, path[j].position)):\n                        new_path.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No shortcut found, add next vertex\n                    new_path.append(path[i + 1])\n                    i += 1\n            path = new_path\n        return path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct and smooth path using iterative shortcutting\n        grid = self._get_grid()\n        goal_v = Vertex(grid.goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicate start\n        path.reverse()\n\n        smoothed_path = self._iterative_shortcut(path, iterations=5)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        self._graph.root_vertex_start.cost = 0.0\n\n        max_iterations: int = max(self._max_iterations_base, int(grid.size.prod() * 1.5))  # adapt by env size\n        start_time = time.time()\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n\n        for i in range(max_iterations):\n            if time.time() - start_time > self._timeout_secs:\n                break\n\n            q_sample: Point = self._get_custom_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius)\n            chosen_parent: Vertex = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Track best goal reach for early extraction, allow small buffer radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_goal_cost:\n                    best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n\n                # If found sufficiently good path (cost + heuristic below threshold), break early\n                threshold = best_goal_cost * 1.1\n                if q_new.cost + self._heuristic_cost(q_new.position) < threshold:\n                    break\n\n            self.key_frame()\n\n        # If found a goal vertex, extract path; else fail silently (timeout or no path)\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner builds upon the RRT* inspired approach by integrating:\n     - Heuristic-guided sampling combining goal bias and informed ellipse sampling (Informed RRT*)\n       to more efficiently focus the search space as better paths are found.\n     - Adaptive radius reduction in rewiring based on current best path cost, narrowing rewiring radius over time.\n     - Early stopping when the goal is reached and path cost stabilizes to prevent unnecessary exploration.\n     - Maintaining a lower bound on step size to balance exploration and incremental path adjustments.\n     - A refined _extract_path step using a more aggressive shortcutting mechanism to further smooth the final path.\n     These enhancements collectively improve planning efficiency (reducing iterations needed),\n     path quality (shorter, smoother paths), robustness (higher success rate by reducing redundant sampling),\n     and responsiveness with a strict 10-second timeout.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # For Informed sampling - track best cost found\n        self._best_cost: float = float('inf')\n        self._start_pos: Point = self._get_grid().agent.position\n        self._goal_pos: Point = self._get_grid().goal.position\n\n    def _heuristic_cost(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return Map.get_distance(p1, p2)\n\n    def _get_informed_sample(self) -> Point:\n        # If no solution found, sample uniformly with goal bias\n        if self._best_cost == float('inf'):\n            return self._get_random_sample(goal_sample_rate=0.3)\n\n        # Informed sampling: sample inside ellipse defined by start, goal, and best cost\n        center = Point(*(((self._start_pos.to_tensor() + self._goal_pos.to_tensor()) / 2).tolist()))\n        dist_start_goal = self._heuristic_cost(self._start_pos, self._goal_pos)\n        c_best = self._best_cost\n        c_min = dist_start_goal\n\n        # If current best cost is close to min, fallback to goal bias sampling\n        if c_best <= c_min:\n            return self._get_random_sample(goal_sample_rate=0.3)\n\n        a1 = (self._goal_pos.to_tensor() - self._start_pos.to_tensor()) / dist_start_goal  # unit vector\n\n        # Sampling inside an ellipse radius parameters\n        r1 = c_best / 2.0\n        r2 = np.sqrt(c_best**2 - c_min**2) / 2.0\n\n        while True:\n            # Sample random point in unit circle\n            rand_point_in_unit_circle = Point(*self._sample_unit_ball(n_dim=len(center)))\n            # Scale to ellipse with radii r1, r2 and rotate along a1 axis\n            # 2D assumption (or adapt for higher dim accordingly)\n            # Construct rotation matrix to align x-axis with a1 vector\n            # For n_dim=2, rotation matrix is simple\n            \n            dim = len(center)\n            if dim == 2:\n                a1_np = a1.numpy()\n                angle = np.arctan2(a1_np[1], a1_np[0])\n                c, s = np.cos(angle), np.sin(angle)\n                R = np.array([[c, -s], [s, c]])\n\n                sample_ellipse = np.array([r1 * rand_point_in_unit_circle[0], r2 * rand_point_in_unit_circle[1]])\n                rotated = R @ sample_ellipse\n                sample_pt = center.to_tensor().numpy() + rotated\n                sample_pt = Point(*np.round(sample_pt).astype(int))\n\n            else:\n                # For n_dim > 2, only scale inside hyperellipse; ignoring rotation for simplicity\n                radii = torch.tensor([r1] + [r2]*(dim-1))\n                sample_tensor = center.to_tensor() + radii * torch.tensor(rand_point_in_unit_circle)\n                sample_pt = Point.from_tensor(sample_tensor.round())\n\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _sample_unit_ball(self, n_dim: int) -> List[float]:\n        # Sample random point uniformly inside an n-dimensional unit ball\n        while True:\n            point = np.random.uniform(-1,1,n_dim)\n            if np.linalg.norm(point) <= 1:\n                return point.tolist()\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=20.0) -> float:\n        # Keep as is but increase max_dist slightly for faster exploration\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=7):\n            direction = self._goal_pos.to_tensor() - pos.to_tensor()\n            norm_dir = torch.norm(direction)\n            if norm_dir == 0:\n                break\n            dir_norm = direction / norm_dir\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Adaptive radius shrink as better paths found\n        adaptive_radius = radius\n        if self._best_cost < float('inf'):\n            # Shrink radius proportional to improvement (with floor limit)\n            adaptive_radius = max(8.0, radius * (self._best_cost / 100.0))\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, adaptive_radius)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new to start\n        goal_v = Vertex(self._goal_pos)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicate of start\n        path.reverse()\n\n        # Aggressive shortcutting with double pass for smoother shorter path\n        def aggressive_shortcut_path(path_vertices: List[Vertex]) -> List[Vertex]:\n            if len(path_vertices) <= 2:\n                return path_vertices[:]\n            shortcut_path = [path_vertices[0]]\n            idx = 0\n            while idx < len(path_vertices) - 1:\n                next_idx = len(path_vertices) - 1\n                # Find farthest reachable vertex from shortcut_path end\n                while next_idx > idx + 1:\n                    line_check = self._get_grid().get_line_sequence(shortcut_path[-1].position, path_vertices[next_idx].position)\n                    if self._get_grid().is_valid_line_sequence(line_check):\n                        break\n                    next_idx -= 1\n                shortcut_path.append(path_vertices[next_idx])\n                idx = next_idx\n            return shortcut_path\n\n        path = aggressive_shortcut_path(path)\n        path = aggressive_shortcut_path(path)  # second pass to improve further\n\n        # Trace path and key frame animation\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        search_radius: float = 15.0  # max rewiring radius\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        iterations_since_improve = 0\n        max_stable_iterations = 300  # early stop if no improvement\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout - terminate search\n                break\n\n            # Use informed sample if path cost found else goal biased uniform sample\n            q_sample: Point = self._get_informed_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            # Enforce a minimum max_dist for smooth incremental expansion, avoiding too coarse jumps\n            max_dist = max(3.0, max_dist)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Get neighbors with adaptive radius based on current best cost\n            q_near_list = self._get_near_vertices(q_new, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors excluding chosen parent\n            neighbors_to_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, neighbors_to_rewire)\n\n            # Check goal proximity with radius threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost if improved\n                path_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._goal_pos)\n                if path_cost < self._best_cost:\n                    self._best_cost = path_cost\n                    iterations_since_improve = 0\n                    self._extract_path(q_new)\n                    # Early stopping condition if cost close enough to direct start-goal distance\n                    if abs(self._best_cost - self._heuristic_cost(self._start_pos, self._goal_pos)) < 1.0:\n                        break\n                else:\n                    iterations_since_improve += 1\n                    if iterations_since_improve > max_stable_iterations:\n                        break\n            else:\n                iterations_since_improve += 1\n                if iterations_since_improve > max_stable_iterations:\n                    # No progress on improving path - early stop to save time\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal biasing and rewiring for path quality improvement.\n    The algorithm samples points with a goal bias, dynamically adjusts max step distance, connects new vertices \n    by minimizing cost considering nearby vertices, and rewires the graph to improve path optimality.\n    Early stopping on goal reach and time limit (10 seconds) is enforced to enhance efficiency.\n    The extracted path is smoothed by shortcutting invalid intermediate points for better path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        # With probability goal_bias, sample the goal position directly to bias growth toward goal\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace from goal to start through parents, build path\n        path = [q_last]\n        while len(path[-1].parents) != 0:\n            # Since rewiring can cause multiple parents, pick parent with minimum cost\n            min_parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(min_parent)\n        path.reverse()\n\n        # Shortcut path to smooth it\n        path = self._shortcut_path(path)\n\n        # Animate path moving agent\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to skip intermediate vertices if direct line is valid between vertices\n        shortened = [path[0]]\n        for i in range(1, len(path)):\n            # Check if direct line from last added vertex to this vertex is valid\n            line_seq = self._get_grid().get_line_sequence(shortened[-1].position, path[i].position)\n            if i == len(path) - 1 or not self._get_grid().is_valid_line_sequence(line_seq):\n                # Can't skip, add previous vertex i-1\n                shortened.append(path[i - 1])\n        # Always append last vertex if not included\n        if shortened[-1] != path[-1]:\n            shortened.append(path[-1])\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 10.0\n        max_dist_min = 3.0\n        max_dist_max = 15.0\n        iteration_limit = 10000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        # Initialize costs for start vertex\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive step size based on iteration progress (shrink over time)\n            max_dist = max(\n                max_dist_max - (max_dist_max - max_dist_min) * (i / iteration_limit),\n                max_dist_min,\n            )\n\n            # Sample point with goal biasing\n            q_sample = self._get_random_sample(goal_bias=0.15)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line between q_near and q_new\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Find neighbors within a radius for rewiring (RRT* style)\n            radius = min(max_dist * 2.5, 30)\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n\n            # Choose parent with lowest cost+distance in neighbors\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Check if path from neighbor to q_new is collision free\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # If no suitable parent, fallback to q_near\n                if not self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Add q_new vertex with parent_for_new\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire: remove old edges from all parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check goal reached under radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add final goal vertex connected from q_new (if valid)\n                final_goal_pos = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Mark key frame for visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring}\n\n    This algorithm extends the classical RRT by incorporating the following enhancements:\n    - Goal-biased sampling to encourage exploration towards the goal, improving success rate and efficiency.\n    - Adaptive rewiring of vertices within a neighborhood radius (RRT* style) to optimize path cost and quality.\n    - Dynamic max_dist step size tuned by environment scale.\n    - Early stopping by time limit (10 seconds) and immediate path extraction upon reaching goal region.\n    - Shortcut smoothing applied after path extraction to reduce unnecessary detours.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.15   # Probability of sampling the goal to bias sampling towards it.\n        self._rewire_radius = 15        # Radius for rewiring neighbors for optimization.\n        self._max_dist = 12             # Max extension distance per step.\n        self._max_iterations = 8000     # Max iterations to limit planning effort.\n        self._time_limit_sec = 10.0     # Time limit in seconds to stop search if no path found.\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased random sampling to increase goal reach chance.\n        from random import random\n\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as base, clipped to max_dist step.\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent that gives lowest cost path to q_new considering cost + movement cost\n        min_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            q_new.cost = min_cost\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if beneficial (lower cost and valid path)\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove old parent edges of q_neighbor leading to higher cost\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from start to q_goal by traversing parents with lowest cost path\n        path: List[Vertex] = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            # Select parent with least cost\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        # After path extraction, apply shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        # Move the agent along the path with animation key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: iteratively try to connect non-adjacent vertices directly\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Cost to start vertex is zero\n\n        for iteration in range(self._max_iterations):\n            # Check time limit for early termination\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Fail to find path in allocated time\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            # Validate path from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Near neighbors for rewiring\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Select best parent from neighbors (including q_near)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            # Add q_new with selected parent\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new reached goal region\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and cost calculation\n                goal_vertex = self._graph.root_vertex_goal\n\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm combining goal-biased adaptive informed sampling, \n    heuristic-guided dynamic expansion, and efficient rewiring optimization aiming for \n    faster convergence, higher success rate, and smoother paths. \n    Key improvements over the base include:\n    - Adaptive max step size scaled dynamically with progress towards goal and tree size,\n      allowing coarser exploration far and finer near goal.\n    - Enhanced sampling distribution mixing uniform, goal-biased, and informed ellipsoidal sampling \n      based on current best path cost to focus search.\n    - Heuristic cost incorporating both traveled cost and admissible distance-to-go to prioritize vertices.\n    - Dynamic neighborhood radius for rewiring scaled with tree size and iteration.\n    - Early rewire pruning to decrease tree clutter and improve paths.\n    - Path shortcutting with robust multiple attempts for smoothing.\n    - Early termination on finding direct connect to goal with smooth path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.5   # Min step size near goal for finer control\n        self._goal_sample_rate = 0.25  # Slightly increased goal bias\n        self._informed_sample_rate = 0.3  # Probability to do informed sampling\n        self._max_iterations = 4000  # Reduced max iterations due to more efficient search\n        self._lambda_rrt_star = 45  # tuning rewiring radius factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._best_cost = float('inf')  # Track best path cost found so far\n        self._init_displays()\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        # Sample inside an ellipsoid defined by start, goal, and current best cost c_max (informed sampling)\n        import math\n        import torch\n\n        # If no current best cost (or infinite), fallback to uniform sampling\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(\n            *(((start_pos.to_tensor().float()+goal_pos.to_tensor().float())/2).tolist())\n        )\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        # Unit vector from start to goal\n        e1 = diff / dist_start_goal\n\n        # Compute rotation matrix (2D)\n        # Since dimension=2, rotation matrix R aligns x-axis with vector start->goal\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta],\n                          [sin_theta, cos_theta]])\n\n        # Define ellipsoid axes lengths\n        a = c_max / 2.0  # major axis length\n        b = math.sqrt(max(c_max**2 - dist_start_goal**2, 1e-6)) / 2.0  # minor axis length\n\n        for _ in range(40):  # max retries\n            # Sample uniformly inside unit ball in 2D\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            # Scale by ellipsoid axes\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            # Rotate and translate back to world frame\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform random sample if informed fails\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal biased sampling: sample near the goal within min_max_dist radius\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset = sample_offset / torch.norm(sample_offset) if torch.norm(sample_offset) > 1e-8 else sample_offset\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling to focus search within cost bound\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling in grid valid positions\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start position\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Dynamic max step size, also depends on tree size for finer control as more vertices are added\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        progress_factor = max(0.05, min(1.0, dist / max(grid.size)))  # normalized distance to goal\n        tree_size_factor = min(1.0, 500 / (self._graph.size + 1))  # shrink step size as tree grows\n        scaled = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * tree_size_factor\n        return scaled\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Admissible heuristic: Euclidean distance to goal\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Same as reference but enhanced shortcutting with multiple tries for robustness\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Robust shortcut smoothing: multiple passes\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time check early stop\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Abort if planning too long\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Construct new vertex and calculate cost to reach\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose the best parent with minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-5 < q_near.cost:  # add a small epsilon for numerical stability\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one old parent edge (tree structure)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Construct or update goal vertex connection\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Check and update best path cost found\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early stop on valid goal connection\n                    break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the RRT*-style planner by integrating heuristic-guided sampling \n      biased towards the goal and the best-connected vertex, adaptive step size based on clearance and heuristic \n      cost-to-go, and dynamic rewiring radius that shrinks over time for efficiency. It uses an A*-inspired \n      cost-to-go heuristic to guide vertex selection and sampling, improving exploration towards promising regions. \n      Early stopping criteria include timeout and goal reach detection. Path extraction includes aggressive shortcutting \n      for smoother paths. These enhancements lead to faster convergence, higher success rates, and shorter,\n      smoother, more robust paths in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        self._start_pos = self._get_grid().agent.position\n        self._goal_pos = self._get_grid().goal.position\n\n    def _heuristic_cost_to_goal(self, pos: Point) -> float:\n        # Use Euclidean distance as heuristic cost-to-go\n        return Map.get_distance(pos, self._goal_pos)\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Enhancement: reduce max_dist if heuristic cost is small (near goal) for finer expansions\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=5):\n            direction = self._goal_pos.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        heuristic_cost = self._heuristic_cost_to_goal(pos)\n        # Shrink max distance when close to goal to improve path precision\n        if heuristic_cost < max_dist:\n            clearance = min(clearance, max(min_dist, heuristic_cost*0.7))\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Vertex | None':\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> list[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: list[Vertex], q_new: Vertex) -> Vertex | None:\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            # Cost augmented by heuristic to encourage paths closer to goal\n            cost_augmented = cost + self._heuristic_cost_to_goal(q_new.position) * 0.1\n            if cost_augmented < min_cost:\n                min_cost = cost_augmented\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list[Vertex]) -> None:\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._goal_pos)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        # Aggressive shortcut smoothing\n        smoothed_path = [path[0]]\n        last_valid = path[0]\n        for vertex in path[1:]:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(last_valid.position, vertex.position)):\n                continue\n            else:\n                prev_index = path.index(vertex) - 1\n                smoothed_path.append(path[prev_index])\n                last_valid = path[prev_index]\n        smoothed_path.append(path[-1])\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_best_near_vertex(self, q_sample: Point, radius: float) -> Vertex | None:\n        # Additional heuristic-guided vertex selection near sample to improve connection to promising nodes\n        near_verts = self._get_near_vertices(Vertex(q_sample), radius)\n        best_vertex = None\n        best_score = float('inf')\n        for v in near_verts:\n            dist_to_sample = Map.get_distance(v.position, q_sample)\n            heuristic = self._heuristic_cost_to_goal(v.position)\n            score = v.cost + dist_to_sample + heuristic  # combined cost\n            if score < best_score:\n                best_score = score\n                best_vertex = v\n        return best_vertex\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        goal_sample_rate: float = 0.35\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n\n        # Dynamic search radius shrinks over iterations for efficiency\n        max_search_radius = 20.0\n        min_search_radius = 8.0\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failure\n                break\n\n            # Hybrid sampling: mix of goal bias, best-vertex bias, random uniform\n            sample_type = np.random.rand()\n            if sample_type < goal_sample_rate:\n                q_sample = self._goal_pos\n            elif sample_type < goal_sample_rate + 0.1 and self._graph.size > 5:\n                # biased sample near best known tree vertex\n                best_nodes = [v for v in self._graph.root_vertices if v.cost + self._heuristic_cost_to_goal(v.position) < float('inf')]\n                if len(best_nodes) > 0:\n                    chosen = min(best_nodes, key=lambda v: v.cost + self._heuristic_cost_to_goal(v.position))\n                    noise = np.random.normal(scale=3.0, size=self._get_grid().size.n_dim)\n                    noisy_sample_tensor = chosen.position.to_tensor() + torch.tensor(noise, dtype=torch.float32)\n                    noisy_sample = Point.from_tensor(torch.clamp(noisy_sample_tensor, 0, self._get_grid().size.to_tensor()))\n                    if self._get_grid().is_agent_valid_pos(noisy_sample):\n                        q_sample = noisy_sample\n                    else:\n                        q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n                else:\n                    q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n            else:\n                q_sample = self._get_random_sample(goal_sample_rate=goal_sample_rate)\n\n            # Choose best vertex near sample considering heuristic cost and distance\n            search_radius = max_search_radius - (max_search_radius - min_search_radius) * (i / max_iterations)\n            q_near = self._get_best_near_vertex(q_sample, search_radius)\n            if q_near is None:\n                # Fallback to nearest vertex if no nearby vertices found\n                q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Radius for rewiring decreases with iterations to improve efficiency\n            search_radius_rewire = max(10.0, search_radius * 0.6)\n\n            q_near_list = self._get_near_vertices(q_new, search_radius_rewire)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Remove chosen parent from neighbors before rewiring\n            q_near_list_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list_rewire)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved sample-based path planner inspired by RRT* principles, \n    designed for grid-based environments. It implements goal-biased sampling to improve \n    success rate, dynamic/adaptive step size for efficient exploration, and rewiring of \n    vertices to optimize path cost and smoothness (like RRT*). It aborts if planning time \n    exceeds 10 seconds to maintain robustness. After connecting start to goal, it extracts \n    and performs path shortcutting to further smooth the path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal for RRT* style optimization\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        \"\"\"\n        With probability goal_bias, sample goal position exactly to bias tree growth toward goal\n        Otherwise random sample in valid positions\n        \"\"\"\n        if np.random.rand() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex], radius: float) -> None:\n        \"\"\"Rewire nearby vertices to q_new if the cost through q_new is cheaper.\"\"\"\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            # check if edge from q_new to q_neighbor is valid\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_q_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_neighbor.position)\n            if cost_through_q_new < q_neighbor.cost:\n                # Remove old parent edge\n                for p in list(q_neighbor.parents):\n                    self._graph.remove_edge(p, q_neighbor)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = cost_through_q_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from q_new to root\n        path: List[Vertex] = [q_new]\n        while len(path[-1].parents) != 0:\n            # choose the parent with minimum cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Connect to goal vertex explicitly if close but not exact\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = Map.get_distance(path[-1].position, goal_pos)\n        if dist_to_goal <= 1.5:  # within 1.5 cells, attempt direct connection\n            line_seq = self._get_grid().get_line_sequence(path[-1].position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                goal_v = Vertex(goal_pos)\n                goal_v.cost = path[-1].cost + self._get_grid().get_movement_cost(path[-1].position, goal_pos)\n                self._graph.add_edge(path[-1], goal_v)\n                path.append(goal_v)\n\n        # Shortcut path smoothing by attempting to connect nonadjacent points directly\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    # shortcut possible: remove intermediate vertices between i and j\n                    # create direct edge i -> j and remove edges in between\n                    # remove old edges\n                    for k in range(i + 1, j + 1):\n                        for p in list(path[k].parents):\n                            self._graph.remove_edge(p, path[k])\n                    self._graph.add_edge(path[i], path[j])\n                    # rebuild path list skipping intermediate\n                    path = path[:i + 1] + path[j:]\n                    break\n                j -= 1\n            i += 1\n\n        # Move agent along the smoothed path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _adaptive_max_dist(self, dist_to_goal: float, default_max=10.0, min_step=1.0) -> float:\n        \"\"\"\n        Adaptive max step size which decreases when close to goal for better refinement.\n        \"\"\"\n        if dist_to_goal < default_max:\n            return max(min_step, dist_to_goal / 2.0)\n        return default_max\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iter = 10000\n        default_max_dist = 10.0\n        goal_radius = 1.5  # radius to consider reached goal region\n\n        # Initialize start and goal vertices cost\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iter_idx in range(max_iter):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:  # abort if planning exceeds 10 seconds\n                # No path found within time limit\n                return\n\n            # Goal-biased random sampling\n            q_sample = self._get_random_sample(goal_bias=0.15)\n\n            # Find nearest vertex in tree\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n            adaptive_max_dist = self._adaptive_max_dist(dist_to_goal, default_max_dist)\n\n            # Steer towards sample with adaptive step size\n            q_new = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            # Check if path between q_near and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to reach q_new through q_near\n            cost_to_q_new = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_to_q_new\n\n            # Find neighbors within radius for rewiring (RRT* style)\n            radius = min(15.0, (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** 0.5 * 50)  # heuristic radius scaled with tree size\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n            # Choose parent among neighbors that gives lowest cost path\n            best_parent = q_near\n            best_cost = cost_to_q_new\n            for q_neighbor in neighbors:\n                line_seq_n = self._get_grid().get_line_sequence(q_neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_n):\n                    continue\n                cost_n = q_neighbor.cost + self._get_grid().get_movement_cost(q_neighbor.position, q_new.position)\n                if cost_n < best_cost:\n                    best_parent = q_neighbor\n                    best_cost = cost_n\n            q_new.cost = best_cost\n\n            # Insert q_new and add edge from best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if cheaper path exists through q_new\n            self._rewire(q_new, neighbors, radius)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Heuristic-Guided Expansion,\n    Dynamic Step Sizing, and Multi-Stage Smoothing for Superior Path Quality and Planning Efficiency",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Heuristic-Guided Expansion,\n    Dynamic Step Sizing, and Multi-Stage Smoothing for Superior Path Quality and Planning Efficiency}\n\n    This improved version builds on the baseline RRT* inspired approach and introduces the following key advancements:\n    - Adaptive max_dist scaling based on environment size and current iteration progress for balanced exploration/exploitation.\n    - Heuristic-guided sampling biased both towards the goal and sparsely around a dynamic heuristic funnel region to reduce unnecessary exploration.\n    - Dual-rewire strategy: immediate neighborhood rewiring and delayed local refinement rewiring after path connection.\n    - Hybrid path smoothing combining shortcut smoothing during extraction and Bezier curve smoothing post extraction for natural smoothness.\n    - Early stopping with timeout capped at 10 seconds for robustness.\n    - Cost-to-go heuristic included in parent choice to prioritize vertices promising shortest overall path.\n    - Goal connection uses a relaxed radius to allow earlier connection attempts.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.18      # Slightly increased goal bias sampling.\n        self._rewire_radius = 18           # Increased radius for better rewiring opportunities.\n        self._max_dist_base = 14           # Base max extension distance.\n        self._max_iterations = 7000        # Slightly reduced max iterations for efficiency.\n        self._time_limit_sec = 10.0        # Time limit in seconds.\n        self._delayed_rewire_radius = 8    # Smaller radius for delayed local refinement rewiring.\n        self._heuristic_funnel_rate = 0.12 # Sampling rate for heuristic funnel region.\n\n    def _get_heuristic_funnel_sample(self) -> Point:\n        \"\"\"\n        Generate a sample biased in a heuristic funnel region between start and goal.\n        This helps focus growth along promising corridor.\n        \"\"\"\n        import random\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        if random.random() > self._heuristic_funnel_rate:\n            return None  # Outside funnel this iteration\n\n        alpha = random.random()\n        interp = Point(\n            int(start_pos.x + alpha * (goal_pos.x - start_pos.x)),\n            int(start_pos.y + alpha * (goal_pos.y - start_pos.y)),\n        )\n        # Add small gaussian noise to spread out samples around line\n        from numpy.random import normal\n\n        noise_x = int(normal(0, 6))\n        noise_y = int(normal(0, 6))\n        sample = Point(interp.x + noise_x, interp.y + noise_y)\n        if grid.is_agent_valid_pos(sample):\n            return sample\n        else:\n            # Fallback to start or goal if noise invalid\n            return random.choice([start_pos, goal_pos])\n\n    def _get_adaptive_max_dist(self, iteration: int) -> float:\n        \"\"\"\n        Dynamically adjusts max_dist depending on iteration count and environment size,\n        encouraging coarse exploration early and finer local refinement late.\n        \"\"\"\n        grid = self._get_grid()\n        env_diag = (\n            (grid.size.x ** 2 + grid.size.y ** 2) ** 0.5\n        )  # Diagonal distance on grid\n        fraction = min(1.0, iteration / (self._max_iterations * 0.7))\n        max_dist = self._max_dist_base * (1.0 - 0.65 * fraction) + max(4, env_diag * 0.03) * fraction\n        if max_dist < 3:\n            max_dist = 3\n        return max_dist\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Choose parent with minimum cost + heuristic cost to goal (cost-to-come + cost-to-go)\n        min_total_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic_to_goal = grid.get_distance(q_new.position, goal_pos)\n            total_cost = cost_to_new + heuristic_to_goal * 0.95  # weight heuristic slightly less than cost\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                min_vertex = q_near\n\n        if min_vertex is not None:\n            min_vertex_cost = min_vertex.cost + grid.get_distance(min_vertex.position, q_new.position)\n            q_new.cost = min_vertex_cost\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        # Rewire neighbors to q_new if it improves cost and path valid\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost + 1e-6 < q_neighbor.cost:  # add small epsilon for numerical stability\n                # Remove all old parents to avoid multiple incoming edges\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _delayed_local_rewire(self, path: list) -> None:\n        \"\"\"\n        Run refinement rewiring along extracted path vertices,\n        allowing local neighborhood to rewire and improve path cost.\n        \"\"\"\n        grid = self._get_grid()\n        for vertex in path:\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], vertex.position, self._delayed_rewire_radius\n            )\n            self._rewire(vertex, neighbors)\n\n    def _bezier_smooth_path(self, path: list) -> list:\n        \"\"\"\n        Apply mild cubic Bezier smoothing on path vertices to reduce sharp turns.\n        Returns a new list of vertices with interpolated smoother positions.\n        \"\"\"\n        import numpy as np\n\n        if len(path) < 4:\n            return path  # Not enough points to smooth\n\n        # Convert path vertices to numpy points for convenience\n        points = np.array([[v.position.x, v.position.y] for v in path], dtype=np.float32)\n\n        smoothed_points = []\n\n        def cubic_bezier(p0, p1, p2, p3, t):\n            return (\n                (1 - t) ** 3 * p0\n                + 3 * (1 - t) ** 2 * t * p1\n                + 3 * (1 - t) * t ** 2 * p2\n                + t ** 3 * p3\n            )\n\n        n = len(points)\n        smoothed_points.append(points[0])\n\n        step = 0.15\n        for i in range(n - 3):\n            p0 = points[i]\n            p1 = points[i + 1]\n            p2 = points[i + 2]\n            p3 = points[i + 3]\n\n            # Generate intermediate points between p1 and p2 using Bezier curve\n            t_values = np.arange(step, 1 + step, step)\n            for t in t_values:\n                bez_point = cubic_bezier(p0, p1, p2, p3, t)\n                smoothed_points.append(bez_point)\n\n        smoothed_points.append(points[-1])\n\n        # Convert back to Vertices with integer-rounded positions, ensuring valid moves.\n        grid = self._get_grid()\n        new_vertices = []\n        prev_p = path[0]\n        for pt in smoothed_points:\n            p = Point(int(round(pt[0])), int(round(pt[1])))\n            if grid.is_agent_valid_pos(p):\n                new_v = Vertex(p)\n                # Assign dummy cost, will be updated if needed later\n                new_v.cost = 0\n                new_vertices.append(new_v)\n        # Remove duplicates near each other (distance zero)\n        filtered_vertices = []\n        last_pos = None\n        for v in new_vertices:\n            if last_pos is None or v.position != last_pos:\n                filtered_vertices.append(v)\n                last_pos = v.position\n\n        return filtered_vertices if len(filtered_vertices) >= 2 else path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path by ascending parents with min cost, then smooth in two stages:\n        # classic shortcut path smoothing + Bezier curve smoothing for natural turns\n        path: list = [q_goal]\n        curr = q_goal\n        while curr.parents:\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        # Delayed neighborhood rewiring for local refinement\n        self._delayed_local_rewire(path)\n\n        # Bezier smoothing for natural smoothness\n        path_smoothed = self._bezier_smooth_path(path)\n\n        # Move the agent along the polished path with animation key frames\n        for vertex in path_smoothed:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        # Classic shortcut smoothing by connecting non-adjacent vertices directly if path is valid\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0  # Initialize start cost zero\n\n        start_time = time.time()\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Timeout condition: fail search\n                break\n\n            # Adaptive sampling: goal bias, heuristic funnel sample or uniform random\n            q_sample = None\n            r = random.random()\n            if r < self._goal_sample_rate:\n                q_sample = goal_vertex.position\n            else:\n                funnel_sample = self._get_heuristic_funnel_sample()\n                if funnel_sample is not None:\n                    q_sample = funnel_sample\n                else:\n                    # Uniform random sample\n                    while True:\n                        rand_pos = random.choices(range(grid.size.x), k=1)[0], random.choices(range(grid.size.y), k=1)[0]\n                        sample = Point(rand_pos[0], rand_pos[1])\n                        if grid.is_agent_valid_pos(sample):\n                            q_sample = sample\n                            break\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(iteration)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius(\n                [start_vertex], q_new.position, self._rewire_radius\n            )\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            # Add new vertex and edge\n            self._graph.add_edge(q_parent, q_new)\n\n            # Immediate rewiring neighbors\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached or can be connected (expanded radius to relax)\n            goal_connect_dist = self._rewire_radius * 1.3\n            dist_to_goal = grid.get_distance(q_new.position, goal_vertex.position)\n\n            if dist_to_goal <= goal_connect_dist:\n                # Try to connect q_new to goal\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm extends the original RRT* approach by integrating heuristic guidance inspired by A* cost estimation to bias expansions towards promising directions and improve planning efficiency. It uses goal-biased adaptive sampling combined with heuristic-informed sampling around the tree frontier to better explore relevant regions. \n    Adaptive step sizes adjust according to clearance as before, but with dynamic shrinkage near obstacles to enhance smoothness. The rewiring step incorporates not only cost but also a smoothness metric based on direction changes between parent-child edges to reduce sharp turns.\n    Additionally, dynamic early stopping occurs not only on time but also on path cost convergence and goal proximity, improving robustness.\n    The path extraction uses enhanced shortcutting using iterative smoothing combined with collision checks, providing a smoother final trajectory.\n    Overall, the algorithm balances exploration and exploitation with informed sampling and rewire smoothness, leading to faster, more robust, and higher-quality paths with fewer iterations and greater success rates.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        self._last_path_cost = float('inf')\n        self._convergence_count = 0\n        self._max_convergence_stalls = 5  # Number of consecutive iterations path cost not improved before early stop\n\n    def _heuristic_cost(self, position: Point) -> float:\n        # Estimated cost to goal (heuristic) with Euclidean distance\n        return Map.get_distance(position, self._get_grid().goal.position)\n\n    def _smoothness_cost(self, parent: Vertex, child: Vertex) -> float:\n        # Smoothness cost penalizes sharp turns by comparing direction vectors\n        if not parent.parents:\n            return 0.0\n        grandparent = next(iter(parent.parents))\n        vec1 = (parent.position.to_tensor() - grandparent.position.to_tensor())\n        vec2 = (child.position.to_tensor() - parent.position.to_tensor())\n        if vec1.norm() == 0 or vec2.norm() == 0:\n            return 0.0\n        cos_angle = torch.dot(vec1 / vec1.norm(), vec2 / vec2.norm())\n        # Penalize sharp turns by inverse of cosine angle (1 - cos_angle), range [0,2]\n        return float(1.0 - cos_angle)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Optional[Vertex]':\n        # Modified to shrink max_dist adaptively when near obstacles for smoothness\n        # Use clearance factor to shrink max_dist if close to obstacles (check nearness by repeated tries)\n        base_dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(base_dir)\n        if norm == 0:\n            return None\n        \n        # Adaptive shrink based on distance to closest obstacle by sampling ahead along direction\n        clearance_factor = 1.0\n        for scale in np.linspace(1.0, 0.3, 4):\n            test_dist = max_dist * scale\n            projected_point = Point.from_tensor(q_near.position.to_tensor() + (base_dir / norm) * test_dist)\n            if not self._get_grid().is_agent_valid_pos(projected_point):\n                clearance_factor = scale * 0.6\n                break\n            line_seq = self._get_grid().get_line_sequence(q_near.position, projected_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance_factor = scale * 0.6\n                break\n        \n        effective_max_dist = max_dist * clearance_factor\n\n        if norm <= effective_max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = base_dir / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + effective_max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: 'List[Vertex]', q_new: 'Vertex') -> 'Optional[Vertex]':\n        # Weighted cost: cost + movement + heuristic + smoothness to prefer smoother and efficient paths\n        min_total_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            base_cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            heuristic = self._heuristic_cost(q_new.position)\n            smooth = self._smoothness_cost(v, q_new)\n            total_cost = base_cost + heuristic * 0.2 + smooth * 3.0  # Tuned weights; smoothness high priority\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: 'Vertex', q_near_list: 'List[Vertex]') -> None:\n        # Rewire neighbors through q_new if reduced total cost (cost+heuristic+smoothness)\n        for v in q_near_list:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            base_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            heuristic = self._heuristic_cost(v.position)\n            smooth = self._smoothness_cost(q_new, v)\n            total_cost = base_cost + heuristic * 0.2 + smooth * 3.0\n            \n            if total_cost < v.cost:\n                # Remove old edges from parents to v and add edge from q_new to v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = total_cost\n\n    def _iterative_path_shortcut(self, path: 'List[Vertex]', max_iter: int = 30) -> 'List[Vertex]':\n        # Improved smoothing by iterative shortcutting and path simplification with collision checks\n        smoothed_path = path[:]\n        for _ in range(max_iter):\n            if len(smoothed_path) <= 2:\n                break\n            # Attempt to skip intermediate vertices if line is valid\n            i = 0\n            changed = False\n            while i < len(smoothed_path) - 2:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed_path[i].position, smoothed_path[i + 2].position)):\n                    smoothed_path.pop(i + 1)\n                    changed = True\n                else:\n                    i += 1\n            if not changed:\n                break\n        return smoothed_path\n\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: 'List[Vertex]' = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Choose parent with minimum cost (and smallest smoothness if tie)\n            min_cost_parent = None\n            min_cost = float('inf')\n            min_smooth = float('inf')\n            for p in path[-1].parents:\n                smooth = self._smoothness_cost(p, path[-1])\n                if p.cost < min_cost or (p.cost == min_cost and smooth < min_smooth):\n                    min_cost = p.cost\n                    min_cost_parent = p\n                    min_smooth = smooth\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        # Iterative path shortcutting for smoothness\n        smoothed_path = self._iterative_path_shortcut(path)\n\n        # Trace the path to move agent, with key frames for visualization\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_heuristic_bias_sample(self, base_sample: Point, radius: float) -> Point:\n        # Sample around base_sample using Gaussian centered at base_sample truncated by radius,\n        # but restricted to valid positions. This encourages focused sampling near frontier.\n        for _ in range(20):\n            offset = np.random.normal(0, radius / 2, size=self._get_grid().size.n_dim)\n            sample_tensor = base_sample.to_tensor() + torch.tensor(offset, dtype=torch.float)\n            sample_int = Point(*np.clip(sample_tensor.round().int().tolist(), 0, self._get_grid().size - 1))\n            if self._get_grid().is_agent_valid_pos(sample_int):\n                return sample_int\n        # fallback\n        return base_sample\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        goal_sample_rate = 0.25\n        search_radius = 12.0  # slightly smaller radius for local rewiring to improve smoothness\n        start_time = time.time()\n        self._graph.root_vertex_start.cost = 0.0\n\n        # Maintain a frontier set for heuristic-biased sampling (closest vertices to goal)\n        frontier_vertices: 'List[Vertex]' = [self._graph.root_vertex_start]\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failure\n                break\n\n            # Heuristic-biased sampling: With prob goal_sample_rate choose goal,\n            # otherwise biased sampling at frontier or random\n            if np.random.rand() < goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                # 60%: random valid sample, 40% biased near frontier closest to goal\n                if np.random.rand() < 0.4 and frontier_vertices:\n                    # Pick a frontier vertex close to goal and sample around it\n                    frontier_vertices_sorted = sorted(frontier_vertices, key=lambda v: self._heuristic_cost(v.position))\n                    base_vertex = frontier_vertices_sorted[0]\n                    q_sample = self._get_heuristic_bias_sample(base_vertex.position, radius=5.0)\n                else:\n                    # Uniform random valid sample\n                    while True:\n                        rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                        q_sample_candidate = Point(*rand_pos)\n                        if self._get_grid().is_agent_valid_pos(q_sample_candidate):\n                            q_sample = q_sample_candidate\n                            break\n            \n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, min_dist=2.0, max_dist=12.0)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list = self._get_near_vertices(q_new, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n            \n            # Add edge & cost\n            base_cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n            # Incorporate heuristic and smoothness for cost stored in vertex for better rewiring decisions\n            heuristic = self._heuristic_cost(q_new.position)\n            smoothness = self._smoothness_cost(chosen_parent, q_new)\n            q_new.cost = base_cost + heuristic * 0.2 + smoothness * 3.0\n\n            self._graph.add_edge(chosen_parent, q_new)\n\n            # Rewire neighbors (excluding parent)\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Update frontier: add q_new if it advances towards goal and isn't too far\n            dist_to_goal = Map.get_distance(q_new.position, self._get_grid().goal.position)\n            if dist_to_goal < 20.0 and q_new not in frontier_vertices:\n                frontier_vertices.append(q_new)\n\n            # Remove frontier vertices too close to q_new (converged region)\n            frontier_vertices = [v for v in frontier_vertices if Map.get_distance(v.position, q_new.position) > 2.0]\n\n            # Check for early goal reach considering path improvement\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                path_cost_now = q_new.cost\n                # If new path cost improves or stable for consecutive iterations -> extract path\n                if path_cost_now < self._last_path_cost:\n                    self._last_path_cost = path_cost_now\n                    self._convergence_count = 0\n                else:\n                    self._convergence_count += 1\n                if self._convergence_count >= self._max_convergence_stalls or i > 100:\n                    self._extract_path(q_new)\n                    break\n\n            # Also convergence check on max iterations earlier than max_iterations\n            if i > 200 and self._convergence_count >= self._max_convergence_stalls:\n                # Can't find better path, stop to save time\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved PathPlanning Algorithm with enhanced smoothness and efficiency:\n    - Adaptive max step size dynamically scales with progress and tree size for balanced exploration.\n    - Mixed sampling combining uniform, goal-biased, and adaptive informed ellipsoidal to focus sampling.\n    - Heuristic-guided vertex expansion incorporating traveled cost and admissible distance to goal.\n    - Dynamic neighborhood radius for rewiring, scaled with logarithm of tree size, supporting RRT*-style optimization.\n    - Early neighbor pruning during rewiring to reduce clutter and improve path quality.\n    - Robust multi-pass path shortcutting smoothing with attempts to produce smooth final trajectory.\n    - Early termination upon detecting a direct valid connection to goal with a shorter path.\n    - Overall improves planning speed, success rate, and path smoothness under time constraints.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size far from goal\n        self._min_max_dist = 2.5   # Min step size near goal for fine control\n        self._goal_sample_rate = 0.25  # Goal biased sampling probability\n        self._informed_sample_rate = 0.3  # Probability of ellipsoidal informed sampling\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45  # Rewiring radius factor tuning\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 500 / (self._graph.size + 1))\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor\n        return scaled_step\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        import math\n        import torch\n\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(*(((start_pos.to_tensor().float() + goal_pos.to_tensor().float()) / 2).tolist()))\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        e1 = diff / dist_start_goal\n\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        a = c_max / 2.0\n        b = math.sqrt(max(c_max ** 2 - dist_start_goal ** 2, 1e-6)) / 2.0\n\n        for _ in range(40):\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal biased sampling with radius min_max_dist around goal\n        if rand_val < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    sample_offset = sample_offset / norm\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        # Informed ellipsoidal sampling focused within current best cost bound\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling across valid grid\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            # Fallback to start position if no valid sample found\n            return self._graph.root_vertex_start.position\n\n    def _extract_path_and_smooth(self, goal_vertex: Vertex):\n        # Extract path from root to goal vertex\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Multi-pass robust shortcut smoothing with more attempts per pass\n        smoothing_attempts = 4\n        for _pass in range(smoothing_attempts):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        shortened = True\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic-guided minimum cost parent selection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n\n            # Combine actual cost + heuristic to goal in parent selection for better exploration\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n                heuristic_candidate_parent = self._heuristic_cost(q_near.position, goal_pos)\n\n                # Prefer parents with lower cost + heuristic to goal\n                if (cost_candidate + heuristic_new) < (c_min + self._heuristic_cost(q_min.position, goal_pos)):\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Early pruning neighbors with regressive cost\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                # Include small epsilon stability to avoid float issues\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one parent edge (tree structure maintenance)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                        # Early termination on direct goal connect with best path\n                        if cost_to_goal < float('inf'):\n                            break\n\n            # Mark key frame visualization every 40 iterations for smooth animation\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning algorithm combining goal-biased informed sampling, \n    heuristic-guided tree expansion with clearance-awareness, adaptive step size, \n    and rewiring inspired by RRT*. This version enhances path clearance by biasing \n    sampling towards regions with higher clearance from obstacles to improve robustness \n    and success rate. It also employs a clearance-aware cost heuristic to prefer safer \n    paths, adaptive rewiring radius scaled with graph size, and path shortcutting with \n    clearance checks for smoother and shorter paths. The planning halts early if a path \n    is found or after 10 seconds to improve efficiency.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        # Additional parameters for clearance-aware sampling and cost\n        self._clearance_sample_attempts = 50\n        self._min_clearance_threshold = 1.5  # minimal clearance distance to obstacles for samples\n        self._clearance_influence_weight = 5.0  # weight factor for clearance in cost heuristic\n        self._init_displays()\n\n    def _compute_clearance(self, point: Point) -> float:\n        \"\"\"\n        Compute clearance distance from obstacles for a given point by checking\n        neighbors and finding minimum distance to obstacles within a small radius.\n        \"\"\"\n        grid = self._get_grid()\n        min_clearance = float('inf')\n        # We check neighbors within a small radius (e.g., 5 grid units)\n        check_radius = 5\n        x, y = point.x, point.y\n        for dx in range(-check_radius, check_radius + 1):\n            for dy in range(-check_radius, check_radius + 1):\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < grid.size[0] and 0 <= ny < grid.size[1]:\n                    neighbor = Point(nx, ny)\n                    if not grid.is_agent_valid_pos(neighbor):\n                        dist = Map.get_distance(point, neighbor)\n                        if dist < min_clearance:\n                            min_clearance = dist\n        # If no obstacle nearby, clearance is the check_radius + 1\n        if min_clearance == float('inf'):\n            return check_radius + 1\n        return min_clearance\n\n    def _clearance_weighted_sample(self) -> Point:\n        \"\"\"\n        Sample points with a bias towards higher clearance areas.\n        Attempts multiple samples and chooses the one with max clearance.\n        Incorporates goal biasing.\n        \"\"\"\n        import time\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        if torch.rand(1).item() < self._goal_sample_rate:\n            # Sample in a small ball around goal for goal bias\n            for _ in range(30):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback if can't sample near goal\n            return goal_pos\n        else:\n            best_sample = None\n            best_clearance = -1\n            for _ in range(self._clearance_sample_attempts):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if not grid.is_agent_valid_pos(sample):\n                    continue\n                clearance = self._compute_clearance(sample)\n                if clearance >= self._min_clearance_threshold and clearance > best_clearance:\n                    best_clearance = clearance\n                    best_sample = sample\n            # If no high clearance sample found, fallback to random valid\n            if best_sample:\n                return best_sample\n            # fallback: random valid sampling with at most 100 tries\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start pos if no valid sample found (very rare)\n            return self._graph.root_vertex_start.position\n\n    def _cost_with_clearance(self, parent: Vertex, child_pos: Point) -> float:\n        \"\"\"\n        Compute cost from parent to child with clearance heuristic added.\n        Cost = Path length + clearance penalty\n        Clearance penalty is inversely proportional to clearance to obstacles.\n        \"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(parent.position, child_pos)\n        clearance = self._compute_clearance(child_pos)\n        clearance_penalty = 0.0\n        if clearance < self._min_clearance_threshold:\n            clearance_penalty = (self._min_clearance_threshold - clearance) * self._clearance_influence_weight\n        return parent.cost + dist + clearance_penalty\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Stop searching after time limit\n                return\n\n            # Sample with clearance bias and goal bias\n            q_sample = self._clearance_weighted_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Find nearby vertices for rewiring using adaptive radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among nearby vertices using clearance-aware cost\n            q_min = q_nearest\n            c_min = self._cost_with_clearance(q_nearest, q_new.position)\n\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = self._cost_with_clearance(q_near, q_new.position)\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if (cost_candidate < c_min) and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to improve their costs if passing through q_new is cheaper\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                cost_through_new = self._cost_with_clearance(q_new, q_near.position)\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge (single parent assumption from tree)\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if close to goal within adaptive max_dist\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm leveraging adaptive, clearance-aware sampling, \n    heuristic-guided expansion, and efficient rewiring optimization for faster convergence, \n    higher success, and safer paths. Key innovations include:\n\n    - Clearance-augmented sampling: biased toward higher clearance regions by rejecting low-clearance samples,\n      improving robustness by steering away from tight obstacles.\n    - Adaptive step size scaled dynamically with progress and tree size, tuned by local clearance, \n      allowing coarse exploration in open spaces and finer near clutter or goal.\n    - Enhanced mixed sampling strategy combining goal bias, informed ellipsoidal sampling, and clearance-aware uniform sampling \n      to focus samples in promising and safe areas.\n    - Neighborhood radius for rewiring dynamically computed based on tree size and incorporates clearance factors.\n    - Early pruning of rewiring if cost improvement is negligible, reducing clutter and improving runtime.\n    - Multiple passes of robust shortcut smoothing to ensure path quality and smoothness.\n    - Early termination upon direct goal connection and smoothing, positing improved efficiency.\n    - Enforces a 10-second timeout for planning to guarantee timely response.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0  # Slightly increased max step size for faster exploration in open areas\n        self._min_max_dist = 2.5   # Minimum step size near goal or clutter for precision\n        self._goal_sample_rate = 0.2  # Balanced goal bias\n        self._informed_sample_rate = 0.4  # Increased informed sampling to focus effort\n        self._max_iterations = 3500  # Lower max iterations due to increased efficiency\n        self._lambda_rrt_star = 40  # Rewiring radius tuning factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Enforce 10 second planning limit\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3  # Minimum clearance radius for accepting samples\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"Estimate clearance as minimum distance to any obstacle or boundary.\"\"\"\n        grid = self._get_grid()\n        max_clearance_check = 10.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        # Also consider distance to map boundary\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _clearance_aware_sample(self) -> Point:\n        \"\"\"\n        Returns a random valid sample that has clearance above threshold by rejection sampling.\n        Tries uniformly but rejects low clearance points.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        for _ in range(150):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        # fallback uniformly if no high-clearance sample found\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        prob = torch.rand(1).item()\n        if prob < self._goal_sample_rate:\n            # Goal biased sampling inside goal radius zone expanded by min_max_dist\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                offset_vec = torch.randn(self._dimension)\n                norm = torch.norm(offset_vec).item()\n                if norm < 1e-8:\n                    continue\n                offset_vec = offset_vec / norm\n                offset_len = torch.rand(1).item() * self._min_max_dist\n                sample_coords = (goal_pos.to_tensor().float() + offset_vec * offset_len).round().int()\n                sample = Point.from_tensor(sample_coords)\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            return goal_pos\n\n        elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling with clearance check\n            for _ in range(30):\n                sample = self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n                if self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            # fallback\n            return self._clearance_aware_sample()\n\n        else:\n            # Clearance-aware uniform sampling\n            return self._clearance_aware_sample()\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_goal = Map.get_distance(q_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n\n        # Tree size factors: larger tree => smaller step size to allow refinement near goal\n        tree_factor = min(1.0, 600 / (self._graph.size + 1))\n\n        # Clearance scaling: smaller step size if clearance is small, larger if clearance high (up to max dist)\n        clearance = self._get_clearance(q_pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 2.0))  # Normalize clearance factor (0 to 1+)\n\n        step = (self._min_max_dist + \n                (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor * clearance_factor)\n        return max(self._min_max_dist, min(step, self._max_max_dist))\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance admissible heuristic for consistency with costs\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex) -> None:\n        # Extract path and perform multiple robust shortcut passes\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n        grid = self._get_grid()\n\n        # Multiple shortcutting passes for smoothing\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early timeout abort\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # abort planning after 10 seconds\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 25.0)\n\n            # Inflate radius slightly adapting to clearance to allow more neighbors in open areas\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent with minimal cost plus heuristic and valid connection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Efficient rewire neighbors if improved cost (with pruning threshold)\n            rewire_threshold = 0.005\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove old parent edge (single-parent tree structure)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early termination: direct goal reach with smooth path extraction\n                    break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired path planner with enhanced clearance awareness and heuristic guidance.\n    This algorithm builds on goal-biased adaptive sampling and rewiring of the RRT* backbone,\n    but enhances performance by including:\n    - Clearance-weighted adaptive step sizing that more effectively respects free space and obstacles,\n      allowing longer stable extensions in safe areas and cautious steps near obstacles.\n    - A dynamically computed heuristic cost combining path cost and estimated distance-to-goal,\n      guiding tree growth preferentially toward promising regions and reducing wasted exploration.\n    - Adaptive sampling: mixing pure uniform sampling, goal-centric bias, and biased sampling toward\n      regions of high clearance to avoid narrow passages.\n    - Enhanced rewiring considering clearance and cost to improve robustness and path quality.\n    - Early stopping with a timeout to bound planning time.\n    - Final path smoothing with shortcutting using clearance-aware validation to produce safer and smoother paths.\n    This algorithm aims to improve planning efficiency, path smoothness, robustness, and success rate\n    compared to the baseline RRT* approach.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # Additional member for clearance-biased sampling weights\n        self._clearance_sample_weight = 0.3\n        self._uniform_sample_weight = 0.5\n        self._goal_sample_weight = 0.2\n\n    def _clearance_at_point(self, pos: Point, max_check_dist=10.0, resolution=1.0) -> float:\n        # Estimate clearance radius by checking distance in multiple directions until obstacles or bounds\n        # returns clearance estimate capped at max_check_dist\n        grid = self._get_grid()\n        directions = [\n            torch.tensor([1.0, 0.0]),\n            torch.tensor([-1.0, 0.0]),\n            torch.tensor([0.0, 1.0]),\n            torch.tensor([0.0, -1.0]),\n            torch.tensor([1.0, 1.0]).float().normalize(),\n            torch.tensor([-1.0, 1.0]).float().normalize(),\n            torch.tensor([1.0, -1.0]).float().normalize(),\n            torch.tensor([-1.0, -1.0]).float().normalize(),\n        ]\n        clearance = max_check_dist\n        for d in directions:\n            for dist in np.arange(resolution, max_check_dist + resolution, resolution):\n                check_tensor = pos.to_tensor() + d * dist\n                check_point = Point.from_tensor(check_tensor)\n                if not grid.is_agent_valid_pos(check_point):\n                    clearance = min(clearance, dist - resolution)\n                    break\n                line_seq = grid.get_line_sequence(pos, check_point)\n                if not grid.is_valid_line_sequence(line_seq):\n                    clearance = min(clearance, dist - resolution)\n                    break\n        return max(0.0, clearance)\n\n    def _get_clearance_biased_sample(self) -> Point:\n        # Sample with bias toward regions of higher clearance by sampling positions,\n        # evaluating clearance, and probabilistically selecting one with higher clearance.\n        grid = self._get_grid()\n        attempts = 0\n        max_attempts = 30\n        samples_clearance = []\n        samples = []\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if not grid.is_agent_valid_pos(sample):\n                attempts += 1\n                continue\n            clearance = self._clearance_at_point(sample, max_check_dist=10.0)\n            samples.append(sample)\n            samples_clearance.append(clearance)\n            attempts += 1\n        if not samples:\n            # fallback to uniform random valid sample\n            return self._get_random_sample(goal_sample_rate=0)\n        # Normalize clearance scores to probabilities\n        clearance_array = np.array(samples_clearance)\n        if clearance_array.sum() == 0:\n            probabilities = np.ones_like(clearance_array) / len(clearance_array)\n        else:\n            probabilities = clearance_array / clearance_array.sum()\n        chosen_idx = np.random.choice(len(samples), p=probabilities)\n        return samples[chosen_idx]\n\n    def _get_random_sample(self, goal_sample_rate=0.3) -> Point:\n        # Mix three sampling modes: goal biased, clearance biased, uniform random\n        rand_val = np.random.rand()\n        if rand_val < self._goal_sample_weight:\n            return self._get_grid().goal.position\n        elif rand_val < self._goal_sample_weight + self._clearance_sample_weight:\n            return self._get_clearance_biased_sample()\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=4.0, max_dist=20.0) -> float:\n        # Clearance aware step size - extension length scales with clearance but capped\n        clearance = self._clearance_at_point(pos, max_check_dist=max_dist)\n        # Conservative scale: Leave margin of around 1 grid cell\n        step = np.clip(clearance - 1.0, min_dist, max_dist)\n        return step\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # heuristic cost combining Euclidean distance and estimated clearance cost\n        dist = self._get_grid().get_distance(from_pos, to_pos)\n        clearance = self._clearance_at_point(from_pos)\n        # Penalize low clearance (smaller clearance => higher heuristic)\n        clearance_penalty = (1.0 / (clearance + 1e-5))\n        return dist * clearance_penalty\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Select parent minimizing cost + heuristic cost toward goal, with line validity\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            movement_cost = self._get_grid().get_movement_cost(v.position, q_new.position)\n            cost = v.cost + movement_cost\n            heuristic = self._heuristic_cost(q_new.position, self._get_grid().goal.position)\n            total_cost = cost + heuristic\n            if total_cost < min_cost:\n                min_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Rewire neighbors through q_new if it reduces cost considering movement cost and validity\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                # Update edges in graph\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Enhanced shortcutting: Try to skip intermediate vertices where line is not only collision-free but clearance is high\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        last_idx = 0\n        for i in range(1, len(path)):\n            line_seq = grid.get_line_sequence(shortcut_path[-1].position, path[i].position)\n            if (not grid.is_valid_line_sequence(line_seq)) or (self._clearance_at_point(path[i].position) < 1.5):\n                shortcut_path.append(path[i - 1])\n                last_idx = i - 1\n        if shortcut_path[-1] != path[-1]:\n            shortcut_path.append(path[-1])\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new to start, add goal connection, smooth path and trace it\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        search_radius = 18.0\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate=0.3)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            neighbors_to_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, neighbors_to_rewire)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm combining:\n     - Adaptive max step size dynamically scaled by progress towards goal and tree size,\n     - Enhanced mixed sampling (uniform, goal-biased, and informed ellipsoidal) focused by best-known path cost,\n     - Heuristic-guided vertex expansion prioritizing cost-to-come + admissible cost-to-go,\n     - Dynamic neighborhood radius for rewiring scaled with tree size and iteration,\n     - Early rewire pruning to reduce clutter and improve path quality,\n     - Multi-pass robust shortcut smoothing on extracted path,\n     - Early termination upon discovering a direct connect to goal with smooth path,\n     - Imposes a strict 10 seconds timeout to constrain planning time.\n    Aims for improved efficiency, path quality, robustness, and success rate over standard RRT*-informed approaches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        from heapq import heappush, heappop\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n        self._start_time = time.time()\n\n        max_total_time = 10.0  # seconds total budget for planning\n\n        def heuristic_cost(pos: Point) -> float:\n            return Map.get_distance(pos, goal_pos)\n\n        def combined_cost(vertex: Vertex) -> float:\n            # g + h cost used to prioritize vertices for expansion, admissible heuristic\n            return vertex.cost + heuristic_cost(vertex.position)\n\n        def sample_point() -> Point:\n            # Mixing uniform, goal-biased, and ellipse informed sampling based on best cost\n            rand_val = torch.rand(1).item()\n            if rand_val < self._goal_sample_rate:\n                # Goal biased sampling near goal within min_max_dist\n                for _ in range(40):\n                    offset = torch.randn(self._dimension)\n                    norm_offset = offset / torch.norm(offset) if torch.norm(offset) > 1e-8 else offset\n                    scaled_offset = norm_offset * (torch.rand(1).item() * self._min_max_dist)\n                    sample = Point(*((goal_pos.to_tensor().float() + scaled_offset).round().int().tolist()))\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n                return goal_pos\n            elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n                return self._sample_in_ellipsoid(start_vertex.position, goal_pos, self._best_cost)\n            else:\n                for _ in range(120):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        return sample\n                return start_vertex.position\n\n        def adaptive_max_step(pos: Point) -> float:\n            dist_goal = Map.get_distance(pos, goal_pos)\n            progress = max(0.05, min(1.0, dist_goal / max(grid.size)))\n            scale = min(1.0, 500 / (self._graph.size + 1))\n            return self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress * scale\n\n        def rewiring_radius(iter_n: int) -> float:\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            base_radius = (self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)))\n            # Shrink radius gently with iterations to focus rewiring\n            shrink_factor = max(0.3, 1.0 - iter_n / self._max_iterations)\n            return min(base_radius * shrink_factor, 25.0)\n\n        # Priority queue for vertex expansion to enforce heuristic-guided exploration\n        # (Currently we implement standard iterative sampling but evaluate heuristic for parent choice)\n        iterations = 0\n        while iterations < self._max_iterations:\n            elapsed = time.time() - self._start_time\n            if elapsed > max_total_time:\n                # Abort planning due to time limit\n                break\n\n            q_sample = sample_point()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                iterations += 1\n                continue\n\n            max_dist = adaptive_max_step(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir == 0:\n                iterations += 1\n                continue\n\n            if norm_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm_vec = dir_vec / norm_dir\n                point_tensor = (q_nearest.position.to_tensor().float() + dir_norm_vec * max_dist).round().int()\n                q_new_pos = Point.from_tensor(point_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                iterations += 1\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                iterations += 1\n                continue\n\n            # Construct new vertex with initial parent q_nearest\n            q_new = Vertex(q_new_pos)\n            dist_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_to_new\n\n            # Dynamic radius for rewiring\n            radius = rewiring_radius(iterations)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent from neighbors minimizing cost + heuristic\n            parent_candidates = []\n            for q_neigh in neighbors:\n                dist_neigh_new = torch.norm(q_neigh.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_neigh.cost + dist_neigh_new\n                # Check line of sight\n                line_neighbor_new = grid.get_line_sequence(q_neigh.position, q_new.position)\n                if grid.is_valid_line_sequence(line_neighbor_new):\n                    heappush(parent_candidates, (cost_candidate, q_neigh))\n\n            if parent_candidates:\n                cost_min, best_parent = parent_candidates[0]\n                # Assign best parent and cost to q_new\n                q_new.cost = cost_min\n                self._graph.add_edge(best_parent, q_new)\n            else:\n                # Fallback to q_nearest if no better parent found\n                self._graph.add_edge(q_nearest, q_new)\n\n            # Rewire neighbors if improved path through q_new available\n            for q_neigh in neighbors:\n                if q_neigh.position == q_new.position:\n                    continue\n                dist_new_neigh = torch.norm(q_new.position.to_tensor().float() - q_neigh.position.to_tensor().float()).item()\n                new_cost = q_new.cost + dist_new_neigh\n                if new_cost + 1e-6 < q_neigh.cost:  # epsilon for numerical stability\n                    line_new_neigh = grid.get_line_sequence(q_new.position, q_neigh.position)\n                    if grid.is_valid_line_sequence(line_new_neigh):\n                        # Remove one old parent edge to maintain tree\n                        for parent in q_neigh.parents:\n                            self._graph.remove_edge(parent, q_neigh)\n                            break\n                        q_neigh.cost = new_cost\n                        self._graph.add_edge(q_new, q_neigh)\n\n            # Attempt to connect q_new directly to goal if close enough with valid path\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_goal < self._best_cost:\n                        self._best_cost = cost_goal\n                        found_goal = goal_vertex\n                    # Early exit on direct goal connection with good cost\n                    break\n\n            if iterations % 40 == 0:\n                self.key_frame()\n\n            iterations += 1\n\n        if found_goal is not None:\n            # Extract and smooth path robustly\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* Inspired Algorithm with Goal-Biased Sampling and Adaptive Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Inspired Algorithm with Goal-Biased Sampling and Adaptive Rewiring}\n\n    This algorithm improves the baseline RRT by incorporating:\n    - Goal-biased sampling (sampling towards the goal with a probability) to improve convergence.\n    - RRT* style rewiring to optimize path quality (shorter, smoother paths).\n    - Adaptive max step distance based on distance to goal to accelerate early expansion and refine near goal.\n    - Early stopping when a solution is found and further rewiring iterations are limited.\n    - Shortcut smoothing in the extracted path by trying to directly connect non-adjacent vertices.\n    - A hard timeout of 10 seconds to ensure bounded planning time.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring edge removals for optimization\n        self._init_displays()\n\n        # Parameters\n        self._goal_sample_rate = 0.15   # Probability of sampling the goal directly (goal bias)\n        self._max_iterations = 5000\n        self._initial_max_dist = 15.0   # Initial max extension distance\n        self._min_max_dist = 2.0        # Minimum step size near the goal\n        self._rewiring_radius = 20.0    # Radius for neighbor search during rewiring\n        self._timeout_sec = 10.0        # Timeout limit in seconds\n\n    def _get_adaptive_max_dist(self, q_near_pos: Point) -> float:\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = Map.get_distance(q_near_pos, goal_pos)\n        # Linearly scale max_dist between min_max_dist and initial max based on distance to goal\n        dist_clamped = max(min(dist_to_goal, self._initial_max_dist), self._min_max_dist)\n        return dist_clamped\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        best_goal_vertex: Optional[Vertex] = None\n        best_cost_to_goal = float('inf')\n\n        for iteration in range(self._max_iterations):\n            # Check timeout\n            if time.time() - start_time > self._timeout_sec:\n                # Timeout reached, declare fail to find path\n                break\n\n            # Goal biased sampling\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost to reach q_new via q_near\n            cost_to_new_via_q_near = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Create new vertex with cost info\n            q_new.cost = cost_to_new_via_q_near\n\n            # Find neighbors within rewiring radius\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewiring_radius)\n\n            # Choose best parent among neighbors to minimize cost to q_new\n            best_parent = q_near\n            best_cost = cost_to_new_via_q_near\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                line_seq_neighbor = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_neighbor):\n                    continue\n                tentative_cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if tentative_cost < best_cost:\n                    best_cost = tentative_cost\n                    best_parent = neighbor\n\n            # Set q_new cost and add edge from best parent\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if connecting through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    continue\n                cost_through_q_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if cost_through_q_new < neighbor.cost:\n                    # Remove old parent edges (for simplicity, remove all parents and add new)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n            # Check if q_new is within goal radius and is better path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_cost_to_goal:\n                    best_cost_to_goal = q_new.cost\n                    best_goal_vertex = q_new\n\n            self.key_frame()\n\n            # Early stopping if good path found and iterations passed\n            if best_goal_vertex and iteration > self._max_iterations // 10:\n                break\n\n        # If found path, extract and smooth\n        if best_goal_vertex is not None:\n            self._extract_and_smooth_path(best_goal_vertex)\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        # Extract path from goal_vertex back to start by parents\n        path: List[Vertex] = [goal_vertex]\n        current_vertex = goal_vertex\n\n        while len(current_vertex.parents) != 0:\n            # Choose parent with min cost (in case multiple)\n            parent = min(current_vertex.parents, key=lambda p: p.cost)\n            path.append(parent)\n            current_vertex = parent\n\n        # Path is from goal to start, reverse it\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path by skipping intermediate vertices\n        path = self._shortcut_path(path)\n\n        # Animate moving along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut the path by checking direct line between non-adjacent vertices\n        if len(path) <= 2:\n            return path\n\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # Start by trying to connect directly to goal\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n        return smoothed_path",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on RRT*, integrating:\n     - Goal-biased sampling (20% samples biased towards goal)\n     - Adaptive step size: max_dist adapts based on distance to goal to allow coarse-to-fine exploration\n     - Rewiring for path optimization (RRT* style) to improve path quality and robustness\n     - Smoothed path extraction by shortcutting line-of-sight segments on the final path\n     - Early stopping if path not found within 10 seconds\n     Overall aims:\n     - Improve planning efficiency by biasing sampling and adaptive step size\n     - Improve success rate by rewiring for shorter paths and better connectivity\n     - Improve path quality by shortcutting path before animation",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable rewiring edge removability for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias_ratio: float = 0.2) -> Point:\n        # Goal biased sampling: With probability goal_bias_ratio sample goal directly\n        if np.random.rand() < goal_bias_ratio:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample_pos: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample_pos):\n                    return sample_pos\n\n    def _choose_best_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the neighbor that results in minimum cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for nbr in neighbors:\n            if nbr.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(nbr.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = nbr.cost + self._get_grid().get_distance(nbr.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = nbr\n        if best_parent is None:\n            best_parent = neighbors[0]  # fallback (should not happen if neighbors not empty)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        # Try to improve cost to existing neighbors via q_new\n        for nbr in neighbors:\n            if nbr.position == q_new.position:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, nbr.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_distance(q_new.position, nbr.position)\n            if potential_cost < nbr.cost:\n                # Remove old parent edge(s) to nbr\n                for p in list(nbr.parents):\n                    self._graph.remove_edge(p, nbr)\n                # Add edge from q_new to nbr\n                self._graph.add_edge(q_new, nbr)\n                nbr.cost = potential_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to shorten path by skipping intermediate nodes if direct line is clear\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                # Check if direct line from path[i] to path[j] valid\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_final: Vertex) -> None:\n        path: List[Vertex] = [q_final]\n        # Backtrack parents to start vertex\n        while len(path[-1].parents) != 0:\n            for p in path[-1].parents:\n                path.append(p)\n                break\n        path.reverse()\n        # Shortcut path for smoother trajectory\n        path = self._shortcut_path(path)\n        # Animate path movement\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 10000\n        start_time = time()\n        max_dist_base = 10.0\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            # Check timeout (stop search after 10 seconds)\n            if time() - start_time > 10.0:\n                break\n\n            q_sample = self._get_random_sample(goal_bias_ratio=0.2)\n\n            # Adaptive max_dist: smaller when close to goal to improve precision\n            dist_to_goal = self._get_grid().get_distance(q_sample, goal_vertex.position)\n            max_dist = max(2.0, min(max_dist_base, dist_to_goal / 2))\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors within radius for rewiring (RRT*) radius proportional to max_dist\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius=max_dist * 2.0)\n            if not neighbors:\n                neighbors = [q_near]\n\n            # Choose best parent to minimize cost\n            best_parent = self._choose_best_parent(neighbors, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors through q_new if shorter path exists\n            self._rewire(neighbors, q_new)\n\n            # Check if q_new reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex directly if line is valid\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    q_goal_new = Vertex(goal_vertex.position)\n                    q_goal_new.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, q_goal_new)\n                    self._extract_path(q_goal_new)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT*-inspired path planner with adaptive informed sampling\n    and dynamic step adjustment for enhanced planning efficiency and path quality. Instead of naive uniform\n    random sampling, it uses an ellipsoidal informed sampling region that biases samples towards areas\n    likely to improve the current best solution, reducing exploration of irrelevant space and improving\n    success rate. It adaptively adjusts the max step size based on local environment clearance to balance\n    between exploration and refinement. Rewiring ensures cost optimization. Early stopping after 10 seconds\n    or upon finding a valid goal path is employed. Path shortcutting smooths the final solution for better quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # required for rewiring in RRT*\n        self._init_displays()\n        self._best_cost = float(\"inf\")\n        self._best_goal_vertex = None\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        \"\"\"\n        Compute an adaptive max_dist based on clearance around position.\n        Use a small radius and check clearance (distance to obstacles).\n        Return a max_dist scaled accordingly between min and max bounds.\n        \"\"\"\n        min_dist = 3.0\n        max_dist = 15.0\n        check_radius = 5  # radius in grid units around position to check clearance\n\n        grid = self._get_grid()\n        clearance = max_dist  # assume max clearance at start\n\n        # Evaluate clearance by checking free neighbors within check_radius in 8 directions\n        directions = [\n            Point(1, 0), Point(-1, 0), Point(0, 1), Point(0, -1),\n            Point(1, 1), Point(1, -1), Point(-1, 1), Point(-1, -1)\n        ]\n\n        for d in directions:\n            for r in range(1, check_radius + 1):\n                check_point = Point(position.x + d.x * r, position.y + d.y * r)\n                if not grid.is_agent_valid_pos(check_point):\n                    clearance = min(clearance, float(r))\n                    break\n\n        # Scale between min_dist and max_dist\n        scaled_dist = min_dist + (max_dist - min_dist) * (clearance / check_radius)\n        return max(min_dist, min(scaled_dist, max_dist))\n\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample a point from an ellipsoidal informed region defined by current best cost.\n        If no best path yet, fallbacks to uniform sampling with goal bias.\n        \"\"\"\n        grid = self._get_grid()\n        goal_bias = 0.2\n        if np.random.random() < goal_bias:\n            return goal\n\n        if self._best_cost == float(\"inf\"):  # no best path yet, uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                p = Point(*rand_pos)\n                if grid.is_agent_valid_pos(p):\n                    return p\n\n        # Ellipsoidal informed sampling\n        c_best = self._best_cost\n        c_min = grid.get_distance(start, goal)\n        if c_best < float(\"inf\") and c_min > 0:\n            # Sample inside an ellipse formed by start, goal, and current best path cost (c_best)\n            import math\n\n            center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n            a1 = ((goal.x - start.x) / c_min, (goal.y - start.y) / c_min)  # unit vector from start to goal\n            # Rotation matrix from ellipse space to grid space\n            rot = np.array([[a1[0], -a1[1]], [a1[1], a1[0]]])\n\n            # Semi-major axis length\n            r1 = c_best / 2\n            # Semi-minor axis length\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n            # Sample random point in unit circle in ellipse coordinates\n            while True:\n                theta = 2 * math.pi * np.random.random()\n                rho = np.sqrt(np.random.random())\n                x_ball = rho * math.cos(theta)\n                y_ball = rho * math.sin(theta)\n\n                # Scale by ellipse axes\n                sample_local = np.array([r1 * x_ball, r2 * y_ball])\n                # Rotate back to map frame\n                sample_global = rot @ sample_local\n                sample_point = Point(int(center.x + sample_global[0]), int(center.y + sample_global[1]))\n\n                if 0 <= sample_point.x < grid.size.x and 0 <= sample_point.y < grid.size.y:\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Fallback uniform sampling\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            p = Point(*rand_pos)\n            if grid.is_agent_valid_pos(p):\n                return p\n\n    def _update_best_path(self, goal_vertex: Vertex):\n        \"\"\"\n        Update the best found goal vertex and best cost.\n        \"\"\"\n        if goal_vertex.cost < self._best_cost:\n            self._best_cost = goal_vertex.cost\n            self._best_goal_vertex = goal_vertex\n\n    def _extract_and_move(self, goal_vertex: Vertex):\n        self._extract_path(goal_vertex)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        iteration_limit = 8000\n        start_time = time.time()\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: stop search\n                break\n\n            # Adaptive and local max step size around nearest vertex\n            q_sample = self._informed_sample(start_vertex.position, self._graph.root_vertex_goal.position)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist_local = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist_local)\n\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                continue\n\n            # Radius for neighbor search scales with step size and log of vertex count (RRT* theory)\n            radius = max(15.0, max_dist_local * (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** 0.5 * 5)\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                line_seq_nw = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # fallback to q_near if no better parent found\n                line_seq_qn = grid.get_line_sequence(q_near.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_qn):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n\n            # Add new vertex with chosen parent\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire nearby neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove all old parent edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if new vertex reaches goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_pos = grid.goal.position\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._update_best_path(goal_vertex)\n                    self._extract_and_move(goal_vertex)\n                    break\n\n            # Provide visualization keyframe\n            self.key_frame()\n\n        # If after iterations we have a best goal found, move along path\n        if self._best_goal_vertex is not None:\n            self._extract_and_move(self._best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm with memory-conscious management and enhanced convergence.\n\n    This implementation refines the baseline with:\n    - Memory-efficient vertex management by pruning unreachable or dominated vertices early.\n    - Adaptive sampling biased toward high-clearance and closer-to-goal regions for focused exploration.\n    - Heuristic-guided rewiring with tighter pruning to avoid unnecessary graph expansion.\n    - Adaptive step size scaling with clearance and distance, fostering efficient exploration and refinement.\n    - Early stopping once a direct goal connection is found and smoothed.\n    - Efficient shortcut smoothing performed conditionally.\n    - Enforced 10-second timeout for timely completion.\n\n    The approach balances path quality, success rate, and resource usage while preserving improvements \n    of informed sampling and clearance-aware exploration.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.2\n        self._informed_sample_rate = 0.4\n        self._max_iterations = 3500\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3\n\n        # Additional member variables for memory control and pruning\n        self._rewire_prune_threshold = 0.01  # Increased threshold to prune minor rewiring gains\n        self._max_vertices = 3000  # Limit graph size to control memory\n\n        self._init_displays()\n\n    def _prune_vertices(self) -> None:\n        \"\"\"\n        Prune vertices with cost much worse than current best cost or unreachable (isolated),\n        to limit memory consumption and speed rewiring.\n        \"\"\"\n        vertices_to_remove = []\n        cost_limit = self._best_cost * 1.5 if self._best_cost < float('inf') else float('inf')\n        for root in self._graph.root_vertices:\n            # Collect all vertices reachable from this root using DFS\n            stack = [root]\n            visited = set()\n            while stack:\n                v = stack.pop()\n                if v in visited:\n                    continue\n                visited.add(v)\n\n                # Prune condition: vertices with cost exceeding threshold or no parents and cost > 0 (excluding start)\n                if v.cost > cost_limit and v.cost > 0.0:\n                    vertices_to_remove.append(v)\n                stack.extend(v.children)\n\n        for v in vertices_to_remove:\n            # Remove edges to parents and children, effectively pruning vertex\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n            # Also remove from root vertices if present\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Terminate if time limit exceeded\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create new vertex and calculate cost from chosen parent candidate\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new_pos.to_tensor().float()).item()\n            q_new = Vertex(q_new_pos)\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / (self._clearance_threshold * 1.5), 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Identify best parent for q_new with minimal cost + valid collision-free connection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate + 1e-6 < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if cost improved beyond prune threshold (more aggressive pruning)\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n\n                if cost_through_new + self._rewire_prune_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove old parent edges for single-parent tree consistency\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            # Attempt direct goal connection if close enough\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early termination on direct goal connection\n                    break\n\n            # Periodic keyframe and pruning to limit growth & keep responsive\n            if iteration % 40 == 0:\n                self.key_frame()\n                if self._graph.size > self._max_vertices:\n                    self._prune_vertices()\n\n        # If found path, extract and smooth it effectively\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an Improved Heuristic-Based Anytime Sampling Tree (IHAST)\n    algorithm for grid path planning.\n    It combines heuristic-guided sampling inspired by A* with adaptive step size and goal biasing,\n    while maintaining a dynamically rewired tree structure for quality improvement.\n    Key ideas:\n      - Samples are generated using a heuristic distribution that favors points closer to the\n        estimated optimal path (start to goal distances combined).\n      - Adaptive step size is adjusted based on clearance from obstacles and direction smoothness.\n      - A priority-based rewiring next to new vertices attempts local path optimization continuously.\n      - Uses early termination if goal is reached or 10 seconds exceeded.\n      - Implements a shortcutting smoothing step when extracting the path.\n      - This method aims to reduce iterations by focused sampling and improve path smoothness and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._goal_sample_rate = 0.25  # percent chance to sample from goal directly\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Samples points biased by heuristic distribution combining distance from start and to goal.\n        Uses rejection sampling to favor points closer to the optimal heuristic corridor.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_distance = Map.get_distance(Point(0, 0), Point(*size))\n        attempts = 0\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            # Heuristic = dist(start->sample) + dist(sample->goal)\n            h_val = Map.get_distance(agent_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n\n            # Normalize heuristic into [0,1]\n            h_norm = h_val / max_distance\n\n            # Use h_norm as probability threshold (lower h_norm favored)\n            if np.random.rand() < 1.0 - h_norm:\n                return sample_pt\n\n            if attempts > 500:\n                # fallback: return any valid sample to avoid infinite loops\n                return sample_pt\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size scales with clearance in the direction of movement and alignment smoothness.\n        Smaller steps near obstacles or sharp turns.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        # Normalize direction vector to tensor\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Sample distances at intervals along direction to detect obstacle clearance\n        for radius in np.linspace(min_step, max_step, num=6):\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n\n            if not grid.is_agent_valid_pos(sample_point):\n                # Obstacle close, reduce step proportionally\n                return radius * 0.5\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return radius * 0.5\n\n        return max_step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Generate new Vertex stepping towards q_sample from q_near with adaptive step-size check.\n        Returns None if move invalid.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        # Evaluate adaptive step size in that direction\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n\n        step_size = min(step_size, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        # Validate path line sequence\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose lowest cost parent vertex for q_new from q_near_list with a valid collision-free connection.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Attempt local rewiring by connecting neighbors through q_new if it decreases cost.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    # Add new edge\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing tries to connect farther away vertices directly to minimize path length.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path  # Nothing to shortcut\n\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            last_added = shortcut_path[-1]\n            # Try to connect farthest reachable node directly ahead\n            max_reachable_idx = idx + 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = grid.get_line_sequence(last_added.position, path[test_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    max_reachable_idx = test_idx\n                    break\n            shortcut_path.append(path[max_reachable_idx])\n            idx = max_reachable_idx\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Build path from q_new up to start vertex, add goal connection, smooth path,\n        then move the agent along the smoothed path.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Pick minimal cost parent among multiple parents\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        # Smooth via shortcutting\n        smooth_path = self._shortcut_path(path)\n\n        # Trace agent through smoothed path\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n\n            if time.time() - start_time > self._time_limit:\n                # Timeout condition, no solution found within time\n                break\n\n            # Goal biasing: sample goal directly with probability\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample()\n\n            # Find nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step_size(q_near.position, Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor()))\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for parent selection and rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and update cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors through q_new if beneficial\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Check for goal reach with radius consider start with smaller radius threshold\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm implements a hybrid heuristic-guided and incremental graph search approach inspired by A* and PRM. \n    It maintains a cyclic graph and dynamically expands promising vertices prioritized by an estimated total cost (cost-to-come + heuristic).\n    Sampling combines uniform and goal-biased strategies with adaptive step size controlled by environment complexity.\n    Rewiring is done conservatively to maintain graph connectivity and improve local paths without excessive pruning.\n    Early stopping occurs if a path to goal is found with a smooth valid shortcut.\n    The approach focuses on managing an expanding priority queue of frontier vertices, yielding efficiency by directing sampling and expansion;\n    it improves robustness by allowing cyclic connections to revisit vertices and refine path quality over iterations.\n    Path extraction performs shortcut smoothing using multiple shortcut attempts.\n    A 10-second hard timeout enforces maximum planning time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n\n        self._max_max_dist = 12.0      # Max step size for expansion\n        self._min_max_dist = 3.0       # Min step size near goal for finer control\n        self._goal_sample_rate = 0.20  # Goal bias probability during sampling\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10  # Time limit for planning (seconds)\n        self._dimension = 2\n\n        # Priority queue for vertices to expand; items are tuples (priority, vertex)\n        self._queue = []\n\n        # Track best found cost and goal connection vertex\n        self._best_cost = float('inf')\n        self._found_goal_vertex = None\n\n        # For efficient repeated vector operations\n        import heapq\n        import time\n        import torch\n        self._heapq = heapq\n        self._time = time\n        self._torch = torch\n\n        # Initialize priority queue with start vertex with priority = heuristic only\n        start_h = self._heuristic_cost(start_vertex.position, self._get_grid().goal.position)\n        self._heapq.heappush(self._queue, (start_h, start_vertex))\n\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic\n        return Map.get_distance(pos, goal_pos)\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"Adaptive max expansion step size scales down near goal and in dense graphs\"\"\"\n        grid = self._get_grid()\n        dist_to_goal = Map.get_distance(pos, grid.goal.position)\n        max_grid_dim = max(grid.size)\n        dist_norm = min(1.0, max(0.0, dist_to_goal / max_grid_dim))  # Normalize\n        # Shrink step size near goal: linear interpolation min_max_dist when near, max_max_dist far\n        base_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * dist_norm\n        \n        # Further shrink based on number of vertices (denser graph means smaller steps)\n        graph_size = max(1, self._graph.size)\n        size_factor = max(0.1, min(1.0, 200 / graph_size))\n        adapted = base_step * size_factor\n        \n        # Clamp step size reasonably\n        adapted = max(self._min_max_dist, min(self._max_max_dist, adapted))\n        return adapted\n\n    def _goal_biased_sample(self) -> Point:\n        \"\"\"Sample near goal within a radius proportional to min_max_dist\"\"\"\n        grid = self._get_grid()\n        import torch\n\n        radius = self._min_max_dist * 1.5\n        goal_pos = grid.goal.position\n        for _ in range(50):\n            offset_vector = torch.randn(self._dimension)\n            norm_val = torch.norm(offset_vector).item()\n            if norm_val < 1e-8:\n                continue\n            offset_vector /= norm_val\n            offset_vector *= torch.rand(1).item() * radius\n            candidate = Point.from_tensor((goal_pos.to_tensor().float() + offset_vector).round().int())\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n        return goal_pos\n\n    def _uniform_sample(self) -> Point:\n        \"\"\"Uniform random valid sample in the grid.\"\"\"\n        grid = self._get_grid()\n        import torch\n        for _ in range(100):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # Fallback to start if no valid pos found\n        return self._graph.root_vertex_start.position\n\n    def _sample_point(self) -> Point:\n        import torch\n        rand_val = torch.rand(1).item()\n        if rand_val < self._goal_sample_rate:\n            return self._goal_biased_sample()\n        else:\n            return self._uniform_sample()\n\n    def _try_connect(self, parent: Vertex, child_pos: Point) -> 'Vertex | None':\n        \"\"\"\n        Attempts to connect from parent to a new child_pos.\n        Returns the child Vertex if successful, else None.\n        \"\"\"\n        grid = self._get_grid()\n        import torch\n\n        # Adaptive step size for expansion\n        max_dist = self._adaptive_max_dist(parent.position)\n\n        dir_vec = child_pos.to_tensor().float() - parent.position.to_tensor().float()\n        dist = torch.norm(dir_vec).item()\n        if dist == 0 or dist > max_dist + 1e-5:\n            # Too far: clip to max_dist\n            dir_vec /= dist\n            new_pos_tensor = parent.position.to_tensor().float() + dir_vec * max_dist\n            new_pos = Point.from_tensor(new_pos_tensor.round().int())\n        else:\n            new_pos = child_pos\n\n        if not grid.is_agent_valid_pos(new_pos):\n            return None\n\n        line_seq = grid.get_line_sequence(parent.position, new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n\n        # Create new vertex\n        new_vertex = Vertex(new_pos, store_connectivity=True)\n\n        # Cost to reach this new vertex via parent\n        travel_cost = Map.get_distance(parent.position, new_pos)\n        new_vertex.cost = parent.cost + travel_cost\n\n        # Add edge in cyclic graph\n        self._graph.add_edge(parent, new_vertex)\n        return new_vertex\n\n    def _attempt_rewire(self, new_vertex: Vertex, radius: float) -> None:\n        \"\"\"Attempt to rewire neighbors within radius if it improves costs.\"\"\"\n        neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], new_vertex.position, radius)\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == new_vertex:\n                continue\n\n            dist_new_to_neighbor = Map.get_distance(new_vertex.position, neighbor.position)\n            potential_cost = new_vertex.cost + dist_new_to_neighbor\n            if potential_cost + 1e-6 < neighbor.cost:\n                # Check line of sight for rewiring\n                line_seq = grid.get_line_sequence(new_vertex.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove one parent edge (to preserve tree-like edge count)\n                    if neighbor.parents:\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                            break\n                    neighbor.cost = potential_cost\n                    self._graph.add_edge(new_vertex, neighbor)\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        \"\"\"Smooth path by attempting to shortcut edges multiple times.\"\"\"\n        grid = self._get_grid()\n        import random\n        length = len(path)\n        for _ in range(5):\n            i = 0\n            while i < length - 2:\n                j = random.randint(i + 2, length - 1)\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del path[i + 1:j]\n                    length = len(path)\n                else:\n                    i += 1\n        return path\n\n    def _extract_path(self, goal_vertex: Vertex) -> list[Vertex]:\n        \"\"\"Extract path from start to goal.\"\"\"\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            # pick parent with minimal cost (in case of multiple parents)\n            current = min(current.parents, key=lambda v: v.cost)\n        path.reverse()\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        self._found_goal_vertex = None\n\n        start_time = time.time()\n\n        # Main loop: process until queue empty or max iterations/time exceeded\n        iterations = 0\n        while self._queue and iterations < self._max_iterations:\n            # Time check\n            if (time.time() - start_time) > self._time_limit_seconds:\n                # Timeout, no path found within time\n                break\n\n            current_priority, current_vertex = heapq.heappop(self._queue)\n\n            # If current vertex cost plus heuristic is already no better than best found, skip\n            est_total_cost = current_vertex.cost + self._heuristic_cost(current_vertex.position, goal_pos)\n            if est_total_cost > self._best_cost:\n                iterations += 1\n                continue\n\n            # Try to directly connect to goal if close enough\n            dist_to_goal = Map.get_distance(current_vertex.position, goal_pos)\n            adaptive_dist = self._adaptive_max_dist(current_vertex.position)\n\n            if dist_to_goal <= adaptive_dist:\n                line_seq_goal = grid.get_line_sequence(current_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    # Create goal vertex connection\n                    goal_vertex = Vertex(goal_pos, store_connectivity=True)\n                    goal_vertex.cost = current_vertex.cost + dist_to_goal\n                    self._graph.add_edge(current_vertex, goal_vertex)\n\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        self._found_goal_vertex = goal_vertex\n\n                        # Extract and smooth path then move agent\n                        path = self._extract_path(goal_vertex)\n                        path = self._shortcut_path(path)\n                        for v in path:\n                            self.move_agent(v.position)\n                            self.key_frame(ignore_key_frame_skip=True)\n                        return  # Early stop on path found\n\n            # Sampling and expansion guided by heuristic priority\n            new_point = self._sample_point()\n            new_vertex = self._try_connect(current_vertex, new_point)\n            if new_vertex is None:\n                iterations += 1\n                continue\n\n            # Compute priority for new_vertex: cost-to-come + heuristic lookahead\n            heuristic_est = self._heuristic_cost(new_vertex.position, goal_pos)\n            total_priority = new_vertex.cost + heuristic_est\n\n            # Only consider vertices better than current best found\n            if total_priority < self._best_cost:\n                heapq.heappush(self._queue, (total_priority, new_vertex))\n\n            # Rewiring within adaptive radius for improving neighbors\n            # Radius scaled by log(vertex_count)/vertex_count similar to RRT* but conservatively smaller\n            card_v = max(1, self._graph.size)\n            radius = min(20.0, 30.0 * ((torch.log(torch.tensor(float(card_v))).item() + 1) / card_v) ** (1 / self._dimension))\n            self._attempt_rewire(new_vertex, radius)\n\n            iterations += 1\n\n            if iterations % 40 == 0:\n                self.key_frame()\n\n        # If finished without early return but goal found, extract and smooth path\n        if self._found_goal_vertex is not None:\n            path = self._extract_path(self._found_goal_vertex)\n            path = self._shortcut_path(path)\n            for v in path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Heuristic-informed Bi-directional RRT* with Deterministic Sampling and Adaptive Expansion:\n    - Bi-directional growth of trees from start and goal simultaneously to improve connection speed.\n    - Deterministic grid-based quasi-random sampling (Sobol-like uniformity) to improve coverage efficiency.\n    - Heuristic cost (A*-style: g + h) guided selection of expansion roots for focused growth.\n    - Adaptive variable step size max_dist tuned dynamically per expansion based on local clearance and tree size.\n    - Radius-based rewiring in both trees for quality path improvement, pruning redundant vertices.\n    - Early attempt to connect trees by fast local checking to terminate quickly on solution.\n    - Robust path extraction merges both trees and performs shortcut smoothing.\n    - Timeout at 10 seconds to ensure practical responsiveness.\n    This design balances exploration with informed exploitation, reducing iterations and improving path smoothness and completeness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(root_vertex_start=start_vertex, root_vertex_goal=goal_vertex, root_vertices=[start_vertex, goal_vertex])\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10\n        self._dimension = 2\n        self._init_displays()\n        # Additional members for bi-directional sampling control\n        self._bi_directional_toggle = True  # Alternate expansion between start tree and goal tree\n        self._sobol_seq_index = 0\n        self._sobol_seq_limit = 10000\n        self._sobol_direction_vectors = self._generate_sobol_direction_vectors(self._sobol_seq_limit, self._dimension)\n        self._min_step = 3.0\n        self._max_step = 12.0\n        self._rewiring_factor = 30.0\n\n    def _generate_sobol_direction_vectors(self, n: int, dim: int) -> list:\n        # Produces quasi-random uniform samples in unit square [0,1]^dim (simple Halton sequence-like)\n        seq = []\n        base_primes = [2, 3, 5, 7, 11, 13, 17]  # enough for dim <=7\n        def halton(index, base):\n            result = 0.0\n            f = 1.0 / base\n            i = index\n            while i > 0:\n                result += f * (i % base)\n                i //= base\n                f /= base\n            return result\n        for i in range(n):\n            point = tuple(halton(i+1, base_primes[d]) for d in range(dim))\n            seq.append(point)\n        return seq\n\n    def _sobol_sample(self) -> Point:\n        \"\"\"Deterministic quasi-random sampling of valid positions on grid using sobol_direction_vectors.\"\"\"\n        grid = self._get_grid()\n        while self._sobol_seq_index < self._sobol_seq_limit:\n            sample_uv = self._sobol_direction_vectors[self._sobol_seq_index]\n            self._sobol_seq_index += 1\n            # Map from unit cube to grid coordinates (scale)\n            ptr_sample = []\n            valid = True\n            for dim_i in range(self._dimension):\n                val = int(sample_uv[dim_i] * grid.size[dim_i])\n                # Clamp to grid bounds\n                if val < 0:\n                    val = 0\n                elif val >= grid.size[dim_i]:\n                    val = grid.size[dim_i] - 1\n                ptr_sample.append(val)\n            candidate = Point(*ptr_sample)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n        # Fallback to random uniform if sobol exhausted\n        for _ in range(200):\n            import torch\n            sample_coords = [torch.randint(0, grid.size[dim_i], (1,)).item() for dim_i in range(self._dimension)]\n            pt = Point(*sample_coords)\n            if grid.is_agent_valid_pos(pt):\n                return pt\n        return self._graph.root_vertex_start.position\n\n    def _heuristic(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(from_pos, to_pos)\n\n    def _adaptive_step_size(self, pos: Point, target: Point) -> float:\n        # Adaptive step size based on distance and local clearance approximation\n        dist = Map.get_distance(pos, target)\n        ratio = max(0.1, min(1.0, dist / max(self._get_grid().size)))\n        tree_size_factor = max(0.5, min(1.0, 2000 / (self._graph.size + 1)))\n        base_step = self._min_step + (self._max_step - self._min_step) * ratio * tree_size_factor\n        # Check immediate clearance by probing along direction\n        direction_vec = target.to_tensor().float() - pos.to_tensor().float()\n        norm_dir = torch.norm(direction_vec).item()\n        if norm_dir < 1e-6:\n            return self._min_step\n        unit_dir = direction_vec / norm_dir\n        grid = self._get_grid()\n        for alpha in [base_step * f for f in [1.0, 0.75, 0.5, 0.25]]:\n            probe_pos_t = pos.to_tensor().float() + alpha * unit_dir\n            probe_pos = Point.from_tensor((probe_pos_t.round().int()))\n            if not grid.is_agent_valid_pos(probe_pos):\n                base_step = alpha * 0.5\n                break\n            line_check = grid.get_line_sequence(pos, probe_pos)\n            if not grid.is_valid_line_sequence(line_check):\n                base_step = alpha * 0.5\n                break\n        return max(self._min_step, base_step)\n\n    def _steer_towards(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = to_point.to_tensor().float() - from_vertex.position.to_tensor().float()\n        dist = torch.norm(dir_vec).item()\n        if dist < 1e-8:\n            return None\n        if dist <= max_dist:\n            new_pos = to_point\n        else:\n            dir_norm = dir_vec / dist\n            new_pos_t = from_vertex.position.to_tensor().float() + max_dist * dir_norm\n            new_pos = Point.from_tensor(new_pos_t.round().int())\n        grid = self._get_grid()\n        if not grid.is_agent_valid_pos(new_pos):\n            return None\n        line_sequence = grid.get_line_sequence(from_vertex.position, new_pos)\n        if not grid.is_valid_line_sequence(line_sequence):\n            return None\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, neighbors: list, new_vertex: Vertex) -> Optional[Vertex]:\n        grid = self._get_grid()\n        best_cost = float('inf')\n        best_parent = None\n        for v in neighbors:\n            dist = Map.get_distance(v.position, new_vertex.position)\n            line_seq = grid.get_line_sequence(v.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_candidate = v.cost + dist\n            if cost_candidate < best_cost:\n                best_cost = cost_candidate\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list):\n        grid = self._get_grid()\n        for v in neighbors:\n            if v == q_new.parents:\n                continue\n            dist = Map.get_distance(q_new.position, v.position)\n            potential_cost = q_new.cost + dist\n            if potential_cost + 1e-6 < v.cost:\n                line_seq = grid.get_line_sequence(q_new.position, v.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _try_connect_trees(self, v_start: Vertex, v_goal: Vertex, max_connect_dist: float) -> Optional[Vertex]:\n        # Try direct connection between vertices from start and goal trees\n        grid = self._get_grid()\n        dist = Map.get_distance(v_start.position, v_goal.position)\n        if dist > max_connect_dist:\n            return None\n        line_seq = grid.get_line_sequence(v_start.position, v_goal.position)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n        # Create joining vertex at goal side\n        connection_vertex = Vertex(v_goal.position)\n        connection_vertex.cost = v_start.cost + dist\n        self._graph.add_edge(v_start, connection_vertex)\n        return connection_vertex\n\n    def _extract_bidirectional_path_and_smooth(self, meet_vertex: Vertex, meet_vertex_goal_side: Vertex) -> None:\n        # Extract path from start tree root to meet vertex\n        path_start = []\n        curr = meet_vertex\n        while curr.parents:\n            path_start.append(curr)\n            curr = next(iter(curr.parents))\n        path_start.append(curr)\n        path_start.reverse()\n\n        # Extract path from goal tree root to meet vertex on goal side\n        path_goal = []\n        curr = meet_vertex_goal_side\n        while curr.parents:\n            path_goal.append(curr)\n            curr = next(iter(curr.parents))\n        path_goal.append(curr)\n\n        # Combine start path + reversed goal path (excluding duplicated meeting vertex)\n        full_path = path_start + path_goal[-2::-1]\n\n        grid = self._get_grid()\n\n        # Multi-pass shortcut smoothing with attempts to reduce vertex count\n        passes = 3\n        for _ in range(passes):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                shortcut_done = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i + 1:j]\n                        shortcut_done = True\n                        j = i + 1\n                    else:\n                        j -= 1\n                if not shortcut_done:\n                    i += 1\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        found_meeting = None\n        found_meeting_goal_side = None\n\n        start_time = time.time()\n\n        # Initialize trees with root vertices\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > self._time_limit_seconds:\n                break\n\n            # Alternate expansion direction: True->expand start tree, False->goal tree\n            expand_start_tree = self._bi_directional_toggle\n            self._bi_directional_toggle = not self._bi_directional_toggle\n\n            # Select expansion tree roots and other tree vertices for connection attempts\n            if expand_start_tree:\n                root_vertices = tree_start_vertices\n                other_tree_vertices = tree_goal_vertices\n                goal_pos = goal_vertex.position\n            else:\n                root_vertices = tree_goal_vertices\n                other_tree_vertices = tree_start_vertices\n                goal_pos = start_vertex.position\n\n            # Sampling using deterministic Sobol quasi-random method with goal bias\n            rand_val = torch.rand(1).item()\n            if rand_val < 0.15:\n                sample_point = goal_pos\n            else:\n                sample_point = self._sobol_sample()\n\n            # Select vertex in current direction tree with lowest heuristic + cost sum towards sample\n            def score_func(v: Vertex) -> float:\n                return v.cost + self._heuristic(v.position, sample_point)\n            q_near = min(root_vertices, key=score_func)\n\n            max_dist = self._adaptive_step_size(q_near.position, sample_point)\n\n            q_new = self._steer_towards(q_near, sample_point, max_dist)\n            if q_new is None:\n                # Failed to create valid new vertex; continue next iteration\n                self.key_frame()\n                continue\n\n            # Find neighbors in expansion tree for rewiring\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._rewiring_factor * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n            neighbors = self._graph.get_vertices_within_radius(root_vertices, q_new.position, radius)\n\n            parent = self._choose_best_parent(neighbors, q_new)\n            if parent is None:\n                parent = q_near\n\n            q_new.cost = parent.cost + Map.get_distance(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors to improve path cost\n            neighbors = [v for v in neighbors if v != parent]\n            self._rewire(q_new, neighbors)\n\n            # Add new vertex to appropriate tree vertex list\n            if expand_start_tree:\n                tree_start_vertices.append(q_new)\n            else:\n                tree_goal_vertices.append(q_new)\n\n            # Try connect to other tree vertices within max_dist radius\n            other_neighbors = self._graph.get_vertices_within_radius(other_tree_vertices, q_new.position, max_dist)\n            connect_candidates = []\n            grid_valid = True\n            best_connection_cost = float('inf')\n            best_start_vertex = None\n            best_goal_vertex = None\n\n            for ote_v in other_neighbors:\n                dist = Map.get_distance(q_new.position, ote_v.position)\n                if dist > max_dist:\n                    continue\n                line_seq = grid.get_line_sequence(q_new.position, ote_v.position)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                connection_cost = q_new.cost + dist + ote_v.cost\n                if connection_cost < best_connection_cost:\n                    best_connection_cost = connection_cost\n                    best_start_vertex = q_new if expand_start_tree else ote_v\n                    best_goal_vertex = ote_v if expand_start_tree else q_new\n\n            if best_start_vertex is not None and best_goal_vertex is not None:\n                # Connection found: build meeting vertices and finish search\n                found_meeting = best_start_vertex\n                found_meeting_goal_side = best_goal_vertex\n                break\n\n            # Mark key frame periodically every 20 iterations\n            if iteration % 20 == 0:\n                self.key_frame()\n\n        if found_meeting is not None and found_meeting_goal_side is not None:\n            # Extract path and smooth before tracing\n            self._extract_bidirectional_path_and_smooth(found_meeting, found_meeting_goal_side)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Incremental Graph Search with Bidirectional Tree Growing, Adaptive Step Control,\n    and Vertex Prioritization by Heuristic+Cost Ordering for Efficient, Robust, and High-Quality Paths.\n\n    Algorithm Features:\n    - Bidirectional sampling and expansion from start and goal simultaneously to improve connection speed.\n    - Vertex priority queue ordered by f = cost + heuristic guides expansions toward promising vertices.\n    - Adaptive step size tuned by local clearance and distance-to-goal for balanced exploration/refinement.\n    - Lazy collision-checking combined with caching of validation results for efficiency.\n    - Rewiring inspired by RRT* within neighborhood radius for path quality improvement.\n    - Early termination on connecting the two trees with shortcut checks.\n    - Path extracted from connected graph and smoothed by iterative shortcutting.\n    - Global timeout of 10 seconds to ensure responsiveness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 20.0\n        self._min_max_dist = 2.0\n        self._goal_sample_rate = 0.15\n        self._bidirectional_sample_rate = 0.3  # chance to sample near opposite tree root\n        self._max_iterations = 3000\n        self._lambda_rrt_star = 35\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_threshold = 2.5\n        self._collision_cache = dict()  # cache line validity to avoid redundant checks\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_check = 10.0\n        min_dist = max_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0] - 1 - x, grid.size[1] - 1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        norm_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        size_factor = min(1.0, 700 / (self._graph.size + 1))\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n        base_dist = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * norm_dist * clearance_factor * size_factor\n        return max(self._min_max_dist, min(base_dist, self._max_max_dist))\n\n    def _heuristic(self, pos: Point, goal: Point) -> float:\n        return Map.get_distance(pos, goal)\n\n    def _cache_collision_check(self, line_seq: tuple) -> bool:\n        # line_seq is tuple of Points\n        if line_seq in self._collision_cache:\n            return self._collision_cache[line_seq]\n        grid = self._get_grid()\n        valid = grid.is_valid_line_sequence(list(line_seq))\n        self._collision_cache[line_seq] = valid\n        return valid\n\n    def _lazy_edge_collision(self, start: Vertex, end: Vertex) -> bool:\n        # Check cached line validity or update cache\n        grid = self._get_grid()\n        line_seq = tuple(grid.get_line_sequence(start.position, end.position))\n        return self._cache_collision_check(line_seq)\n\n    def _get_nearest_vertex_with_priority(self, vertices: list, point: Point):\n        # Pick vertex minimizing cost + heuristic + dist-from-point as tie breaker (efficient)\n        import torch\n        best_vertex = None\n        best_value = float('inf')\n        point_tensor = point.to_tensor().float()\n        for v in vertices:\n            h = self._heuristic(v.position, point)\n            v_pos_tensor = v.position.to_tensor().float()\n            dist_to_sample = torch.norm(v_pos_tensor - point_tensor).item()\n            val = v.cost + h + 0.5 * dist_to_sample\n            if val < best_value:\n                best_value = val\n                best_vertex = v\n        return best_vertex\n\n    def _extract_path(self, goal_vertex: Vertex) -> list:\n        # Extract path parent chain from either root to root\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n        return path\n\n    def _shortcut_path(self, path: list) -> list:\n        grid = self._get_grid()\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = tuple(grid.get_line_sequence(path[i].position, path[j].position))\n                    if self._cache_collision_check(line_seq):\n                        del path[i + 1:j]\n                        improved = True\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        import heapq\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n\n        self._best_cost = float('inf')\n        self._collision_cache = dict()\n        self._start_time = time.time()\n\n        # Bidirectional trees: maintain two sets of vertices\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        # Priority queues for expansions with (cost+heuristic, vertex)\n        pq_start = []\n        heapq.heappush(pq_start, (start_vertex.cost + self._heuristic(start_vertex.position, goal_pos), start_vertex))\n        pq_goal = []\n        heapq.heappush(pq_goal, (goal_vertex.cost + self._heuristic(goal_vertex.position, start_vertex.position), goal_vertex))\n\n        connected_vertex_start = None\n        connected_vertex_goal = None\n\n        def try_connect_trees(v_start, v_goal):\n            # Try direct connection with collision checking\n            line_seq = tuple(grid.get_line_sequence(v_start.position, v_goal.position))\n            if self._cache_collision_check(line_seq):\n                return True\n            return False\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Timeout: abort planning\n                return\n\n            # Alternate expansions start and goal\n            expand_start = (iteration % 2 == 1)\n\n            active_tree = tree_start if expand_start else tree_goal\n            pq_active = pq_start if expand_start else pq_goal\n            other_tree = tree_goal if expand_start else tree_start\n\n            if not pq_active:\n                # No vertices to expand that direction, fail early\n                break\n\n            f_val, v_expand = heapq.heappop(pq_active)\n            if v_expand not in active_tree:\n                # Might have been removed by rewiring or duplicate, continue\n                continue\n\n            # Sample: goal bias mixed with uniform and bias to opposite tree root vicinity\n            prob = torch.rand(1).item()\n            if prob < self._goal_sample_rate:\n                # sample near opposite root to promote connection\n                opposite_root = other_tree[0].position\n                for _ in range(30):\n                    offset = torch.randn(self._dimension)\n                    norm = torch.norm(offset).item()\n                    if norm < 1e-8:\n                        continue\n                    offset /= norm\n                    length = torch.rand(1).item() * self._min_max_dist * 2\n                    sample_pos_tensor = opposite_root.to_tensor().float() + offset * length\n                    sample_pos = Point.from_tensor(sample_pos_tensor.round().int())\n                    if grid.is_agent_valid_pos(sample_pos):\n                        q_sample = sample_pos\n                        break\n                else:\n                    q_sample = opposite_root\n            elif prob < self._goal_sample_rate + self._bidirectional_sample_rate:\n                # sample near v_expand for local refinement\n                base_pos = v_expand.position\n                for _ in range(30):\n                    offset = torch.randn(self._dimension)\n                    norm = torch.norm(offset).item()\n                    if norm < 1e-8:\n                        continue\n                    offset /= norm\n                    length = torch.rand(1).item() * self._adaptive_max_dist(base_pos)\n                    sample_pos_tensor = base_pos.to_tensor().float() + offset * length\n                    sample_pos = Point.from_tensor(sample_pos_tensor.round().int())\n                    if grid.is_agent_valid_pos(sample_pos):\n                        q_sample = sample_pos\n                        break\n                else:\n                    q_sample = base_pos\n            else:\n                # uniform random sample\n                for _ in range(50):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    sample_pos = Point(*coords)\n                    if grid.is_agent_valid_pos(sample_pos):\n                        q_sample = sample_pos\n                        break\n                else:\n                    q_sample = v_expand.position\n\n            # Find nearest vertex in active tree to q_sample minimizing cost+heuristic+dist\n            q_nearest = self._get_nearest_vertex_with_priority(active_tree, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_nearest.position)\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                q_new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = tuple(grid.get_line_sequence(q_nearest.position, q_new_pos))\n            if not self._cache_collision_check(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            cost_to_new = q_nearest.cost + Map.get_distance(q_nearest.position, q_new_pos)\n            q_new.cost = cost_to_new\n\n            # Rewiring radius with logarithmic growth factor\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n\n            # Find neighbors in active tree within radius\n            near_vertices = self._graph.get_vertices_within_radius(active_tree, q_new.position, radius)\n\n            # Choose best parent among neighbors for minimal cost + collision free\n            q_min = q_nearest\n            c_min = cost_to_new\n            for v_near in near_vertices:\n                dist_to_new = Map.get_distance(v_near.position, q_new.position)\n                candidate_cost = v_near.cost + dist_to_new\n                if candidate_cost + 1e-8 < c_min:\n                    cand_line = tuple(grid.get_line_sequence(v_near.position, q_new.position))\n                    if self._cache_collision_check(cand_line):\n                        q_min = v_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n            active_tree.append(q_new)\n            heapq.heappush(pq_active, (q_new.cost + self._heuristic(q_new.position, goal_pos if expand_start else start_vertex.position), q_new))\n\n            # Rewire neighbors to q_new if better cost and collision free\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = Map.get_distance(q_new.position, v_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + 1e-5 < v_near.cost:\n                    rew_line = tuple(grid.get_line_sequence(q_new.position, v_near.position))\n                    if self._cache_collision_check(rew_line):\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            # Attempt connect opposite tree vertices near q_new within radius\n            connect_candidates = []\n            for v_other in self._graph.get_vertices_within_radius(other_tree, q_new.position, radius):\n                if self._lazy_edge_collision(q_new, v_other):\n                    cost_total = q_new.cost + Map.get_distance(q_new.position, v_other.position) + v_other.cost\n                    if cost_total < self._best_cost:\n                        connect_candidates.append((cost_total, q_new, v_other))\n\n            if connect_candidates:\n                # Pick best connection candidate\n                connect_candidates.sort(key=lambda x: x[0])\n                best_cost, best_from, best_to = connect_candidates[0]\n                self._best_cost = best_cost\n                connected_vertex_start = best_from if expand_start else best_to\n                connected_vertex_goal = best_to if expand_start else best_from\n                break\n\n            # Occasionally add key frame\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if connected_vertex_start is not None and connected_vertex_goal is not None:\n            # Construct connected root by linking connecting vertices and extract path\n            # Break parents of goal side to form a unified path\n            for p in list(connected_vertex_goal.parents):\n                self._graph.remove_edge(p, connected_vertex_goal)\n            self._graph.add_edge(connected_vertex_start, connected_vertex_goal)\n\n            # Extract path from start root to goal end vertex\n            raw_path = self._extract_path(connected_vertex_goal)\n            smooth_path = self._shortcut_path(raw_path)\n\n            for v in smooth_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm introduces a hybrid heuristic-tree approach inspired by both RRT-star and A*-informed search,\n    designed to improve planning efficiency, path quality, robustness, and success rate.\n\n    Key innovations:\n    - Dual graph tracking: maintains a growing exploration tree (Forest) combined with a priority queue-driven\n      best-first search over vertices to prioritize expansions based on estimated full path cost (cost-so-far + heuristic).\n    - Adaptive step size tuned dynamically by both clearance and heuristic distance to goal, allowing flexible zoom-in/out.\n    - Sampling combines goal bias and clearance-aware uniform sampling to balance exploitation and safe exploration.\n    - Lazy collision checking: line sequence validity is deferred until a promising expansion is found to reduce overhead.\n    - Rewiring with cost-improvement pruning, but only applied when improvement exceeds a dynamic threshold scaled to current best cost.\n    - Early stopping triggered immediately upon discovering a path improving over best known cost, and final path smoothing.\n    - Timeout enforced after 10 seconds to ensure practical responsiveness.\n    - Path extraction uses graph-parent pointers with post-processing shortcut smoothing for high-quality output.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Parameters blending previous insights\n        self._goal_sample_rate = 0.25\n        self._clearance_threshold = 2.5\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._min_step = 2.0\n        self._max_step = 15.0\n        self._rewire_lambda = 30.0  # radius scaling factor for neighborhood rewiring\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_clearance_check = 12.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _clearance_aware_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        for _ in range(120):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n        prob = torch.rand(1).item()\n        if prob < self._goal_sample_rate:\n            # goal biased with small random offset inside goal radius\n            goal_pos = grid.goal.position\n            for _ in range(30):\n                offset = torch.randint(-2, 3, (self._dimension,))\n                candidate = Point(goal_pos.x + offset[0].item(), goal_pos.y + offset[1].item())\n                if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                    return candidate\n            return goal_pos\n        else:\n            # clearance-aware uniform sample\n            return self._clearance_aware_sample()\n\n    def _adaptive_step_size(self, pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        norm_dist = min(1.0, dist_to_goal / max(grid.size))\n\n        tree_size = max(self._graph.size, 1)\n        tree_factor = min(1.0, 500.0 / tree_size)\n\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n\n        step = self._min_step + (self._max_step - self._min_step) * norm_dist * tree_factor * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _heuristic(self, pos: Point) -> float:\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n        self._start_time = time.time()\n\n        # Priority queue for best-first expansion: (estimated_total_cost, vertex)\n        open_queue = []\n        # Init with start vertex: cost_so_far + heuristic\n        heapq.heappush(open_queue, (self._heuristic(start_vertex.position), start_vertex))\n\n        # We'll store a lookup for vertices by position for quick prune/add\n        vertex_map = {start_vertex.position: start_vertex}\n\n        iterations = 0\n        while iterations < self._max_iterations:\n            if time.time() - self._start_time > self._time_limit_seconds:\n                break\n\n            if not open_queue:\n                # No vertices to expand => failure to find path\n                break\n\n            est_tot_cost, current_v = heapq.heappop(open_queue)\n            iterations += 1\n\n            # Sample a new point biased by heuristics and clearance-aware sample\n            q_sample = self._get_random_sample()\n\n            # Adaptive step towards sample from current vertex\n            max_step = self._adaptive_step_size(current_v.position)\n            dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_norm = dir_vec / dist\n            step_length = min(dist, max_step)\n            new_pos_tensor = torch.round(torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == current_v.position:\n                continue\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Lazy collision checking: only check edge if promising cost\n            # Check if q_new_pos is already in graph: skip duplicates\n            if q_new_pos in vertex_map:\n                continue\n\n            # Validate line sequence between current and q_new\n            line_seq = grid.get_line_sequence(current_v.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n            cost_to_q_new = current_v.cost + move_cost\n            q_new_vertex.cost = cost_to_q_new\n\n            # Neighborhood radius for rewiring, adapt with clearance and iteration\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._rewire_lambda * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n            clearance_factor = 1.0 + min(self._get_clearance(q_new_pos) / (self._clearance_threshold * 2.0), 1.0)\n            radius *= clearance_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Among neighbors pick parent with minimum cost + heuristic if connection valid\n            best_parent = current_v\n            best_cost = cost_to_q_new\n            for neighbor in near_vertices:\n                candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                if candidate_cost < best_cost - 1e-5:\n                    # Validate edge before choosing parent\n                    line_seq_candidate = grid.get_line_sequence(neighbor.position, q_new_pos)\n                    if not grid.is_valid_line_sequence(line_seq_candidate):\n                        continue\n                    best_cost = candidate_cost\n                    best_parent = neighbor\n\n            q_new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, q_new_vertex)\n            vertex_map[q_new_pos] = q_new_vertex\n\n            # Rewiring neighbors to q_new if improved cost and valid\n            cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost< float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                new_cost_via_qnew = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                if new_cost_via_qnew + cost_improve_thresh < neighbor.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove existing parent edges\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost_via_qnew\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            # Push q_new_vertex into priority queue with estimated total cost heuristic\n            est_total_cost = q_new_vertex.cost + self._heuristic(q_new_vertex.position)\n            heapq.heappush(open_queue, (est_total_cost, q_new_vertex))\n\n            # Check for goal reach with adaptive radius (using step size)\n            dist_to_goal = Map.get_distance(q_new_vertex.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_to_goal = grid.get_line_sequence(q_new_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new_vertex.cost + dist_to_goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        found_goal_vertex = goal_vertex\n\n                    # Early termination with path smoothing\n                    break\n\n            # Periodic key frame for visualizations or debugging\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            # Extract path from found goal to root\n            path = []\n            curr = found_goal_vertex\n            while True:\n                path.append(curr)\n                if len(curr.parents) == 0:\n                    break\n                # Choose minimum cost parent to backtrack path\n                curr = min(curr.parents, key=lambda p: p.cost)\n            path.reverse()\n\n            # Path shortcut smoothing: multiple passes trying to remove intermediate vertices\n            for _ in range(3):\n                i = 0\n                while i < len(path) - 2:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(path[i].position, path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            del path[i+1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n            for v in path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a hybrid Adaptive Bidirectional RRT* with heuristic pruning and dynamic step adjustment.\n    Key ideas: \n    - Bidirectional growth: Trees grow simultaneously from start and goal to reduce search space.\n    - Adaptive step size based on local clearance and distance to connection tree frontier for efficient exploration.\n    - Heuristic-guided pruning: Uses admissible heuristic (Euclidean + cost) to prune expansions unlikely to improve path.\n    - Rewiring within dynamically computed radius incorporating clearance for path cost improvement.\n    - Failsafe goal bias sampling only on start tree, combined with uniform sampling in overall environment with clearance awareness.\n    - Early termination triggered upon successful connection between the two trees.\n    - Post-connection: robust shortcut smoothing is applied to finalized path.\n    - Enforces 10-second timeout as planning limit.\n    This approach aims at better exploration efficiency, higher success, and smoother optimal paths by leveraging bidirectional search, adaptive parameters, and heuristic pruning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        self._best_cost = float('inf')\n        found_connection = None\n        trees = {\n            \"start\": [start_vertex],\n            \"goal\": [goal_vertex]\n        }\n\n        self._start_time = getattr(self, '_start_time', None)\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        MAX_ITERATIONS = 3000\n        DIMENSION = 2\n        LAMBDA_RRT_STAR = 40\n        CLEARANCE_THRESHOLD = 3\n        REWIRE_THRESHOLD = 0.005\n        MAX_STEP_SIZE = 15.0\n        MIN_STEP_SIZE = 2.0\n        MAX_RADIUS = 25.0\n\n        def get_clearance(point: Point) -> float:\n            max_check = 10.0\n            min_dist = max_check\n            for obs in grid.obstacles:\n                dist = Map.get_distance(point, obs.position) - obs.radius\n                if dist < min_dist:\n                    min_dist = dist\n            x, y = point.x, point.y\n            boundary_clearance = min(x, y, grid.size[0] - 1 - x, grid.size[1] - 1 - y)\n            return max(0.0, min(min_dist, boundary_clearance))\n\n        def adaptive_step_size(q_pos: Point) -> float:\n            goal_pos = grid.goal.position\n            dist_goal = Map.get_distance(q_pos, goal_pos)\n            norm_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n            tree_size_factor = min(1.0, 700 / (self._graph.size + 1))\n            clearance = get_clearance(q_pos)\n            clearance_factor = min(1.0, clearance / (CLEARANCE_THRESHOLD * 2.0))\n            step = (MIN_STEP_SIZE + (MAX_STEP_SIZE - MIN_STEP_SIZE) * norm_dist * tree_size_factor * clearance_factor)\n            return max(MIN_STEP_SIZE, min(step, MAX_STEP_SIZE))\n\n        def heuristic_cost(pos1: Point, pos2: Point) -> float:\n            return Map.get_distance(pos1, pos2)\n\n        def choose_parent(vertices, new_pos):\n            c_min = float('inf')\n            q_min = None\n            for v in vertices:\n                dist_to_new = Map.get_distance(v.position, new_pos)\n                cost_candidate = v.cost + dist_to_new\n                line_seq = grid.get_line_sequence(v.position, new_pos)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq):\n                    c_min = cost_candidate\n                    q_min = v\n            return q_min, c_min\n\n        def rewire_near_vertices(q_new: Vertex, near_vertices: list):\n            for v_near in near_vertices:\n                if v_near == q_new:\n                    continue\n                dist_new_to_near = Map.get_distance(q_new.position, v_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + REWIRE_THRESHOLD < v_near.cost:\n                    line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove old parent edges (single parent)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n        def sample_from_start_tree() -> Point:\n            # Biased sampling: 25% goal bias, 10% clearance-aware, rest pure uniform clearance-aware\n            r = torch.rand(1).item()\n            if r < 0.25:\n                return grid.goal.position\n            elif r < 0.35:\n                # clearance aware sample\n                for _ in range(30):\n                    sample = Point(*[torch.randint(0, grid.size[d], (1,)).item() for d in range(DIMENSION)])\n                    if grid.is_agent_valid_pos(sample) and get_clearance(sample) >= CLEARANCE_THRESHOLD:\n                        return sample\n                return start_vertex.position\n            else:\n                # uniform clearance aware fallback by rejection\n                for _ in range(50):\n                    sample = Point(*[torch.randint(0, grid.size[d], (1,)).item() for d in range(DIMENSION)])\n                    if grid.is_agent_valid_pos(sample) and get_clearance(sample) >= CLEARANCE_THRESHOLD:\n                        return sample\n                return start_vertex.position\n\n        def sample_uniform():\n            # Uniform sampling with clearance awareness for goal tree growth\n            for _ in range(50):\n                sample = Point(*[torch.randint(0, grid.size[d], (1,)).item() for d in range(DIMENSION)])\n                if grid.is_agent_valid_pos(sample) and get_clearance(sample) >= CLEARANCE_THRESHOLD:\n                    return sample\n            return goal_vertex.position\n\n        def connect_vertices(v_from: Vertex, v_to: Vertex):\n            # Check validity and cost\n            line_seq = grid.get_line_sequence(v_from.position, v_to.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                return False\n            dist = Map.get_distance(v_from.position, v_to.position)\n            cost_candidate = v_from.cost + dist\n            if cost_candidate < v_to.cost:\n                # Remove old parents if any (single-parent structure)\n                for p in list(v_to.parents):\n                    self._graph.remove_edge(p, v_to)\n                    break\n                v_to.cost = cost_candidate\n                self._graph.add_edge(v_from, v_to)\n                return True\n            return False\n\n        def extract_bidirectional_path(v_start: Vertex, v_goal: Vertex) -> None:\n            # Extract path from start root to v_start\n            path_start = []\n            current = v_start\n            while True:\n                path_start.append(current)\n                if not current.parents:\n                    break\n                current = next(iter(current.parents))\n            path_start.reverse()\n\n            # Extract path from goal root to v_goal\n            path_goal = []\n            current = v_goal\n            while True:\n                path_goal.append(current)\n                if not current.parents:\n                    break\n                current = next(iter(current.parents))\n\n            # Combine paths (start to connection vertex + reversed goal tree path)\n            full_path = path_start + path_goal\n\n            # Shortcut smoothing\n            for _ in range(3):\n                i = 0\n                while i < len(full_path) - 2:\n                    j = len(full_path) - 1\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            del full_path[i+1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n            for v in full_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        # Initialize costs\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        for iteration in range(MAX_ITERATIONS):\n            # Check time limit 10s\n            if (time.time() - self._start_time) > 10:\n                # No path found within time limit\n                return\n\n            # Alternate tree growth: even iterations grow start tree, odd grow goal tree\n            grow_from_start = (iteration % 2 == 0)\n\n            if grow_from_start:\n                q_sample = sample_from_start_tree()\n                tree_label = \"start\"\n                other_label = \"goal\"\n                current_roots = trees[tree_label]\n                other_roots = trees[other_label]\n            else:\n                q_sample = sample_uniform()\n                tree_label = \"goal\"\n                other_label = \"start\"\n                current_roots = trees[tree_label]\n                other_roots = trees[other_label]\n\n            # Find nearest vertex in current tree\n            q_nearest = self._graph.get_nearest_vertex(current_roots, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            step_size = adaptive_step_size(q_nearest.position)\n\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= step_size:\n                q_new_pos = q_sample\n            else:\n                q_new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_vec / dist * step_size).round().int()\n                q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Get vertices within rewiring radius\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            base_radius = min(LAMBDA_RRT_STAR * ((ln_size / size) ** (1 / DIMENSION)), MAX_RADIUS)\n            clearance_new = get_clearance(q_new.position)\n            radius = base_radius * (1.0 + min(clearance_new / CLEARANCE_THRESHOLD, 1.0))\n\n            near_vertices = self._graph.get_vertices_within_radius(current_roots, q_new.position, radius)\n            # Guarantee q_nearest in near_vertices if missing\n            if q_nearest not in near_vertices:\n                near_vertices.append(q_nearest)\n\n            # Choose parent that gives minimum cost\n            q_min, c_min = choose_parent(near_vertices, q_new.position)\n            if q_min is None:\n                continue\n\n            q_new.cost = c_min\n\n            self._graph.add_edge(q_min, q_new)\n            current_roots.append(q_new)\n\n            # Rewire neighbors for better paths\n            rewire_near_vertices(q_new, near_vertices)\n\n            # Attempt connection to other tree\n            # Find nearest vertex from q_new to other tree\n            q_other_nearest = self._graph.get_nearest_vertex(other_roots, q_new.position)\n            dist_q_to_other = Map.get_distance(q_new.position, q_other_nearest.position)\n            if dist_q_to_other <= radius:\n                # Check connection line validity\n                line_seq_connect = grid.get_line_sequence(q_new.position, q_other_nearest.position)\n                if grid.is_valid_line_sequence(line_seq_connect):\n                    # Connect trees by adding edge from q_new->q_other_nearest if growing from start\n                    # or q_other_nearest->q_new if growing from goal\n                    if grow_from_start:\n                        # Only add edge if cost improves\n                        connected = connect_vertices(q_new, q_other_nearest)\n                        connection_pair = (q_new, q_other_nearest)\n                    else:\n                        connected = connect_vertices(q_other_nearest, q_new)\n                        connection_pair = (q_other_nearest, q_new)\n\n                    if connected:\n                        cost_candidate = connection_pair[0].cost + Map.get_distance(connection_pair[0].position,\n                                                                                   connection_pair[1].position) + connection_pair[1].cost\n                        if cost_candidate < self._best_cost:\n                            self._best_cost = cost_candidate\n                            found_connection = connection_pair\n\n                            # Early termination\n                            break\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if found_connection is not None:\n            # Extract full path from root start to root goal via connection\n            start_connect_vertex, goal_connect_vertex = found_connection\n            extract_bidirectional_path(start_connect_vertex, goal_connect_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Guided Frontier Tree (HGFT) Algorithm for Grid Path Planning:\n    This algorithm maintains and incrementally expands multiple frontier vertices chosen by a combined criterion of heuristic priority and frontier exploration exposure.\n    It uses a frontier queue sorted by a hybrid cost: actual traveled cost plus heuristic to the goal plus an exploration bonus for vertices less expanded. \n    Sampling is local around frontier vertices with adaptive radius to balance global exploration and local refinement.\n    Adaptive step size depends on clearance and progress, avoiding obstacles and shrinking near the goal region.\n    Tree rewiring is selectively applied within a dynamic neighborhood to improve paths but limit overhead.\n    The algorithm aggressively prunes stale frontier vertices with no successful expansion attempts to improve efficiency.\n    Early stopping triggers on direct goal connection or time exhaustion.\n    Final path extraction applies repeated shortcutting and smoothing.\n    This approach targets more targeted expansion via prioritized frontier vertices, improving planning efficiency, reducing iterations, and increasing robust success rate with quality paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Extended parameters initialized here:\n        self._time_limit = 10.0\n        self._max_iterations = 5000\n        self._goal_sample_rate = 0.2\n        self._exploration_bonus_weight = 5.0  # Weight for exploration exposure bonus\n        self._frontier_expand_radius = 8.0\n        self._rewire_radius_factor = 20.0  # scaling factor for rewiring radius\n        self._min_step_size = 2.0\n        self._max_step_size = 12.0\n        self._prune_attempt_limit = 5  # prune frontier vertices after X failed expansions\n\n        # Aux data keys in vertex aux:\n        # .aux['expansion_failures']: counts consecutive failed expansions\n        # .aux['frontier_count']: how many times vertex is used as frontier\n\n    def _compute_hybrid_priority(self, vertex: Vertex) -> float:\n        \"\"\"\n        Compute priority for picking frontier vertex.\n        Combines cost, heuristic, and exploration bonus.\n        Lower value = higher priority.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        heuristic = Map.get_distance(vertex.position, goal_pos)\n        cost = vertex.cost\n        exploration_bonus = (\n            self._exploration_bonus_weight / (1 + vertex.aux.get(\"frontier_count\", 0))\n        )\n        return cost + heuristic - exploration_bonus\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size based on clearance and alignment.\n        Shrinks near obstacles or sharp changes.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step_size\n        max_step = self._max_step_size\n\n        import torch\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm < 1e-8:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Check clearance along direction at discrete intervals to adjust step size\n        for step_fraction in [1.0, 0.75, 0.5, 0.3]:\n            radius = max_step * step_fraction\n            sample_pos_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_pos_tensor.round().int())\n            if not grid.is_agent_valid_pos(sample_point):\n                return max(min_step, radius * 0.5)\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return max(min_step, radius * 0.5)\n\n        return max_step\n\n    def _local_sample_around(self, center: Point, radius: float) -> Point:\n        \"\"\"\n        Sample valid point uniformly within a radius around center.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        dimension = len(grid.size)\n\n        for _ in range(40):\n            offset = (\n                torch.randn(dimension).float()\n                * radius\n            )  # Gaussian distributed offset\n            candidate_tensor = center.to_tensor().float() + offset\n            candidate_point = Point.from_tensor(candidate_tensor.round().int())\n            if grid.is_agent_valid_pos(candidate_point):\n                return candidate_point\n        return center\n\n    def _choose_parent_among(self, neighbors: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose best parent with minimal path cost through a valid collision-free edge.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float(\"inf\")\n        chosen_parent = None\n        for nbr in neighbors:\n            cost_through = nbr.cost + grid.get_movement_cost(nbr.position, q_new.position)\n            if cost_through < min_cost:\n                line_seq = grid.get_line_sequence(nbr.position, q_new.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    min_cost = cost_through\n                    chosen_parent = nbr\n        return chosen_parent\n\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewire neighbor vertices through q_new if it improves path cost.\n        \"\"\"\n        grid = self._get_grid()\n        for nbr in neighbors:\n            if q_new in nbr.parents:\n                continue\n            current_cost = nbr.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, nbr.position)\n            if potential_cost + 1e-6 < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, nbr.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for p in list(nbr.parents):\n                        self._graph.remove_edge(p, nbr)\n                    self._graph.add_edge(q_new, nbr)\n                    nbr.cost = potential_cost\n\n    def _extract_and_smooth_path(self, q_goal_parent: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal and shortcut with multiple passes.\n        Move agent along the path.\n        \"\"\"\n        grid = self._get_grid()\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Multiple shortcut passes for smoothing\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1 : j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        start_vertex.cost = 0.0\n        self._graph.root_vertex_goal.cost = float(\"inf\")\n        frontier_vertices = {start_vertex}  # Set of frontier vertices being expanded\n        iteration = 0\n\n        start_time = time.time()\n\n        # Dictionary to track expansion failures for pruning\n        expansion_failures = {}\n\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            if (time.time() - start_time) > self._time_limit:\n                # Timeout without success\n                break\n\n            if len(frontier_vertices) == 0:\n                # No frontier left to expand\n                break\n\n            # Pick frontier vertex with lowest hybrid priority\n            front_list = list(frontier_vertices)\n            priorities = [self._compute_hybrid_priority(v) for v in front_list]\n            min_idx = min(range(len(priorities)), key=lambda i: priorities[i])\n            q_front = front_list[min_idx]\n\n            # Increase frontier count to reduce over-exploring same vertex\n            q_front.aux[\"frontier_count\"] = q_front.aux.get(\"frontier_count\", 0) + 1\n\n            # Sampling radius shrinks as cost grows (more refinement near goal)\n            adaptation_ratio = min(1.0, q_front.cost / (Map.get_distance(start_vertex.position, goal_pos) + 1e-8))\n            local_sample_radius = max(\n                self._min_step_size,\n                self._frontier_expand_radius * (1.0 - adaptation_ratio),\n            )\n\n            # Sample locally around chosen frontier vertex\n            q_sample = self._local_sample_around(q_front.position, local_sample_radius)\n\n            if q_sample == q_front.position:\n                # Fail counts increment & possible pruning\n                expansion_failures[q_front] = expansion_failures.get(q_front, 0) + 1\n                if expansion_failures[q_front] >= self._prune_attempt_limit:\n                    frontier_vertices.discard(q_front)\n                continue\n\n            # Compute movement direction vector and adaptive step size\n            dir_vec = q_sample.to_tensor().float() - q_front.position.to_tensor().float()\n            dir_tensor = torch.tensor(dir_vec)\n            norm_dir = torch.norm(dir_tensor).item()\n            if norm_dir < 1e-8:\n                expansion_failures[q_front] = expansion_failures.get(q_front, 0) + 1\n                if expansion_failures[q_front] >= self._prune_attempt_limit:\n                    frontier_vertices.discard(q_front)\n                continue\n\n            unit_dir = dir_tensor / norm_dir\n            max_step = self._adaptive_step_size(q_front.position, Point.from_tensor(unit_dir))\n\n            max_step = min(max_step, norm_dir, self._max_step_size)\n            step_pos_tensor = q_front.position.to_tensor().float() + max_step * unit_dir\n            q_new_pos = Point.from_tensor(step_pos_tensor.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                expansion_failures[q_front] = expansion_failures.get(q_front, 0) + 1\n                if expansion_failures[q_front] >= self._prune_attempt_limit:\n                    frontier_vertices.discard(q_front)\n                continue\n\n            # Validate line sequence\n            line_seq = grid.get_line_sequence(q_front.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                expansion_failures[q_front] = expansion_failures.get(q_front, 0) + 1\n                if expansion_failures[q_front] >= self._prune_attempt_limit:\n                    frontier_vertices.discard(q_front)\n                continue\n\n            # Construct new vertex\n            q_new = Vertex(q_new_pos)\n            dist = grid.get_movement_cost(q_front.position, q_new.position)\n            q_new.cost = q_front.cost + dist\n\n            # Find neighbors for choosing parent and rewiring\n            card_v = max(self._graph.size, 1)\n            from math import log, pow\n\n            ln_card_v = log(float(card_v)) if card_v > 1 else 0.0\n            radius = min(\n                self._rewire_radius_factor * pow((ln_card_v / card_v), 1 / 2),\n                25.0,\n            )\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            chosen_parent = self._choose_parent_among(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_front  # fallback to q_front as parent\n\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n            self._graph.add_edge(chosen_parent, q_new)\n\n            # Attempt rewiring neighbors through q_new\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire_neighbors(q_new, neighbors)\n\n            # Add q_new to frontier set for expansion attempts\n            frontier_vertices.add(q_new)\n\n            # Reset expansion failures count if any\n            if q_front in expansion_failures:\n                expansion_failures[q_front] = 0\n\n            # Check for goal reach and direct connect to goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_goal_seq = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal_seq):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    frontier_vertices.add(goal_vertex)\n                    self._extract_and_smooth_path(goal_vertex)\n                    return\n\n            # Prune frontier vertices with too many failed expansions\n            prune_candidates = [v for v in frontier_vertices if expansion_failures.get(v, 0) >= self._prune_attempt_limit]\n            for pr_v in prune_candidates:\n                frontier_vertices.discard(pr_v)\n\n            if iteration % 25 == 0:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Bidirectional Heuristic-Guided RRT* with Adaptive Sampling and Dynamic Rewiring",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Hybrid Bidirectional Heuristic-Guided RRT* with Adaptive Sampling and Dynamic Rewiring}\n\n    This algorithm integrates a bidirectional search framework combining both start-rooted and goal-rooted trees,\n    utilizing heuristic-guided vertex expansion and adaptive sampling stratagems to enhance exploration efficiency.\n\n    Key features:\n    - Bidirectional trees (start and goal) grown simultaneously with heuristic-aware nearest vertex selection.\n    - Adaptive max step size that shrinks as we approach goal or start regions, fostering fine local refinement.\n    - Sampling strategy blends uniform random, heuristic-biased near-goal, and midway heuristic sampling between trees.\n    - Dynamic rewiring radius adapting based on the logarithm of the total sample count to efficiently optimize paths.\n    - Early path connection test between two trees enabling fast discovery of a feasible path.\n    - Path extraction traces back from the connecting vertices in both trees yielding the final route.\n    - Post-extraction smoothing attempts shortcuts applying robust line-of-sight checks.\n    - Time limit of 10 seconds and iteration cap for robust path search control.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        start_vertex = Vertex(start_pos)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(goal_pos)\n        goal_vertex.cost = 0\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._dimension = 2\n        self._max_iterations = 5000\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._lambda_rewire = 40  # rewire radius tuning factor\n        self._min_step = 1.5\n        self._max_step = 14.0\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        return Map.get_distance(pos, goal_pos)\n\n    def _adaptive_step_size(self, pos: Point, toward_goal: bool = True) -> float:\n        grid = self._get_grid()\n        reference = grid.goal.position if toward_goal else grid.agent.position\n        dist_to_ref = self._heuristic_cost(pos, reference)\n        norm_dist = max(0.05, min(1.0, dist_to_ref / max(grid.size)))\n        step_scale = self._min_step + (self._max_step - self._min_step) * norm_dist\n        return step_scale\n\n    def _sample(self, iteration: int) -> Point:\n        grid = self._get_grid()\n        import random\n\n        r = random.random()\n        # 20%: goal-biased sampling\n        if r < 0.2:\n            for _ in range(20):\n                offset = Point(\n                    grid.goal.position.x + random.randint(-3, 3),\n                    grid.goal.position.y + random.randint(-3, 3),\n                )\n                if grid.is_agent_valid_pos(offset):\n                    return offset\n            return grid.goal.position\n\n        # 15%: start-biased sampling\n        elif r < 0.35:\n            for _ in range(20):\n                offset = Point(\n                    grid.agent.position.x + random.randint(-3, 3),\n                    grid.agent.position.y + random.randint(-3, 3),\n                )\n                if grid.is_agent_valid_pos(offset):\n                    return offset\n            return grid.agent.position\n\n        # 15%: midpoint heuristic sampling between start and goal trees\n        elif r < 0.5 and self._graph.size > 10:\n            start_pos = self._graph.root_vertex_start.position\n            goal_pos = self._graph.root_vertex_goal.position\n            mid_point = Point(\n                (start_pos.x + goal_pos.x) // 2 + random.randint(-2, 2),\n                (start_pos.y + goal_pos.y) // 2 + random.randint(-2, 2),\n            )\n            if grid.is_agent_valid_pos(mid_point):\n                return mid_point\n            else:\n                # fallback uniform\n                return self._random_uniform_sample()\n\n        # 50%: uniform random sampling over the grid\n        else:\n            return self._random_uniform_sample()\n\n    def _random_uniform_sample(self) -> Point:\n        grid = self._get_grid()\n        import random\n        size_x, size_y = grid.size\n        for _ in range(50):\n            sample = Point(random.randint(0, size_x - 1), random.randint(0, size_y - 1))\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # fallback start position\n        return self._graph.root_vertex_start.position\n\n    def _steer(self, from_pos: Point, to_pos: Point, max_dist: float) -> Point:\n        import torch\n        dir_vec = to_pos.to_tensor().float() - from_pos.to_tensor().float()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return to_pos\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = from_pos.to_tensor().float() + dir_normalized * max_dist\n        return Point.from_tensor(new_pos_tensor.round().int())\n\n    def _choose_parent_bidirectional(self, neighbors: list, q_new: Vertex, goal_pos: Point) -> Vertex:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n        heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_candidate = q_near.cost + grid.get_distance(q_near.position, q_new.position) + heuristic_new\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                best_parent = q_near\n        if best_parent is not None:\n            q_new.cost = best_parent.cost + grid.get_distance(best_parent.position, q_new.position)\n        return best_parent\n\n    def _rewire_bidirectional(self, q_new: Vertex, neighbors: list) -> None:\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost + 1e-6 < q_neighbor.cost:\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _connect_trees(self, q_new: Vertex, opposite_vertices: list) -> Vertex:\n        \"\"\"\n        Attempt to connect q_new in one tree to vertices in the opposite tree.\n        Return connecting vertex in opposite tree if connection found; else None.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_connect = None\n        for q_opp in opposite_vertices:\n            dist = grid.get_distance(q_new.position, q_opp.position)\n            if dist > self._max_step + 2:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_opp.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_path = q_new.cost + dist + q_opp.cost\n            if cost_path < min_cost:\n                min_cost = cost_path\n                best_connect = q_opp\n        return best_connect\n\n    def _extract_bidirectional_path(self, conn_start: Vertex, conn_goal: Vertex) -> list:\n        # Trace path backward from conn_start to start root\n        path_start = []\n        curr = conn_start\n        while True:\n            path_start.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = next(iter(curr.parents))\n        path_start.reverse()\n\n        # Trace path backward from conn_goal to goal root\n        path_goal = []\n        curr = conn_goal\n        while True:\n            path_goal.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = next(iter(curr.parents))\n\n        # Combine paths: start path + reverse of goal path (to avoid overlap at connection)\n        full_path = path_start + path_goal[::-1]\n\n        # Apply multi-pass shortcut smoothing\n        full_path = self._shortcut_path_multistage(full_path)\n\n        return full_path\n\n    def _shortcut_path_multistage(self, path: list) -> list:\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        smoothing_passes = 3\n        for _ in range(smoothing_passes):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        shortened = True\n                        j = i + 1\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n        return path\n\n    def _move_agent_along_path(self, path: list) -> None:\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        start_vertices = [start_vertex]\n        goal_vertices = [goal_vertex]\n        start_time = time.time()\n        found_path = None\n\n        for iter_count in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_seconds:\n                break\n\n            # Alternate tree growth direction every iteration\n            grow_start_tree = (iter_count % 2 == 0)\n\n            # Sample point using heuristic adaptive strategy\n            q_sample = self._sample(iter_count)\n\n            tree_vertices = start_vertices if grow_start_tree else goal_vertices\n            opposite_vertices = goal_vertices if grow_start_tree else start_vertices\n            tree_root = start_vertex if grow_start_tree else goal_vertex\n            reference_pos = grid.goal.position if grow_start_tree else grid.agent.position\n\n            # Find nearest vertex in chosen tree\n            q_nearest = self._graph.get_nearest_vertex(tree_vertices, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            # Adaptive step size based on toward which tree we are growing\n            max_dist = self._adaptive_step_size(q_nearest.position, toward_goal=grow_start_tree)\n\n            q_new_pos = self._steer(q_nearest.position, q_sample, max_dist)\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Compute cost to q_new from q_nearest (actual movement cost)\n            move_cost = grid.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + move_cost\n\n            # Find neighbors for rewiring in current tree\n            total_vertices_count = max(self._graph.size, 1)\n            ln_card = torch.log(torch.tensor(float(total_vertices_count))).item() if total_vertices_count > 1 else 0.0\n            radius = min(self._lambda_rewire * ((ln_card / total_vertices_count) ** (1/self._dimension)), 25.0)\n\n            neighbors = self._graph.get_vertices_within_radius(tree_vertices, q_new.position, radius)\n            if q_nearest not in neighbors:\n                neighbors.append(q_nearest)\n\n            # Choose best parent from neighbors (heuristic + cost)\n            q_parent = self._choose_parent_bidirectional(neighbors, q_new, reference_pos)\n            if q_parent is None:\n                continue\n\n            # Add edge from best parent to q_new\n            self._graph.add_edge(q_parent, q_new)\n            tree_vertices.append(q_new)\n\n            # Rewire neighbors to optimize path costs\n            self._rewire_bidirectional(q_new, neighbors)\n\n            # Attempt to connect q_new to opposite tree vertices\n            connect_candidate = self._connect_trees(q_new, opposite_vertices)\n            if connect_candidate is not None:\n                # A connecting path between two trees found\n                if grow_start_tree:\n                    path = self._extract_bidirectional_path(q_new, connect_candidate)\n                else:\n                    path = self._extract_bidirectional_path(connect_candidate, q_new)\n\n                total_path_cost = q_new.cost + connect_candidate.cost + grid.get_distance(q_new.position, connect_candidate.position)\n                if total_path_cost < self._best_cost:\n                    self._best_cost = total_path_cost\n                    found_path = path\n                    break  # early stop on connection\n\n            # Key frame visualization every 50 iterations\n            if iter_count % 50 == 0:\n                self.key_frame()\n\n        if found_path is not None:\n            self._move_agent_along_path(found_path)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal-biased sampling, adaptive step size, and rewiring for path optimization.\n\n    Key improvements over basic RRT:\n    - Goal bias: With a probability bias_towards_goal, samples are taken directly at the goal, encouraging faster connection.\n    - Adaptive step size: max_dist dynamically shrinks as the tree approaches the goal, giving finer resolution near target.\n    - Rewiring: After adding a new vertex, nearby vertices are examined and rewired if the cost via the new vertex is lower, improving path quality.\n    - Early stopping: Searches cut off after 10 seconds if no path is found.\n    - Shortcut path smoothing applied after path extraction to improve smoothness and reduce unnecessary detours.\n    - The method retains the underlying Vertex and Forest structure, reusing helper methods from RRT.",
     "code": "class PathPlanning(RRT):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Parameters for improvements\n        self._goal_bias_prob: float = 0.2    # Probability to sample goal directly\n        self._adaptive_max_dist_initial: float = 15.0  # Initial max step size\n        self._adaptive_max_dist_min: float = 3.0       # Minimum max step size near goal\n        self._rewire_radius: float = 20.0              # Radius for rewiring neighborhood\n\n    def _get_adaptive_max_dist(self, dist_to_goal: float) -> float:\n        \"\"\"Adaptive max_dist: shrink step size closer to goal.\"\"\"\n        if dist_to_goal < self._adaptive_max_dist_min:\n            return self._adaptive_max_dist_min\n        if dist_to_goal > self._adaptive_max_dist_initial:\n            return self._adaptive_max_dist_initial\n        # Linear interpolation\n        scale = (dist_to_goal - self._adaptive_max_dist_min) / (self._adaptive_max_dist_initial - self._adaptive_max_dist_min)\n        return self._adaptive_max_dist_min + scale * (self._adaptive_max_dist_initial - self._adaptive_max_dist_min)\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"Sample point with goal bias.\"\"\"\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _rewire(self, q_new: Vertex) -> None:\n        \"\"\"Rewire nearby vertices to potentially improve path costs.\"\"\"\n        near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(\n            [self._graph.root_vertex_start], q_new.position, self._rewire_radius)\n\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old edge(s) connecting to q_near parents\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge via q_new\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        \"\"\"Shortcut path to remove unnecessary intermediate vertices if direct connection is valid.\"\"\"\n        if len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"Extract path using parents and apply shortcut for smoothing.\"\"\"\n        # Connect to goal vertex directly\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Backtrack parents until root start vertex\n        current_v = goal_v\n        while len(current_v.parents) != 0:\n            current_v = next(iter(current_v.parents))\n            path.append(current_v)\n        path.reverse()\n\n        # Shortcut to smooth path\n        path = self._shortcut_path(path)\n\n        # Animate agent along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n\n        # Initialize cost for start vertex\n        start_vertex.cost = 0.0\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # Timeout after 10 seconds\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = self._get_adaptive_max_dist(dist_to_goal)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost for q_new\n            cost_new = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = cost_new\n\n            # Choose parent with lowest cost within radius around q_new (including q_near)\n            neighbor_radius = self._rewire_radius\n            neighbor_vertices: List[Vertex] = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, neighbor_radius)\n            candidate_parent: Optional[Vertex] = None\n            candidate_cost = cost_new\n\n            for q_near_candidate in neighbor_vertices:\n                line_candidate_seq = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_candidate_seq):\n                    continue\n\n                cost_candidate = q_near_candidate.cost + self._get_grid().get_distance(q_near_candidate.position, q_new.position)\n                if cost_candidate < candidate_cost:\n                    candidate_cost = cost_candidate\n                    candidate_parent = q_near_candidate\n\n            if candidate_parent is not None:\n                q_new.cost = candidate_cost\n                self._graph.add_edge(candidate_parent, q_new)\n            else:\n                self._graph.add_edge(q_near, q_new)\n\n            # Rewire nearby nodes for optimization\n            self._rewire(q_new)\n\n            # Check if new node is within goal radius to stop and extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with heuristic-guided adaptive sampling,\n    variable step size, and informed rewiring. This algorithm integrates the following enhancements:\n\n    - Heuristic-biased sampling towards a dynamically shrinking informed ellipsoid based on the current best path cost.\n    - Adaptive max step distance based on local vertex density to balance exploration and exploitation.\n    - Use of an informed radius for neighbor search adapting to vertex density and search progress.\n    - Early stopping on goal reach or timeout (10 seconds).\n    - Path quality improvement via rewiring and shortcut smoothing.\n    - Robustness by fallback strategies if no suitable parent is found.\n    - Improved success rate by aggressively sampling in promising regions and reusing previously found paths to guide sampling.\n\n    Overall, this method aims to improve planning efficiency, path quality, and success rate by leveraging heuristics and adaptive exploration.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n        # New member variables to track best cost and sampling control\n        self._best_cost = float(\"inf\")\n        self._goal_vertex = None\n\n    def _heuristic_cost(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(p1, p2)\n\n    def _get_informed_sample(self, goal_bias: float, iteration: int, max_iterations: int) -> Point:\n        \"\"\"\n        Sample in an ellipsoidal region informed by the best path cost found so far.\n        If no best path, revert to uniform random sampling with goal bias.\n        \"\"\"\n        if self._best_cost == float(\"inf\") or np.random.random() < goal_bias:\n            # Regular goal biased sample\n            return self._get_random_sample(goal_bias=goal_bias)\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        c_best = self._best_cost\n        c_min = self._heuristic_cost(agent_pos, goal_pos)\n        if c_best < c_min:\n            c_best = c_min  # avoid degenerate ellipsoid\n\n        # Ellipsoidal sampling strategy inspired by Informed RRT*\n        center = Point(\n            (agent_pos.x + goal_pos.x) / 2,\n            (agent_pos.y + goal_pos.y) / 2\n        )\n\n        # Unit vector from start to goal\n        start_to_goal_vec = (goal_pos.to_tensor() - agent_pos.to_tensor())\n        start_to_goal_unit = start_to_goal_vec / torch.norm(start_to_goal_vec)\n        # Basis completion for 2D environment\n        # Construct orthonormal basis for ellipsoid axes\n        # Here n_dim assumed 2 from grid size, extend if needed\n        if len(center.to_tensor()) == 2:\n            e1 = start_to_goal_unit\n            e2 = torch.tensor([-e1[1], e1[0]])\n            C = torch.stack([e1, e2], dim=1)\n        else:\n            # Fallback to identity if dimensions not 2\n            C = torch.eye(len(center.to_tensor()))\n\n        # Radii of the ellipsoid\n        r1 = c_best / 2\n        r2 = (np.sqrt(c_best ** 2 - c_min ** 2)) / 2 if c_best > c_min else 0.0\n\n        # Sample uniformly in unit ball\n        while True:\n            # Sample a random point in a unit n-ball\n            rand_dir = torch.randn(C.shape[0])\n            norm_dir = torch.norm(rand_dir)\n            if norm_dir == 0:\n                continue\n            unit_rand_dir = rand_dir / norm_dir\n            radius = np.random.random() ** (1.0 / C.shape[0])\n            rand_ball_point = radius * unit_rand_dir\n\n            # Scale by axes radii\n            scaled_point = torch.tensor([r1 * rand_ball_point[0], r2 * rand_ball_point[1]])\n            sample_tensor = C @ scaled_point + center.to_tensor()\n            sample = Point.from_tensor(sample_tensor)\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, iteration: int, iteration_limit: int) -> float:\n        # Adaptive step size shrinks over iterations for refinement\n        max_dist_init = 15.0\n        max_dist_min = 3.0\n        decay_ratio = min(iteration / iteration_limit, 1.0)\n        max_dist = max_dist_init * (1 - 0.8 * decay_ratio)  # shrinks from 15 to ~3\n        max_dist = max(max_dist, max_dist_min)\n        return max_dist\n\n    def _adaptive_radius(self, max_dist: float) -> float:\n        # Neighbor search radius for rewiring is proportional to step size\n        return max_dist * 3.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Override to reuse existing helper with some minor modification to prevent zero-length edges\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length == 0:\n            return None\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        if not self._get_grid().is_agent_valid_pos(q_new_pos):\n            return None\n        return Vertex(q_new_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        iteration_limit = 10000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: terminate if path not found in time\n                break\n\n            max_dist = self._adaptive_max_dist(iteration, iteration_limit)\n            radius = self._adaptive_radius(max_dist)\n            goal_bias = 0.2\n\n            # Sample a point using informed sampling strategy to focus search\n            q_sample = self._get_informed_sample(goal_bias=goal_bias, iteration=iteration, max_iterations=iteration_limit)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Validate path from q_near to q_new\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Get neighbors for rewiring within adaptive radius\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Compute cost of connecting from neighbors, choose best\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Validate edge from neighbor to q_new for collision\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n\n                cost_through_neighbor = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                heuristic_remain = self._heuristic_cost(q_new.position, self._get_grid().goal.position)\n                estimated_total_cost = cost_through_neighbor + heuristic_remain\n                if estimated_total_cost < min_cost:\n                    min_cost = estimated_total_cost\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # Fallback to q_near if no better parent found\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Set q_new cost as cost to reach it (exclude heuristic here for actual cost)\n            q_new.cost = parent_for_new.cost + self._get_grid().get_distance(parent_for_new.position, q_new.position)\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors if cost improves via q_new\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old parents edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if goal reached within radius, attempt to connect to actual goal\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                final_goal_pos = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n\n                    # Attach goal vertex only if cost is better than previous best (if any)\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        self._goal_vertex = goal_vertex\n                        self._graph.add_edge(q_new, goal_vertex)\n                        # Extract path with shortcutting and animate\n                        self._extract_path(goal_vertex)\n                        break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Anytime Heuristic Sampling Tree (IAHAST) Algorithm for Grid Path Planning\n    This algorithm enhances baseline IHAST by incorporating:\n      - A dynamically adjusted goal bias rate increasing over time to focus search near goal gradually.\n      - A priority queue (min-heap) guided expansion prioritizing vertices with lowest f = cost + heuristic,\n        blending classic A* ideas with sampling-based exploration.\n      - Adaptive heuristic sampling confined within a dynamic corridor around current best path cost.\n      - Efficient rewiring with pruning of higher cost edges for robustness and overall graph quality.\n      - Early stopping triggered when a valid path is found and no better improvement occurs in a short time.\n      - Enhanced shortcut smoothing considering multiple hop connections to reduce path segments.\n      - Use of Euclidean heuristic consistent with grid distance for fast goal distance estimation.\n    This balances exploration and exploitation, improves planning efficiency, path smoothness,\n    and success rate within a 10s runtime limit.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 6000  # fewer max iterations due to improved method\n        self._goal_sample_rate_base = 0.1  # start with low goal sample rate\n        self._goal_sample_rate_max = 0.4   # max goal sampling by progress\n        self._search_radius_rewire = 10.0  # slightly smaller radius for faster rewire\n        self._min_step = 3.0\n        self._max_step = 12.0\n        self._heuristic_corridor_width_factor = 1.5  # width factor to filter heuristic sampling\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        grid = self._get_grid()\n        return Map.get_distance(pos, grid.goal.position)\n\n    def _dynamic_goal_bias(self, elapsed_time: float) -> float:\n        # Linearly increase goal bias from base to max over time limit for gradual focus\n        rate = self._goal_sample_rate_base + (self._goal_sample_rate_max - self._goal_sample_rate_base) * min(elapsed_time / self._time_limit, 1.0)\n        return rate\n\n    def _heuristic_sample(self, best_cost: float) -> Point:\n        \"\"\"\n        Heuristic biased sampling restricted within a corridor defined by (start->sample + sample->goal) <= best_cost * corridor factor.\n        This focuses sampling to promising regions closer to estimated best path cost.\n        Falls back after multiple attempts to any valid sample.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_distance = Map.get_distance(Point(0,0), Point(*size))\n        corridor_limit = best_cost * self._heuristic_corridor_width_factor\n\n        attempts = 0\n        max_attempts = 500\n        while attempts < max_attempts:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            h_val = Map.get_distance(agent_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n            if h_val <= corridor_limit:\n                # Acceptance probability biased towards smaller h_val\n                h_norm = h_val / max_distance\n                if np.random.rand() < 1.0 - h_norm:\n                    return sample_pt\n\n        # fallback any valid position\n        while True:\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n            if grid.is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Overrides base with consistent step size clamping and improved collision validation.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = min(step_size, max_dist)\n        step_size = max(step_size, self._min_step)\n\n        # Clamp by available distance\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n\n        if not grid.is_agent_valid_pos(q_new_pos):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Select parent with lowest cost + heuristic considering line validity.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if cost_to_new >= min_cost:\n                continue\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            min_cost = cost_to_new\n            chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewiring neighbors through q_new if cost reduction and valid.\n        Prune older higher cost parents to maintain better tree quality.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove edges from higher cost parents first\n                    to_remove = [p for p in list(neighbor.parents) if p.cost > potential_cost]\n                    for parent in to_remove:\n                        self._graph.remove_edge(parent, neighbor)\n                    # Add new edge\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Enhanced shortcut smoothing: tries multiple hops ahead reducing path length more aggressively.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortcut_path = [path[0]]\n        idx = 0\n        n = len(path)\n        while idx < n - 1:\n            last_added = shortcut_path[-1]\n            max_reachable_idx = idx + 1\n            # Test all farther nodes to find longest collision-free shortcut\n            for test_idx in range(n - 1, idx, -1):\n                line_seq = grid.get_line_sequence(last_added.position, path[test_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    max_reachable_idx = test_idx\n                    break\n            shortcut_path.append(path[max_reachable_idx])\n            idx = max_reachable_idx\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Construct path backward from q_new to start, add goal, smooth, then move agent.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        # Backtrack minimal cost path\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()\n        path.reverse()\n\n        smooth_path = self._shortcut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Priority queue for vertices to expand: (f = cost + heuristic, iteration, vertex)\n        open_set = []\n        iteration_counter = 0\n        root_start = self._graph.root_vertex_start\n        root_start_cost = root_start.cost\n        h_start = self._heuristic_cost(root_start.position)\n        heapq.heappush(open_set, (root_start_cost + h_start, iteration_counter, root_start))\n\n        best_goal_vertex = None\n        best_goal_cost = float('inf')\n        last_improvement_time = start_time\n\n        while iteration_counter < self._max_iterations:\n            iteration_counter += 1\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._time_limit:\n                break\n\n            goal_sample_rate = self._dynamic_goal_bias(elapsed_time)\n            if np.random.rand() < goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                # Use corridor based heuristic sampling centered on best known cost\n                corridor_cost = best_goal_cost if best_goal_cost < float('inf') else (Map.get_distance(agent_pos, goal_pos) * 3.0)\n                q_sample = self._heuristic_sample(corridor_cost)\n\n            # Extract from priority queue the most promising vertex\n            if not open_set:\n                # Seed with root start if empty\n                heapq.heappush(open_set, (root_start_cost + h_start, iteration_counter, root_start))\n\n            _, _, q_near = heapq.heappop(open_set)\n\n            if q_near.position == q_sample:\n                # Sample equals vertex, skip iteration\n                continue\n\n            direction_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            max_dist = self._adaptive_step_size(q_near.position, Point.from_tensor(direction_vec))\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and set cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors excluding chosen parent for improvement\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Add q_new into open set with priority f = cost + heuristic\n            f_val = q_new.cost + self._heuristic_cost(q_new.position)\n            heapq.heappush(open_set, (f_val, iteration_counter, q_new))\n\n            # Check goal reach (inside radius)\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best goal if cost improves\n                if q_new.cost < best_goal_cost:\n                    best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n                    last_improvement_time = time.time()\n\n            # Early stop if solution found and no improvement in last 1.5 seconds\n            if best_goal_vertex is not None and (time.time() - last_improvement_time) > 1.5:\n                self._extract_path(best_goal_vertex)\n                break\n\n            self.key_frame()\n\n        # If exit without early stop but best found, extract the path\n        if best_goal_vertex is not None and (time.time() - last_improvement_time) <= 1.5:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced PathPlanning Algorithm focusing on faster convergence and higher success rate:\n    - Adaptive step size with environment-aware modulation and progress feedback to avoid overshooting.\n    - Hybrid sampling strategy mixing uniform, goal bias, and adaptive informed ellipsoidal sampling with dynamic probabilities increasing goal bias as planning proceeds.\n    - Heuristic-guided vertex expansion using actual cost + admissible heuristic (like A*) for better directionality.\n    - RRT*-style rewiring with efficient neighborhood pruning based on radius scaled by log(tree size).\n    - Lazy collision checking during rewiring for speed and filtered rewiring to reduce unnecessary graph clutter.\n    - Multi-pass aggressive shortcut smoothing to yield smoother and shorter paths.\n    - Early termination not only on direct goal connection but also when incremental best cost plateaus to save runtime.\n    - Time constrained within 10 seconds hard limit ensuring bounded runtime.\n    Overall, it strikes a balance between exploration and exploitation with dynamic adaptation and informed sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.25\n        self._informed_sample_rate = 0.3\n        self._max_iterations = 3000  # Slightly reduced for efficiency\n        self._lambda_rrt_star = 40  # Slightly tuned for tighter rewiring radius\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._last_cost_improve_iter = 0\n        self._cost_improve_threshold_iters = 150  # Stop if no improvement for these iterations\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 400 / (self._graph.size + 1))\n        # Incorporate progress feedback to reduce jump length as better path found\n        cost_factor = 1.0 if self._best_cost == float('inf') else min(1.0, self._best_cost / (dist_to_goal + 1e-6))\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor * cost_factor\n        return max(self._min_max_dist, min(self._max_max_dist, scaled_step))\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        import math\n        import torch\n\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(*(((start_pos.to_tensor().float() + goal_pos.to_tensor().float()) / 2).tolist()))\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        e1 = diff / dist_start_goal\n\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        a = c_max / 2.0\n        b = math.sqrt(max(c_max ** 2 - dist_start_goal ** 2, 1e-6)) / 2.0\n\n        max_tries = 30\n        for _ in range(max_tries):\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        elapsed_time = time.time() - self._start_time\n\n        # Dynamic goal biasing increasing as time progresses to accelerate convergence\n        dynamic_goal_rate = min(0.5, self._goal_sample_rate + 0.25 * (elapsed_time / self._time_limit_seconds))\n        # Reduce informed sampling later to avoid local minima trapping\n        dynamic_informed_rate = max(0.05, self._informed_sample_rate * (1.0 - (elapsed_time / self._time_limit_seconds)))\n\n        rand_val = torch.rand(1).item()\n\n        if rand_val < dynamic_goal_rate:\n            goal_pos = grid.goal.position\n            max_radius = self._min_max_dist * 1.5\n            for _ in range(30):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    sample_offset = sample_offset / norm\n                sample_offset = sample_offset * (torch.rand(1).item() * max_radius)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        elif rand_val < dynamic_goal_rate + dynamic_informed_rate and self._best_cost < float('inf'):\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            for _ in range(100):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            return self._graph.root_vertex_start.position\n\n    def _extract_path_and_smooth(self, goal_vertex: Vertex):\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Enhanced aggressive multi-pass shortcut smoothing with more attempts and early break\n        smoothing_attempts = 5\n        for _ in range(smoothing_attempts):\n            i = 0\n            modified = False\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        shortened = True\n                        modified = True\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n            if not modified:\n                break\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n        best_cost_prev = float('inf')\n        self._start_time = time.time()\n        iteration = 0\n\n        while iteration < self._max_iterations:\n            curr_time = time.time()\n            if (curr_time - self._start_time) > self._time_limit_seconds:\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                iteration += 1\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                iteration += 1\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                iteration += 1\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic guided minimum cost parent\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n\n            heuristic_goal = goal_pos\n            heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n            best_total_cost = c_min + self._heuristic_cost(q_min.position, goal_pos)\n\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_candidate = self._heuristic_cost(q_near.position, goal_pos)\n                total_candidate = cost_candidate + heuristic_new  # heuristic_new for new vertex\n\n                # Check line of sight before parent selection to minimize collision check overhead\n                if total_candidate < best_total_cost:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n                        best_total_cost = total_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors selectively to improve cost\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-8 < q_near.cost:\n                    # Lazy collision check to reduce overhead\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        if len(q_near.parents) > 0:\n                            for parent in q_near.parents:\n                                self._graph.remove_edge(parent, q_near)\n                                break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n                        self._last_cost_improve_iter = iteration\n\n                        # Early termination upon sufficiently good path\n                        if cost_to_goal < float('inf'):\n                            break\n\n            # Early termination if cost improvement plateaus\n            if iteration - self._last_cost_improve_iter > self._cost_improve_threshold_iters:\n                break\n\n            # Visualization keyframe every 30 iterations for faster frame updates\n            if iteration % 30 == 0:\n                self.key_frame()\n\n            iteration += 1\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planner with goal biasing and rewiring.\n\n    This algorithm extends RRT by incorporating:\n    1. Goal-biased sampling to efficiently direct growth toward the goal.\n    2. Adaptive step size for better exploration and connection flexibility.\n    3. RRT* style rewiring of nearby vertices within a radius to improve path quality.\n    4. Early stopping when a path is found and no significant improvement is made.\n    5. Shortcut smoothing after path extraction for shorter and smoother paths.\n    6. Time limit of 10 seconds to avoid excessive computation.\n\n    This results in better planning efficiency, smoother and shorter paths,\n    higher success rate, and robustness while maintaining compatibility\n    with the existing Map, Forest, and Vertex structures.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring for RRT*\n        self._init_displays()\n        # Parameters for improved algorithm\n        self._max_dist = 15.0\n        self._goal_sample_rate = 0.15  # Probability of sampling the goal directly (goal bias)\n        self._neighbor_radius = 20.0   # Radius to consider neighbors for rewiring\n        self._iteration_limit = 1500   # Max iterations (will be capped by time)\n        self._time_limit_sec = 10.0    # Max allowed planning time in seconds\n\n    # Modified helper: goal-biased random sampling\n    def _get_biased_random_sample(self) -> Point:\n        import time\n        r = np.random.rand()\n        if r < self._goal_sample_rate:\n            # Sample directly at goal for biasing\n            return self._get_grid().goal.position\n        else:\n            # Uniform random sample in valid positions as before\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Find vertex with minimum cost plus distance heuristic in radius\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        min_cost = float('inf')\n        best_parent = None\n        for q_near in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = q_near\n        if best_parent is None:\n            return None\n        q_new.cost = min_cost\n        return best_parent\n\n    # Rewire nearby vertices for path improvement\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        for q_near in near_vertices:\n            if q_near == q_new.parents or q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old edge parent->q_near\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge q_new -> q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    # Shortcut smoothing for a found path\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) <= 2:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            smoothed.append(path[next_idx])\n            idx = next_idx\n        return smoothed\n\n    # Extract optimized path with shortcut smoothing\n    def _extract_optimized_path(self, q_goal_candidate: Vertex) -> None:\n        path: List[Vertex] = [q_goal_candidate]\n        while True:\n            parents = path[-1].parents\n            if not parents:\n                break\n            # Choose parent with min cost (should be unique mostly)\n            parent = min(parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(path)\n\n        # Animate movement along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._graph.root_vertices = [start_vertex]\n\n        iterations = 0\n        found_goal = False\n        q_goal_candidate = None\n        best_cost_to_goal = float('inf')\n\n        while iterations < self._iteration_limit:\n            current_time = time.time()\n            if current_time - start_time > self._time_limit_sec:\n                # Timeout: end search with failure if path not found\n                break\n\n            iterations += 1\n\n            q_sample: Point = self._get_biased_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step: decrease max_dist near goal to improve final connectivity\n            dist_to_goal = Map.get_distance(q_near.position, goal_vertex.position)\n            max_dist = self._max_dist if dist_to_goal > 5.0 else max(3.0, dist_to_goal / 2)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors for RRT*\n            near_vertices = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._neighbor_radius)\n\n            # Choose best parent\n            best_parent = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:\n                # No valid parent found: discard q_new\n                continue\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors for better paths\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to root vertices for extended exploration\n            self._graph.root_vertices.append(q_new)\n\n            cost_to_goal = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n            # Check if near enough to goal to consider connecting\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position) and cost_to_goal < best_cost_to_goal:\n                # Try connecting new vertex directly to goal vertex\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    # Attach goal vertex as child of q_new with updated cost\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    q_goal_candidate = goal_vertex\n                    best_cost_to_goal = cost_to_goal\n                    found_goal = True\n\n                    # Early stopping criterion: break if improvement is minimal for some iterations\n                    if iterations > 100 and best_cost_to_goal < float('inf'):\n                        break\n\n            self.key_frame()\n\n        if found_goal and q_goal_candidate:\n            self._extract_optimized_path(q_goal_candidate)\n        else:\n            # Path not found within iteration/time limit, do not move agent\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired algorithm with heuristic-guided sampling and adaptive rewiring for enhanced path quality and efficiency.\n\n    Key improvements over baseline:\n    - Uses heuristic-informed goal-biased sampling: samples a mixture of random, goal-biased, and informed samples\n      focused on an ellipse around start-goal to prioritize promising regions.\n    - Dynamically adapts max step size based on local clearance (distance to obstacles) promoting efficient progress without collision risk.\n    - Implements rewiring with a progressively shrinking radius for neighbors to optimize graph connections over iterations.\n    - Incorporates A*-style cost-to-go heuristic to guide parent selection and rewiring decisions (cost + heuristic).\n    - Early stopping on goal reach or max 10 seconds timeout.\n    - Applies path shortcutting and smoothing to improve final path quality.\n    - Integrates validation caching on line sequences to reduce redundant collision checks, improving planning speed.\n    - Tracks success rate by ensuring non-trivial connection attempts between nodes before rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring\n        self._init_displays()\n\n        # Cache for collision validity checks for line sequences\n        self._line_validity_cache = {}\n\n    def _heuristic_cost(self, frm: Point) -> float:\n        # Heuristic cost estimate: Euclidean distance to goal\n        return self._get_grid().get_distance(frm, self._get_grid().goal.position)\n\n    def _cached_line_valid(self, frm: Point, to: Point) -> bool:\n        # Cache collision checking for line sequences between points\n        key = (frm, to)\n        if key in self._line_validity_cache:\n            return self._line_validity_cache[key]\n        line_seq = self._get_grid().get_line_sequence(frm, to)\n        valid = self._get_grid().is_valid_line_sequence(line_seq)\n        self._line_validity_cache[key] = valid\n        return valid\n\n    def _sample_informed(self, c_best: float, start: Point, goal: Point) -> Point:\n        # Informed sampling within ellipse defined by c_best (best path cost found)\n\n        # If no path found yet, fall back to uniform random with goal bias\n        if c_best == float('inf'):\n            return self._get_random_sample(goal_bias=0.2)\n\n        # Ellipse parameters\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n        dist_start_goal = self._get_grid().get_distance(start, goal)\n        if dist_start_goal == 0:\n            return goal\n\n        # Define ellipse axes lengths\n        a = c_best / 2\n        b_sq = a ** 2 - (dist_start_goal / 2) ** 2\n        b = max(0.1, b_sq ** 0.5) if b_sq > 0 else 0.1  # Minor axis\n\n        # Sample random point in unit circle\n        while True:\n            theta = 2 * np.pi * np.random.random()\n            r = np.sqrt(np.random.random())\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n\n            # Map unit circle sample to ellipse on workspace\n            ellipse_x = a * x\n            ellipse_y = b * y\n\n            # Rotate ellipse to align with start-goal line\n            dx = goal.x - start.x\n            dy = goal.y - start.y\n            phi = np.arctan2(dy, dx)\n\n            rot_x = ellipse_x * np.cos(phi) - ellipse_y * np.sin(phi)\n            rot_y = ellipse_x * np.sin(phi) + ellipse_y * np.cos(phi)\n\n            sample = Point(int(center.x + rot_x), int(center.y + rot_y))\n\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, q_near: Vertex, max_dist_min: float, max_dist_max: float) -> float:\n        # Compute max distance adaptive to local clearance (distance to nearest obstacle)\n        clearance = self._estimate_clearance(q_near.position)\n        # Linearly scale step size between min and max dist based on clearance threshold\n        clearance_threshold = 5.0  # Tunable parameter max clearance to cap step size\n        scaled = max_dist_min + (max_dist_max - max_dist_min) * min(clearance, clearance_threshold) / clearance_threshold\n        return max(min(scaled, max_dist_max), max_dist_min)\n\n    def _estimate_clearance(self, pos: Point, search_radius: int = 5) -> float:\n        # Estimate local clearance by checking distance to nearest obstacle within search radius in grid\n        min_dist = float('inf')\n        grid = self._get_grid()\n        sx, sy = pos.x, pos.y\n        for dx in range(-search_radius, search_radius + 1):\n            for dy in range(-search_radius, search_radius + 1):\n                nx, ny = sx + dx, sy + dy\n                neighbor = Point(nx, ny)\n                if not grid.is_agent_valid_pos(neighbor):\n                    dist = grid.get_distance(pos, neighbor)\n                    if dist < min_dist:\n                        min_dist = dist\n        if min_dist == float('inf'):\n            # No obstacles nearby: full clearance\n            return search_radius + 1\n        return min_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_min = 3.0\n        max_dist_max = 20.0\n        iteration_limit = 8000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        best_path_cost = float(\"inf\")\n        goal_vertex_found = None\n\n        for i in range(iteration_limit):\n            # Timeout protection\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                break\n\n            # Use informed sampling when a path found to focus search\n            q_sample = None\n            if best_path_cost < float(\"inf\"):\n                q_sample = self._sample_informed(best_path_cost, start_vertex.position, self._get_grid().goal.position)\n            else:\n                q_sample = self._get_random_sample(goal_bias=0.2)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on clearance near q_near\n            max_dist = self._adaptive_max_dist(q_near, max_dist_min, max_dist_max)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line collision with caching\n            if not self._cached_line_valid(q_near.position, q_new.position):\n                continue\n\n            # Radius for neighbor search shrinking gradually from max to min\n            r_max = 30.0\n            r_min = 10.0\n            radius = r_max - (r_max - r_min) * (i / iteration_limit)\n            radius = max(radius, r_min)\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select parent minimizing cost + heuristic cost-to-go\n            min_total_cost = float(\"inf\")\n            parent_for_new = None\n\n            for neighbor in neighbors:\n                # Validate neighbor connection\n                if not self._cached_line_valid(neighbor.position, q_new.position):\n                    continue\n                cost_through_neighbor = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                heuristic = self._heuristic_cost(q_new.position)\n                total_cost = cost_through_neighbor + heuristic\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    parent_for_new = neighbor\n\n            # Fallback if no suitable parent\n            if parent_for_new is None:\n                if not self._cached_line_valid(q_near.position, q_new.position):\n                    continue\n                parent_for_new = q_near\n                min_total_cost = parent_for_new.cost + self._get_grid().get_distance(q_near.position, q_new.position) + self._heuristic_cost(q_new.position)\n\n            q_new.cost = min_total_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Try rewiring neighbors via q_new if improves path cost + heuristic\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                if not self._cached_line_valid(q_new.position, neighbor.position):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                new_total_cost = new_cost + self._heuristic_cost(neighbor.position)\n                old_total_cost = neighbor.cost + self._heuristic_cost(neighbor.position)\n                if new_total_cost < old_total_cost:\n                    # Remove all old parents edges to neighbor before rewiring\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if goal reached and connection is collision free\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                final_goal_pos = self._get_grid().goal.position\n                if self._cached_line_valid(q_new.position, final_goal_pos):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Update best path if improved\n                    if goal_vertex.cost < best_path_cost:\n                        best_path_cost = goal_vertex.cost\n                        goal_vertex_found = goal_vertex\n\n                    # Early stop on first found path for speed or continue improving?\n                    # Here we choose early stop to favor efficiency\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Key frame for visualization\n            self.key_frame()\n\n        # If path found previously but loop exited without early break, extract best path again\n        if goal_vertex_found is not None:\n            self._extract_path(goal_vertex_found)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm leveraging goal-biased adaptive informed sampling,\n    heuristic-guided dynamic expansion with A*-like cost prioritization, adaptive step size,\n    and radius rewiring optimization. Enhancements include:\n    - Adaptive max step size scales with progress and tree size.\n    - Mixed sampling strategy (uniform, goal-biased, informed ellipsoid) adaptively focused by path cost.\n    - Heuristic cost includes traveled cost + admissible Euclidean distance to guide search like A*.\n    - Dynamic neighborhood radius for rewiring improves optimization and pruning for cleaner trees.\n    - Early stopping on connecting directly to goal with smooth successful path extraction.\n    - Multiple shortcut smoothing passes improve path quality.\n    - Time budget enforced to abort planning after 10 seconds.\n    Designed to improve planning efficiency, solution quality, success rate, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.25\n        self._informed_sample_rate = 0.3\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost_with_travel(self, curr_cost: float, pos: Point, goal_pos: Point) -> float:\n        # Combined cost = cost_so_far + heuristic estimate to goal (Euclidean)\n        return curr_cost + Map.get_distance(pos, goal_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        goal_vertex_found = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Abort if time exceeded 10 seconds\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_vec).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Cost from nearest to new\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            cost_to_new_from_nearest = q_nearest.cost + dist_nearest_new\n\n            # Dynamic rewiring radius\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            nearby_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent using cost + heuristic guiding expansion\n            q_min = q_nearest\n            c_min = cost_to_new_from_nearest\n            for q_near in nearby_vertices:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                candidate_cost = q_near.cost + dist_near_new\n                if candidate_cost < c_min:\n                    candidate_line = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line):\n                        q_min = q_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if going through new vertex improves cost\n            # Early pruning of edges to reduce clutter\n            for q_near in nearby_vertices:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                new_path_cost = q_new.cost + dist_new_near\n                if new_path_cost + 1e-6 < q_near.cost:\n                    rewire_line = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(rewire_line):\n                        # Remove one parent edge to keep tree structure\n                        for old_parent in q_near.parents:\n                            self._graph.remove_edge(old_parent, q_near)\n                            break\n                        q_near.cost = new_path_cost\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if goal is reachable from q_new within max_dist step\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                goal_line = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(goal_line):\n                    # Create temporary goal vertex (new instance)\n                    new_goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    new_goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, new_goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        goal_vertex_found = new_goal_vertex\n\n                    # Early termination on valid goal connection\n                    break\n\n            # Key frames for visualization every 50 iterations approx.\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if goal_vertex_found is not None:\n            # Extract path and robust shortcut smoothing\n            self._extract_path_and_smooth(goal_vertex_found)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired algorithm with heuristic-guided sampling and rewiring:\n    This variant enhances the base RRT* by incorporating:\n    - Heuristic-biased sampling that blends uniform random and goal-directed sampling \n      influenced by a heuristic weight based on distance to goal.\n    - Adaptive max step size that dynamically adjusts based on recent successes to improve exploration.\n    - Cost-to-go heuristic (Euclidean distance to goal) combined with path cost for parent selection.\n    - More aggressive rewiring with limited scope to improve path quality.\n    - Early stopping upon goal reach or 10-second time limit.\n    - Shortcut path smoothing to produce smoother, shorter paths.\n    These modifications aim to improve planning efficiency, path quality, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n        # Track success rate for adaptive max_dist adjustments\n        self._success_in_last_iter = []\n\n    def _heuristic_cost(self, position: Point) -> float:\n        # Heuristic function: Euclidean distance to goal\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(position, goal_pos)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, heuristic_weight=0.7, goal_bias=0.15) -> Point:\n        \"\"\"\n        Sample with:\n        - With goal_bias probability, directly sample goal to bias tree growth.\n        - Otherwise sample with heuristic bias: sample points closer to goal with higher probability.\n        - Fall back to uniform sampling when heuristic biased sample invalid.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        if np.random.random() < goal_bias:\n            return goal_pos\n\n        attempt = 0\n        max_attempts = 50\n        while attempt < max_attempts:\n            # Sample uniformly in grid\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_pos)\n\n            # Probability to accept based on heuristic (closer to goal preferred)\n            max_dist_est = np.sqrt(sum(size**2))\n            h = self._heuristic_cost(sample)\n            accept_prob = (max_dist_est - h) / max_dist_est  # nearer => higher probability\n            accept_prob = accept_prob ** heuristic_weight\n\n            if np.random.random() < accept_prob and grid.is_agent_valid_pos(sample):\n                return sample\n\n            attempt += 1\n\n        # Fallback uniform valid sample\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace from goal to start through parents, pick lowest cost parent at multi-parent junctions\n        path = [q_last]\n        while len(path[-1].parents) != 0:\n            current_vertex = path[-1]\n            min_parent = None\n            min_c = float(\"inf\")\n            for p in current_vertex.parents:\n                if p.cost < min_c:\n                    min_c = p.cost\n                    min_parent = p\n            path.append(min_parent)\n        path.reverse()\n\n        # Shortcut path for smoothing\n        path = self._shortcut_path(path)\n\n        # Animate agent movement along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        # Improved shortcut: attempt to skip multiple intermediates with greedy check\n        shortened = [path[0]]\n        n = len(path)\n        i = 0\n        grid = self._get_grid()\n        while i < n - 1:\n            j = n - 1  # attempt jump to farthest reachable vertex\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(shortened[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened.append(path[j])\n            i = j\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n\n        max_dist_min = 3.0\n        max_dist_max = 18.0\n        max_dist = max_dist_max\n        iteration_limit = 10000\n        goal_radius = max(grid.goal.radius, 1)\n\n        start_time = time.time()\n\n        # Maintain history of success (adding new vertex) to tune max_dist adaptively every window\n        adapt_window = 50\n        success_history = []\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: stop early\n                break\n\n            # Adaptive max_dist:\n            # Increase step size if recent success rate high, else decrease step size for precision\n            if len(success_history) == adapt_window:\n                success_rate = sum(success_history) / adapt_window\n                if success_rate > 0.7:\n                    max_dist = min(max_dist_max, max_dist * 1.1)\n                elif success_rate < 0.3:\n                    max_dist = max(max_dist_min, max_dist * 0.7)\n                success_history.clear()\n\n            # Heuristic-biased and goal-biased sampling combined\n            q_sample = self._get_random_sample(heuristic_weight=0.7, goal_bias=0.15)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                success_history.append(False)\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                success_history.append(False)\n                continue\n\n            # Find neighbors within radius for rewiring (RRT* style), radius based on max_dist and iteration size\n            radius = min(max_dist * 3.0, 25)  # slightly smaller radius for rewiring to limit processing\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select parent that minimizes sum of cost-to-come and heuristic cost-to-go\n            min_total_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Validate edge neighbor->q_new\n                line_seq_nw = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                heuristic_cost = self._heuristic_cost(q_new.position)\n                total_cost = cost_through_n + heuristic_cost\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # Fallback to q_near if line valid\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    success_history.append(False)\n                    continue\n                parent_for_new = q_near\n                min_total_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) + self._heuristic_cost(q_new.position)\n\n            # Set real cost as cost-to-come\n            cost_to_come = min_total_cost - self._heuristic_cost(q_new.position)\n            q_new.cost = cost_to_come\n            self._graph.add_edge(parent_for_new, q_new)\n            success_history.append(True)\n\n            # Rewire neighbors: if going through q_new improves cost-to-come, rewire (limit rewiring to neighbors with better cost)\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old edges from all parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if goal reached within radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                final_goal_pos = grid.goal.position\n                line_seq_goal = grid.get_line_sequence(q_new.position, final_goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    final_goal_vertex = Vertex(final_goal_pos)\n                    final_goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, final_goal_vertex)\n                    self._extract_path(final_goal_vertex)\n                    break\n\n            # Keyframe for visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "PathPlanning is an improved sample-based pathfinding algorithm inspired by RRT*.\n    It incorporates goal-biased sampling to bias exploration towards the goal,\n    adaptive step size depending on distance to goal for efficiency,\n    and rewiring to optimize the tree for shorter, smoother paths.\n    The algorithm also performs shortcut smoothing on the final path to improve path quality.\n    Early stopping is enforced by a 10-second timeout. This approach improves\n    success rate, path smoothness, and planning efficiency compared to baseline RRT.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Enable rewiring in RRT*\n        self._init_displays()\n        self._goal_sample_rate = 0.2       # 20% samples goal biased\n        self._max_dist_default = 10.0      # max extension distance\n        self._rewire_radius = 15.0         # radius for rewiring neighbors\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with some prob sample goal position directly\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, q_near: Vertex, neighbors: List[Vertex], q_new: Vertex) -> Vertex:\n        # Among neighbors, choose the parent leading to minimum total cost path to q_new\n        min_cost = float('inf')\n        best_parent = q_near\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # For each neighbor, try to see if connecting from q_new reduces cost and path is valid\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Rewire edges\n                if neighbor.parents:\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = new_cost\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut by connecting non-adjacent vertices directly if path is valid\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(shortcut_path[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from q_new to root (start) by parents\n        path = [q_new]\n        while path[-1].parents:\n            # Choose parent with lowest cost (should be only one if tree)\n            parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path for smoothness\n        path = self._shortcut_path(path)\n\n        # Animate traversal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time: float = time()\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iterations: int = 10000\n\n        for i in range(iterations):\n            current_time = time()\n            if current_time - start_time > 10.0:\n                # Timeout after 10 seconds: treat as no path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size: smaller step near goal for precision\n            dist_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = min(self._max_dist_default, dist_to_goal * 0.5 + 1.0)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewire radius\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, self._rewire_radius\n            )\n            # Choose best parent among neighbors (including q_near)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            best_parent = self._choose_parent(q_near, neighbors, q_new)\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to potentially improve paths\n            neighbors_without_new = [v for v in neighbors if v != best_parent and v != q_new]\n            self._rewire(q_new, neighbors_without_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner enhances the RRT* backbone by integrating heuristic-guided sampling\n    combining uniform random and informed elliptical sampling focused on the region between start \n    and goal to reduce wasted samples and improve convergence rate. It adaptively adjusts step size \n    using environment clearance and dynamically adapts the rewiring radius based on node density to \n    balance exploration and refinement. Additionally, it performs incremental path smoothing during \n    exploration by shortcutting local connections at each iteration to encourage smoother trajectories.\n    Early stopping if goal is reached or timeout after 10 seconds ensures practical responsiveness.\n    This combination improves planning efficiency, path quality, robustness, and success rate.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring with edge removals.\n        self._init_displays()\n        self._max_runtime_seconds = 10.0\n        self._base_search_radius = 15.0\n        self._goal_bias = 0.25\n        self._max_iterations = 8000  # Slightly reduced for efficiency\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Sample from the ellipse defined by the start-goal line and current best cost to bias sampling in promising region.\n        If no valid path cost known, fall back to goal-biased uniform sampling.\n        \"\"\"\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        goal = self._graph.root_vertex_goal.position\n\n        # Approximate current best cost (start to goal) - if no solution yet, return None\n        best_cost = None\n        # Find best cost among vertices connected to goal within radius 3*agent radius or small threshold\n        radius_search = 3.0\n        near_to_goal = self._graph.get_vertices_within_radius([self._graph.root_vertex_goal], goal, radius_search)\n        if near_to_goal:\n            best_cost = min(v.cost + grid.get_movement_cost(v.position, goal) for v in near_to_goal if v.cost < float('inf'))\n\n        if best_cost is None or best_cost == float('inf'):\n            # No informed sample possible, do goal-biased uniform sample\n            return self._get_random_sample(self._goal_bias)\n\n        c_best = best_cost\n        c_min = Map.get_distance(start, goal)\n        if c_min == 0:\n            return goal\n\n        # Create ellipse parameters\n        center = Point(*((start.to_tensor() + goal.to_tensor()) / 2).tolist())\n        a = c_best / 2.0  # major axis radius\n        b = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0  # minor axis radius, safe guard b>0\n        if b <= 0:\n            return self._get_random_sample(self._goal_bias)  # fallback\n\n        # Sampling in unit circle\n        while True:\n            theta = np.random.uniform(0, 2 * np.pi)\n            r = np.sqrt(np.random.uniform(0, 1))  # uniform in circle\n            x = r * np.cos(theta)\n            y = r * np.sin(theta)\n\n            # Rotate and scale to ellipse in 2D\n            direction = (goal.to_tensor() - start.to_tensor()).numpy()\n            dx, dy = direction[0], direction[1]\n            angle = np.arctan2(dy, dx)\n            sample_x = a * x\n            sample_y = b * y\n            rot_x = sample_x * np.cos(angle) - sample_y * np.sin(angle)\n            rot_y = sample_x * np.sin(angle) + sample_y * np.cos(angle)\n\n            sample_point_array = center.to_tensor().numpy()\n            sample_point_array[0] += rot_x\n            sample_point_array[1] += rot_y\n\n            # Round and clamp within grid bounds\n            sample_coords = np.clip(np.round(sample_point_array).astype(int), 0, grid.size.n_dim - 1)\n            sample = Point(*sample_coords)\n\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _local_shortcut(self, path: list) -> list:\n        \"\"\"\n        Perform incremental shortcut smoothing on a partial path by testing and replacing\n        local sub-paths if a direct connection without obstacle is possible.\n        \"\"\"\n        smoothed = [path[0]]\n        idx = 1\n        while idx < len(path):\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed[-1].position, path[idx].position)):\n                idx += 1  # can skip intermediate vertices\n            else:\n                smoothed.append(path[idx - 1])\n        smoothed.append(path[-1])\n        return smoothed\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        start_time = time.time()\n        iter_count = 0\n\n        # Dynamically scale rewiring radius with number of vertices and environment dimension (2D assumed)\n        def dynamic_radius(n_vertices: int) -> float:\n            eta = self._base_search_radius\n            dim = 2  # 2D grid environment assumed\n            gamma_rrt_star = eta * ((np.log(n_vertices + 1) / (n_vertices + 1)) ** (1 / dim))\n            gamma_rrt_star = np.clip(gamma_rrt_star, 3.0, self._base_search_radius)\n            return gamma_rrt_star\n\n        while iter_count < self._max_iterations:\n            # Timeout check\n            if time.time() - start_time > self._max_runtime_seconds:\n                break\n\n            iter_count += 1\n\n            # Use a mixed sampling strategy: 50% informed ellipse, 25% goal bias, 25% uniform valid\n            sample_prob = np.random.rand()\n            if sample_prob < 0.5:\n                q_sample = self._informed_sample()\n            elif sample_prob < 0.75:\n                q_sample = grid.goal.position\n            else:\n                # Uniform random valid\n                while True:\n                    rand_coords = np.random.randint(0, grid.size, grid.size.n_dim)\n                    q_sample_candidate = Point(*rand_coords)\n                    if grid.is_agent_valid_pos(q_sample_candidate):\n                        q_sample = q_sample_candidate\n                        break\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Get neighbors with dynamic radius based on current graph size\n            radius = dynamic_radius(self._graph.size)\n            q_near_list = self._get_near_vertices(q_new, radius)\n\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors excluding chosen_parent to improve path costs\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Incremental shortcut smoothing on recent local graph branch connected to q_new\n            # Extract local path to start as a list for smoothing attempts\n            local_path = []\n            v = q_new\n            while v and len(local_path) < 20:\n                local_path.append(v)\n                if v.parents:\n                    v = min(v.parents, key=lambda p: p.cost)\n                else:\n                    break\n            local_path.reverse()\n            if len(local_path) > 2:\n                smoothed_local_path = self._local_shortcut(local_path)\n                # Rewire graph edges to smoothed connections\n                for idx in range(len(smoothed_local_path) - 1):\n                    parent_v = smoothed_local_path[idx]\n                    child_v = smoothed_local_path[idx + 1]\n                    line_seq = grid.get_line_sequence(parent_v.position, child_v.position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove old edges from child_v parents to child_v if not parent_v\n                        for p in list(child_v.parents):\n                            if p != parent_v:\n                                self._graph.remove_edge(p, child_v)\n                        if parent_v not in child_v.parents:\n                            self._graph.add_edge(parent_v, child_v)\n                        child_v.cost = parent_v.cost + grid.get_movement_cost(parent_v.position, child_v.position)\n\n            # Check goal reached with radius threshold using agent's radius * 2\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Extract, smooth final path with global shortcutting and trace it\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Algorithm Description:\n    An enhanced RRT*-inspired path planning algorithm with improved smoothness and efficiency. \n    Key improvements include:\n    - Adaptive max step size scaled by proximity to goal and tree size for balanced exploration/exploitation.\n    - Mixed sampling: uniform, goal-biased, and adaptive ellipsoidal informed sampling to effectively focus search space.\n    - Heuristic-guided parent selection integrating past cost + admissible heuristic to promote faster convergence.\n    - Dynamic neighborhood radius for rewiring based on tree size and dimension supporting local optimal paths.\n    - Early pruning in rewiring step to minimize unnecessary graph edges and improve path quality.\n    - Multi-pass path shortcutting with randomized shortcuts and smoothing of path points (Bezier interpolation).\n    - Early termination if a better or equal cost path is found connecting directly to the goal.\n    - Adaptive iteration stopping by runtime limit (10 seconds).\n    - Robust to obstacle configurations through line validity checks and sampling retries.\n    Overall this algorithm improves planning speed, success rate, and generates smoother paths than standard RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        # can add new member vars here if needed\n        self._smooth_iterations = 5  # Number of post-processing smoothing passes\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Straight-line Euclidean distance as admissible heuristic\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 600 / (self._graph.size + 1))  # slightly more aggressive pruning\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor\n        return scaled_step\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal biased sampling radius scaled by adaptive max step size for more informed focus\n        goal_sample_radius = self._get_adaptive_max_dist(grid.goal.position) * 1.5\n\n        if rand_val < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            for _ in range(50):\n                sample_offset = torch.randn(2)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    sample_offset = sample_offset / norm\n                sample_offset *= (torch.rand(1).item() * goal_sample_radius)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # ellipsoidal informed sampling within current best cost bound\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            for _ in range(150):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(2)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            return self._graph.root_vertex_start.position\n\n    def _bezier_interpolate(self, path_points: list, granularity: int = 6) -> list:\n        # Smooth path via quadratic Bezier interpolation for finer smoothing\n        if len(path_points) < 3:\n            return path_points[:]\n\n        def bezier(p0, p1, p2, t):\n            return (1 - t) ** 2 * p0 + 2 * (1 - t) * t * p1 + t ** 2 * p2\n\n        import torch\n        interpolated_path = []\n        pts_tensor = torch.tensor([[p.position.x, p.position.y] for p in path_points], dtype=torch.float32)\n        n = len(path_points)\n\n        interpolated_path.append(path_points[0])\n        for i in range(n - 2):\n            p0 = pts_tensor[i]\n            p1 = pts_tensor[i + 1]\n            p2 = pts_tensor[i + 2]\n\n            for step in range(1, granularity):\n                t = step / granularity\n                pt_vec = bezier(p0, p1, p2, t)\n                interp_point = Point(int(round(pt_vec[0].item())), int(round(pt_vec[1].item())))\n                interpolated_path.append(Vertex(interp_point))\n\n            interpolated_path.append(path_points[i + 1])\n        interpolated_path.append(path_points[-1])\n        return interpolated_path\n\n    def _extract_path_and_smooth(self, goal_vertex: Vertex):\n        grid = self._get_grid()\n\n        # Extract path from root to goal vertex\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Multi-pass robust shortcut smoothing with randomized shortcuts followed by Bezier smoothing\n        smoothing_passes = self._smooth_iterations\n        for _pass in range(smoothing_passes):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        shortened = True\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n\n        # After shortcutting, run Bezier interpolation smoothing\n        bezier_smoothed_path = self._bezier_interpolate(path, granularity=6)\n\n        # Move agent along the smoothed path with key frames for animation\n        for vertex in bezier_smoothed_path:\n            if grid.is_agent_valid_pos(vertex.position):\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        dimension = 2\n        max_iterations = self._max_iterations\n        lambda_rrt_star = self._lambda_rrt_star\n\n        for iteration in range(max_iterations):\n            current_time = time.time()\n            if current_time - self._start_time > self._time_limit_seconds:\n                # Early stop when over time limit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n\n            pos_tensor = q_nearest.position.to_tensor().float()\n            sample_tensor = q_sample.to_tensor().float()\n            direction = sample_tensor - pos_tensor\n            dir_norm = torch.norm(direction).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = direction / dir_norm\n                new_pos_tensor = pos_tensor + dir_normalized * max_dist\n                q_new_pos = Point.from_tensor(new_pos_tensor.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(lambda_rrt_star * ((ln_card_v / card_v) ** (1.0 / dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic + cost guided minimum cost parent selection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n            h_q_min = self._heuristic_cost(q_min.position, goal_pos)\n            h_q_new = self._heuristic_cost(q_new.position, goal_pos)\n\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_candidate = self._heuristic_cost(q_near.position, goal_pos)\n                # Select parent with minimal f = cost + heuristic guided by also new node heuristic\n                if (cost_candidate + h_q_new) < (c_min + h_q_min):\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n                        h_q_min = heuristic_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if cost improves, pruning redundant or worsening connections\n            neighbors_to_rewire = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_rewire:\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-7 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one parent edge to maintain tree structure\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal_check = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal_check):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                        # Early termination on connecting goal with best path found\n                        if self._best_cost < float('inf'):\n                            break\n\n            # Keyframe update every 30 iterations for smoother visualization and responsiveness\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if found_goal:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm combining goal-biased adaptive informed sampling,\n    heuristic-guided dynamic expansion, efficient rewiring optimization, and advanced progressive \n    path smoothing. Key improvements:\n    - Adaptive max step size scaled with proximity to goal and tree size for balanced exploration.\n    - Hybrid sampling mixing uniform, goal-biased, and informed ellipsoidal focused by current best cost.\n    - Heuristic cost combining traveled cost and Euclidean admissible heuristic to prioritize expansion.\n    - Dynamic neighborhood radius for rewiring scaled by iteration and tree size.\n    - Early pruning of suboptimal edges during rewiring to reduce clutter and improve tree quality.\n    - Progressive multi-level shortcut smoothing with increasing smoothness attempts over the extracted path.\n    - Early termination immediately on direct, collision-free connection to goal for path efficiency.\n    - Timeout safeguard for max 10 seconds planning time to fail gracefully.\n    This yields faster convergence, higher success rate, smoother and shorter paths, and increased robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        def heuristic_cost(pos: Point) -> float:\n            # Euclidean distance as heuristic\n            return Map.get_distance(pos, goal_pos)\n\n        def compute_radius(iteration: int, n_vertices: int) -> float:\n            # Dynamic rewiring radius based on tree size and iteration count\n            # Using RRT* formula scaled and capped\n            if n_vertices <= 1:\n                return 25.0\n            dim = self._dimension\n            gamma_rrt_star = self._lambda_rrt_star\n            radius = gamma_rrt_star * ((torch.log(torch.tensor(float(n_vertices))) / n_vertices) ** (1.0 / dim))\n            radius_clamped = max(min(radius.item(), 25.0), self._min_max_dist)\n            # Gradually reduce radius as iterations grow to focus rewiring locally\n            radius_dynamic = radius_clamped * max(0.5, 1.0 - iteration / self._max_iterations)\n            return radius_dynamic\n\n        def shortcut_path(path: list) -> list:\n            # Progressive multi-pass shortcutting to aggressively smooth path\n            # Runs passes with descending shortcut attempt counts\n            max_passes = 4\n            grid_local = grid\n            for pass_i in range(max_passes):\n                max_checks = 3 + 2 * pass_i  # increasing number of checks per pass\n                i = 0\n                while i < len(path) - 2:\n                    j = min(i + 1 + max_checks, len(path) - 1)\n                    while j > i + 1:\n                        line_seq = grid_local.get_line_sequence(path[i].position, path[j].position)\n                        if grid_local.is_valid_line_sequence(line_seq):\n                            del path[i + 1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n            return path\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            # Check time limit (max 10 seconds)\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                break\n\n            # Hybrid adaptive sampling: weighted mix of uniform / goal-biased / informed\n            q_sample = self._get_random_sample()\n\n            # Find nearest existing vertex to sample\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                iteration += 1\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            diff = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist_norm = torch.norm(diff).item()\n            if dist_norm == 0:\n                iteration += 1\n                continue\n\n            # Steer towards sample within max_dist\n            if dist_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                direction = diff / dist_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + direction * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                iteration += 1\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                iteration += 1\n                continue\n\n            # Create new vertex and assign cost from q_nearest + edge cost\n            q_new = Vertex(q_new_pos)\n            edge_cost = grid.get_movement_cost(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + edge_cost\n\n            # Determine neighborhood for rewiring\n            n_vertices = max(self._graph.size, 1)\n            radius = compute_radius(iteration, n_vertices)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent minimizing cost + heuristic\n            q_best_parent = q_nearest\n            c_best = q_new.cost  # currently q_nearest cost + edge_cost\n            for q_near in vertices_near:\n                dist_to_new = Map.get_distance(q_near.position, q_new.position)\n                cost_cand = q_near.cost + dist_to_new\n                if cost_cand < c_best:\n                    line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_cand):\n                        q_best_parent = q_near\n                        c_best = cost_cand\n\n            # Attach q_new to best parent\n            q_new.cost = c_best\n            self._graph.add_edge(q_best_parent, q_new)\n\n            # Rewire neighborhood vertices if cost improves with q_new\n            for q_near in vertices_near:\n                if q_near == q_best_parent:\n                    continue\n                dist_new_to_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + 1e-7 < q_near.cost:  # epsilon to avoid oscillations\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge (maintain tree)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check connection possibility to goal for early termination\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Update best found path cost\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early optimal termination since direct connection found\n                    break\n\n            # Periodic visualization step\n            if iteration % 40 == 0:\n                self.key_frame()\n\n            iteration += 1\n\n        # If successful path found, extract and progressively smooth it before moving agent\n        if found_goal is not None:\n            # Extract path from goal vertex back to start\n            path_vertices = []\n            current = found_goal\n            while True:\n                path_vertices.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n            path_vertices.reverse()\n\n            # Run enhanced multi-level shortcut smoothing\n            path_vertices = shortcut_path(path_vertices)\n\n            # Move agent along smooth path with key frames\n            for v in path_vertices:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved clearance-aware sampling combined with heuristic-guided RRT* expansion.\n    Features:\n    - Strong clearance-biased rejection sampling to ensure safer samples.\n    - Dynamically adaptive step size depending on progress, clearance, and tree size.\n    - Enhanced mixed sampling combining goal bias, clearance-aware uniform, and ellipsoidal informed sampling.\n    - Dynamic rewiring radius scaled with both tree size and clearance for efficient graph optimization.\n    - Early pruning of rewiring when cost improvement is negligible to reduce unnecessary work.\n    - Multiple robust shortcut smoothing passes for better path quality.\n    - Early termination on direct goal connections combined with immediate smoothing & key-frame visualization.\n    - Enforced 10-second planning timeout for guaranteed responsiveness.\n    Overall, trades slight sampling overhead for significant gains in safety, path quality, and planning speed.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        \n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        \n        self._best_cost = float('inf')\n        found_goal = None\n        \n        if self._start_time is None:\n            self._start_time = time.time()\n        \n        rewire_threshold = 0.005  # cost improvement threshold for rewiring pruning\n        \n        for iteration in range(self._max_iterations):\n            # Enforce 10 second timeout\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Abort planning if over time\n            \n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                # Sample coincides with existing vertex; skip iteration\n                continue\n            \n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            direction_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(direction_vec).item()\n            if dist < 1e-8:\n                continue\n            \n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = direction_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n            \n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n            \n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            \n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n            \n            # Calculate rewiring/neighborhood radius scaled by tree size and clearance\n            size_tree = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size_tree))).item() if size_tree > 1 else 0.0\n            base_radius = self._lambda_rrt_star * ((ln_size / size_tree) ** (1 / self._dimension))\n            base_radius = min(base_radius, 25.0)\n            \n            clearance_new = self._get_clearance(q_new.position)\n            clearance_factor = 1.0 + min(clearance_new / max(self._clearance_threshold, 1e-6), 1.0)\n            radius = base_radius * clearance_factor\n            \n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n            \n            # Choose parent vertex with best cost + heuristic to goal that has valid connection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                candidate_cost = v.cost + dist_v_new\n                # Check if candidate cost is better and line is free\n                if candidate_cost < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = candidate_cost\n            \n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n            \n            # Rewire neighbors if cost improvement passes threshold and path is collision-free\n            for v_near in near_vertices:\n                if v_near is q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove one old parent (assumes tree structure)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n            \n            # Check if can connect directly to goal with valid line and improved cost\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n                    \n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n                    \n                    # Early termination - found direct path to goal\n                    break\n            \n            if iteration % 30 == 0:\n                self.key_frame()\n        \n        # If goal found, extract and smooth path\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based RRT* inspired planner with goal biasing and rewiring to enhance path quality and success rate.\n    It uses adaptive step size based on distance to sampled point, goal-biased sampling to accelerate reaching the goal,\n    and rewires the tree locally to optimize cost of paths progressively.\n    The path extraction applies smoothing by shortcutting after connection.\n    An early stopping criteria based on time (10 seconds) is implemented to stop search if solution is too slow.\n    This results in more efficient, smoother, and robust path planning in grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges for RRT*\n        self._init_displays()\n\n        # Additional member variables\n        self._goal_sample_rate = 0.2  # 20% goal bias\n        self._search_radius = 15.0  # radius for rewiring (can be adaptive)\n        self._max_step_distance = 15  # max step, adaptive later\n        self._time_limit_seconds = 10  # max planning time allowed\n\n    def _get_adaptive_max_dist(self, dist_to_goal: float) -> float:\n        # Adaptive step size: smaller step when near goal for precision, larger otherwise\n        if dist_to_goal < 20:\n            return max(5, dist_to_goal / 2)\n        return self._max_step_distance\n\n    def _get_random_sample(self) -> Point:\n        import time\n\n        # Goal-biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return super()._get_random_sample()\n\n    def _get_neighbors(self, q_new: Vertex) -> List[Vertex]:\n        # Find vertices within search radius for rewiring\n        neighbors = self._graph.get_vertices_within_radius(\n            [self._graph.root_vertex_start], q_new.position, self._search_radius\n        )\n        return neighbors\n\n    def _choose_parent(self, neighbors: List[Vertex], q_near: Vertex, q_new: Vertex) -> Vertex:\n        # Choose best parent with lowest cost + valid connection\n        min_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new.position)\n        best_parent = q_near\n        for neighbor in neighbors:\n            if neighbor == q_near:\n                continue\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n            ):\n                continue\n            cost = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex) -> None:\n        # For each neighbor, try to connect q_new as better parent to reduce cost\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            ):\n                continue\n            cost_through_qnew = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost:\n                # Rewire edge: remove old edges from parents and add from q_new\n                for parent in list(neighbor.parents):\n                    self._graph.remove_edge(parent, neighbor)\n                self._graph.add_edge(q_new, neighbor)\n                neighbor.cost = cost_through_qnew\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shortcut path by connecting nonadjacent vertices with straight valid lines\n        if len(path) < 3:\n            return path\n\n        shortened_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                next_idx -= 1\n            shortened_path.append(path[next_idx])\n            idx = next_idx\n        return shortened_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract best path by backtracking parents with minimal cost and smooth it\n        path: List[Vertex] = [q_new]\n        current = q_new\n        while current.position != self._graph.root_vertex_start.position:\n            if not current.parents:\n                break\n            min_parent = min(\n                current.parents,\n                key=lambda p: p.cost,\n            )\n            path.append(min_parent)\n            current = min_parent\n        path.reverse()\n\n        # Shortcut path for smoothing\n        path = self._shortcut_path(path)\n\n        # Animate path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        iterations = 10000\n\n        # Initialize start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(iterations):\n            # Early stop if over time limit\n            if time.time() - start_time > self._time_limit_seconds:\n                # Mark no solution found by not extracting path and return\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = self._get_grid().get_distance(q_near.position, q_sample)\n            max_dist = self._get_adaptive_max_dist(self._get_grid().get_distance(q_sample, self._get_grid().goal.position))\n            max_dist = min(max_dist, dist_to_sample)\n            # Get new vertex towards sample but limited by adaptive max_dist\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            if torch.norm(dir_vec) == 0:\n                continue\n            dir_normalized = dir_vec / torch.norm(dir_vec)\n            q_new_pos_tensor = q_near.position.to_tensor() + dir_normalized * max_dist\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            # Skip if new position invalid or same as near\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n            if q_new_pos == q_near.position:\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Find neighbors within radius for rewiring and potential parents\n            neighbors = self._get_neighbors(q_new)\n\n            # Choose best parent among neighbors (including q_near)\n            best_parent = self._choose_parent(neighbors, q_near, q_new)\n            q_new.cost = best_parent.cost + self._get_grid().get_movement_cost(best_parent.position, q_new.position)\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to optimize cost\n            self._rewire(neighbors, q_new)\n\n            # If close to goal, connect and check\n            goal_dist = self._get_grid().get_distance(q_new.position, self._get_grid().goal.position)\n            if goal_dist <= self._max_step_distance:\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, self._get_grid().goal.position)\n                ):\n                    goal_vertex = self._graph.root_vertex_goal\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, self._get_grid().goal.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                        self._extract_path(goal_vertex)\n                        break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Clearance-Enhanced RRT* Inspired PathPlanning Algorithm:\n    This algorithm improves path planning by incorporating explicit clearance-aware sampling and obstacle avoidance heuristics:\n    - Clearance-aware adaptive step size that reduces step length near obstacles for safer expansions.\n    - Clearance-biased sampling: samples are rejected or re-sampled if too close to obstacles, promoting safer path selection.\n    - Heuristic clearance-weighted cost function to prefer paths with higher clearance from obstacles.\n    - RRT*-style local rewiring with dynamic neighborhood radius and early pruning for better path quality.\n    - Goal-biased and ellipsoidal sampling balanced with clearance constraints to guide sampling efficiently.\n    - Robust multi-pass path shortcutting smoothing that respects clearance and obstacle proximity.\n    - Early stopping on valid direct connection to goal.\n    - Timeout limit for search capped at 10 seconds.\n    Overall, the algorithm aims to generate safer, smoother, and more reliable paths that maintain higher clearance from obstacles, improving success rate and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size far from goal\n        self._min_max_dist = 2.5   # Min step size near goal for fine control\n        self._goal_sample_rate = 0.25  # Goal biased sampling probability\n        self._informed_sample_rate = 0.3  # Probability of ellipsoidal informed sampling\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45  # Rewiring radius factor tuning\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._min_clearance = 2.0  # Minimum clearance distance considered safe from obstacles\n        self._clearance_influence_weight = 5.0  # Weight factor in cost for clearance heuristic\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(pos, goal_pos)\n\n    def _clearance_to_nearest_obstacle(self, pos: Point) -> float:\n        \"\"\"\n        Compute minimum Euclidean distance from pos to any obstacle boundary set.\n        Uses obstacle bounds expansion for clearance calculation.\n        \"\"\"\n        grid = self._get_grid()\n        min_dist = float('inf')\n        pos_tensor = pos.to_tensor().float()\n        for obs in grid.obstacles:\n            obs_bound = grid.get_obstacle_bound(obs.position)\n            for bound_p in obs_bound:\n                bd_tensor = bound_p.to_tensor().float()\n                dist = (pos_tensor - bd_tensor).norm().item()\n                if dist < min_dist:\n                    min_dist = dist\n                if min_dist <= 0.0:\n                    return 0.0\n        return min_dist if min_dist != float('inf') else self._max_max_dist\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        \"\"\"\n        Adaptive max step that reduces near both goal and obstacles\n        to improve clearance by shortening steps near obstacles.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist_goal = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n\n        clearance = self._clearance_to_nearest_obstacle(curr_pos)\n        normalized_clearance = max(0.0, min(1.0, clearance / (self._max_max_dist * 0.5)))\n\n        # Combine goal distance-based scaling and clearance-based scaling\n        base_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist_goal\n        max_dist = base_step * normalized_clearance\n        # Ensure not below minimum step\n        return max(max_dist, self._min_max_dist)\n\n    def _clearance_weighted_cost(self, parent_cost: float, parent_pos: Point, child_pos: Point) -> float:\n        \"\"\"\n        Computes cost from parent to child combining distance and clearance penalty.\n        Paths close to obstacles get a higher cost to encourage safer expansions.\n        \"\"\"\n        dist = Map.get_distance(parent_pos, child_pos)\n        clearance = self._clearance_to_nearest_obstacle(child_pos)\n        clearance_penalty = 0.0\n        if clearance < self._min_clearance:\n            clearance_penalty = self._clearance_influence_weight * (self._min_clearance - clearance)\n        return parent_cost + dist + clearance_penalty\n\n    def _sample_with_clearance_check(self) -> Point:\n        \"\"\"\n        Sample a valid point ensuring minimum clearance from obstacles.\n        Uses the existing sampling scheme but rejects samples too close to obstacles.\n        \"\"\"\n        import time\n        import torch\n\n        grid = self._get_grid()\n        attempts = 0\n        max_sample_attempts = 150\n        clearance_threshold = self._min_clearance * 0.7\n        while attempts < max_sample_attempts:\n            sample = self._get_random_sample()\n            clearance = self._clearance_to_nearest_obstacle(sample)\n            if clearance >= clearance_threshold:\n                return sample\n            attempts += 1\n        # Fallback to valid point with no clearance guarantee\n        return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Timeout check (>10 seconds)\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # Sample point with clearance bias\n            q_sample = self._sample_with_clearance_check()\n\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Compute adaptive max distance step size considering clearance\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos_tensor = q_nearest.position.to_tensor().float() + dir_normalized * max_dist\n                q_new_pos = Point.from_tensor(q_new_pos_tensor.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Further check clearance along connecting line for safer edges\n            has_low_clearance = False\n            for p in line_seq:\n                clearance = self._clearance_to_nearest_obstacle(p)\n                if clearance < self._min_clearance * 0.5:\n                    has_low_clearance = True\n                    break\n            if has_low_clearance:\n                # Reject extensions going too close to obstacles\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Rewire radius factor based on tree size and dimension\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic and clearance-weighted parent selection for minimal cost\n            q_min = q_nearest\n            c_min = self._clearance_weighted_cost(q_nearest.cost, q_nearest.position, q_new.position)\n\n            goal_heuristic = self._heuristic_cost(q_new.position, goal_pos)\n\n            for q_near in vertices_near:\n                cost_candidate = self._clearance_weighted_cost(q_near.cost, q_near.position, q_new.position)\n                h_cost_near = self._heuristic_cost(q_near.position, goal_pos)\n                total_candidate = cost_candidate + goal_heuristic\n                total_current = c_min + self._heuristic_cost(q_min.position, goal_pos)\n                if total_candidate < total_current:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        # Check clearance along candidate path segment\n                        clearance_ok = True\n                        for p in line_seq_candidate:\n                            clearance = self._clearance_to_nearest_obstacle(p)\n                            if clearance < self._min_clearance * 0.5:\n                                clearance_ok = False\n                                break\n                        if clearance_ok:\n                            q_min = q_near\n                            c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors with clearance-aware cost improvements\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                cost_through_new = self._clearance_weighted_cost(q_new.cost, q_new.position, q_near.position)\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Check clearance for rewiring edge\n                        clearance_ok = True\n                        for p in line_seq_rewire:\n                            clearance = self._clearance_to_nearest_obstacle(p)\n                            if clearance < self._min_clearance * 0.5:\n                                clearance_ok = False\n                                break\n                        if clearance_ok:\n                            for parent in q_near.parents:\n                                self._graph.remove_edge(parent, q_near)\n                                break\n                            q_near.cost = cost_through_new\n                            self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Ensure clearance on final edge before connecting goal\n                    clearance_ok_goal = True\n                    for p in line_goal:\n                        clearance = self._clearance_to_nearest_obstacle(p)\n                        if clearance < self._min_clearance * 0.5:\n                            clearance_ok_goal = False\n                            break\n                    if clearance_ok_goal:\n                        goal_vertex = Vertex(goal_pos)\n                        cost_to_goal = q_new.cost + dist_to_goal\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                        if cost_to_goal < self._best_cost:\n                            self._best_cost = cost_to_goal\n                            found_goal = goal_vertex\n\n                            # Early termination on direct goal connect with best path\n                            if cost_to_goal < float('inf'):\n                                break\n\n            # Mark key frame visualization every 40 iterations\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            # Smooth extracted path respecting clearance\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Clearance-Aware RRT* Path Planning Algorithm with Variable Step Size, Clearance Maximization, and \n    Heuristic-Guided Sampling",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Adaptive Clearance-Aware RRT* Path Planning Algorithm with Variable Step Size, Clearance Maximization, and \n    Heuristic-Guided Sampling}\n\n    This algorithm improves upon the baseline RRT* approach by:\n    - Incorporating adaptive step size that adjusts based on proximity to obstacles and environment scale for safer expansions.\n    - Using a clearance heuristic to bias sampling towards safer regions with higher clearance from obstacles.\n    - Employing a goal-biased and clearance-biased sampling strategy to improve success and quality.\n    - Implementing dynamic rewiring with a radius based on environment size to optimize tree connectivity and path cost.\n    - Utilizing heuristic cost-to-go estimates (like A*) to guide parent selection and rewiring for better path quality.\n    - Early stopping on goal reach or after 10s time limit.\n    - Shortcut path smoothing after extraction for smoother paths.\n    - Maintains robustness by rejecting extensions with insufficient clearance or invalid paths.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.15        # Probability of sampling the goal directly.\n        self._clearance_sample_rate = 0.25   # Probability to sample high-clearance points.\n        self._rewire_radius_factor = 0.15    # Factor of environment size to set rewire radius.\n        self._max_dist_min = 6                # Minimum max step size.\n        self._max_dist_max = 20               # Maximum max step size.\n        self._max_iterations = 6000           # Limit number of iterations.\n        self._time_limit_sec = 10.0           # 10 seconds max per planning run.\n        self._clearance_check_samples = 5     # Number of points along path to check clearance.\n\n    def _sample_high_clearance(self) -> Point:\n        \"\"\"Sample a random valid point biased towards higher clearance from obstacles.\"\"\"\n        grid = self._get_grid()\n        max_tries = 50\n        best_point = None\n        best_clearance = -1.0\n\n        for _ in range(max_tries):\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            candidate = Point(*rand_pos)\n            if not grid.is_agent_valid_pos(candidate):\n                continue\n\n            clearance = self._estimate_clearance(candidate)\n            if clearance > best_clearance:\n                best_clearance = clearance\n                best_point = candidate\n        # If no better point found (very dense obstacles), fallback to random valid\n        if best_point is None:\n            # fallback uniform random valid position\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                candidate = Point(*rand_pos)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n        return best_point\n\n    def _estimate_clearance(self, pos: Point) -> float:\n        \"\"\"Estimate clearance of position from obstacles using Manhattan distance to nearest obstacle pixel.\"\"\"\n        grid = self._get_grid()\n        obstacles_points = set()\n        for obs in grid.obstacles:\n            obstacles_points.update(grid.get_obstacle_bound(obs.position))\n        # If no obstacles, clearance is infinite (large number)\n        if not obstacles_points:\n            return float('inf')\n        # Compute min manhattan distance to obstacles\n        min_dist = float('inf')\n        for ob_pt in obstacles_points:\n            dist = abs(pos.x - ob_pt.x) + abs(pos.y - ob_pt.y)\n            if dist < min_dist:\n                min_dist = dist\n        return min_dist\n\n    def _adaptive_max_dist(self, q_near: Vertex) -> float:\n        \"\"\"Adapt max step size based on clearance around q_near and environment scale.\"\"\"\n        grid = self._get_grid()\n        clearance = self._estimate_clearance(q_near.position)\n        env_diag = (grid.size.x ** 2 + grid.size.y ** 2) ** 0.5\n        # Normalize clearance roughly relative to environment size\n        norm_clearance = min(clearance / (env_diag * 0.1), 1.0)\n        # Interpolate max dist between min and max bound\n        max_dist = self._max_dist_min + (self._max_dist_max - self._max_dist_min) * norm_clearance\n        return max_dist\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Sample a point with combined goal bias and clearance bias.\"\"\"\n        from random import random\n\n        grid = self._get_grid()\n\n        roll = random()\n        if roll < self._goal_sample_rate:\n            return grid.goal.position\n        elif roll < self._goal_sample_rate + self._clearance_sample_rate:\n            return self._sample_high_clearance()\n        else:\n            # Uniform random valid sample\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Compute direction and clamp by max_dist\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist == 0:\n            return Vertex(q_near.position)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_norm)\n\n        # Adjust q_new_pos slightly towards higher clearance locally (small perturbation)\n        clearance_loc = self._estimate_clearance(q_new_pos)\n        if clearance_loc < 2:\n            # Try small local perturbations to improve clearance\n            best_pos = q_new_pos\n            best_clr = clearance_loc\n            for dx in [-1,0,1]:\n                for dy in [-1,0,1]:\n                    if dx == 0 and dy == 0:\n                        continue\n                    cand = Point(q_new_pos.x + dx, q_new_pos.y + dy)\n                    grid = self._get_grid()\n                    if not (0 <= cand.x < grid.size.x and 0 <= cand.y < grid.size.y):\n                        continue\n                    if not grid.is_agent_valid_pos(cand):\n                        continue\n                    clr = self._estimate_clearance(cand)\n                    if clr > best_clr:\n                        best_clr = clr\n                        best_pos = cand\n            q_new_pos = best_pos\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list[Vertex], q_new: Vertex) -> Vertex:\n        # Use heuristic cost: cost-to-come plus estimated cost-to-goal (Euclidean)\n        grid = self._get_grid()\n        min_cost = float('inf')\n        min_vertex = None\n        goal_pos = grid.goal.position\n        for q_near in q_near_list:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            dist_to_new = grid.get_distance(q_near.position, q_new.position)\n\n            # Check clearance along this edge, reject if clearance low at any sampled point\n            if not self._edge_has_sufficient_clearance(line_seq):\n                continue\n\n            cost_to_come = q_near.cost + dist_to_new\n\n            # Heuristic cost to goal\n            heuristic_to_goal = grid.get_distance(q_new.position, goal_pos)\n\n            total_cost = cost_to_come + heuristic_to_goal\n            if total_cost < min_cost:\n                min_cost = total_cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            # Set actual cost-to-come ignoring heuristic\n            min_vertex_cost_to_new = min_vertex.cost + grid.get_distance(min_vertex.position, q_new.position)\n            q_new.cost = min_vertex_cost_to_new\n            return min_vertex\n        else:\n            return None\n\n    def _edge_has_sufficient_clearance(self, line_seq: list[Point]) -> bool:\n        \"\"\"\n        Checks sampled points on line for minimum clearance to obstacles.\n        We sample several points along the line and reject if clearance too low.\n        \"\"\"\n        if not line_seq:\n            return False\n        grid = self._get_grid()\n        step = max(1, len(line_seq) // self._clearance_check_samples)\n        for idx in range(0, len(line_seq), step):\n            pt = line_seq[idx]\n            clr = self._estimate_clearance(pt)\n            if clr < 1:  # clearance threshold, 1 means touching obstacle adjacency\n                return False\n        return True\n\n    def _rewire(self, q_new: Vertex, neighbors: list[Vertex]) -> None:\n        # Rewire neighbors to q_new if it reduces cost and path valid with clearance\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            # Check clearance along rewiring edge\n            if not self._edge_has_sufficient_clearance(line_seq):\n                continue\n\n            new_cost_to_neighbor = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            heuristic_to_goal = grid.get_distance(q_neighbor.position, goal_pos)\n            new_total_cost = new_cost_to_neighbor + heuristic_to_goal\n            current_cost = q_neighbor.cost + heuristic_to_goal\n\n            if new_total_cost < current_cost:\n                # Remove parents edges\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add edge from q_new to q_neighbor\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost_to_neighbor\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path by traversing parents with minimum cost similar as before\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n        path.reverse()\n\n        # Shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        grid = self._get_grid()\n        # Animate movement along path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Same shortcut smoothing as before but use clearance check internally\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        result = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq) and self._edge_has_sufficient_clearance(line_seq):\n                    break\n                j -= 1\n            result.append(path[j])\n            i = j\n        return result\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        env_diag = (grid.size.x ** 2 + grid.size.y ** 2) ** 0.5\n        rewire_radius = env_diag * self._rewire_radius_factor\n        rewire_radius = max(5, rewire_radius)  # At least some small radius\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Timeout reached, stop search\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new with clearance check\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if not self._edge_has_sufficient_clearance(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached within radius, connect and extract path\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = self._graph.root_vertex_goal\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_to_goal) and self._edge_has_sufficient_clearance(line_to_goal):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning algorithm enhancing memory efficiency and planning robustness:\n    - Uses goal-biased adaptive sampling combined with heuristic-guided expansion.\n    - Implements an adaptive max step size that shrinks near the goal for finer path refinement.\n    - Employs selective rewiring with a dynamic neighborhood radius computed from graph size and distance.\n    - Utilizes a lazy evaluation technique for rewiring to reduce unnecessary edge modifications and memory overhead.\n    - Maintains a simplified forest graph only with start-rooted tree (no dual root structures) to save memory.\n    - Implements early stopping on goal reach or after 10 seconds to constrain runtime.\n    - Smooths and shortcuts paths post-extraction using valid line sequences for better path quality.\n    - Improved sampling retries and vertex reuse to avoid redundant vertex allocations, saving memory.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 4000  # Reduced iterations for efficiency\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        visited_samples = set()\n\n        def vertex_exists_at(pos: Point):\n            # Tries to find existing vertex at pos to avoid duplicates\n            for v in self._graph.root_vertices:\n                if v.position == pos:\n                    return v\n            return None\n\n        for iteration in range(self._max_iterations):\n            if self._start_time is None:\n                self._start_time = time.time()\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Time limit exceeded, stop searching\n                return\n\n            # Sample with goal bias, retrying until unique valid sample found or max tries\n            sample_retry_limit = 30\n            q_sample = None\n            for _ in range(sample_retry_limit):\n                sample_candidate = self._get_random_sample()\n                if sample_candidate not in visited_samples and grid.is_agent_valid_pos(sample_candidate):\n                    q_sample = sample_candidate\n                    visited_samples.add(q_sample)\n                    break\n            if q_sample is None:\n                # Fallback to start vertex pos\n                q_sample = start_vertex.position\n\n            # Find nearest vertex in the tree\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue  # sampled exactly at an existing vertex, skip\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue  # zero distance, skip\n\n            # Steer towards sample with adaptive max step size\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Avoid adding duplicate vertex at q_new_pos\n            q_existing = None\n            # Check only vertices close to q_new_pos to reduce search cost\n            radius_check = 1.5  # small radius to reduce duplicates\n            vertices_close = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius_check)\n            for v in vertices_close:\n                if v.position == q_new_pos:\n                    q_existing = v\n                    break\n\n            if q_existing:\n                # If existing vertex has higher cost through q_nearest, consider rewiring\n                dist_nearest_new = (q_nearest.position.to_tensor() - q_existing.position.to_tensor()).norm().item()\n                new_cost = q_nearest.cost + dist_nearest_new\n                if new_cost < q_existing.cost:\n                    # Check edge validity\n                    line_seq_rewire = grid.get_line_sequence(q_nearest.position, q_existing.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Rewire q_existing to q_nearest\n                        for parent in q_existing.parents:\n                            self._graph.remove_edge(parent, q_existing)\n                            break\n                        q_existing.cost = new_cost\n                        self._graph.add_edge(q_nearest, q_existing)\n                continue  # Do not add a new vertex, skip to next iteration\n\n            # Create new vertex q_new\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = (q_nearest.position.to_tensor() - q_new.position.to_tensor()).norm().item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            # Compute adaptive radius for rewiring neighbors\n            cardinality = float(self._graph.size if self._graph.size > 0 else 1)\n            log_card = max(1.0, torch.log(torch.tensor(cardinality)).item())\n            radius = min(self._lambda_rrt_star * ((log_card / cardinality) ** (1 / self._dimension)), 25.0)\n            radius = max(radius, max_dist)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent from nearby vertices minimizing cost + heuristic\n            q_min = q_nearest\n            c_min = q_new.cost\n\n            for q_near in vertices_near:\n                if q_near.position == q_new.position:\n                    continue\n                dist_near_new = (q_near.position.to_tensor() - q_new.position.to_tensor()).norm().item()\n                tentative_cost = q_near.cost + dist_near_new\n                if tentative_cost < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = tentative_cost\n\n            # Assign best parent and cost\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Lazy rewiring: only consider vertices that improve cost via q_new\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = (q_new.position.to_tensor() - q_near.position.to_tensor()).norm().item()\n                cost_via_new = q_new.cost + dist_new_near\n                if cost_via_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_via_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early goal check: if newly added vertex close enough, try to connect goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            # Key frame update for animation/visualization\n            if iteration % 10 == 0 or iteration == self._max_iterations - 1:\n                self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired path planning algorithm augmenting the backbone ideas of goal-biased sampling,\n    rewiring for path cost minimization, and adaptive step size with additional heuristics and memory\n    efficiency improvements.\n    Key improvements:\n    - Adaptive sampling radius based on local obstacle density to limit neighbor checks and memory footprint.\n    - Informed sampling biased not just by goal but constrained to an ellipsoidal region defined by current\n      best path cost estimate (informed RRT*) to enhance search efficiency.\n    - Early pruning of vertices with costs exceeding current best solution cost to reduce tree growth.\n    - Lazy collision checking deferred until connection attempts to reduce redundant checks.\n    - Dynamic step size adjusting based on success ratio to balance exploration and exploitation.\n    - Rewiring optimized via prioritized neighborhood search under adaptive radius.\n    - Early stopping on goal reach or timeout (10s).\n    - Path smoothing via shortcutting after extraction.\n    This approach balances path quality, computational efficiency, and robustness in grid-based planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n        # Additional members for adaptive behavior\n        self._best_cost = float(\"inf\")\n        self._success_count = 0\n        self._fail_count = 0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_heuristic(self, point: Point) -> float:\n        \"\"\"Estimate heuristic cost-to-go from point to goal.\"\"\"\n        goal_pos = self._get_grid().goal.position\n        return self._get_grid().get_distance(point, goal_pos)\n\n    def _get_informed_sample(self, cost_best: float, start: Point, goal: Point, goal_bias=0.15) -> Point:\n        \"\"\"Sample points inside an ellipsoidal informed sampling region or uniform when no solution yet.\"\"\"\n        import math\n\n        if np.random.random() < goal_bias:\n            return goal\n        if cost_best == float(\"inf\"):\n            # No solution yet, uniform random valid sample\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipse defined by start, goal, and cost_best\n        # This is for 2D or general n-D space\n        c_min = self._get_grid().get_distance(start, goal)\n        if cost_best < c_min:\n            cost_best = float(\"inf\")  # fallback\n\n        # Transformation to ellipsoid space centered on start-goal line\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min\n        # Create orthonormal basis via SVD or gram schmidt\n        # For 2D, a simple basis suffice, for higher dims create basis:\n        n_dim = self._get_grid().size.n_dim\n        U = torch.zeros((n_dim, n_dim))\n        U[:, 0] = a1\n        # Complete orthonormal basis by Gram-Schmidt\n        def gram_schmidt_columns(X):\n            Q, _ = torch.linalg.qr(X)\n            return Q\n\n        # Initialize random matrix with a1 as first col, then orthonormalize\n        if n_dim > 1:\n            remaining = torch.eye(n_dim)\n            remaining[:, 0] = a1\n            Q = gram_schmidt_columns(remaining)\n        else:\n            Q = torch.ones((1, 1))\n\n        # Sample random unit ball in n-D scaled to ellipse radii\n        # Radii:\n        r1 = cost_best / 2.0\n        if cost_best == float(\"inf\"):\n            r2 = r1\n        else:\n            r2 = math.sqrt(cost_best ** 2 - c_min ** 2) / 2.0\n        radii = torch.ones(n_dim) * r2\n        radii[0] = r1\n\n        # Sample uniformly in unit n-ball:\n        while True:\n            x_ball = torch.randn(n_dim)\n            norm_x = torch.norm(x_ball)\n            if norm_x == 0:\n                continue\n            u = x_ball / norm_x\n            radius = np.random.random() ** (1 / n_dim)\n            x_rand_ball = u * radius  # uniformly random in unit ball\n\n            x_rand = torch.zeros(n_dim)\n            for i in range(n_dim):\n                x_rand[i] = x_rand_ball[i] * radii[i]\n\n            sample_tensor = (\n                torch.tensor((start.to_tensor() + goal.to_tensor()), dtype=torch.float32) / 2.0\n                + Q @ x_rand\n            )\n            sample_np = sample_tensor.numpy()\n            sample_point = Point(*np.round(sample_np).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 12.0\n        max_dist_min = 4.0\n        max_dist_max = 18.0\n        iteration_limit = 8000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._best_cost = float(\"inf\")\n\n        max_dist = max_dist_init\n        success_ratio_window = []\n        max_window_length = 50\n\n        # Pre-cache start and goal for heuristics\n        start_pos = start_vertex.position\n        goal_pos = goal_vertex.position\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive max_dist based on recent success ratio\n            if success_ratio_window:\n                success_ratio = sum(success_ratio_window) / len(success_ratio_window)\n                if success_ratio > 0.7:\n                    max_dist = min(max_dist_max, max_dist * 1.05)\n                elif success_ratio < 0.3:\n                    max_dist = max(max_dist_min, max_dist * 0.85)\n\n            # Informed sample using current best cost\n            q_sample = self._get_informed_sample(\n                self._best_cost, start_pos, goal_pos, goal_bias=0.2\n            )\n\n            # Find nearest vertex in tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                success_ratio_window.append(0)\n                if len(success_ratio_window) > max_window_length:\n                    success_ratio_window.pop(0)\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity only on connect attempt (lazy collision checking)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                success_ratio_window.append(0)\n                if len(success_ratio_window) > max_window_length:\n                    success_ratio_window.pop(0)\n                self.key_frame()\n                continue\n\n            # Neighbor radius scaled by sqrt(log(n)/n) for RRT* style with adaptive factor\n            n_vertices = max(1, self._graph.size)\n            gamma_rrt_star = 30.0\n            r_rad = min(\n                max_dist * 2.5,\n                gamma_rrt_star * (math.log(n_vertices) / n_vertices) ** 0.5,\n                30.0,\n            )\n\n            neighbors = self._graph.get_vertices_within_radius(\n                [start_vertex], q_new.position, r_rad\n            )\n\n            # Select best parent using cost-to-come + distance heuristic\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Early prune neighbor if cost estimate worse than current best\n                heuristic_to_goal = self._get_heuristic(q_new.position)\n                estimate_cost = (\n                    neighbor.cost\n                    + self._get_grid().get_distance(neighbor.position, q_new.position)\n                    + heuristic_to_goal\n                )\n\n                if estimate_cost > self._best_cost:\n                    continue\n\n                # Collision check for neighbor -> q_new edge (lazy)\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n\n                cost_through_n = neighbor.cost + self._get_grid().get_distance(\n                    neighbor.position, q_new.position\n                )\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # If no suitable parent, fallback to q_near (already checked line valid)\n                parent_for_new = q_near\n                min_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # If the cost through parent is already worse than best known, skip adding q_new\n            heuristic_to_goal = self._get_heuristic(q_new.position)\n            if min_cost + heuristic_to_goal > self._best_cost:\n                success_ratio_window.append(0)\n                if len(success_ratio_window) > max_window_length:\n                    success_ratio_window.pop(0)\n                self.key_frame()\n                continue\n\n            # Add q_new vertex with parent_for_new\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors for better costs\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove all previous parents' edges to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check if q_new reached goal or within goal radius (with a valid edge to goal)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                final_goal_pos = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    # Add goal vertex connected from q_new\n                    goal_vertex_new = Vertex(final_goal_pos)\n                    goal_vertex_new.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex_new)\n\n                    # Update best cost solution found\n                    if goal_vertex_new.cost < self._best_cost:\n                        self._best_cost = goal_vertex_new.cost\n                        self._extract_path(goal_vertex_new)\n                        # Early stop on good enough path\n                        break\n\n            # Update success/failure ratios for adaptive step size adjustment\n            success_ratio_window.append(1)\n            if len(success_ratio_window) > max_window_length:\n                success_ratio_window.pop(0)\n\n            # Mark key frame for visualization\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Dynamic Step Size, \n    Heuristic-guided Parent Selection, and Efficient Memory Use",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Enhanced RRT* Inspired Path Planning Algorithm with Adaptive Sampling, Dynamic Step Size, \n    Heuristic-guided Parent Selection, and Efficient Memory Use}\n    \n    This algorithm improves upon classical RRT* by:\n    - Using adaptive max_dist step size based on environment scale and distance-to-goal\n    - Incorporating a heuristic combining path cost and estimated remaining distance (A*-like)\n    - Goal-biased and informed sampling within an ellipsoidal region around start and goal to \n      focus sampling within a probable solution space (informed RRT*)\n    - Limiting rewiring radius adaptively to reduce computations and memory overhead\n    - Early path extraction and shortcut smoothing upon goal reach\n    - Early stop if path not found within 10 seconds\n    - Avoiding large neighborhood expansions for rewiring to save memory and CPU cycles\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._goal_sample_rate = 0.20          # Slightly increased goal bias\n        self._initial_max_dist = 15             # Initial max extension distance\n        self._rewire_radius_base = 10           # Base radius for rewiring\n        self._max_iterations = 6000             # Lower max iterations for efficiency\n        self._time_limit_sec = 10.0             # Time limit in seconds\n\n        # Precompute environment scale metric for adaptive use\n        grid_size = self._get_grid().size\n        self._env_scale = max(grid_size)       # Use max dimension as scale for distances\n\n    def _sample_in_ellipsoid(self) -> Point:\n        \"\"\"\n        Samples a point within an ellipsoidal informed set\n        defined by the start and goal positions and current best cost.\n        Falls back to uniform random sampling if no solution yet.\n        \"\"\"\n\n        from random import random\n        import numpy as np\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position.to_tensor()\n        goal = self._graph.root_vertex_goal.position.to_tensor()\n\n        # If no path found yet, use goal bias + uniform random sampling\n        if not hasattr(self, '_best_cost') or self._best_cost == float('inf'):\n            if random() < self._goal_sample_rate:\n                return grid.goal.position\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Informed sampling inside ellipse\n        c_best = self._best_cost\n        c_min = torch.norm(goal - start).item()\n        if c_best < float('inf'):\n            a1 = (goal - start) / c_min  # unit vector from start to goal\n            center = (start + goal) / 2.0\n\n            # Rotation matrix to align x-axis with a1 (for n-D)\n            def rotation_to_x(vec):\n                # Compute rotation matrix aligning vec to x-axis\n                dim = vec.shape[0]\n                x_axis = torch.tensor([1.] + [0.]*(dim-1))\n                v = torch.cross(vec, x_axis)\n                s = torch.norm(v)\n                c = torch.dot(vec, x_axis)\n                if s == 0:\n                    return torch.eye(dim)\n                vx = torch.zeros((dim, dim))\n                if dim == 3:\n                    vx = torch.tensor([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                else:\n                    # For 2D or higher dims - fallback to identity (less optimal)\n                    return torch.eye(dim)\n                R = torch.eye(dim) + vx + vx @ vx * ((1 - c) / (s ** 2))\n                return R\n\n            L = torch.diag(torch.tensor([c_best / 2] + [torch.sqrt((c_best ** 2 - c_min ** 2)) / 2] * (start.shape[0] - 1)))\n            R = rotation_to_x(a1)\n\n            while True:\n                # Sample random point inside unit n-ball\n                u = torch.randn(start.shape[0])\n                normu = torch.norm(u)\n                u = u / normu * (torch.rand(1).item() ** (1 / start.shape[0]))\n\n                # Map to ellipsoid\n                sample_tensor = torch.matmul(R, torch.matmul(L, u)) + center\n                sample_point = Point.from_tensor(sample_tensor.round())\n\n                if 0 <= sample_point[0] < grid.size[0] and 0 <= sample_point[1] < grid.size[1]:\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n\n        # Fallback uniform random sampling if sampling fails\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, dist_to_goal: float) -> float:\n        \"\"\"\n        Adapt max extension distance based on distance to goal and environment scale,\n        encouraging finer exploration near the goal.\n        \"\"\"\n        base = self._initial_max_dist\n        scale = self._env_scale\n        if dist_to_goal > scale * 0.5:\n            return base\n        elif dist_to_goal > scale * 0.2:\n            return base * 0.6\n        else:\n            return max(2.0, base * 0.3)\n\n    def _choose_parent(self, neighbor_list: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Heuristic-guided parent selection based on cost-to-come plus estimated cost-to-goal (A* like).\n        This guides tree growth towards lower total estimated cost.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = self._graph.root_vertex_goal.position\n        min_total_cost = float('inf')\n        selected_parent = None\n\n        for q_near in neighbor_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            g_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            # heuristic cost estimate from q_new to goal (Euclidean distance)\n            h_cost = grid.get_distance(q_new.position, goal_pos)\n            total_cost = g_cost + h_cost\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                selected_parent = q_near\n\n        if selected_parent is not None:\n            selected_parent_cost = selected_parent.cost + grid.get_distance(selected_parent.position, q_new.position)\n            q_new.cost = selected_parent_cost\n            return selected_parent\n\n        return None\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewire neighborhood vertices to q_new if it offers shorter path.\n        Limit rewiring radius to reduce computation and memory overhead.\n        \"\"\"\n        grid = self._get_grid()\n\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove parents leading to higher cost paths\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extracts path by backtracking via parents with minimum cost,\n        followed by shortcut smoothing to produce a near-optimal path.\n        \"\"\"\n        path = [q_goal]\n        current = q_goal\n        while len(current.parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        self._best_cost = float('inf')\n        self._found_goal_vertex = None\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Stop search after time limit - path not found\n                break\n\n            # Use informed sampling (goal bias + ellipsoidal informed region)\n            q_sample = self._sample_in_ellipsoid()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_sample = grid.get_distance(q_near.position, q_sample)\n            dist_to_goal = grid.get_distance(q_sample, goal_vertex.position)\n            max_dist_step = self._adaptive_max_dist(dist_to_goal)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist_step)\n\n            if not grid.is_agent_valid_pos(q_new.position):\n                continue\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Adaptive rewire radius shrinks with iterations to focus rewiring locally\n            iteration_ratio = iteration / self._max_iterations\n            rewire_radius = max(5.0, self._rewire_radius_base * (1 - iteration_ratio))\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n\n            self._rewire(q_new, neighbors)\n\n            # Check if close enough to goal and can connect directly\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_line_seq = grid.get_line_sequence(q_new.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(goal_line_seq):\n                    estimated_goal_cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    if estimated_goal_cost < self._best_cost:\n                        self._best_cost = estimated_goal_cost\n                        goal_vertex.cost = estimated_goal_cost\n                        self._graph.add_edge(q_new, goal_vertex)\n                        self._found_goal_vertex = goal_vertex\n                        # Extract shortened path and stop early for efficiency\n                        self._extract_path(goal_vertex)\n                        break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved path planning algorithm focusing on computational memory efficiency \n    while retaining robustness, efficiency, and path quality.\n\n    Core ideas and improvements:\n    - Memory-efficient tree management by limiting stored vertices: prune distant or unpromising branches dynamically.\n    - Adaptive sampling with combined goal bias, ellipsoidal informed sampling, and clearance-based rejection to reduce needless exploration.\n    - Adaptive step size tuned by local clearance and progress to balance coarse search and precision.\n    - Radius-based rewiring with early pruning to optimize only relevant vertices and reduce overhead.\n    - Early stopping upon direct feasible goal connection found.\n    - Path smoothing with aggressive shortcutting using grid line checks.\n    - Enforced 10-second timeout ensuring timely termination.\n    - Reduced memory footprint by reusing vertices when possible and avoiding duplicate near vertices.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.2\n        self._informed_sample_rate = 0.4\n        self._max_iterations = 2500  # Slightly reduced to focus on efficient sampling\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3\n        self._prune_distance_factor = 1.5  # Factor for pruning distant vertices from best path\n        self._init_displays()\n\n    def _prune_distant_vertices(self, radius_threshold: float, goal_pos: Point) -> None:\n        \"\"\"Prune vertices far beyond current best path cost plus margin to reduce memory.\"\"\"\n        to_remove = []\n        root_vertex = self._graph.root_vertex_start\n        for v in list(self._graph.root_vertices):\n            # Prune vertices further than best cost + margin from start to goal heuristic\n            dist_to_goal = Map.get_distance(v.position, goal_pos)\n            if v.cost + dist_to_goal > self._best_cost * self._prune_distance_factor:\n                # Remove edges to parents and from children to isolate vertex\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                for c in list(v.children):\n                    self._graph.remove_edge(v, c)\n                to_remove.append(v)\n        # Remove vertices from root roots if applicable\n        for v in to_remove:\n            try:\n                self._graph.root_vertices.remove(v)\n            except ValueError:\n                pass\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        iterations_since_prune = 0\n        prune_interval = 100  # prune every 100 iterations\n\n        for iteration in range(self._max_iterations):\n            elapsed_time = time.time() - self._start_time\n            if elapsed_time > self._time_limit_seconds:\n                return  # Timeout enforced\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Check if a vertex already exists at q_new_pos nearby with better cost to avoid unnecessary growth\n            radius_near_check = max_dist * 0.5\n            nearby_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius_near_check)\n            better_exists = False\n            for nv in nearby_vertices:\n                if Map.get_distance(nv.position, q_new_pos) < 1.0 and nv.cost <= q_nearest.cost + dist:\n                    better_exists = True\n                    break\n            if better_exists:\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            # Tentative cost from q_nearest to q_new plus q_nearest cost\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            # Dynamic radius calculation for neighbor search\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 25.0)\n\n            # Inflate radius dynamically by clearance factor (bounded)\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent by cost + distance if connection valid\n            q_min = q_nearest\n            c_min = q_min.cost + dist_qnearest_qnew\n\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate + 1e-5 < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to q_new if it improves cost, apply early pruning threshold\n            rewire_threshold = 0.01\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rew_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rew_line_seq):\n                        # Remove old parent edges (single parent tree)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            # Check connection to goal region for early termination\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early stop: direct goal connection found\n                    break\n\n            # Periodic pruning of distant vertices to reduce memory usage and improve runtime\n            iterations_since_prune += 1\n            if iterations_since_prune >= prune_interval and self._best_cost < float('inf'):\n                self._prune_distant_vertices(self._best_cost * self._prune_distance_factor, goal_pos)\n                iterations_since_prune = 0\n\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            # Extract and smooth path with multiple shortcut passes\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Heuristic Sampling and Anytime Repairing RRT-inspired Algorithm with Bidirectional Search",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Adaptive Heuristic Sampling and Anytime Repairing RRT-inspired Algorithm with Bidirectional Search}\n\n    This algorithm introduces a bidirectional tree expansion approach to improve connection speed between start and goal.\n    Leveraging heuristic-guided adaptive sampling and dynamic step size adjustment, it balances exploration and exploitation.\n    Key features:\n    - Bidirectional growth: simultaneously expands trees from start and goal to meet faster.\n    - Heuristic adaptive max_dist per vertex considering proximity to the goal and obstacles for efficient steps.\n    - Priority queue-based selection of expansion vertices based on f = cost + heuristic (A*-like), improving quality.\n    - Anytime repairing: rewires the trees to optimize paths when connections improve cost.\n    - Shortcut smoothing applied after solution found.\n    - Early termination on first valid connection with path extraction.\n    - Time cutoff at 10 seconds for guaranteed responsiveness.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._time_limit_seconds = 10.0\n        self._max_iterations = 3000\n        self._min_step = 2.0\n        self._max_step = 15.0\n        self._clearance_threshold = 2.5\n        self._lambda_rrt_star = 30\n        self._dimension = 2\n        self._start_time = None\n        self._init_displays()\n\n    def _heuristic(self, pos: Point, goal: Point) -> float:\n        return Map.get_distance(pos, goal)\n\n    def _adaptive_max_step(self, pos: Point) -> float:\n        # Adaptive max step depending on clearance and distance to goal\n        grid = self._get_grid()\n        clearance = self._get_clearance(pos)\n        goal_dist = Map.get_distance(pos, grid.goal.position)\n        max_map_dim = max(grid.size)\n        norm_goal_dist = min(max(goal_dist / max_map_dim, 0.05), 1.0)\n        clearance_factor = min(clearance / (self._clearance_threshold * 1.5), 1.0)\n        step = self._min_step + (self._max_step - self._min_step) * norm_goal_dist * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        min_clearance = float('inf')\n        for obs in grid.obstacles:\n            dist = Map.get_distance(point, obs.position) - obs.radius - grid.agent.radius\n            if dist < min_clearance:\n                min_clearance = dist\n        # Also consider map boundaries\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_clearance, boundary_clearance))\n\n    def _select_vertex_to_expand(self, open_vertices: list, goal: Point) -> Vertex:\n        # Select vertex with minimal f = cost + heuristic\n        best_vertex = None\n        best_f = float('inf')\n        for vertex in open_vertices:\n            f = vertex.cost + self._heuristic(vertex.position, goal)\n            if f < best_f:\n                best_f = f\n                best_vertex = vertex\n        return best_vertex\n\n    def _choose_parent_bidirectional(self, neighbors: list, q_new: Vertex) -> Vertex:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        min_parent = None\n        for neighbor in neighbors:\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_parent = neighbor\n        if min_parent:\n            q_new.cost = min_cost\n        return min_parent\n\n    def _rewire_bidirectional(self, q_new: Vertex, neighbors: list):\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parents to keep tree structure, can be one parent only here\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                neighbor.cost = new_cost\n                self._graph.add_edge(q_new, neighbor)\n\n    def _extract_bidirectional_path(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> None:\n        # Extract path from start tree root to goal tree root through connection vertices\n        path_start = []\n        curr = connect_vertex_start\n        while True:\n            path_start.append(curr)\n            if not curr.parents:\n                break\n            curr = next(iter(curr.parents))\n        path_start.reverse()\n\n        path_goal = []\n        curr = connect_vertex_goal\n        while True:\n            path_goal.append(curr)\n            if not curr.parents:\n                break\n            curr = next(iter(curr.parents))\n\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing multiple passes\n        grid = self._get_grid()\n        for _ in range(3):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(full_path[i].position, full_path[j].position)):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import random\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Initialize open sets for bidirectional trees\n        open_start = [start_vertex]\n        open_goal = [goal_vertex]\n\n        # Containers for all vertices in each tree to enable nearest neighbor search\n        vertices_start = [start_vertex]\n        vertices_goal = [goal_vertex]\n\n        connected = False\n        connection_start = None\n        connection_goal = None\n\n        while not connected:\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Timeout: no path found in time\n                break\n\n            # Alternate growing start and goal trees\n            for tree_side in ('start', 'goal'):\n                if tree_side == 'start':\n                    curr_open = open_start\n                    curr_vertices = vertices_start\n                    other_vertices = vertices_goal\n                    curr_root = start_vertex\n                    sample_goal = goal_pos\n                else:\n                    curr_open = open_goal\n                    curr_vertices = vertices_goal\n                    other_vertices = vertices_start\n                    curr_root = goal_vertex\n                    sample_goal = start_vertex.position\n\n                if not curr_open:\n                    # No nodes to expand, stop this side\n                    continue\n\n                # Select vertex to expand based on A*-style priority\n                q_nearest = self._select_vertex_to_expand(curr_open, sample_goal)\n                if q_nearest is None:\n                    continue\n\n                max_step = self._adaptive_max_step(q_nearest.position)\n\n                # Sample biased toward opposite root area to increase chance of connection\n                # Mix goal bias and uniform random sampling in relevant half space\n                def sample_toward_goal():\n                    # Try biased sample in direction toward target goal area\n                    direction = sample_goal.to_tensor() - q_nearest.position.to_tensor()\n                    if torch.norm(direction) < 1e-8:\n                        return sample_goal\n                    direction = direction / torch.norm(direction)\n                    offset_len = random.uniform(0.0, max_step)\n                    offset_point = q_nearest.position.to_tensor() + direction * offset_len\n                    candidate = Point.from_tensor(offset_point.round().int())\n                    if grid.is_agent_valid_pos(candidate):\n                        return candidate\n                    else:\n                        return None\n\n                q_sample = None\n                for _ in range(15):\n                    candidate = sample_toward_goal()\n                    if candidate is not None:\n                        clearance = self._get_clearance(candidate)\n                        if clearance >= self._clearance_threshold:\n                            q_sample = candidate\n                            break\n                if q_sample is None:\n                    # Fallback uniform random valid sample in environment\n                    for _ in range(30):\n                        coords = [torch.randint(0, grid.size[d], (1,)).item() for d in range(self._dimension)]\n                        candidate = Point(*coords)\n                        if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                            q_sample = candidate\n                            break\n                    if q_sample is None:\n                        # fallback to current position\n                        q_sample = q_nearest.position\n\n                # Move q_nearest toward q_sample clipped by max_step\n                dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n                dist = torch.norm(dir_vec).item()\n                if dist < 1e-8:\n                    continue\n\n                if dist <= max_step:\n                    q_new_pos = q_sample\n                else:\n                    dir_norm = dir_vec / dist\n                    step_pos_tensor = q_nearest.position.to_tensor().float() + dir_norm * max_step\n                    q_new_pos = Point.from_tensor(step_pos_tensor.round().int())\n\n                if not grid.is_agent_valid_pos(q_new_pos):\n                    continue\n\n                line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n\n                q_new = Vertex(q_new_pos)\n\n                # Find neighbors in current tree for parent selection and rewiring\n                size = max(len(curr_vertices), 1)\n                ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n                radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 22.0)\n\n                clearance_new = self._get_clearance(q_new.position)\n                clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n                radius *= clearance_radius_factor\n\n                near_vertices = [v for v in curr_vertices if Map.get_distance(v.position, q_new.position) <= radius]\n\n                # Choose best parent allowing valid connection and minimum cost path\n                parent = self._choose_parent_bidirectional(near_vertices + [q_nearest], q_new)\n                if parent is None:\n                    continue\n\n                self._graph.add_edge(parent, q_new)\n\n                curr_open.append(q_new)\n                curr_vertices.append(q_new)\n\n                # Rewire neighbors to potentially improve cost path\n                self._rewire_bidirectional(q_new, near_vertices)\n\n                # Check connection possibility to nodes in opposite tree\n                near_opposite = [v for v in other_vertices if Map.get_distance(v.position, q_new.position) <= radius]\n\n                connection_found = False\n                for v_opp in near_opposite:\n                    line_seq_connect = grid.get_line_sequence(q_new.position, v_opp.position)\n                    if grid.is_valid_line_sequence(line_seq_connect):\n                        # Connect trees through these vertices\n                        # Connect q_new to v_opp by creating edges both ways in cyclic graph style\n                        self._graph.add_edge(q_new, v_opp)\n                        self._graph.add_edge(v_opp, q_new)\n                        connection_start = q_new if tree_side == 'start' else v_opp\n                        connection_goal = v_opp if tree_side == 'start' else q_new\n                        connected = True\n                        connection_found = True\n                        break\n                if connection_found:\n                    break\n\n                # Remove q_nearest from open list iff fully expanded (to prefer frontier)\n                curr_open.remove(q_nearest)\n\n            if connected:\n                break\n\n        if connected and connection_start is not None and connection_goal is not None:\n            self._extract_bidirectional_path(connection_start, connection_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Algorithm Description:\n    This improved algorithm combines a systematic heuristic-driven incremental search \n    with adaptive local exploration and targeted rewiring for path optimization.\n    It incorporates:\n      - A bounded prioritized queue (min-heap) of vertices sorted by f-cost = g-cost + heuristic,\n        blending A* style best-first search with sampling-based RRT expansion.\n      - Adaptive step size decreasing as vertices near the goal for fine-grained control.\n      - Goal bias in sampling and informed ellipsoidal sampling conditioned on best cost found,\n        balancing exploration and exploitation efficiently.\n      - Early goal connection detection with dynamic cost update and path extraction.\n      - Local neighborhood rewiring with cost improvement checks, ensuring smoother paths.\n      - Multi-pass shortcut smoothing robustly applied after path extraction.\n      - Timeout safety after 10 seconds to avoid infinite computation.\n    This approach aims for efficient convergence to high-quality shortest paths with improved\n    success rate and robustness in complex grid environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        # Parameters for adaptive step size and sampling\n        self._max_step_far = 12.0\n        self._min_step_near = 3.0\n        self._goal_sample_prob = 0.3\n        self._informed_sample_prob = 0.3\n        self._max_iterations = 3000\n        self._dimension = 2\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(pos, goal_pos)\n\n    def _adaptive_step(self, position: Point) -> float:\n        # Step size shrinks near the goal and as graph grows\n        grid = self._get_grid()\n        dist_goal = Map.get_distance(position, grid.goal.position)\n        normalized_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n        size_factor = min(1.0, 200 / (self._graph.size + 1))\n        step = self._min_step_near + (self._max_step_far - self._min_step_near) * normalized_dist * size_factor\n        return step\n\n    def _adaptive_sampling(self, best_cost: float) -> Point:\n        import torch\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal-biased sampling near goal radius\n        if rand_val < self._goal_sample_prob:\n            goal_pos = grid.goal.position\n            for _ in range(30):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    dir_norm = sample_offset / norm\n                else:\n                    dir_norm = sample_offset\n                sample_pt = Point(*(goal_pos.to_tensor().float() + dir_norm * (torch.rand(1).item() * self._min_step_near)).round().int().tolist())\n                if grid.is_agent_valid_pos(sample_pt):\n                    return sample_pt\n            return goal_pos\n\n        # Informed ellipsoidal sampling centered between start and goal if best_cost known\n        elif rand_val < self._goal_sample_prob + self._informed_sample_prob and best_cost < float('inf'):\n            start_pos = grid.agent.position\n            goal_pos = grid.goal.position\n            center = Point(*(((start_pos.to_tensor().float() + goal_pos.to_tensor().float()) / 2).tolist()))\n            diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n            dist_start_goal = torch.norm(diff).item()\n            if dist_start_goal < 1e-8:\n                return start_pos\n            e1 = diff / dist_start_goal\n            # Construct rotation matrix R based on unit vector e1\n            R = torch.tensor([[e1[0].item(), -e1[1].item()], [e1[1].item(), e1[0].item()]])\n            a = best_cost / 2.0\n            b = max((best_cost ** 2 - dist_start_goal ** 2), 1e-6) ** 0.5 / 2.0\n\n            for _ in range(40):\n                theta = 2 * 3.141592653589793 * torch.rand(1).item()\n                r = torch.sqrt(torch.rand(1)).item()\n                x_ball = torch.tensor([r * torch.cos(theta), r * torch.sin(theta)])\n                sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n                sample_world = R @ sample_local + center.to_tensor().float()\n                sample_point = Point.from_tensor(sample_world.round().int())\n                if grid.is_agent_valid_pos(sample_point):\n                    return sample_point\n\n        # Uniform random sampling fallback\n        for _ in range(100):\n            rand_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample_point = Point(*rand_coords)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # If all fail, return start position\n        return self._graph.root_vertex_start.position\n\n    def _shortcut_path(self, path: list):\n        grid = self._get_grid()\n        changed = True\n        while changed:\n            changed = False\n            i = 0\n            while i < len(path) - 2:\n                for j in range(len(path)-1, i+1, -1):\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i+1:j]\n                        changed = True\n                        break\n                i += 1\n\n    def _extract_smooth_path(self, goal_vertex: Vertex) -> None:\n        # Extract and smooth path before animating\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n        self._shortcut_path(path)  # robust shortcut smoothing\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        # Priority queue elements are tuples of (f_cost, g_cost, Vertex)\n        # f_cost = g_cost + heuristic cost to goal\n        queue = []\n        heapq.heappush(queue, (self._heuristic_cost(start_vertex.position, goal_pos), 0.0, start_vertex))\n        visited_positions = {start_vertex.position: start_vertex.cost}\n\n        start_time = time.time()\n\n        iterations = 0\n        while queue and (time.time() - start_time) < self._time_limit_seconds and iterations < self._max_iterations:\n            iterations += 1\n            f_curr, cost_curr, curr_vertex = heapq.heappop(queue)\n\n            # Early stopping if found better or equal path to goal\n            if curr_vertex.position == goal_pos or grid.is_agent_in_goal_radius(curr_vertex.position):\n                # Construct goal vertex connected to curr_vertex if not exact goal pos\n                goal_vertex = Vertex(goal_pos)\n                dist_to_goal = Map.get_distance(curr_vertex.position, goal_pos)\n                cost_to_goal = curr_vertex.cost + dist_to_goal\n                goal_vertex.cost = cost_to_goal\n\n                line_to_goal = grid.get_line_sequence(curr_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal) and cost_to_goal < self._best_cost:\n                    self._graph.add_edge(curr_vertex, goal_vertex)\n                    self._best_cost = cost_to_goal\n                    found_goal_vertex = goal_vertex\n                    break\n\n            # Adaptive step size for expansion\n            step_dist = self._adaptive_step(curr_vertex.position)\n\n            # Sample candidates close to current for local exploration\n            local_samples = []\n            local_samples.append(self._adaptive_sampling(self._best_cost))  # adaptive sampling mix\n            # Also add some small Gaussian perturbation around current vertex position for local search\n            import numpy as np\n            perturbations_added = 0\n            while perturbations_added < 3:\n                delta = np.random.normal(scale=step_dist / 2, size=self._dimension)\n                candidate_pt = Point(*(curr_vertex.position.to_tensor().float() + torch.tensor(delta)).round().int().tolist())\n                if grid.is_agent_valid_pos(candidate_pt):\n                    local_samples.append(candidate_pt)\n                    perturbations_added += 1\n\n            for q_sample in local_samples:\n                if q_sample == curr_vertex.position:\n                    continue\n                dir_vec = q_sample.to_tensor().float() - curr_vertex.position.to_tensor().float()\n                dist_dir = torch.norm(dir_vec).item()\n                if dist_dir == 0:\n                    continue\n                if dist_dir > step_dist:\n                    dir_vec = dir_vec / dist_dir\n                    q_new_pos = Point.from_tensor((curr_vertex.position.to_tensor().float() + dir_vec * step_dist).round().int())\n                else:\n                    q_new_pos = q_sample\n\n                if not grid.is_agent_valid_pos(q_new_pos):\n                    continue\n\n                line_seq = grid.get_line_sequence(curr_vertex.position, q_new_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n\n                new_g_cost = curr_vertex.cost + Map.get_distance(curr_vertex.position, q_new_pos)\n                # Check if this position has been visited with better cost before\n                if q_new_pos in visited_positions and visited_positions[q_new_pos] <= new_g_cost:\n                    continue\n\n                q_new_vertex = Vertex(q_new_pos)\n                q_new_vertex.cost = new_g_cost\n                self._graph.add_edge(curr_vertex, q_new_vertex)\n                visited_positions[q_new_pos] = new_g_cost\n\n                f_cost = new_g_cost + self._heuristic_cost(q_new_pos, goal_pos)\n                heapq.heappush(queue, (f_cost, new_g_cost, q_new_vertex))\n\n                # Rewiring near neighbors with cost improvement\n                # Radius proportional to log|V| / |V|\n                card_v = max(self._graph.size, 1)\n                ln_card = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n                radius = min(40 * ((ln_card / card_v) ** (1 / self._dimension)), 25.0)\n                neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new_vertex.position, radius)\n                for neighbor in neighbors:\n                    if neighbor == curr_vertex or neighbor == q_new_vertex:\n                        continue\n                    dist_n_to_new = Map.get_distance(neighbor.position, q_new_vertex.position)\n                    possible_cost = neighbor.cost + dist_n_to_new\n                    if possible_cost + 1e-7 < q_new_vertex.cost:\n                        line_check = grid.get_line_sequence(neighbor.position, q_new_vertex.position)\n                        if grid.is_valid_line_sequence(line_check):\n                            # Remove old parent edges from q_new_vertex\n                            for p in list(q_new_vertex.parents):\n                                self._graph.remove_edge(p, q_new_vertex)\n                            q_new_vertex.cost = possible_cost\n                            self._graph.add_edge(neighbor, q_new_vertex)\n                            # Update heap with new costs\n                            f_cost_new = q_new_vertex.cost + self._heuristic_cost(q_new_vertex.position, goal_pos)\n                            heapq.heappush(queue, (f_cost_new, q_new_vertex.cost, q_new_vertex))\n\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_smooth_path(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Algorithm Description:\n    This algorithm integrates a hybrid search strategy combining A*-inspired heuristic path growth with \n    adaptive bidirectional sampling and shortcutting. It maintains two growing trees simultaneously \n    rooted at the start and goal positions, respectively. Each iteration attempts to expand the frontier\n    of these trees by sampling points with a bias towards the other tree, improving the chance of connection.\n\n    Key aspects:\n    - Bidirectional Growth: Trees expand from both start and goal, improving connection speed.\n    - Heuristic-guided vertex expansion: Uses cost-to-come (g) and admissible heuristic (h) \n      to prioritize vertex expansion and parent selection.\n    - Adaptive step size (max_dist): dynamically adjusted by clearance estimation and distance to goal.\n    - Connection attempts between trees occur when the frontier nodes come within radius.\n    - Rewiring is applied within each tree to optimize costs locally with pruning based on heuristics.\n    - Path extraction merges the two trees' paths once connected, followed by robust shortcut smoothing.\n    - Early termination after successful connection or timeout after 10s.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Using a CyclicGraph to enable connections forming cycles between two trees\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._max_step = 14.0\n        self._min_step = 3.0\n        self._connection_radius_factor = 12.0\n        self._dimension = 2\n        self._max_iterations = 6000\n        self._goal_bias = 0.2\n        self._timeout_secs = 10\n        self._init_displays()\n\n    def _heuristic(self, pos1: Point, pos2: Point) -> float:\n        # Admissible heuristic (Euclidean distance)\n        return Map.get_distance(pos1, pos2)\n\n    def _adaptive_step_size(self, pos: Point) -> float:\n        # Step size depends on clearance and proximity to goal; smaller near goal or obstacles\n        max_dist = self._max_step\n        min_dist = self._min_step\n        grid = self._get_grid()\n        clearance = max_dist\n        # Sample clearance in cardinal directions within max_dist radius\n        directions = [\n            Point(1,0),\n            Point(-1,0),\n            Point(0,1),\n            Point(0,-1),\n            Point(1,1),\n            Point(-1,-1),\n            Point(1,-1),\n            Point(-1,1)\n        ]\n        for radius in [max_dist, max_dist * 0.75, max_dist * 0.5]:\n            for d in directions:\n                test_tensor = pos.to_tensor().float() + d.to_tensor().float() * radius\n                test_point = Point.from_tensor(test_tensor.round().int())\n                if not grid.is_agent_valid_pos(test_point):\n                    clearance = min(clearance, radius * 0.5)\n            if clearance < max_dist:\n                break\n        # Also reduce step as get closer to goal\n        dist_to_goal = self._heuristic(pos, grid.goal.position)\n        clearance = min(clearance, max(min_dist, dist_to_goal * 0.8))\n        return clearance\n\n    def _sample_towards_tree(self, source_vertex: Vertex, target_vertices: list) -> Point:\n        # Sample a point biased toward the closest vertex in the opposite tree,\n        # or uniform with goal bias fallback.\n        grid = self._get_grid()\n        import numpy as np\n\n        # With some probability sample exactly at the other tree root or goal\n        if np.random.rand() < self._goal_bias:\n            return grid.goal.position\n\n        if not target_vertices:\n            # Fallback uniform random sample\n            for _ in range(100):\n                candidate = Point(*np.random.randint(0, grid.size, self._dimension))\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n            return source_vertex.position\n\n        # Pick nearest vertex in opposite tree\n        target_nearest = min(target_vertices, key=lambda v: self._heuristic(source_vertex.position, v.position))\n        direction_vec = target_nearest.position.to_tensor().float() - source_vertex.position.to_tensor().float()\n        dist = torch.norm(direction_vec).item()\n        if dist < 1e-5:\n            return source_vertex.position\n\n        max_step = self._adaptive_step_size(source_vertex.position)\n        step_len = min(max_step, dist)\n        sample_tensor = source_vertex.position.to_tensor().float() + (direction_vec / dist) * step_len\n\n        sample_point = Point.from_tensor(sample_tensor.round().int())\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n\n        # Try small perturbations around sample_point\n        perturb_offsets = [Point(1,0), Point(-1,0), Point(0,1), Point(0,-1)]\n        for offset in perturb_offsets:\n            candidate = Point(sample_point.x + offset.x, sample_point.y + offset.y)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n\n        # Fallback uniform random sample\n        for _ in range(50):\n            candidate = Point(*np.random.randint(0, grid.size, self._dimension))\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n        return source_vertex.position\n\n    def _extend_tree(self, tree_roots: list, other_tree_roots: list) -> Vertex:\n        # Extend one tree towards samples biased by other tree\n        grid = self._get_grid()\n        from copy import deepcopy\n        # Pick random vertex in tree_roots to expand from (weighted by cost inverse for better frontiers)\n        costs = [max(1e-4, 1.0 / (v.cost + 1)) for v in tree_roots]\n        total = sum(costs)\n        probs = [c / total for c in costs]\n\n        import random\n        q_near = random.choices(tree_roots, weights=probs, k=1)[0]\n\n        q_sample = self._sample_towards_tree(q_near, other_tree_roots)\n\n        direction_tensor = q_sample.to_tensor().float() - q_near.position.to_tensor().float()\n        norm_dir = torch.norm(direction_tensor).item()\n        if norm_dir == 0:\n            return None\n\n        step_dist = self._adaptive_step_size(q_near.position)\n        if norm_dir > step_dist:\n            direction_tensor = direction_tensor / norm_dir * step_dist\n        q_new_pos_tensor = q_near.position.to_tensor().float() + direction_tensor\n        q_new_pos = Point.from_tensor(q_new_pos_tensor.round().int())\n\n        if not grid.is_agent_valid_pos(q_new_pos):\n            return None\n\n        line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n\n        q_new = Vertex(q_new_pos)\n        q_new.cost = q_near.cost + Map.get_distance(q_near.position, q_new_pos)\n\n        # Find neighbors within radius for rewiring\n        n = max(1, len(tree_roots))\n        radius = min(self._connection_radius_factor * (torch.log(torch.tensor(n)).item() / n)**(1/self._dimension), 20.0)\n        q_near_list = self._graph.get_vertices_within_radius(tree_roots, q_new_pos, radius)\n        if q_near_list:\n            # Select best parent (rewire candidate) minimizing cost + line validity\n            min_cost = q_new.cost\n            min_parent = q_near\n            for v in q_near_list:\n                cost_candidate = v.cost + Map.get_distance(v.position, q_new_pos)\n                if cost_candidate < min_cost:\n                    candidate_line = grid.get_line_sequence(v.position, q_new_pos)\n                    if grid.is_valid_line_sequence(candidate_line):\n                        min_cost = cost_candidate\n                        min_parent = v\n            q_new.cost = min_cost\n            self._graph.add_edge(min_parent, q_new)\n        else:\n            self._graph.add_edge(q_near, q_new)\n\n        # Rewire neighbors through q_new for improvement\n        for v in q_near_list:\n            if v == q_new.parents or v == q_new:\n                continue\n            cost_through_new = q_new.cost + Map.get_distance(q_new_pos, v.position)\n            if cost_through_new + 1e-6 < v.cost:\n                line_seq_rewire = grid.get_line_sequence(q_new_pos, v.position)\n                if grid.is_valid_line_sequence(line_seq_rewire):\n                    # Remove all parent edges (prune)\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    v.cost = cost_through_new\n                    self._graph.add_edge(q_new, v)\n\n        return q_new\n\n    def _try_connect_trees(self, vertex_start: Vertex, vertex_goal_list: list) -> (Vertex, Vertex):\n        # Try connecting vertex_start to any vertex in vertex_goal_list by valid line\n        grid = self._get_grid()\n        for v_goal in vertex_goal_list:\n            dist = Map.get_distance(vertex_start.position, v_goal.position)\n            max_dist = self._adaptive_step_size(vertex_start.position)\n            # Use a slightly larger tolerance for connection radius\n            connect_radius = max_dist * 1.2\n            if dist <= connect_radius:\n                line_seq = grid.get_line_sequence(vertex_start.position, v_goal.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    return vertex_start, v_goal\n        return None, None\n\n    def _extract_bidirectional_path(self, connection_start: Vertex, connection_goal: Vertex):\n        # Extract path from start tree root to connection_start\n        path_start = []\n        current = connection_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            # follow parent with minimal cost\n            current = min(current.parents, key=lambda p: p.cost)\n        path_start.reverse()\n\n        # Extract path from goal tree root to connection_goal\n        path_goal = []\n        current = connection_goal\n        while True:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n\n        # Merge paths (start path + reverse of goal path)\n        full_path = path_start + path_goal[::-1]\n\n        # Robust multiple-pass shortcut smoothing\n        grid = self._get_grid()\n        for _ in range(4):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Trace smoothed path\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        start_time = time.time()\n        connected = False\n        connection_vertices = (None, None)\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_secs:\n                break\n\n            # Alternate extension between start and goal trees for bidirectional growth\n            expand_start_tree = (iteration % 2 == 0)\n            if expand_start_tree:\n                q_new = self._extend_tree(tree_start, tree_goal)\n                if q_new is None:\n                    self.key_frame()\n                    continue\n                tree_start.append(q_new)\n\n                # Attempt connection to goal tree\n                c_start, c_goal = self._try_connect_trees(q_new, tree_goal)\n                if c_start and c_goal:\n                    connected = True\n                    connection_vertices = (c_start, c_goal)\n                    break\n\n            else:\n                q_new = self._extend_tree(tree_goal, tree_start)\n                if q_new is None:\n                    self.key_frame()\n                    continue\n                tree_goal.append(q_new)\n\n                # Attempt connection to start tree\n                c_goal, c_start = self._try_connect_trees(q_new, tree_start)\n                if c_start and c_goal:\n                    connected = True\n                    connection_vertices = (c_start, c_goal)\n                    break\n\n            # Periodic bookkeeping and pruning: remove high cost leaves for efficiency\n            if iteration % 200 == 0:\n                threshold_cost_start = max(v.cost for v in tree_start) * 1.2\n                tree_start[:] = [v for v in tree_start if v.cost <= threshold_cost_start]\n                threshold_cost_goal = max(v.cost for v in tree_goal) * 1.2\n                tree_goal[:] = [v for v in tree_goal if v.cost <= threshold_cost_goal]\n\n            if iteration % 25 == 0:\n                self.key_frame()\n\n        if connected and connection_vertices != (None, None):\n            self._extract_bidirectional_path(connection_vertices[0], connection_vertices[1])",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Anytime A*-inspired Sample-Based Algorithm with Adaptive Bidirectional Frontier Wavefront Expansion:\n    - Utilizes a bidirectional forest expansion from both start and goal vertices to rapidly discover a connecting path.\n    - Instead of purely random sampling, employs heuristic-guided frontier wavefront growth focusing on promising regions near the current fronts.\n    - Adaptive max step size computed via local environment obstacle density to balance exploration and fine connection.\n    - Combines heuristic cost (g + h) prioritization with dynamic vertex frontier queues for efficient expansion.\n    - Rewiring is invoked locally near newly added vertices to optimize paths and reduce cost.\n    - Path extraction employs bi-directional meeting point assembly and smoothing via iterative shortcutting.\n    - Enforces a hard 10-second time limit with early termination on connecting the two trees.\n    - Overall, aims for faster convergence, increased robustness by avoiding over-sampling, and smoother, shorter paths by frontier-based control.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        goal_vertex.cost = 0.0\n        self._graph = Forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True  # enable rewiring\n        # Queues to manage frontier vertices for start and goal expansion\n        self._frontier_start = [start_vertex]\n        self._frontier_goal = [goal_vertex]\n        self._max_iteration_limit = 6000\n        self._time_limit_seconds = 10.0\n        self._init_displays()\n\n    def _heuristic(self, pos: Point, goal: Point) -> float:\n        # Euclidean distance heuristic\n        return Map.get_distance(pos, goal)\n\n    def _compute_local_obstacle_density(self, center: Point, radius: int = 5) -> float:\n        # Measure obstacle density around center point by counting obstacle grid points within radius \n        grid = self._get_grid()\n        obstacle_points = 0\n        total_points = 0\n        sz = grid.size\n        cx, cy = center.x, center.y\n        for dx in range(-radius, radius+1):\n            for dy in range(-radius, radius+1):\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < sz[0] and 0 <= ny < sz[1]:\n                    total_points += 1\n                    pt = Point(nx, ny)\n                    if not grid.is_agent_valid_pos(pt):\n                        obstacle_points += 1\n        if total_points == 0:\n            return 0.0\n        return obstacle_points / total_points\n\n    def _adaptive_step_size(self, pos: Point) -> float:\n        # Adapt max step distance based on local obstacle density (smaller near obstacles)\n        base_max = 12.0\n        min_step = 2.5\n        density = self._compute_local_obstacle_density(pos, radius=4)\n        adaptive = base_max * (1.0 - density)\n        return max(min_step, adaptive)\n\n    def _line_collision_free(self, frm: Point, to: Point) -> bool:\n        # Wrapper to check line collision\n        return self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(frm, to))\n\n    def _rewire_nearby(self, q_new: Vertex, radius: float = 10.0) -> None:\n        # Local rewiring: try to improve cost of neighbors near q_new by reconnecting through q_new\n        grid = self._get_grid()\n        nearby = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n        for nbr in nearby:\n            if nbr == q_new:\n                continue\n            cost_through_new = q_new.cost + Map.get_distance(q_new.position, nbr.position)\n            if cost_through_new + 1e-6 < nbr.cost:\n                if self._line_collision_free(q_new.position, nbr.position):\n                    # Remove all old parents\n                    for p in list(nbr.parents):\n                        self._graph.remove_edge(p, nbr)\n                    self._graph.add_edge(q_new, nbr)\n                    nbr.cost = cost_through_new\n\n    def _extract_bidirectional_path(self, meet_vertex_start: Vertex, meet_vertex_goal: Vertex) -> None:\n        # Extract path from start to meet vertex\n        path_start = []\n        curr = meet_vertex_start\n        while True:\n            path_start.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Greedy pick parent with minimum cost\n            curr = min(curr.parents, key=lambda p: p.cost)\n        path_start.reverse()\n\n        # Extract path from meet to goal\n        path_goal = []\n        curr = meet_vertex_goal\n        while True:\n            path_goal.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = min(curr.parents, key=lambda p: p.cost)\n\n        # Combine paths (note: meet vertex appears twice so remove duplicate)\n        full_path = path_start + path_goal[1:]\n\n        # Path shortcutting - iterative multiple passes for smoothing\n        grid = self._get_grid()\n        for _ in range(3):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Animate path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _expand_frontier(self, frontier: list, opposite_root_verts: list, goal_pos: Point) -> (bool, Vertex, Vertex):\n        # Perform one expansion step of frontier wavefront:\n        # - Pop the vertex with lowest cost+heuristic from frontier (priority by cost + h)\n        # - Sample a direction towards unvisited neighbors or random samples around frontier vertex\n        # - Add new vertex if valid, link, rewire neighbors\n        # - Check connection with opposite forest => if connected return (True, connecting vertices)\n\n        from heapq import heappush, heappop, heapify\n\n        if not frontier:\n            return False, None, None\n\n        grid = self._get_grid()\n\n        # Prepare heap queue prioritizing vertices by f = cost + heuristic\n        heap = []\n        for v in frontier:\n            f_score = v.cost + self._heuristic(v.position, goal_pos)\n            heappush(heap, (f_score, v))\n\n        # Pop top candidate for expansion\n        _, curr_vertex = heappop(heap)\n        frontier.remove(curr_vertex)\n\n        max_step = self._adaptive_step_size(curr_vertex.position)\n\n        # Generate candidate expansions: try neighbors from grid moves, augmented by a few random samples biased towards goal\n        candidates = []\n\n        # 1. Neighbors from grid's next positions\n        next_positions = grid.get_next_positions(curr_vertex.position)\n        for nxt in next_positions:\n            if not grid.is_agent_valid_pos(nxt):\n                continue\n            dist = Map.get_distance(curr_vertex.position, nxt)\n            if dist > max_step:\n                # Scale direction vector to max_step distance\n                dir_vec = nxt.to_tensor().float() - curr_vertex.position.to_tensor().float()\n                dir_norm = torch.norm(dir_vec)\n                if dir_norm == 0:\n                    continue\n                dir_normed = dir_vec / dir_norm\n                nxt_scaled = Point.from_tensor((curr_vertex.position.to_tensor().float() + dir_normed * max_step).round().int())\n                if not grid.is_agent_valid_pos(nxt_scaled):\n                    continue\n                candidates.append(nxt_scaled)\n            else:\n                candidates.append(nxt)\n\n        # 2. A few random samples near current vertex biased towards goal\n        import random\n        goal_vec = goal_pos.to_tensor().float() - curr_vertex.position.to_tensor().float()\n        goal_dist = torch.norm(goal_vec).item()\n        for _ in range(3):\n            if goal_dist > 1e-4:\n                dir_goal_norm = goal_vec / goal_dist\n            else:\n                dir_goal_norm = torch.zeros_like(goal_vec)\n            random_offset = torch.randn(2)\n            random_offset = random_offset / (torch.norm(random_offset) + 1e-8)\n            step_length = random.uniform(0.3 * max_step, 1.0 * max_step)\n            combined_vec = 0.7 * dir_goal_norm + 0.3 * random_offset\n            combined_vec = combined_vec / (torch.norm(combined_vec) + 1e-8)\n            sample_pt_tensor = curr_vertex.position.to_tensor().float() + combined_vec * step_length\n            sample_pt = Point.from_tensor(sample_pt_tensor.round().int())\n            if grid.is_agent_valid_pos(sample_pt):\n                candidates.append(sample_pt)\n\n        # Remove duplicates\n        seen_set = set()\n        filtered_candidates = []\n        for c in candidates:\n            if (c.x, c.y) not in seen_set and c != curr_vertex.position:\n                seen_set.add((c.x, c.y))\n                filtered_candidates.append(c)\n\n        # Attempt to add each candidate as a new vertex linked from current vertex, respecting collision check and cost\n        for cand_pos in filtered_candidates:\n            if not self._line_collision_free(curr_vertex.position, cand_pos):\n                continue\n            new_vertex = Vertex(cand_pos)\n            # Cost from start (or goal) + distance\n            new_vertex.cost = curr_vertex.cost + Map.get_distance(curr_vertex.position, cand_pos)\n\n            # Check if vertex already exists in graph (avoid duplication)\n            # Simple check: nearest vertex within radius 1.5\n            near_verts = self._graph.get_vertices_within_radius(self._graph.root_vertices, cand_pos, radius=1.5)\n            if near_verts:\n                # Pick closest vertex, if cost better consider rewiring\n                existing = min(near_verts, key=lambda v: Map.get_distance(v.position, cand_pos))\n                dist_existing = Map.get_distance(existing.position, cand_pos)\n                if dist_existing < 1.0 and existing.cost <= new_vertex.cost + 1e-6:\n                    # Skip adding redundant vertex\n                    continue\n\n            # Add edge and vertex\n            self._graph.add_edge(curr_vertex, new_vertex)\n\n            # Local rewiring\n            self._rewire_nearby(new_vertex, radius=12.0)\n\n            # Check connection to opposite forest vertices (within radius)\n            opposite_near = self._graph.get_vertices_within_radius(opposite_root_verts, new_vertex.position, radius=4.0)\n            for v_opp in opposite_near:\n                # Check collision free connection to opposite vertex\n                if self._line_collision_free(new_vertex.position, v_opp.position):\n                    # Path found linking two trees\n                    # Add edge from new_vertex to v_opp or vice versa for completion\n\n                    # Decide edge direction based on which forest we expand (always child from current)\n                    if curr_vertex in self._graph.root_vertex_start.parents or curr_vertex == self._graph.root_vertex_start:\n                        # curr_vertex is from start forest, connect new_vertex -> v_opp (goal forest)\n                        self._graph.add_edge(new_vertex, v_opp)\n                        return True, new_vertex, v_opp\n                    else:\n                        # curr_vertex from goal forest, connect new_vertex -> v_opp (start forest)\n                        self._graph.add_edge(new_vertex, v_opp)\n                        return True, new_vertex, v_opp\n\n            # Add new vertex to frontier to expand further\n            frontier.append(new_vertex)\n            break  # only add one vertex per expansion step\n\n        return False, None, None\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_time = time.time()\n\n        # Initialize cost on start and goal vertices\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        max_iters = self._max_iteration_limit\n\n        # Frontier lists for bidirectional expansions\n        frontier_start = [start_vertex]\n        frontier_goal = [goal_vertex]\n\n        found = False\n        meet_start = None\n        meet_goal = None\n\n        for iteration in range(max_iters):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit_seconds:\n                break  # timeout, return no path\n\n            # Alternate expansion between start and goal frontier to balance growth\n            expand_from_start = (iteration % 2 == 0)\n\n            if expand_from_start:\n                connected, node_start, node_goal = self._expand_frontier(frontier_start, [goal_vertex], grid.goal.position)\n                if connected:\n                    found = True\n                    meet_start, meet_goal = node_start, node_goal\n                    break\n            else:\n                connected, node_goal, node_start = self._expand_frontier(frontier_goal, [start_vertex], grid.agent.position)\n                if connected:\n                    found = True\n                    meet_start, meet_goal = node_start, node_goal\n                    break\n\n            # Occasionally prune frontier to keep manageable size:\n            if iteration % 100 == 0:\n                # Keep only best 150 vertices on each frontier (by cost+heuristic)\n                def prune(frontier_list, goal_pos):\n                    frontier_list.sort(key=lambda v: v.cost + self._heuristic(v.position, goal_pos))\n                    del frontier_list[150:]\n\n                prune(frontier_start, grid.goal.position)\n                prune(frontier_goal, grid.agent.position)\n\n            if iteration % 20 == 0:\n                self.key_frame()\n\n        if found and meet_start is not None and meet_goal is not None:\n            # Extract and smooth path\n            self._extract_bidirectional_path(meet_start, meet_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm is a hybrid approach integrating informed heuristic search with topological roadmap\n    expansion on a grid, aiming to boost efficiency, robustness, and path quality.\n    Key features include:\n    - A milestone roadmap strategy building multiple connected subgraphs rooted at start and goal to accelerate connection.\n    - Bidirectional exploration growing two forests in parallel with adaptive radius-driven vertex connection attempts.\n    - Heuristic-driven vertex selection prioritizing expansion towards promising regions balancing explored cost + heuristic.\n    - Dynamic sampling combining uniform random, goal bias, and heuristic funneling near existing roadmap vertices.\n    - Efficient rewiring and local optimization restricted to a limited neighborhood for computational tractability.\n    - Multi-level early stopping: immediate connection detection, cost threshold-based termination, and 10-second timeout.\n    - Post-processing uses aggressive multi-pass shortcutting and partial smoothing to enhance final path smoothness.\n    The roadmap and search fusion enable fewer iterations, more consistent success connecting disparate areas,\n    and improved path quality by focusing on strategic expansions instead of pure incremental random growth.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_iterations = 6000\n        self._time_limit_seconds = 10\n        self._goal_sample_rate = 0.2\n        self._uniform_sample_rate = 0.5  # portion of uniform random sampling\n        self._heuristic_sample_rate = 0.3 # funnel around roadmap vertices\n        self._dimension = 2\n        self._lambda_rewire = 30.0\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        return Map.get_distance(pos, goal_pos)\n\n    def _adaptive_max_dist(self, pos: Point, base_min=3.0, base_max=12.0) -> float:\n        # Step size adapts with distance to goal and current best cost for efficiency and safety\n        dist_to_goal = self._heuristic_cost(pos, self._get_grid().goal.position)\n        factor = dist_to_goal / max(self._get_grid().size)\n        factor = max(0.1, min(1.0, factor))\n        step = base_min + (base_max - base_min)*factor\n        # Decrease step if best cost is low, promoting fine expansions near good path\n        if self._best_cost < float('inf'):\n            step = min(step, self._best_cost * 0.25)\n        return step\n\n    def _sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n\n        rand_val = torch.rand(1).item()\n        # Goal bias sampling\n        if rand_val < self._goal_sample_rate:\n            return grid.goal.position\n\n        # Funnel sampling near existing vertices to encourage roadmap connection\n        elif rand_val < self._goal_sample_rate + self._heuristic_sample_rate and self._graph.size > 10:\n            # Randomly pick a vertex from graph for funnel sample generation\n            vertices_pool = self._graph.root_vertices + list(self._graph.root_vertex_start.children)\n            if not vertices_pool:\n                return self._graph.root_vertex_start.position\n            v = vertices_pool[torch.randint(0, len(vertices_pool), (1,)).item()]\n            center = v.position\n            radius = 5\n            for _ in range(30):\n                offset = torch.randn(self._dimension)\n                norm = torch.norm(offset)\n                if norm > 1e-8:\n                    offset = offset / norm\n                radius_sample = torch.rand(1).item() * radius\n                pt = Point(*(center.to_tensor() + offset * radius_sample).round().int().tolist())\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n            return center\n\n        # Uniform random sampling\n        else:\n            for _ in range(100):\n                rand_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                pt = Point(*rand_coords)\n                if grid.is_agent_valid_pos(pt):\n                    return pt\n            # fallback\n            return self._graph.root_vertex_start.position\n\n    def _try_connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        # Attempt to connect two vertices with edge if line valid and update costs for better paths\n        grid = self._get_grid()\n        if v_from.position == v_to.position:\n            return False\n        line_seq = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line_seq):\n            return False\n        dist = Map.get_distance(v_from.position, v_to.position)\n        potential_cost = v_from.cost + dist\n        if potential_cost < v_to.cost:\n            # Rewire costs and edges accordingly\n            for p in list(v_to.parents):\n                self._graph.remove_edge(p, v_to)\n            self._graph.add_edge(v_from, v_to)\n            v_to.cost = potential_cost\n            return True\n        return False\n\n    def _rewire_local(self, q_new: Vertex) -> None:\n        grid = self._get_grid()\n        radius = self._lambda_rewire\n        near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            dist = Map.get_distance(q_new.position, v.position)\n            cost_through_new = q_new.cost + dist\n            if cost_through_new + 1e-6 < v.cost:\n                line_seq = grid.get_line_sequence(q_new.position, v.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        # Extract path back to start vertex and aggressively shortcut for smoothness\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # choose parent with min cost\n            best_parent = min(current.parents, key=lambda p: p.cost)\n            current = best_parent\n        path.reverse()\n\n        grid = self._get_grid()\n        # Multi-pass shortcutting: greedily remove intermediate vertices when direct connection valid\n        improved = True\n        attempts = 0\n        max_attempts = 5\n        while improved and attempts < max_attempts:\n            improved = False\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove intermediate vertices i+1 to j-1 inclusive\n                        del path[i+1:j]\n                        improved = True\n                        break\n                    j -= 1\n                i += 1\n            attempts += 1\n\n        # Trace agent along path\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Bidirectional forest roots to grow closer from both ends\n        roots = [self._graph.root_vertex_start, self._graph.root_vertex_goal]\n\n        for iter_i in range(self._max_iterations):\n            if time.time() - self._start_time > self._time_limit_seconds:\n                # Timeout: fail search\n                break\n\n            # Choose root to expand alternately\n            root_idx = iter_i % 2\n            root_vertex = roots[root_idx]\n            opposing_root = roots[1 - root_idx]\n\n            q_sample = self._sample()\n\n            # Select best expansion base vertex among forest vertices near sample + heuristic cost\n            close_vertices = self._graph.get_vertices_within_radius([root_vertex], q_sample, radius=15.0)\n            if not close_vertices:\n                base_vertex = self._graph.get_nearest_vertex([root_vertex], q_sample)\n            else:\n                # Heuristic-augmented selection: cost + heuristic to goal/opposite root\n                base_vertex = min(\n                    close_vertices,\n                    key=lambda v: v.cost + self._heuristic_cost(v.position, goal_pos if root_vertex == self._graph.root_vertex_start else self._graph.root_vertex_start.position)\n                )\n\n            if base_vertex.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(base_vertex.position)\n            dir_vec = q_sample.to_tensor().float() - base_vertex.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir == 0:\n                continue\n\n            if norm_dir <= max_dist:\n                new_pos = q_sample\n            else:\n                dir_unit = dir_vec / norm_dir\n                new_pos = Point.from_tensor((base_vertex.position.to_tensor().float() + dir_unit * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(new_pos):\n                continue\n            line_seq = grid.get_line_sequence(base_vertex.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(new_pos)\n            dist_inc = Map.get_distance(base_vertex.position, q_new.position)\n            q_new.cost = base_vertex.cost + dist_inc\n            self._graph.add_edge(base_vertex, q_new)\n\n            # Attempt connections to opposing forest vertices to link start and goal trees\n            connect_radius = 12.0\n            near_opp_verts = self._graph.get_vertices_within_radius([opposing_root], q_new.position, connect_radius)\n\n            connected = False\n            for opp_v in near_opp_verts:\n                line_conn = grid.get_line_sequence(q_new.position, opp_v.position)\n                if grid.is_valid_line_sequence(line_conn):\n                    total_cost = q_new.cost + Map.get_distance(q_new.position, opp_v.position) + opp_v.cost\n                    if total_cost < self._best_cost:\n                        # Connect by adding edge\n                        bridge_vertex = Vertex(opp_v.position)\n                        bridge_vertex.cost = opp_v.cost\n                        self._graph.add_edge(q_new, bridge_vertex)\n                        self._best_cost = total_cost\n                        found_goal_vertex = bridge_vertex\n                        connected = True\n                        break\n            if connected:\n                break\n\n            # Local rewiring for cost lowering\n            self._rewire_local(q_new)\n\n            # Early pruning: Stop if within goal radius on start-to-goal tree\n            if root_vertex == self._graph.root_vertex_start:\n                if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                    if q_new.cost < self._best_cost:\n                        self._best_cost = q_new.cost\n                        found_goal_vertex = q_new\n                        break\n\n            if iter_i % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_and_smooth_path(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a heuristic-driven Bi-directional RRT* inspired planner with dynamic goal biasing \n    and multi-resolution adaptive stepping. It grows two trees simultaneously from start and goal vertices to efficiently \n    explore the space. It uses heuristic cost (A*-like with estimated cost-to-goal) to bias vertex expansion and samples \n    adaptively around regions promising lower-cost connections. Rewiring occurs in both trees to improve path quality \n    continuously. The step size adapts locally based on clearance and goal distance to balance exploration and \n    exploitation. Early stopping occurs on connection of two trees, with further path shortcutting. A 10-second timeout \n    ensures responsiveness. This approach enhances robustness, path quality, success rate, and planning efficiency \n    by combining bidirectional search, heuristics, adaptive stepping, and rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Enable rewiring.\n        self._init_displays()\n\n    def _heuristic(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance as heuristic cost-to-goal\n        return Map.get_distance(pos, goal_pos)\n\n    def _dynamic_goal_bias_rate(self, iteration: int, max_iterations: int) -> float:\n        # Increase goal bias as iterations proceed (start low, increase up to 0.5)\n        return min(0.5, 0.1 + 0.4 * (iteration / max_iterations))\n\n    def _adaptive_step_size(self, pos: Point, base_step=10.0, min_step=3.0, max_step=20.0) -> float:\n        # Combine distance to goal and clearance as adaptivity factors\n        goal_pos = self._get_grid().goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        clearance = max_step\n        for radius in np.linspace(min_step, max_step, num=5):\n            direction = (goal_pos.to_tensor() - pos.to_tensor())\n            if torch.norm(direction) == 0:\n                break\n            dir_norm = direction / torch.norm(direction)\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        # Step size smaller nearer goal or lower clearance\n        adaptive = min(clearance, base_step * (dist_to_goal / max(self._get_grid().size.width, 1)))\n        return np.clip(adaptive, min_step, max_step)\n\n    def _attempt_connection(self, v1: Vertex, v2: Vertex) -> bool:\n        # Try connecting v1 -> v2 or v2 -> v1 if line valid and update graph with edge and cost\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            cost = v1.cost + self._get_grid().get_movement_cost(v1.position, v2.position)\n            if cost < v2.cost:\n                # Remove existing parents and add new edge\n                for p in list(v2.parents):\n                    self._graph.remove_edge(p, v2)\n                self._graph.add_edge(v1, v2)\n                v2.cost = cost\n            return True\n        # Try reverse direction:\n        line_seq_rev = self._get_grid().get_line_sequence(v2.position, v1.position)\n        if self._get_grid().is_valid_line_sequence(line_seq_rev):\n            cost = v2.cost + self._get_grid().get_movement_cost(v2.position, v1.position)\n            if cost < v1.cost:\n                for p in list(v1.parents):\n                    self._graph.remove_edge(p, v1)\n                self._graph.add_edge(v2, v1)\n                v1.cost = cost\n            return True\n        return False\n\n    def _choose_parent_bidirectional(\n        self, q_new: Vertex, near_vertices: list, expanding_from_start: bool\n    ) -> Vertex:\n        # Choose parent vertex minimizing cost + movement cost + heuristic to opposite root\n        if expanding_from_start:\n            opposite_goal = self._graph.root_vertex_goal.position\n        else:\n            opposite_goal = self._graph.root_vertex_start.position\n        min_total_cost = float(\"inf\")\n        parent_candidate = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            hcost = self._heuristic(q_new.position, opposite_goal)\n            total_cost = cost + hcost\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                parent_candidate = v\n        return parent_candidate\n\n    def _rewire_bidirectional(self, q_new: Vertex, near_vertices: list) -> None:\n        # Try rewiring neighbors if q_new provides lower cost valid connection\n        for v in near_vertices:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _extract_bidirectional_path(self, v_start: Vertex, v_goal: Vertex):\n        # Reconstruct path from start to goal via connected nodes from bidirectional trees\n        path_start = [v_start]\n        while len(path_start[-1].parents) != 0:\n            min_parent = min(path_start[-1].parents, key=lambda p: p.cost)\n            path_start.append(min_parent)\n        path_start.reverse()\n\n        path_goal = [v_goal]\n        while len(path_goal[-1].parents) != 0:\n            min_parent = min(path_goal[-1].parents, key=lambda p: p.cost)\n            path_goal.append(min_parent)\n\n        # Combine two paths (removing duplicated connection point)\n        full_path = path_start + path_goal[1:]\n\n        # Shortcut smoothing: try skipping intermediate vertices if direct line valid\n        smoothed_path = [full_path[0]]\n        for i in range(1, len(full_path)):\n            if self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(smoothed_path[-1].position, full_path[i].position)\n            ):\n                # skip previous vertex (continue connecting directly)\n                if smoothed_path[-1] == full_path[i - 1]:\n                    smoothed_path.pop()\n            smoothed_path.append(full_path[i])\n\n        # Animate agent movement along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n\n        # Initialize both trees with zero cost roots\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        # Containers for start and goal tree vertices\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: path not found\n                break\n\n            # Alternate expansion between start and goal trees\n            expanding_from_start = iteration % 2 == 0\n\n            # Determine goal bias adaptively\n            goal_bias = self._dynamic_goal_bias_rate(iteration, max_iterations)\n            if np.random.rand() < goal_bias:\n                sample_point = goal_pos if expanding_from_start else start_pos\n            else:\n                # Sample valid random point in environment\n                while True:\n                    rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    sample_point = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample_point):\n                        break\n\n            # Select tree and vertex list to operate on\n            if expanding_from_start:\n                current_vertices = start_vertices\n                opposite_vertices = goal_vertices\n                root_vertex = self._graph.root_vertex_start\n            else:\n                current_vertices = goal_vertices\n                opposite_vertices = start_vertices\n                root_vertex = self._graph.root_vertex_goal\n\n            # Find nearest vertex in current tree\n            q_near = self._graph.get_nearest_vertex(current_vertices, sample_point)\n            if q_near.position == sample_point:\n                continue\n\n            # Compute adaptive step size based on q_near\n            max_dist = self._adaptive_step_size(q_near.position)\n\n            # Generate new vertex in direction q_near -> sample_point\n            dir_vec = sample_point.to_tensor() - q_near.position.to_tensor()\n            norm_dir = torch.norm(dir_vec)\n            if norm_dir == 0:\n                continue\n            dir_normalized = dir_vec / norm_dir\n            if norm_dir <= max_dist:\n                q_new_pos = sample_point\n            else:\n                q_new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n                q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            # Verify new vertex position validity and line validity\n            if not self._get_grid().is_agent_valid_pos(q_new_pos):\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Find near vertices in current tree around q_new for choosing parent and rewiring\n            search_radius = max_dist * 2.0\n            near_vertices = self._graph.get_vertices_within_radius(current_vertices, q_new.position, search_radius)\n\n            # Choose parent to minimize heuristic cost path\n            chosen_parent = self._choose_parent_bidirectional(q_new, near_vertices, expanding_from_start)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and update cost for q_new\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Add q_new to current vertices tree\n            current_vertices.append(q_new)\n\n            # Rewire neighbors to improve paths\n            near_vertices = [v for v in near_vertices if v != chosen_parent]\n            self._rewire_bidirectional(q_new, near_vertices)\n\n            # Attempt connection to opposite tree vertices within extended radius\n            opposite_near_vertices = self._graph.get_vertices_within_radius(opposite_vertices, q_new.position, search_radius)\n            connection_found = False\n            best_connect_pair = None\n            best_connect_cost = float(\"inf\")\n            for v_opp in opposite_near_vertices:\n                if self._attempt_connection(q_new, v_opp):\n                    path_cost = q_new.cost + v_opp.cost + self._heuristic(q_new.position, v_opp.position)\n                    if path_cost < best_connect_cost:\n                        best_connect_cost = path_cost\n                        best_connect_pair = (q_new, v_opp)\n                        connection_found = True\n\n            if connection_found and best_connect_pair is not None:\n                # Extract and animate combined path between start and goal via connecting vertices\n                if expanding_from_start:\n                    self._extract_bidirectional_path(best_connect_pair[0], best_connect_pair[1])\n                else:\n                    self._extract_bidirectional_path(best_connect_pair[1], best_connect_pair[0])\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Advanced Bidirectional Heuristic-Driven RRT with Dynamic Sampling and Batch Rewiring.\n\n    This algorithm applies a bidirectional tree growth approach with two forests rooted at start and goal,\n    respectively, improving connection chances and convergence speed. It integrates a dynamically adaptive\n    sampling domain that shrinks as the two trees get closer, emphasizing sampling in the \"informed\" ellipsoid\n    defined by the current best cost to accelerate convergence on promising paths.\n\n    Key features include:\n    - Bidirectional tree expansion from both start and goal to reduce search time and increase success.\n    - Adaptive ellipsoidal sampling dynamically refined by the current best solution cost, blending global exploration and local refinement.\n    - Batch rewiring step every N iterations to optimize connectivity and reduce cost more globally.\n    - Step size adaptive to clearance and distance to the other tree, allowing coarse moves in open areas and fine near obstacles or goal.\n    - Early termination once trees connect with a feasible path.\n    - Robust shortcut smoothing with multiple passes post extraction for high-quality path.\n    - 10 second max planning timeout enforced.\n\n    This design leverages strong heuristics on both graph growth and sampling while preserving robustness through clearance-awareness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # CyclicGraph to allow more flexible rewiring and bidirectional edges\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._max_max_dist = 16.0\n        self._min_max_dist = 2.0\n        self._goal_sample_rate = 0.15  # Lower goal bias for start sampling, balanced with bidirectional growth\n        self._informed_sample_rate = 0.3 \n        self._max_iterations = 3000\n        self._lambda_rrt_star = 35\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_threshold = 2.5\n        self._batch_rewire_interval = 50\n\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\" Estimate clearance as minimum distance to obstacles or boundaries.\"\"\"\n        grid = self._get_grid()\n        max_clearance_check = 10.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        # Distance to boundary\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _adaptive_step(self, position: Point, dist_to_other_tree: float) -> float:\n        \"\"\"\n        Adaptive step size scaling by clearance, distance to the other tree, and iteration count\n        to allow larger expansion when far apart and finer steps when trees are close.\n        \"\"\"\n        clearance = self._get_clearance(position)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 2.0))\n        dist_factor = max(0.1, min(1.0, dist_to_other_tree / max(self._get_grid().size)))  # Normalize distance\n        base_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * clearance_factor * dist_factor\n        return max(self._min_max_dist, min(base_step, self._max_max_dist))\n\n    def _sample_in_informed_ellipsoid(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample uniformly inside the ellipsoid defined by current best path cost to prune search space.\n        Samples are biased to lie within the prolate hyperspheroid formed by foci at start and goal with sum of distances <= c_best.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        c_min = Map.get_distance(start, goal)\n        if c_best == float('inf') or c_best <= c_min:\n            # No current solution or invalid, sample uniform in grid\n            for _ in range(100):\n                candidate = Point(\n                    torch.randint(0, grid.size[0], (1,)).item(),\n                    torch.randint(0, grid.size[1], (1,)).item()\n                )\n                if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                    return candidate\n            return start\n\n        center_tensor = (start.to_tensor().float() + goal.to_tensor().float()) / 2.0\n        a1 = (c_best / 2.0)  # Major axis half length\n        a2 = ( (c_best**2 - c_min**2) ** 0.5 ) / 2.0  # Minor axis half length\n\n        for _ in range(40):\n            # Sample random point inside unit circle\n            sample = torch.randn(2)\n            sample_norm = torch.norm(sample)\n            if sample_norm < 1e-8:\n                continue\n            unit_sample = sample / sample_norm\n            radius = torch.rand(1).item() ** (1/2)  # sqrt for uniform area\n            scaled_sample = unit_sample * radius\n            # Scale to ellipsoid axes lengths\n            point_sample = torch.tensor([a1, a2]) * scaled_sample\n            # Rotation aligning ellipse's major axis to line start->goal\n            direction = (goal.to_tensor().float() - start.to_tensor().float())\n            dir_norm = torch.norm(direction)\n            if dir_norm < 1e-8:\n                return start\n            rotation_cos = direction[0] / dir_norm\n            rotation_sin = direction[1] / dir_norm\n            rot_matrix = torch.tensor([[rotation_cos, -rotation_sin], [rotation_sin, rotation_cos]])\n            rotated_vec = rot_matrix @ point_sample\n            final_point = (center_tensor + rotated_vec).round().int()\n            candidate = Point.from_tensor(final_point)\n            if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                return candidate\n        # fallback uniform\n        return start\n\n    def _get_random_sample(self, from_start_tree: bool) -> Point:\n        import torch\n        grid = self._get_grid()\n\n        if from_start_tree:\n            prob = torch.rand(1).item()\n            if prob < self._goal_sample_rate:\n                # Sample near goal but considering clearance\n                goal_pos = grid.goal.position\n                for _ in range(30):\n                    offset = torch.randn(self._dimension)\n                    norm = torch.norm(offset)\n                    if norm < 1e-8:\n                        continue\n                    offset = offset / norm\n                    offset_len = torch.rand(1).item() * self._min_max_dist\n                    sample_coords = (goal_pos.to_tensor().float() + offset * offset_len).round().int()\n                    candidate = Point.from_tensor(sample_coords)\n                    if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                        return candidate\n                return grid.goal.position\n\n            elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n                return self._sample_in_informed_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n            else:\n                # Clearance-aware uniform\n                for _ in range(150):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    candidate = Point(*coords)\n                    if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                        return candidate\n                return self._graph_start.root_vertex_start.position\n        else:\n            # For goal tree sampling - symmetric but reversed goal/start roles\n            prob = torch.rand(1).item()\n            if prob < self._goal_sample_rate:\n                start_pos = grid.agent.position\n                for _ in range(30):\n                    offset = torch.randn(self._dimension)\n                    norm = torch.norm(offset)\n                    if norm < 1e-8:\n                        continue\n                    offset = offset / norm\n                    offset_len = torch.rand(1).item() * self._min_max_dist\n                    sample_coords = (start_pos.to_tensor().float() + offset * offset_len).round().int()\n                    candidate = Point.from_tensor(sample_coords)\n                    if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                        return candidate\n                return grid.agent.position\n\n            elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n                return self._sample_in_informed_ellipsoid(grid.goal.position, grid.agent.position, self._best_cost)\n\n            else:\n                for _ in range(150):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    candidate = Point(*coords)\n                    if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                        return candidate\n                return self._graph_goal.root_vertex_start.position\n\n    def _try_connect_trees(self, v_start: Vertex, v_goal: Vertex) -> Vertex:\n        \"\"\"\n        Attempt to connect two vertices from opposite trees.\n        If valid connection, create connecting vertex and merge.\n        Returns the \"bridge\" vertex at goal side or None.\n        \"\"\"\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(v_start.position, v_goal.position)\n        if grid.is_valid_line_sequence(line_seq):\n            dist = Map.get_distance(v_start.position, v_goal.position)\n            bridge_vertex = Vertex(v_goal.position)\n            bridge_vertex.cost = v_start.cost + dist\n            # Add edge from start tree ancestor to bridge\n            self._graph_start.add_edge(v_start, bridge_vertex)\n            # Add edge from bridge to goal tree ancestor (make goal tree edge reversed)\n            self._graph_goal.add_edge(bridge_vertex, v_goal)\n            return bridge_vertex\n        return None\n\n    def _extract_bidirectional_path(self, bridge_vertex: Vertex) -> None:\n        \"\"\"\n        Extract path from start root to bridge, and from goal root to bridge, \n        then combine and shortcut.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Extract path start->bridge in start tree\n        path_start = []\n        cur = bridge_vertex\n        while True:\n            path_start.append(cur)\n            if len(cur.parents) == 0:\n                break\n            cur = next(iter(cur.parents))\n        path_start.reverse()\n\n        # Extract path goal->bridge in goal tree (parents point backwards)\n        path_goal = []\n        cur = bridge_vertex\n        while True:\n            path_goal.append(cur)\n            if len(cur.children) == 0:\n                break\n            cur = next(iter(cur.children))\n        path_goal = path_goal[1:]  # Remove duplicate bridge vertex\n\n        full_path = path_start + path_goal\n\n        # Multiple shortcut passes for smoothing\n        for _ in range(5):\n            i = 0\n            while i < len(full_path)-2:\n                j = len(full_path)-1\n                while j > i+1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n        \n        # Move agent along smoothed path with keyframes\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _batch_rewire(self, graph: Forest, radius: float) -> None:\n        \"\"\"\n        Batch rewiring to improve connectivity and reduce costs.\n        Iterates vertices and tries reconnecting neighbors if cheaper.\n        \"\"\"\n        grid = self._get_grid()\n        vertices = list(graph.root_vertices)\n        # Also include all descendants via DFS\n        def collect_all(v: Vertex, acc: set):\n            if v in acc:\n                return\n            acc.add(v)\n            for c in v.children:\n                collect_all(c, acc)\n        all_vertices = set()\n        for root_v in vertices:\n            collect_all(root_v, all_vertices)\n\n        for v in all_vertices:\n            near_vertices = graph.get_vertices_within_radius(vertices, v.position, radius)\n            for near_v in near_vertices:\n                if near_v == v:\n                    continue\n                dist = Map.get_distance(v.position, near_v.position)\n                potential_cost = near_v.cost + dist\n                if potential_cost + 1e-4 < v.cost:\n                    line_seq = grid.get_line_sequence(near_v.position, v.position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove old parent\n                        for p in list(v.parents):\n                            graph.remove_edge(p, v)\n                        v.cost = potential_cost\n                        graph.add_edge(near_v, v)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        grid = self._get_grid()\n        start_vertex = self._graph_start.root_vertex_start\n        goal_vertex = self._graph_goal.root_vertex_start\n\n        self._best_cost = float('inf')\n        connection_found = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Alternate expansions\n        for iteration in range(self._max_iterations):\n            # Timeout enforcement\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # Alternate trees for sampling / expansion\n            from_start_tree = (iteration % 2 == 0)\n            graph_active = self._graph_start if from_start_tree else self._graph_goal\n            graph_other = self._graph_goal if from_start_tree else self._graph_start\n\n            sample = self._get_random_sample(from_start_tree)\n            nearest = graph_active.get_nearest_vertex(graph_active.root_vertices, sample)\n            if nearest.position == sample:\n                continue\n\n            dist_to_other_tree = float('inf')\n            # Estimate minimum distance to other tree vertices to scale step size\n            for v_other in graph_other.root_vertices:\n                d = Map.get_distance(nearest.position, v_other.position)\n                if d < dist_to_other_tree:\n                    dist_to_other_tree = d\n\n            max_dist = self._adaptive_step(nearest.position, dist_to_other_tree)\n            dir_vec = sample.to_tensor().float() - nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                new_pos = sample\n            else:\n                dir_norm = dir_vec / dist\n                new_tensor = (nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                new_pos = Point.from_tensor(new_tensor)\n\n            if not grid.is_agent_valid_pos(new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(nearest.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(new_pos)\n            dist_nearest_new = Map.get_distance(nearest.position, q_new.position)\n            q_new.cost = nearest.cost + dist_nearest_new\n\n            # Compute adaptive neighborhood radius for rewiring based on graph size\n            size = max(graph_active.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1/self._dimension)), 25.0)\n\n            # Inflate radius with clearance factor\n            c = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(c / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = graph_active.get_vertices_within_radius(graph_active.root_vertices, q_new.position, radius)\n\n            # Select best parent with lowest cost and valid connection\n            q_min = nearest\n            c_min = nearest.cost + dist_nearest_new\n            for v_near in near_vertices:\n                dist_vnew = Map.get_distance(v_near.position, q_new.position)\n                cost_cand = v_near.cost + dist_vnew\n                line_seq_candidate = grid.get_line_sequence(v_near.position, q_new.position)\n                if cost_cand < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = v_near\n                    c_min = cost_cand\n\n            q_new.cost = c_min\n            graph_active.add_edge(q_min, q_new)\n\n            # Rewiring neighbors if cost improved\n            rewire_threshold = 0.005\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_near = Map.get_distance(q_new.position, v_near.position)\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        for p in list(v_near.parents):\n                            graph_active.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        graph_active.add_edge(q_new, v_near)\n\n            # Try to connect new vertex with opposite tree vertices near it\n            other_near_vertices = graph_other.get_vertices_within_radius(graph_other.root_vertices, q_new.position, radius)\n            for other_v in other_near_vertices:\n                dist_conn = Map.get_distance(q_new.position, other_v.position)\n                if dist_conn <= max_dist:\n                    bridge = self._try_connect_trees(q_new if from_start_tree else other_v,\n                                                     other_v if from_start_tree else q_new)\n                    if bridge is not None:\n                        # Check total cost for path through bridge\n                        total_cost = bridge.cost + dist_conn\n                        if total_cost < self._best_cost:\n                            self._best_cost = total_cost\n                            connection_found = bridge\n                            break\n            if connection_found is not None:\n                break\n\n            # Batch rewiring every batch interval iteration on each tree\n            if iteration % self._batch_rewire_interval == 0 and iteration > 0:\n                self._batch_rewire(self._graph_start, radius)\n                self._batch_rewire(self._graph_goal, radius)\n\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if connection_found is not None:\n            self._extract_bidirectional_path(connection_found)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a Hybrid Anytime Informed Bidirectional Sampling Tree (HAIBiST) path planner\n    that fuses bidirectional growth with informed sampling guided by a heuristic corridor between start and goal.\n    It maintains two trees growing simultaneously\u2014from start and goal\u2014attempting early connection by bridging.\n    The sampling is restricted within an ellipsoidal informed set estimated dynamically by the best found path cost,\n    thus concentrating exploration efficiently where improvements are likely.\n    Adaptive step sizes utilize clearance and directional smoothness.\n    A novel selective rewiring step rewires locally only when better cost improvements are found through new edges.\n    Early stopping happens upon connection or after a 10-second timeout.\n    The extracted path is shortcut-smoothed and traced forward to the agent.\n    This approach blends informed sampling (like informed-RRT*), bidirectional search (like RRT-Connect),\n    and selective rewiring, improving planning efficiency, success rate, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Use CyclicGraph to allow possible cyclic connections during bridging & rewiring\n        self._graph = CyclicGraph(self._services,\n                                  Vertex(self._get_grid().agent.position),\n                                  Vertex(self._get_grid().goal.position),\n                                  [])\n        self._graph.edges_removable = True\n\n        # Parameters: these values can be tuned or randomized if desired\n        self._time_limit = 10.0\n        self._max_iterations = 7000\n        self._goal_sample_rate = 0.2\n        self._search_radius_rewire = 10.0\n        self._min_step = 2.0\n        self._max_step = 12.0\n\n        # Track best connection cost and connecting vertices\n        self._best_cost = float('inf')\n        self._best_connection = None # tuple (vertex_start_tree, vertex_goal_tree)\n\n        self._init_displays()\n\n    def _heuristic_informed_sample(self, current_best_cost: float) -> Point:\n        \"\"\"\n        Sample uniformly inside an ellipsoid defined by start, goal, and best path cost to\n        focus sampling inside an informed subset of the state space.\n        Fall back to uniform random if no path found yet (current_best_cost inf).\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n        size = grid.size\n        n_dim = size.n_dim\n\n        if current_best_cost == float('inf'):\n            # No solution found yet: sample uniformly with goal bias\n            if np.random.rand() < self._goal_sample_rate:\n                return goal\n            while True:\n                sample_coords = np.random.randint(0, size, n_dim)\n                sample_pt = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample_pt):\n                    return sample_pt\n\n        # Define ellipsoid parameters (in 2D or higher dims):\n        # focus1 = start, focus2 = goal\n        # Long axis length = current_best_cost (path cost heuristic)\n        # Use coordinate transform to sample in unit n-dim ball scaled by axes lengths\n        c = current_best_cost / 2.0\n        center_tensor = (start.to_tensor() + goal.to_tensor()) / 2.0\n        a1 = (goal.to_tensor() - start.to_tensor()).numpy()\n        distance_start_goal = np.linalg.norm(a1)\n        if distance_start_goal == 0:\n            # Start == goal, sample start\n            return start\n        e1 = a1 / distance_start_goal  # unit vector along start-goal\n\n        # Construct orthonormal basis using Gram-Schmidt (for at least 2D)\n        basis_vectors = [e1]\n        # Fill remaining basis vectors orthogonal to e1:\n        for i in range(n_dim):\n            unit_vec = np.zeros(n_dim)\n            unit_vec[i] = 1.0\n            proj = np.sum(unit_vec * e1) * e1\n            ortho_comp = unit_vec - proj\n            norm_ortho = np.linalg.norm(ortho_comp)\n            if norm_ortho > 1e-6:\n                basis_vectors.append(ortho_comp / norm_ortho)\n            if len(basis_vectors) >= n_dim:\n                break\n        basis_matrix = np.array(basis_vectors).T  # n_dim x n_dim matrix\n\n        # Axes lengths of ellipsoid:\n        a = current_best_cost / 2.0\n        if distance_start_goal == 0:\n            b = a\n        else:\n            b = np.sqrt(current_best_cost ** 2 - distance_start_goal ** 2) / 2.0\n        if n_dim == 1:\n            axes_lengths = np.array([a])\n        else:\n            axes_lengths = np.array([a] + [b] * (n_dim - 1))\n\n        # Sample uniformly in n-ball, scale by axes_lengths, rotate to global coords, translate to center\n        while True:\n            # Sample random point in unit n-dim ball using normal distribution then normalize\n            x = np.random.normal(0, 1, n_dim)\n            norm_x = np.linalg.norm(x)\n            if norm_x == 0:\n                continue\n            x_unit = x / norm_x\n            r = np.random.rand() ** (1.0 / n_dim)  # radius in unit ball for uniform volume sampling\n            sample_ball = r * x_unit\n\n            # Scale by ellipse axes lengths\n            sample_ellipse = sample_ball * axes_lengths\n\n            # Rotate (basis_matrix) and translate (center_tensor)\n            sample_global = basis_matrix.dot(sample_ellipse) + center_tensor.numpy()\n\n            # Round and clamp to grid limits\n            sample_coords = np.clip(np.round(sample_global).astype(int), 0, np.array(size) - 1)\n            sample_pt = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _adaptive_step_from_direction(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Similar to previous adaptive step size functions, choose step size based on clearance\n        and movement direction smoothness. Blend min and max steps.\n        \"\"\"\n        grid = self._get_grid()\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return self._min_step\n        unit_dir = dir_tensor / norm\n\n        for radius in np.linspace(self._min_step, self._max_step, num=6):\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n            if not grid.is_agent_valid_pos(sample_point):\n                return radius * 0.5\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return radius * 0.5\n        return self._max_step\n\n    def _get_new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        adaptive_step = self._adaptive_step_from_direction(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = min(adaptive_step, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent_selective(self, neighbors: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Select parent vertex that leads to lowest cost for q_new, considering only \n        parents with valid collision-free connections.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_candidate = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                chosen_parent = neighbor\n        return chosen_parent\n\n    def _selective_rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Attempt rewiring neighbors only if it improves cost and with collision-free lines.\n        Remove previous parents if rewired.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if potential_cost >= current_cost:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            # Rewire: remove old parents and add q_new as parent\n            for old_parent in list(neighbor.parents):\n                self._graph.remove_edge(old_parent, neighbor)\n            self._graph.add_edge(q_new, neighbor)\n            neighbor.cost = potential_cost\n\n    def _connect_trees(self, q_new_start: Vertex, q_new_goal: Vertex, search_radius: float) -> bool:\n        \"\"\"\n        Given new vertices from start and goal trees, attempt to connect trees\n        by trying neighbors near q_new_start in goal tree and vice versa.\n        If connection found with cost improvement, update best path data.\n        \"\"\"\n        grid = self._get_grid()\n        # Search neighbors in goal tree around q_new_start\n        goal_tree_vertices = [self._graph.root_vertex_goal]\n        neighbors_goal = self._graph.get_vertices_within_radius(goal_tree_vertices, q_new_start.position, search_radius)\n        connected = False\n        for neighbor_goal in neighbors_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, neighbor_goal.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_connection = (q_new_start.cost + grid.get_movement_cost(q_new_start.position, neighbor_goal.position) + neighbor_goal.cost)\n            if cost_connection < self._best_cost:\n                self._best_cost = cost_connection\n                self._best_connection = (q_new_start, neighbor_goal)\n                connected = True\n\n        # Likewise, check neighbors in start tree around q_new_goal\n        start_tree_vertices = [self._graph.root_vertex_start]\n        neighbors_start = self._graph.get_vertices_within_radius(start_tree_vertices, q_new_goal.position, search_radius)\n        for neighbor_start in neighbors_start:\n            line_seq = grid.get_line_sequence(q_new_goal.position, neighbor_start.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_connection = (q_new_goal.cost + grid.get_movement_cost(q_new_goal.position, neighbor_start.position) + neighbor_start.cost)\n            if cost_connection < self._best_cost:\n                self._best_cost = cost_connection\n                self._best_connection = (neighbor_start, q_new_goal)\n                connected = True\n\n        return connected\n\n    def _extract_bidirectional_path(self) -> None:\n        \"\"\"\n        Extracts path by combining the best connection found between start and goal trees.\n        Builds individual paths from start to connection vertex and goal to connection vertex,\n        then concatenates and shortcut smooths the combined path.\n        Traces the agent along the final smoothed path.\n        \"\"\"\n        grid = self._get_grid()\n        if self._best_connection is None:\n            return\n\n        v_start, v_goal = self._best_connection\n\n        # Trace back path from v_start to root start\n        path_start = [v_start]\n        while len(path_start[-1].parents) != 0:\n            parent_min = min(path_start[-1].parents, key=lambda p: p.cost)\n            path_start.append(parent_min)\n        path_start.pop()  # remove root duplicate\n        path_start.reverse()  # from root start to connection vertex\n\n        # Trace back path from v_goal to root goal\n        path_goal = [v_goal]\n        while len(path_goal[-1].parents) != 0:\n            parent_min = min(path_goal[-1].parents, key=lambda p: p.cost)\n            path_goal.append(parent_min)\n        path_goal.pop()  # remove root duplicate\n\n        # Combine paths: from start to connection vertex, then reversed goal subtree\n        full_path = path_start + path_goal[::-1]\n\n        # Shortcut smooth the full path with grid validation\n        smooth_path = [full_path[0]]\n        last_index = 0\n        for i in range(1, len(full_path)):\n            line_seq = grid.get_line_sequence(smooth_path[-1].position, full_path[i].position)\n            if grid.is_valid_line_sequence(line_seq):\n                last_index = i\n            else:\n                smooth_path.append(full_path[last_index])\n                last_index = i\n        if smooth_path[-1] != full_path[-1]:\n            smooth_path.append(full_path[-1])\n\n        # Move agent along smoothed path\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        # Initialize cost for roots\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = 0.0\n\n        start_vertices = [self._graph.root_vertex_start]\n        goal_vertices = [self._graph.root_vertex_goal]\n\n        # Alternate tree switching for bidirectional growth\n        # True => grow start tree, False => grow goal tree\n        grow_start_tree = True\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > self._time_limit:\n                # Timeout failure\n                break\n\n            # Sample point using informed heuristic sampling with current best cost\n            q_sample = self._heuristic_informed_sample(self._best_cost)\n\n            if grow_start_tree:\n                # Grow start tree\n                q_near = self._graph.get_nearest_vertex(start_vertices, q_sample)\n                if q_near.position == q_sample:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                max_dist = self._adaptive_step_from_direction(q_near.position, Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor()))\n                new_vertex = self._get_new_vertex_towards(q_near, q_sample, max_dist)\n                if new_vertex is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                neighbors = self._graph.get_vertices_within_radius(start_vertices, new_vertex.position, self._search_radius_rewire)\n                parent = self._choose_parent_selective(neighbors, new_vertex)\n                if parent is None:\n                    parent = q_near\n                self._graph.add_edge(parent, new_vertex)\n                new_vertex.cost = parent.cost + grid.get_movement_cost(parent.position, new_vertex.position)\n                neighbors = [v for v in neighbors if v != parent]\n                self._selective_rewire(new_vertex, neighbors)\n                start_vertices.append(new_vertex)\n\n                # Attempt to connect trees via new_vertex from start tree and any goal tree vertices\n                connected = self._connect_trees(new_vertex, None, self._search_radius_rewire)\n                if connected:\n                    self._extract_bidirectional_path()\n                    break\n\n            else:\n                # Grow goal tree (swap roles)\n                q_near = self._graph.get_nearest_vertex(goal_vertices, q_sample)\n                if q_near.position == q_sample:\n                    grow_start_tree = not grow_start_tree\n                    continue\n\n                max_dist = self._adaptive_step_from_direction(q_near.position, Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor()))\n                new_vertex = self._get_new_vertex_towards(q_near, q_sample, max_dist)\n                if new_vertex is None:\n                    grow_start_tree = not grow_start_tree\n                    continue\n                neighbors = self._graph.get_vertices_within_radius(goal_vertices, new_vertex.position, self._search_radius_rewire)\n                parent = self._choose_parent_selective(neighbors, new_vertex)\n                if parent is None:\n                    parent = q_near\n                self._graph.add_edge(parent, new_vertex)\n                new_vertex.cost = parent.cost + grid.get_movement_cost(parent.position, new_vertex.position)\n                neighbors = [v for v in neighbors if v != parent]\n                self._selective_rewire(new_vertex, neighbors)\n                goal_vertices.append(new_vertex)\n\n                # Attempt to connect trees via new_vertex from goal tree and any start tree vertices\n                connected = self._connect_trees(None, new_vertex, self._search_radius_rewire)\n                if connected:\n                    self._extract_bidirectional_path()\n                    break\n\n            grow_start_tree = not grow_start_tree\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Heuristic-Guided RRT* Algorithm with Dynamic max_dist and Enhanced Sampling",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Adaptive Heuristic-Guided RRT* Algorithm with Dynamic max_dist and Enhanced Sampling}\n\n    This improved algorithm builds upon the foundation of RRT* with goal bias and rewiring by adding:\n\n    - Adaptive max_dist dynamically scaled based on environment size and current progress towards goal.\n    - Heuristic-guided sampling combining goal bias and a corridor sampling around the line from start to goal.\n    - Prioritized parent selection using a cost-to-go heuristic (cost-so-far + estimated cost-to-go).\n    - Early pruning of nodes with high cost to limit search space and improve efficiency.\n    - Adaptive rewiring radius scaled with node density to better optimize paths.\n    - Multiple shortcut smoothing passes after path extraction for superior path quality.\n    - Early stopping by a 10-second runtime limit and immediate extraction on goal reach.\n    - Robust handling of small steps by falling back to exact goal connection attempts.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.20        # Increased goal bias for better directed sampling.\n        self._base_rewire_radius = 20        # Base radius for rewiring neighbors, adaptive in code.\n        self._max_dist_base = 15             # Base max_dist for step size, adaptive in code.\n        self._max_iterations = 6000          # Reduced max iterations to encourage efficiency.\n        self._time_limit_sec = 10.0          # Time limit in seconds to stop search if no path found.\n\n    def _adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        # Adaptive step size: increase if far from goal, decrease closer.\n        dist_to_goal = self._get_grid().get_distance(current_pos, goal_pos)\n        max_env_dim = max(self._get_grid().size)\n        # Scale max_dist between base and half max env dimension clipped\n        adaptive_dist = min(self._max_dist_base, max(3, dist_to_goal / 5))\n        adaptive_dist = min(adaptive_dist, max_env_dim / 3)\n        return adaptive_dist\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_point: Point) -> float:\n        # Heuristic = cost_so_far + estimated cost to go (Euclidean)\n        cost_so_far = from_vertex.cost\n        est_cost_to_go = self._get_grid().get_distance(from_vertex.position, to_point)\n        return cost_so_far + est_cost_to_go\n\n    def _get_random_sample(self) -> Point:\n        from random import random, uniform\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        start_pos = grid.agent.position\n        dim_sizes = grid.size.n_dim\n\n        # With goal_sample_rate, sample goal directly\n        if random() < self._goal_sample_rate:\n            return goal_pos\n\n        # Otherwise biased sampling around corridor line from start to goal\n        # Sample a point near line connecting start to goal with some lateral noise\n\n        t = uniform(0, 1)  # parameter along start->goal line\n        base_pos_tensor = start_pos.to_tensor() * (1 - t) + goal_pos.to_tensor() * t\n\n        # Generate perpendicular noise vector\n        noise_scale = max(dim_sizes) * 0.1  # 10% of max dimension as noise scale\n\n        # For 2D or 3D, generate perpendicular noise\n        if dim_sizes == 2:\n            # In 2D, perpendicular vector can be (-y, x)\n            direction = goal_pos.to_tensor() - start_pos.to_tensor()\n            perp = torch.tensor([-direction[1], direction[0]])\n            perp = perp / torch.norm(perp) if torch.norm(perp) > 0 else perp\n            noise_vec = perp * uniform(-noise_scale, noise_scale)\n        else:\n            # For 3D, generate random vector orthogonal to direction\n            direction = goal_pos.to_tensor() - start_pos.to_tensor()\n            direction_norm = torch.norm(direction)\n            if direction_norm == 0:\n                noise_vec = torch.zeros(dim_sizes)\n            else:\n                u = direction / direction_norm\n                # Random vector\n                rand_vec = torch.randn(dim_sizes)\n                perp_vec = rand_vec - torch.dot(rand_vec, u) * u\n                perp_norm = torch.norm(perp_vec)\n                noise_vec = (perp_vec / perp_norm) * uniform(-noise_scale, noise_scale) if perp_norm > 0 else torch.zeros(dim_sizes)\n\n        sample_tensor = base_pos_tensor + noise_vec\n        sample_int = torch.clamp(sample_tensor.round(), min=0, max=torch.tensor(grid.size) - 1).to(torch.int64)\n        sample_point = Point(*sample_int.tolist())\n\n        # Validate sample point inside valid region, else fallback to uniform sampling\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # Fallback uniform random sample in environment\n            for _ in range(50):\n                rand_pos = [int(uniform(0, sz - 1)) for sz in grid.size]\n                random_sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(random_sample):\n                    return random_sample\n            # Last resort: return goal if all fail\n            return goal_pos\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Choose parent minimizing f = cost_so_far + heuristic_to_goal\n        min_f = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic = cost + grid.get_distance(q_new.position, goal_pos)\n            if heuristic < min_f:\n                min_f = heuristic\n                best_parent = q_near\n                q_new.cost = cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove all old parents, then add q_new as new parent\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _multi_pass_shortcut(self, path: list) -> list:\n        # Apply shortcut smoothing multiple passes for better path\n        smooth_path = path\n        for _ in range(3):  # 3 passes\n            smooth_path = self._shortcut_path(smooth_path)\n        return smooth_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_pos = goal_vertex.position\n\n        iteration = 0\n        # Adaptive radius based on node density, initialized to base\n        adaptive_rewire_radius = self._base_rewire_radius\n\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            # Respect time limit\n            if time.time() - start_time > self._time_limit_sec:\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, goal_pos)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n\n            if not grid.is_valid_line_sequence(line_seq):\n                # Try direct goal connection fallback if close enough\n                dist_to_goal = grid.get_distance(q_near.position, goal_pos)\n                if dist_to_goal <= max_dist:\n                    q_new = Vertex(goal_pos)\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                        q_new.cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n                        self._graph.add_edge(q_near, q_new)\n                        goal_vertex.cost = q_new.cost\n                        self._graph.add_edge(q_new, goal_vertex)\n                        path = self._extract_and_move(goal_vertex)\n                        break\n                continue\n\n            # Get neighbors (adaptive radius shrinking with size)\n            current_size = max(1, self._graph.size)\n            adaptive_rewire_radius = self._base_rewire_radius * ( (current_size / 1000) ** (-0.2) )\n            adaptive_rewire_radius = max(5.0, min(adaptive_rewire_radius, self._base_rewire_radius))\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, adaptive_rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n            self._rewire(q_new, neighbors)\n\n            # Prune nodes with cost significantly higher than direct start to goal cost to improve efficiency\n            direct_start_goal_dist = grid.get_distance(start_vertex.position, goal_pos)\n            if q_new.cost > direct_start_goal_dist * 3.0:\n                for parent in list(q_new.parents):\n                    self._graph.remove_edge(parent, q_new)\n                continue\n\n            # Check goal reach with radius equal to agent + goal radius to handle proximity\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_pos)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    path = self._extract_and_move(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        # If after iterations time reached and goal not connected, attempt direct connection as last resort\n        if not goal_vertex.parents and time.time() - start_time <= self._time_limit_sec:\n            from_vertex = self._graph.get_nearest_vertex([start_vertex], goal_pos)\n            if grid.is_valid_line_sequence(grid.get_line_sequence(from_vertex.position, goal_pos)):\n                goal_vertex.cost = from_vertex.cost + grid.get_distance(from_vertex.position, goal_pos)\n                self._graph.add_edge(from_vertex, goal_vertex)\n                self._extract_and_move(goal_vertex)\n\n    def _extract_and_move(self, q_goal: Vertex) -> list:\n        path: list = [q_goal]\n        curr = q_goal\n        while curr.parents:\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n        path = self._multi_pass_shortcut(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm enhances the original RRT*-inspired planner by integrating an A*-informed sampling \n    heuristic combined with adaptive goal biasing and dynamic rewiring radius. It uses a heuristic \n    cost-to-go estimate to bias sampling towards areas promising lower-cost paths, improving planning \n    efficiency and reducing unnecessary explorations. The rewiring radius reduces dynamically as the tree \n    grows to locally optimize connections, and a heuristic cost-to-go pruning step excludes expanded nodes \n    unlikely to improve the solution. A final path shortcutting and smoothing step ensures a higher-quality \n    path. Early timeout after 10 seconds enforces practical limits on runtime. This results in faster \n    convergence, better path quality, and higher success rate compared to baseline RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        # Additional member variables to support improved sampling and heuristic\n        self._max_iterations = 10000\n        self._timeout_seconds = 10.0\n        self._goal_sample_base_rate = 0.25  # base goal bias rate\n        self._rewire_radius_max = 15.0\n        self._rewire_radius_min = 4.0\n        self._tree_size_for_radius_decay = 500  # heuristically chosen for radius scaling\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Straight-line Euclidean distance heuristic from pos to goal (estimate cost-to-go)\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _adaptive_goal_sample_rate(self, iteration: int) -> float:\n        # Reduce goal bias over time to balance exploration initially and exploitation later\n        decay_factor = max(0.05, self._goal_sample_base_rate * (1 - iteration / self._max_iterations))\n        return decay_factor\n\n    def _dynamic_rewire_radius(self) -> float:\n        # Decrease rewire radius as graph size grows (faster local optimization when dense)\n        size = max(1, self._graph.size)\n        radius = self._rewire_radius_max * (self._tree_size_for_radius_decay**0.5) / (size**0.5)\n        radius_clamped = np.clip(radius, self._rewire_radius_min, self._rewire_radius_max)\n        return radius_clamped\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        # Modified sampling biased by A* heuristic cost; with probability goal_sample_rate returns goal\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos_np = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos_np)\n            if not self._get_grid().is_agent_valid_pos(sample):\n                continue\n            # Additional heuristic bias: accept sample more likely if cost-to-go is small (closer to goal)\n            h_cost = self._heuristic_cost(sample)\n            threshold = np.random.uniform(0, np.linalg.norm(self._get_grid().size))\n            if h_cost < threshold:\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Optional[Vertex]':\n        # Overrides: incorporate adaptive max_dist and validate path for new vertex\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        # Check collision-free path\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> 'Optional[Vertex]':\n        # Choose parent minimizing cost+heuristic-to-go + movement cost from candidate vertices\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            heuristic = self._heuristic_cost(q_new.position)\n            total_estimated_cost = cost + heuristic\n            if total_estimated_cost < min_cost:\n                min_cost = total_estimated_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Rewire neighbors through q_new if it yields lower cost paths\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old parent edges first\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _prune_vertices(self, upper_bound_cost: float) -> None:\n        # Prune vertices from graph whose cost + heuristic exceeds upper bound cost to focus search\n        vertices_to_remove = []\n        def prune_check(v: Vertex) -> bool:\n            if v.cost + self._heuristic_cost(v.position) > upper_bound_cost:\n                vertices_to_remove.append(v)\n            return True\n\n        self._graph.walk_dfs(prune_check)\n        for v in vertices_to_remove:\n            # Remove all edges involving v\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            for c in list(v.children):\n                self._graph.remove_edge(v, c)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path to goal and perform shortcut smoothing as in base, but enhanced smoothing\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: list = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # remove duplicate start\n        path.reverse()\n\n        # Shortcut smoothing: iterative attempt to skip intermediate vertices if direct path valid\n        smoothed_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n\n        # Trace the path for agent movement with key frames\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        # Enhanced RRT* inspired planner with heuristic-informed sampling, adaptive rewiring radius,\n        # pruning unpromising vertices, and dynamic goal biasing.\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        goal_pos = self._get_grid().goal.position\n        start_time = time.time()\n        best_goal_cost = float('inf')\n        path_found = False\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > self._timeout_seconds:\n                break  # Timeout\n\n            goal_sample_rate = self._adaptive_goal_sample_rate(iteration)\n            q_sample = self._get_random_sample(goal_sample_rate)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            rewire_radius = self._dynamic_rewire_radius()\n            q_near_list = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and update cost for q_new\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Prune vertices when we have an improved path (focus tree growth)\n            if best_goal_cost < float('inf'):\n                self._prune_vertices(best_goal_cost)\n\n            q_near_list_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list_rewire)\n\n            # Check if q_new reaches goal radius and if it improves best goal path cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_cost_candidate = q_new.cost + self._heuristic_cost(goal_pos)\n                if goal_cost_candidate < best_goal_cost:\n                    best_goal_cost = goal_cost_candidate\n                    self._extract_path(q_new)\n                    path_found = True\n                    break\n\n            self.key_frame()\n\n        if not path_found:\n            # No path found within timeout or iteration limit\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm enhances the hybrid RRT*-informed search approach with:\n    - Bidirectional growth: simultaneous expansion from start and goal vertices, meeting in the middle to reduce search space and accelerate convergence.\n    - Adaptive balanced sampling: samples alternate between start and goal forests with goal bias, preserving clearance-aware sampling to ensure safe exploration.\n    - Priority queues on both trees with heuristic-guided best-first expansions and lazy collision checking to reduce costly validations.\n    - Dynamic adaptive step size tuned by clearance, heuristic distance, and iteration count for efficient yet precise expansions.\n    - Efficient rewiring with pruning thresholds derived from relative improvement and current best cost, applied over both trees.\n    - Early stopping upon connecting two trees with improved path cost and subsequent smoothing of path extracted from bidirectional parents.\n    - Timeout limitation at 10 seconds to guarantee practical responsiveness.\n    The combination of bidirectional search, informed heuristic priority, and adaptive mechanisms boosts planning efficiency,\n    path quality, robustness, and overall success rate compared to unidirectional approaches.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Parameters blending previous insights and new bidirectional expansion\n        self._goal_sample_rate = 0.30\n        self._clearance_threshold = 2.5\n        self._max_iterations = 2500\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._min_step = 2.0\n        self._max_step = 15.0\n        self._rewire_lambda = 35.0  # radius scaling factor for neighborhood rewiring\n        self._bidirectional_ratio = 0.5  # Probability to expand from start tree vs goal tree\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = grid.goal.position\n        start_pos = grid.agent.position\n\n        self._best_cost = float('inf')\n        found_connection = None\n        self._start_time = time.time()\n        iterations = 0\n\n        # Two priority queues (min-heaps), for start tree and goal tree expansions:\n        # Elements: (estimated_total_cost, vertex)\n        open_queue_start = []\n        open_queue_goal = []\n\n        heapq.heappush(open_queue_start, (self._heuristic(start_vertex.position), start_vertex))\n        heapq.heappush(open_queue_goal, (self._heuristic(goal_vertex.position), goal_vertex))\n\n        # Vertex maps for rapid lookup by position of vertices in each forest\n        vertex_map_start = {start_vertex.position: start_vertex}\n        vertex_map_goal = {goal_vertex.position: goal_vertex}\n\n        # Utility to select random sample biased by goal/start ratio and clearance awareness\n        def sample_point():\n            prob = torch.rand(1).item()\n            if prob < self._goal_sample_rate:\n                # Goal biased sample with offset and clearance test\n                goal_pos_local = grid.goal.position\n                for _ in range(30):\n                    offset = torch.randint(-2, 3, (self._dimension,))\n                    candidate = Point(goal_pos_local.x + offset[0].item(), goal_pos_local.y + offset[1].item())\n                    if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                        return candidate\n                return goal_pos_local\n            else:\n                # Clearance aware uniform sample\n                for _ in range(120):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                    sample = Point(*coords)\n                    if grid.is_agent_valid_pos(sample):\n                        clearance = self._get_clearance(sample)\n                        if clearance >= self._clearance_threshold:\n                            return sample\n                # fallback\n                return start_pos\n\n        # Adaptive step size depends on position, clearance, and iteration count (faster at start, slower near goal)\n        def adaptive_step_size(pos: Point, iteration: int) -> float:\n            dist_to_goal = Map.get_distance(pos, goal_pos)\n            norm_dist = min(1.0, dist_to_goal / max(grid.size))\n            tree_size = max(self._graph.size, 1)\n            tree_factor = min(1.0, 500.0 / tree_size)\n            clearance = self._get_clearance(pos)\n            clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n            iter_factor = max(0.3, 1.0 - (iteration / self._max_iterations))  # tend to smaller step as iterations progress\n            step = self._min_step + (self._max_step - self._min_step) * norm_dist * tree_factor * clearance_factor * iter_factor\n            return max(self._min_step, min(step, self._max_step))\n\n        def try_extend(tree_vertices_map, open_queue, other_vertices_map, from_start_tree: bool):\n            if not open_queue:\n                return None, None\n\n            est_total_cost, current_v = heapq.heappop(open_queue)\n\n            q_sample = sample_point()\n\n            dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                return current_v, None\n            dir_norm = dir_vec / dist\n\n            max_step = adaptive_step_size(current_v.position, iterations)\n            step_length = min(dist, max_step)\n\n            new_pos_tensor = torch.round(torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == current_v.position:\n                return current_v, None\n\n            if q_new_pos in tree_vertices_map:\n                return current_v, None\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                return current_v, None\n\n            line_seq = grid.get_line_sequence(current_v.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                return current_v, None\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n            cost_to_q_new = current_v.cost + move_cost\n            q_new_vertex.cost = cost_to_q_new\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._rewire_lambda * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n            clearance_factor = 1.0 + min(self._get_clearance(q_new_pos) / (self._clearance_threshold * 2.0), 1.0)\n            radius *= clearance_factor\n\n            root_list = [start_vertex] if from_start_tree else [goal_vertex]\n            near_vertices = self._graph.get_vertices_within_radius(root_list, q_new_pos, radius)\n\n            # Choose best parent minimizing cost + heuristic with valid edge\n            best_parent = current_v\n            best_cost = cost_to_q_new\n            for neighbor in near_vertices:\n                candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                if candidate_cost < best_cost - 1e-5:\n                    line_seq_candidate = grid.get_line_sequence(neighbor.position, q_new_pos)\n                    if not grid.is_valid_line_sequence(line_seq_candidate):\n                        continue\n                    best_cost = candidate_cost\n                    best_parent = neighbor\n\n            q_new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, q_new_vertex)\n            tree_vertices_map[q_new_pos] = q_new_vertex\n\n            # Rewiring neighbors to q_new_vertex if cost improved\n            cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost < float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                new_cost = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                if new_cost + cost_improve_thresh < neighbor.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove current parents edges and rewire\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            est_total = q_new_vertex.cost + self._heuristic(q_new_vertex.position) if from_start_tree else q_new_vertex.cost + self._heuristic_reverse(q_new_vertex.position)\n            heapq.heappush(open_queue, (est_total, q_new_vertex))\n\n            # Attempt to connect the other tree by proximity and valid edge\n            other_root_list = [goal_vertex] if from_start_tree else [start_vertex]\n            # Use radius double of step for connection window\n            connect_radius = step_length * 2.0\n            candidates = self._graph.get_vertices_within_radius(other_root_list, q_new_vertex.position, connect_radius)\n            for candidate in candidates:\n                # Candidate belongs to the other tree\n                if candidate.position not in other_vertices_map:\n                    continue\n                line_seq_connect = grid.get_line_sequence(q_new_vertex.position, candidate.position)\n                if not grid.is_valid_line_sequence(line_seq_connect):\n                    continue\n                path_cost = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, candidate.position) + candidate.cost\n                if path_cost < self._best_cost - 1e-5:\n                    self._best_cost = path_cost\n                    # Construct a new vertex representing connecting edge\n                    connection_info = (q_new_vertex, candidate)\n                    return current_v, connection_info\n            return current_v, None\n\n        # Reverse heuristic: distance to agent from position (for goal tree)\n        def heuristic_reverse(pos: Point) -> float:\n            return Map.get_distance(pos, start_pos)\n\n        self._heuristic_reverse = heuristic_reverse  # attach helper for reverse heuristic\n\n        # Main bidirectional search loop\n        while iterations < self._max_iterations:\n            if time.time() - self._start_time > self._time_limit_seconds:\n                break\n\n            # Alternate expansions between start and goal tree based on ratio\n            expand_from_start = (torch.rand(1).item() < self._bidirectional_ratio)\n\n            if expand_from_start:\n                current_vertex, connection = try_extend(vertex_map_start, open_queue_start, vertex_map_goal, True)\n                if connection is not None:\n                    # We found connection between two trees\n                    q_new_vertex, candidate_vertex = connection\n                    # Create connecting edge from q_new_vertex to candidate_vertex (start to goal)\n                    self._graph.add_edge(q_new_vertex, candidate_vertex)\n                    found_connection = (q_new_vertex, candidate_vertex)\n                    break\n            else:\n                current_vertex, connection = try_extend(vertex_map_goal, open_queue_goal, vertex_map_start, False)\n                if connection is not None:\n                    # Connection found from goal tree side\n                    q_new_vertex, candidate_vertex = connection\n                    self._graph.add_edge(q_new_vertex, candidate_vertex)\n                    found_connection = (candidate_vertex, q_new_vertex)  # start tree vertex first\n                    break\n\n            iterations += 1\n\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if found_connection is not None:\n            # Extract path: combined path from start root to first vertex + from goal root to second vertex reversed\n            vertex_from_start, vertex_from_goal = found_connection\n\n            # Backtrack path from start side\n            path_start = []\n            curr = vertex_from_start\n            while True:\n                path_start.append(curr)\n                if not curr.parents:\n                    break\n                curr = min(curr.parents, key=lambda p: p.cost)\n            path_start.reverse()\n\n            # Backtrack path from goal side\n            path_goal = []\n            curr = vertex_from_goal\n            while True:\n                path_goal.append(curr)\n                if not curr.parents:\n                    break\n                curr = min(curr.parents, key=lambda p: p.cost)\n\n            # Full path concatenation\n            full_path = path_start + path_goal\n\n            # Shortcut smoothing: multiple passes\n            for _ in range(3):\n                i = 0\n                while i < len(full_path) - 2:\n                    j = len(full_path) - 1\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            del full_path[i + 1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n            # Move agent along path and keyframe\n            for v in full_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved PathPlanning algorithm builds upon the existing RRT*-inspired approach by integrating several key enhancements:\n    - Adaptive bidirectional tree growth: simultaneously grows two trees from start and goal, allowing faster connection attempts.\n    - Dynamic adaptive max step size based on both distance and progress ratio; this shrinks step size smoothly as trees near connection.\n    - Enhanced goal bias that adapts based on elapsed time to ensure intensified exploration near goal when needed.\n    - Heuristic-augmented nearest vertex selection which considers cost-to-goal (A*-style) to prioritize promising expansions.\n    - Improved rewiring with a dynamically scaled radius adapting to graph size and sampling density.\n    - Early stopping on either successful path connection or after a fixed time limit (10s) to control run time.\n    - Path shortcutting and smoothing post extraction to generate high-quality paths.\n    The approach aims for higher planning efficiency, improved success rate, and better path quality through faster convergence and refined sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Base probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n        # New member variables for bidirectional search and adaptive goal bias:\n        self._start_vertices = [self._graph.root_vertex_start]\n        self._goal_vertices = [self._graph.root_vertex_goal]\n        self._bidirectional = True\n\n    def _get_bidirectional_sample(self) -> Point:\n        \"\"\"\n        Alternates sampling between start tree and goal tree,\n        uses adaptive goal bias increasing over time to encourage reaching goal side.\n        \"\"\"\n        import time\n        grid = self._get_grid()\n        now = time.time()\n        elapsed = now - (self._start_time if self._start_time is not None else now)\n        # Increase goal bias over time linearly (capped at 0.5)\n        adaptive_goal_sample_rate = min(0.5, self._goal_sample_rate + elapsed * 0.03)\n        if torch.rand(1).item() < adaptive_goal_sample_rate:\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return self._graph.root_vertex_start.position\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive max step size shrinks smoothly as vertex approaches the opposite tree's root.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n\n        start_pos = self._graph.root_vertex_start.position\n        dist_to_start = Map.get_distance(pos, start_pos)\n\n        # Use min distance to start or goal for step sizing\n        dist = min(dist_to_goal, dist_to_start)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.3))\n        return scaled\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_pos: Point) -> float:\n        \"\"\"\n        Estimated cost from a vertex to a position, combining cost so far + heuristic estimate (Euclidean dist).\n        \"\"\"\n        return from_vertex.cost + Map.get_distance(from_vertex.position, to_pos)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            now = time.time()\n            if (now - self._start_time) > self._time_limit_seconds:\n                # Timeout reached\n                return\n\n            # Alternate expansion between start and goal trees\n            expanding_from_start = (iteration % 2 == 0)\n            sample = self._get_bidirectional_sample()\n            if expanding_from_start:\n                tree_roots = self._start_vertices\n                other_tree_roots = self._goal_vertices\n            else:\n                tree_roots = self._goal_vertices\n                other_tree_roots = self._start_vertices\n\n            # Select nearest vertex by heuristic-aware search\n            q_nearest = None\n            best_cost = float('inf')\n            vertices_to_search = []\n            for root in tree_roots:\n                vertices_to_search.append(root)\n            # To improve speed, find nearest based on minimal heuristic cost combining cost + dist(sample)\n            nearest_candidate = self._graph.get_nearest_vertex(tree_roots, sample)\n            if nearest_candidate is not None:\n                q_nearest = nearest_candidate\n            if q_nearest is None or q_nearest.position == sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_nearest.position)\n            dir_tensor = sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_dir = torch.norm(dir_tensor)\n            if dist_dir == 0:\n                continue\n            if dist_dir <= max_dist:\n                q_new_pos = sample\n            else:\n                dir_normalized = dir_tensor / dist_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Rewiring neighbors within adaptive radius\n            card_v = float(self._graph.size if self._graph.size > 0 else 1)\n            log_card_v = torch.log(torch.tensor(card_v)) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius(tree_roots, q_new.position, radius)\n\n            # Find best parent among neighbors minimizing cost + valid line\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_to_qnew = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost_candidate = q_near.cost + dist_to_qnew\n                if cost_candidate < c_min:\n                    line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if improved by going through q_new\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_qnew_qnear = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_qnew_qnear\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge\n                        for p in list(q_near.parents):\n                            self._graph.remove_edge(p, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Attempt to connect q_new to the other tree\n            vertices_other_near = self._graph.get_vertices_within_radius(other_tree_roots, q_new.position, radius)\n            connection_found = False\n            connecting_vertex = None\n            for q_other in vertices_other_near:\n                dist_connect = Map.get_distance(q_new.position, q_other.position)\n                if dist_connect <= max_dist:\n                    line_seq_connect = grid.get_line_sequence(q_new.position, q_other.position)\n                    if grid.is_valid_line_sequence(line_seq_connect):\n                        # Connect q_new and q_other: add edges between trees to form path\n                        self._graph.add_edge(q_new, q_other)\n                        # Prepare for path extraction by connecting start and goal trees\n                        connecting_vertex = q_new if expanding_from_start else q_other\n                        connection_found = True\n                        break\n            if connection_found:\n                # Extract path from start to goal by traversing parents from both sides\n                # Build forward path from start tree root to connecting vertex\n                path_start = []\n                curr = connecting_vertex\n                while True:\n                    path_start.append(curr)\n                    if len(curr.parents) == 0 or curr == start_vertex:\n                        break\n                    # pick parent in start tree\n                    curr = next(iter(curr.parents))\n                path_start.reverse()\n\n                # Build forward path from goal tree root to connecting vertex\n                path_goal = []\n                curr_goal = None\n                # Identify the vertex in the other tree connected to connecting_vertex\n                if expanding_from_start:\n                    curr_goal = None\n                    for child in connecting_vertex.children:\n                        if child in other_tree_roots or any(p in other_tree_roots for p in child.parents):\n                            curr_goal = child\n                            break\n                else:\n                    curr_goal = connecting_vertex\n                if curr_goal is None:\n                    # fallback: use goal vertex itself if connection is unclear\n                    curr_goal = goal_vertex\n\n                curr = curr_goal\n                while True:\n                    path_goal.append(curr)\n                    if len(curr.parents) == 0 or curr == goal_vertex:\n                        break\n                    # pick parent in goal tree\n                    curr = next(iter(curr.parents))\n\n                # Merge paths (excluding duplicate connecting_vertex)\n                full_path = path_start + path_goal[1:]\n                \n                # Shortcut smoothing on merged path\n                i = 0\n                while i < len(full_path) - 2:\n                    j = len(full_path) - 1\n                    while j > i + 1:\n                        line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                        if grid.is_valid_line_sequence(line_seq):\n                            del full_path[i + 1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n                # Move agent along final path\n                for v in full_path:\n                    self.move_agent(v.position)\n                    self.key_frame(ignore_key_frame_skip=True)\n                return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved RRT* inspired planner with goal-biased sampling and rewiring for path optimization. \n    It adaptively samples points mostly near the goal to improve convergence speed and path quality. \n    New vertices are connected by the minimal cost parent within a neighborhood radius (rewiring step) to optimize paths.\n    We introduce adaptive max_dist (step size) based on distance to goal to better explore and fine-tune paths near the goal.\n    Also added early stopping after 10 seconds to avoid long unsuccessful runs.\n    The extracted path is shortcut using line-of-sight checks to produce a smoother, shorter path.\n    These improvements aim to enhance planning efficiency, success rate, path optimality, and robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring\n        self._init_displays()\n\n        # Parameters for goal bias and rewiring radius\n        self._goal_bias = 0.2\n        self._neighbor_radius = 15.0\n        self._max_iterations = 10000\n        self._max_time_seconds = 10.0\n\n    # Helper function: goal biased sampling\n    def _get_biased_sample(self) -> Point:\n        # With probability goal_bias, sample goal, else uniformly random\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    # Helper function: choose the best parent vertex from neighbors minimizing cost\n    def _choose_best_parent(self, neighbors: List[Vertex], q_new_pos: Point) -> Vertex:\n        best_parent = None\n        min_cost = float('inf')\n        for neighbor in neighbors:\n            line_seq = self._get_grid().get_line_sequence(neighbor.position, q_new_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = neighbor.cost + self._get_grid().get_movement_cost(neighbor.position, q_new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n        return best_parent, min_cost\n\n    # Helper function: rewire neighbors to q_new if advantageous\n    def _rewire_neighbors(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old edges from parents\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    # Add new edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    # Helper function: adaptive max_dist: smaller steps near goal, bigger far away\n    def _adaptive_max_dist(self, from_pos: Point) -> float:\n        dist_to_goal = self._get_grid().get_distance(from_pos, self._get_grid().goal.position)\n        # Decrease step size linearly when closer than 30 units; min 2, max 15\n        if dist_to_goal < 30:\n            return max(2.0, 15.0 * (dist_to_goal / 30.0))\n        return 15.0\n\n    # Helper function: shortcut path by trying to reconnect non-adjacent vertices for smoother path\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        if len(path) < 3:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Find farthest reachable vertex with direct line-of-sight from current vertex\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Backtrack from goal to root to extract path\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Shortcut path for smoothness\n        path = self._shortcut_path(path)\n\n        # Animate agent along extracted path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        # Initialize costs (start vertex cost=0)\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(self._max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._max_time_seconds:\n                # Timeout: treat as no path found\n                break\n\n            q_sample: Point = self._get_biased_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n            norm_dir = torch.norm(dir_tensor)\n            if norm_dir <= 1e-8:\n                continue\n\n            if norm_dir > max_dist:\n                dir_normalized = dir_tensor / norm_dir\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            else:\n                q_new_pos = q_sample\n\n            # Check line validity\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within radius\n            neighbors: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new_pos, self._neighbor_radius)\n\n            # Choose best parent minimizing cost\n            best_parent, min_cost = self._choose_best_parent(neighbors, q_new_pos)\n            if best_parent is None:\n                # Fallback to nearest vertex if no better parent found\n                best_parent = q_near\n                min_cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new_pos)\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to optimize tree\n            self._rewire_neighbors(q_new, neighbors)\n\n            # Check if goal reached within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to official goal vertex to finalize path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Heuristic-Guided RRT* with Dynamic Step Size, Informed Sampling,\n    and Enhanced Rewiring for Improved Path Quality and Efficiency",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Adaptive Heuristic-Guided RRT* with Dynamic Step Size, Informed Sampling,\n    and Enhanced Rewiring for Improved Path Quality and Efficiency}\n\n    This algorithm builds on classic RRT* with several key improvements:\n    - Adaptive max step size (max_dist) scaled dynamically based on distance to goal \n      for efficient exploration and fine local refinement.\n    - Informed sampling within an ellipsoidal subset towards the goal to focus sampling \n      in promising regions, improving success rate and reducing unnecessary explorations.\n    - Heuristic-guided vertex expansion prioritizing vertices closer to goal via cost + heuristic.\n    - Rewiring neighbors with enhanced pruning and parent selection to further improve path quality.\n    - Early stopping upon reaching goal within radius or time limit (10s).\n    - Shortcut path smoothing post extraction to minimize detours.\n    - Goal biased sampling is incorporated inside the informed sampler to maintain balance.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._goal_sample_rate = 0.20         # Increased goal bias for faster convergence\n        self._rewire_radius = 20              # Slightly larger rewiring radius for better optimization\n        self._max_dist_base = 20              # Base max step size (will adapt)\n        self._max_iterations = 6000           # Reduced iterations due to smarter sampling\n        self._time_limit_sec = 10.0\n\n    def _informed_sample(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Ellipsoidal informed sampling biased towards the subset where better solutions can exist.\n        If path cost c_best is infinity (no solution yet), do uniform random sampling with goal bias.\n        \"\"\"\n        import math\n        import random\n        grid = self._get_grid()\n\n        if c_best == float('inf'):\n            # No current solution, do goal biased sampling\n            if random.random() < self._goal_sample_rate:\n                return goal\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        c_min = start.to_tensor().distance(goal.to_tensor()).item()\n        # Define ellipse parameters: center, rotation (unit vector), axis lengths\n        x_center = (start.to_tensor() + goal.to_tensor()) / 2.0\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min  # Unit vector from start to goal\n        dim = len(start.to_tensor())\n        # Construct rotation matrix (for n-dimensions)\n        # Extend with orthonormal basis using Gram-Schmidt\n        basis = [a1]\n        # Create orthonormal basis for other directions\n        import torch\n        if dim > 1:\n            for i in range(dim):\n                e = torch.zeros(dim)\n                e[i] = 1.0\n                if torch.abs(e - a1).sum() > 1e-5:\n                    proj = e - torch.dot(e, a1) * a1\n                    if proj.norm() > 1e-5:\n                        basis.append(proj / proj.norm())\n        U = torch.stack(basis[:dim], dim=1)  # Rotation matrix of size dim x dim\n\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0 if c_best > c_min else 0.0\n\n        # Sample uniformly in unit n-ball\n        while True:\n            x = torch.randn(dim)\n            norm_x = torch.norm(x)\n            if norm_x <= 1.0 and norm_x > 1e-7:\n                x = x / norm_x\n                break\n\n        # Scale by axes lengths (ellipsoid radii)\n        L = torch.diag(torch.tensor([r1] + [r2] * (dim - 1)))\n        sample_tf = U @ L @ x + x_center\n\n        sample_coords = tuple(int(round(v.item())) for v in sample_tf)\n\n        sample_point = Point(*sample_coords)\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # Fall back to uniform random sample with goal bias if invalid\n            if random.random() < self._goal_sample_rate:\n                return goal\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                fallback_sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(fallback_sample):\n                    return fallback_sample\n\n    def _adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        # Adaptive step size: bigger steps far from goal, smaller near goal for precision\n        distance_to_goal = self._get_grid().get_distance(current_pos, goal_pos)\n        max_step = max(4.0, min(self._max_dist_base, distance_to_goal / 2.0))\n        return max_step\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        \"\"\"\n        Parent selection considering total cost = cost from start + heuristic to goal,\n        where heuristic is Euclidean distance from q_new to goal.\n\n        Only parents with valid line sequences are admissible.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        min_cost = float('inf')\n        min_vertex = None\n\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic = grid.get_distance(q_new.position, goal_pos)\n            total_cost = cost_to_new + heuristic  # A* style cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                min_vertex = q_near\n\n        if min_vertex is not None:\n            q_new.cost = min_vertex.cost + grid.get_distance(min_vertex.position, q_new.position)\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewire neighbors to q_new if it improves cost\n        Also prune redundant edges for robustness.\n        \"\"\"\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove all parent edges with worse cost:\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Same as provided, extracting path using lowest cost parents and shortcut smoothing\n        path = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        # Same shortcut smoothing as original algorithm\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        start_pos = start_vertex.position\n        goal_pos = goal_vertex.position\n\n        best_solution_cost = float('inf')\n        best_goal_vertex = None\n\n        start_time = time.time()\n\n        # Priority queue for vertices to expand: entries are (cost + heuristic, vertex)\n        open_list = []\n        heapq.heappush(open_list, (0.0, start_vertex))\n\n        # We keep track of vertices explored for goal bias and heuristics\n        vertices_set = set([start_vertex])\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if (time.time() - start_time) > self._time_limit_sec:\n                break\n\n            # Sample informed or goal biased\n            q_sample = self._informed_sample(start_pos, goal_pos, best_solution_cost)\n\n            # Select nearest vertex using heuristic-aware priority (heuristic included in expansion)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                # If exact vertex matches sample, skip\n                self.key_frame()\n                continue\n\n            # Adaptive step size based on distance to goal\n            max_dist = self._adaptive_max_dist(q_near.position, goal_pos)\n\n            # Generate new vertex towards q_sample clipped by max_dist\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Neighbors for rewiring within radius (increased radius)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            # Choose best parent by cost + heuristic\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                self.key_frame()\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n            vertices_set.add(q_new)\n\n            # Rewire neighbors\n            self._rewire(q_new, neighbors)\n\n            # If we reached goal radius, connect to goal and check if better solution\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_pos)):\n                    goal_cost = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                    if goal_cost < best_solution_cost:\n                        best_solution_cost = goal_cost\n                        # Update goal vertex cost and add edge if better\n                        goal_vertex.cost = goal_cost\n                        self._graph.add_edge(q_new, goal_vertex)\n                        best_goal_vertex = goal_vertex\n\n            self.key_frame()\n\n            # Early break if solution found and unexplored region deemed unlikely to yield better cost\n            # (Using heuristic we could implement but here we rely on time/iteration limit)\n\n        # If a path to goal found, extract and move agent\n        if best_goal_vertex is not None:\n            self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved path planning algorithm with enhanced heuristic-guided RRT*:\n    - Combines clearance-aware biased sampling (goal, informed ellipsoid, and uniform with clearance).\n    - Adaptive step size dynamically scaled by distance to goal, tree size, and clearance.\n    - Heuristic-cost integration into parent selection and rewiring to prioritize shorter paths.\n    - Dynamic rewiring radius influenced by clearance to better adapt neighborhood size.\n    - Early pruning when cost improvements are marginal during rewiring to reduce overhead.\n    - Multiple robust shortcut smoothing passes to improve path quality.\n    - Early termination as soon as a direct, valid connection to goal is found.\n    - Enforced 10-second runtime limit to maintain responsiveness.\n    \"\"\"\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Precompute constants for rewiring radius calculation\n        rewire_base_lambda = self._lambda_rrt_star\n        dimension = self._dimension\n        clearance_thresh = self._clearance_threshold\n        min_rewire_radius = 10.0\n        max_rewire_radius = 30.0\n\n        for iteration in range(self._max_iterations):\n            # Enforce 10-second timeout\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                break  # Timeout\n\n            # Sample new point using clearance- and heuristics-aware mixed sampling\n            q_sample = self._get_random_sample()\n            \n            # Nearest vertex in the tree to the sample\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                # Skip if sample equals nearest vertex\n                continue\n\n            # Compute adaptive max dist (adaptive per clearance, dist to goal, and tree size)\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n\n            # Direction and distance towards the sample\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist_dir = torch.norm(dir_vec).item()\n            if dist_dir < 1e-8:\n                continue\n\n            # Determine new position with capped step size by max_dist\n            if dist_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist_dir\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            # Validate position for agent and path feasibility\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            \n            # Create new vertex and compute tentative cost via nearest vertex\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            tentative_cost = q_nearest.cost + dist_qnearest_qnew\n\n            # Compute rewiring radius dynamically based on tree size and clearance at new pos\n            tree_size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(tree_size))).item() if tree_size > 1 else 0.0\n            radius = min(rewire_base_lambda * ((ln_size / tree_size) ** (1 / dimension)), max_rewire_radius)\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_factor = 1.0 + min(clearance_new / clearance_thresh, 1.0)\n            radius *= clearance_factor\n            radius = max(radius, min_rewire_radius)\n\n            # Find near vertices for possibly better parent and rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic goal position for cost + heuristic calculation\n            goal_pos_tensor = goal_pos.to_tensor().float()\n\n            # Select best parent: minimal cost + heuristic + valid connection\n            q_min = q_nearest\n            c_min = tentative_cost + self._heuristic_cost(q_new.position, goal_pos)\n            for v in near_vertices:\n                dist_v_qnew = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                # Candidate cost plus heuristic to goal\n                candidate_cost = v.cost + dist_v_qnew\n                f_candidate = candidate_cost + self._heuristic_cost(q_new.position, goal_pos)\n                if f_candidate < c_min:\n                    # Check path validity\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = f_candidate\n\n            # Assign cost without heuristic for actual cost value\n            q_new.cost = q_min.cost + torch.norm(q_min.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n\n            # Add edge (parent-child) to graph\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors for cost improvements with pruning\n            rewire_improve_thresh = 0.005\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_vnear = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_vnear\n                if cost_through_new + rewire_improve_thresh < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove old parent edge (one parent per vertex)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            # Check if goal can be connected directly from q_new within max_dist\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Update best cost and record found goal vertex\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early termination if goal reached efficiently\n                    break\n\n            # Periodically update visualization frames\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        # If goal found, extract and smooth path, then move agent along path\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm integrating adaptive informed sampling, heuristic-guided expansion, \n    dynamic adaptive step size and rewiring radius, with efficient rewiring pruning and robust multi-pass \n    shortcut smoothing. The algorithm balances uniform, goal-biased, and ellipsoidal informed sampling based \n    on current path costs, scales step sizes and rewiring radius dynamically according to progress and tree size, \n    incorporates heuristic cost-to-go in parent choosing, and implements early stopping upon direct goal connection \n    to yield faster planning, higher success rates, and smoother, shorter paths. \n    Robust time-limit enforcement ensures responsiveness and practical usability.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.25\n        self._informed_sample_rate = 0.3\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _get_heuristic_cost(self, q_from: Vertex, q_to: Vertex) -> float:\n        # Heuristic: actual cost + admissible distance to goal\n        return q_from.cost + Map.get_distance(q_from.position, q_to.position)\n\n    def _get_adaptive_rewire_radius(self) -> float:\n        card_v = max(self._graph.size, 1)\n        ln_card_v = 0.0\n        import torch\n        if card_v > 1:\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item()\n        # Radius adapts smaller as the tree grows, capped to 25\n        radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n        return radius\n\n    def _early_rewire_prune(self, q_new: Vertex, neighbors: list):\n        grid = self._get_grid()\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            dist_new_near = Map.get_distance(q_new.position, q_near.position)\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new + 1e-5 < q_near.cost:\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if grid.is_valid_line_sequence(line_seq_rewire):\n                    # Remove one old parent (tree edge)\n                    for parent in q_near.parents:\n                        self._graph.remove_edge(parent, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Robust multi-pass shortcut smoothing preserving connectivity\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Multi-pass shortcutting for smoothness\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove intermediate vertices between i and j\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time limit enforcement\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_vec).item()\n            if dir_norm == 0:\n                continue\n\n            # Adaptive step: interpolate toward sample but bounded by max_dist\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                new_coords = (q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_coords)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # New vertex construction\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            radius = self._get_adaptive_rewire_radius()\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Parent choosing with heuristic-guided cost\n            q_best_parent = q_nearest\n            min_total_cost = q_nearest.cost + dist_nearest_to_new + self._heuristic_cost(q_new.position, goal_pos)\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_candidate = cost_candidate + Map.get_distance(q_new.position, goal_pos)\n                if heuristic_candidate < min_total_cost:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_best_parent = q_near\n                        min_total_cost = heuristic_candidate\n\n            q_new.cost = q_best_parent.cost + Map.get_distance(q_best_parent.position, q_new.position)\n            self._graph.add_edge(q_best_parent, q_new)\n\n            # Early rewire pruning neighbors\n            self._early_rewire_prune(q_new, vertices_near)\n\n            # Check direct connect to goal for early termination\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            adaptive_goal_threshold = max_dist\n            if dist_to_goal <= adaptive_goal_threshold:\n                line_seq_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early terminate with best found path to goal\n                    break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant inspired by RRT*, incorporating:\n    - Goal-biased sampling: sampling towards the goal with probability bias to speed convergence.\n    - Adaptive step size: max_dist adapts based on distance to goal, allowing fine steering near goal.\n    - Rewiring for path optimization (RRT* style): after adding a new vertex, nearby vertices\n      are checked and rewired if a lower cost path is found through the new vertex.\n    - Path smoothing during extraction by shortcutting invalid segments.\n    - Early stopping if a path is found and no significant improvement is detected.\n    - Overall, these enhancements improve planning efficiency, path quality, and success rate.\n    - A 10-second timeout for planning is enforced to ensure timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges\n        self._init_displays()\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        \"\"\"\n        Sample point with a chance to bias towards the goal for faster convergence.\n        \"\"\"\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(\n                0, self._get_grid().size, self._get_grid().size.n_dim\n            )\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _cost(self, frm: Vertex, to: Vertex) -> float:\n        \"\"\"\n        Cost between two vertices: distance + movement cost from map.\n        \"\"\"\n        straight_line = self._get_grid().get_line_sequence(frm.position, to.position)\n        if not self._get_grid().is_valid_line_sequence(straight_line):\n            return float(\"inf\")\n        dist = Map.get_distance(frm.position, to.position)\n        move_cost = 0.0\n        pts = straight_line\n        if len(pts) >= 2:\n            for i in range(len(pts) - 1):\n                move_cost += self._get_grid().get_movement_cost(pts[i], pts[i + 1])\n        else:\n            move_cost = dist\n        return move_cost\n\n    def _find_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find vertices in the graph within a radius of q_new.position for rewiring.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, radius)\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        RRT* style rewiring: for each near vertex, check if path through q_new is cheaper.\n        If yes and path is collision free, rewire the edge.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            cost_through_qnew = q_new.cost + self._cost(q_new, q_near)\n            if cost_through_qnew < q_near.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edge from current parent(s)\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                    # Add new edge q_new -> q_near\n                    self._graph.add_edge(q_new, q_near)\n                    q_near.cost = cost_through_qnew\n\n    def _update_costs_from(self, root: Vertex) -> None:\n        \"\"\"\n        After rewiring, update child costs downstream.\n        \"\"\"\n        def dfs_update(v: Vertex):\n            for child in v.children:\n                old_cost = child.cost\n                edge_cost = self._cost(v, child)\n                new_cost = v.cost + edge_cost\n                if new_cost < old_cost:\n                    child.cost = new_cost\n                    dfs_update(child)\n\n        dfs_update(root)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from goal vertex to start using parent links.\n        Then apply smoothing by shortcutting the path segments.\n        Finally, animate the agent movement along the smoothed path.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) > 0:\n            # Pick the parent with minimal cost (to break multiple parents)\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n\n        path.reverse()\n\n        # Shortcut smoothing: try to connect distant points directly when possible\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        smoothed_path = shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        start_vertex.cost = 0.0\n        max_iterations = 8000\n        max_dist_initial = 12\n        radius_factor = 20.0  # Radius factor for neighbor search\n        best_goal_vertex = None\n        best_cost = float(\"inf\")\n\n        for iter_count in range(max_iterations):\n            if time.time() - start_time > 10.0:  # 10 seconds timeout\n                break\n\n            # Adaptive max distance: smaller near goal to better refine path\n            dist_to_goal = Map.get_distance(start_vertex.position, goal_pos)\n            max_dist = min(max_dist_initial, max(3.0, dist_to_goal / 5.0))\n\n            q_sample = self._get_random_sample(goal_bias=0.15)\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Verify path validity before adding\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            tentative_cost = q_near.cost + self._cost(q_near, q_new)\n            q_new.cost = tentative_cost\n\n            # Find near vertices within radius for rewiring\n            radius = radius_factor * (np.log(self._graph.size + 1) / (self._graph.size + 1)) ** (1 / self._get_grid().size.n_dim)\n            near_vertices = self._find_near_vertices(q_new, radius)\n\n            # Choose parent with minimum cost from near vertices\n            min_cost = tentative_cost\n            min_parent = q_near\n            for near_v in near_vertices:\n                if near_v == q_near:\n                    continue\n                line_seq_candidate = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    cost_candidate = near_v.cost + self._cost(near_v, q_new)\n                    if cost_candidate < min_cost:\n                        min_cost = cost_candidate\n                        min_parent = near_v\n            q_new.cost = min_cost\n\n            self._graph.add_edge(min_parent, q_new)\n\n            # Rewire near vertices through q_new if cheaper\n            self._rewire(q_new, near_vertices)\n            self._update_costs_from(q_new)\n\n            self.key_frame()\n\n            # Check if q_new is close to goal and can connect directly\n            if Map.get_distance(q_new.position, goal_pos) < max_dist_initial:\n                line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                    q_goal = Vertex(goal_pos)\n                    q_goal.cost = q_new.cost + self._cost(q_new, q_goal)\n                    self._graph.add_edge(q_new, q_goal)\n\n                    if q_goal.cost < best_cost:\n                        best_cost = q_goal.cost\n                        best_goal_vertex = q_goal\n\n                        # Once improved path found, attempt path extraction & stop\n                        self._extract_path(q_goal)\n                        return\n\n        # If found no exact connection to goal, check if any vertex within goal radius exists\n        if best_goal_vertex is None:\n            # Find any vertex in goal radius\n            vertices_near_goal = self._graph.get_vertices_within_radius(self._graph.root_vertices, goal_pos, radius=max_dist_initial)\n            valid_candidates = []\n            for v in vertices_near_goal:\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=v.position):\n                    valid_candidates.append(v)\n            if valid_candidates:\n                best_goal_vertex = min(valid_candidates, key=lambda v: v.cost)\n                self._extract_path(best_goal_vertex)\n                return\n\n        # No path found (timeout or no connection)\n        # Optionally: Could raise or handle failure here\n        return",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm:\n    This algorithm enhances the original RRT*-inspired planner by incorporating:\n    - Dynamic adaptive max step size shrinking more aggressively near goal for smoother fine moves.\n    - Goal-biased sampling combined with heuristic steering towards goal using cost-to-go distance.\n    - An improved rewiring approach considering both cost-to-come and estimated cost-to-go (heuristic).\n    - Neighborhood radius adaptation using graph size and distance to goal for more focused rewiring.\n    - Incremental path smoothing during expansion by attempting shortcut edges to ancestors and neighbors.\n    - Early stopping if goal is connected or if planning time exceeds 10 seconds.\n    - Path extraction includes aggressive shortcutting to produce a smoother, shorter path.\n    This method aims for higher success rate, shorter and smoother paths with fewer iterations and better robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._start_time = time.time()\n        found_goal_vertex = None\n\n        # Precompute useful constants\n        dimension = self._dimension\n        max_iterations = self._max_iterations\n        lambda_rrt_star = self._lambda_rrt_star\n        min_max_dist = self._min_max_dist\n        max_max_dist = self._max_max_dist\n        goal_sample_rate = self._goal_sample_rate\n        time_limit = self._time_limit_seconds\n\n        def heuristic_cost(pos: Point) -> float:\n            # Euclidean distance heuristic cost to goal\n            return Map.get_distance(pos, goal_pos)\n\n        def attempt_shortcut_path(path_vertices: list) -> list:\n            # Aggressive shortcutting over path_vertices by skipping intermediate points\n            i = 0\n            while i < len(path_vertices) - 2:\n                j = len(path_vertices) - 1\n                while j > i + 1:\n                    seq = grid.get_line_sequence(path_vertices[i].position, path_vertices[j].position)\n                    if grid.is_valid_line_sequence(seq):\n                        # shortcut path\n                        del path_vertices[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n            return path_vertices\n\n        def try_connect_to_goal(q_vertex: Vertex, max_dist_local: float) -> Vertex or None:\n            # Verify if goal within max_dist_local and connection is valid\n            dist_go = heuristic_cost(q_vertex.position)\n            if dist_go <= max_dist_local:\n                line_to_goal = grid.get_line_sequence(q_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_vertex.cost + dist_go\n                    self._graph.add_edge(q_vertex, goal_vertex)\n                    return goal_vertex\n            return None\n\n        def connect_shortcut_neighbors(q_new: Vertex, neighbor_vertices: list):\n            # Attempt shortcut edges to neighbors and parents to reduce cost and improve smoothness\n            for q_nb in neighbor_vertices:\n                if q_nb == q_new:\n                    continue\n\n                # Check if direct line q_new <-> q_nb is free\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_nb.position)):\n                    dist_link = heuristic_cost(q_new.position) + heuristic_cost(q_nb.position)\n                    cost_through_new = q_new.cost + Map.get_distance(q_new.position, q_nb.position)\n                    cost_through_nb = q_nb.cost + Map.get_distance(q_nb.position, q_new.position)\n\n                    # Rewire neighbor to q_new if cheaper\n                    if cost_through_new < q_nb.cost:\n                        for parent in list(q_nb.parents):\n                            self._graph.remove_edge(parent, q_nb)\n                            break\n                        q_nb.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_nb)\n\n                    # Rewire q_new to neighbor if cheaper\n                    if cost_through_nb < q_new.cost:\n                        for parent in list(q_new.parents):\n                            self._graph.remove_edge(parent, q_new)\n                            break\n                        q_new.cost = cost_through_nb\n                        self._graph.add_edge(q_nb, q_new)\n\n        for iteration in range(max_iterations):\n            # Time cutoff\n            elapsed = time.time() - self._start_time\n            if elapsed > time_limit:\n                return  # time limit exceeded\n\n            # Goal-biased sampling with heuristic steering\n            if torch.rand(1).item() < goal_sample_rate:\n                # Sample near goal in a small ball\n                for _ in range(30):\n                    sample_offset = torch.randn(dimension) * min_max_dist\n                    sample_raw = torch.tensor(goal_pos.to_tensor(), dtype=torch.float) + sample_offset\n                    sample_coords = sample_raw.round().int()\n                    sample_point = Point(*sample_coords.tolist())\n                    if grid.is_agent_valid_pos(sample_point):\n                        q_sample = sample_point\n                        break\n                else:\n                    q_sample = goal_pos\n            else:\n                # Uniform sampling but filtered for valid positions\n                timeout_sample = 0\n                q_sample = None\n                while timeout_sample < 100:\n                    coords = []\n                    for d in range(dimension):\n                        coords.append(torch.randint(0, grid.size[d], (1,)).item())\n                    candidate = Point(*coords)\n                    if grid.is_agent_valid_pos(candidate):\n                        q_sample = candidate\n                        break\n                    timeout_sample += 1\n                if q_sample is None:\n                    q_sample = start_vertex.position\n\n            # Find nearest vertex to sample\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max step size reducing more aggressively near goal\n            dist_to_goal = heuristic_cost(q_nearest.position)\n            adapt_frac = max(dist_to_goal / max_max_dist, 0.1)\n            max_dist = (max_max_dist - min_max_dist) * adapt_frac + min_max_dist\n\n            # Direction and candidate new vertex along step size\n            dir_vec = torch.tensor(q_sample.to_tensor(), dtype=torch.float) - torch.tensor(q_nearest.position.to_tensor(), dtype=torch.float)\n            norm_dir = torch.norm(dir_vec)\n            if norm_dir == 0:\n                continue\n            if norm_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                unit_dir = dir_vec / norm_dir\n                new_pos_tensor = torch.tensor(q_nearest.position.to_tensor(), dtype=torch.float) + unit_dir * max_dist\n                q_new_pos = Point.from_tensor(new_pos_tensor.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check collision with line from nearest to new pos\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            # Rewiring neighborhood radius adaptive to graph size and distance to goal\n            graph_size_tensor = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1), dtype=torch.float)\n            log_card_v = torch.log(graph_size_tensor) if graph_size_tensor > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / graph_size_tensor) ** (1 / dimension)), 30.0)\n            radius = max(radius, max_dist * 1.5)  # Ensure radius >= max_dist for effective rewiring\n\n            # Find nearby vertices for rewiring and possible parents\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Find best parent minimizing cost_to_come + movement + heuristic cost to goal\n            best_parent = q_nearest\n            dist_nearest_new = Map.get_distance(q_nearest.position, q_new.position)\n            best_cost = q_nearest.cost + dist_nearest_new + heuristic_cost(q_new.position)\n\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_through_candidate = q_near.cost + dist_near_new + heuristic_cost(q_new.position)\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_through_candidate < best_cost and grid.is_valid_line_sequence(line_seq_candidate):\n                    best_parent = q_near\n                    best_cost = cost_through_candidate\n\n            # Assign cost and add edge\n            cost_parent_to_new = Map.get_distance(best_parent.position, q_new.position)\n            q_new.cost = best_parent.cost + cost_parent_to_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Attempt to shortcut walks to ancestors and neighbors for smoother connectivity\n            connect_shortcut_neighbors(q_new, vertices_near)\n\n            # Rewire neighbors through q_new if beneficial\n            for q_near in vertices_near:\n                if q_near == best_parent:\n                    continue\n                dist_new_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge(s)\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new can connect to goal with valid edge\n            goal_vertex_candidate = try_connect_to_goal(q_new, max_dist)\n            if goal_vertex_candidate:\n                found_goal_vertex = goal_vertex_candidate\n                break\n\n            self.key_frame()\n\n        if found_goal_vertex is None:\n            # No path found within time or iterations\n            return\n\n        # Extract path from start to goal and aggressively shortcut it\n        path_vertices = []\n        current = found_goal_vertex\n        while True:\n            path_vertices.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_vertices.reverse()\n\n        path_vertices = attempt_shortcut_path(path_vertices)\n\n        # Move agent along smoothed path (with animation keyframes)\n        for v in path_vertices:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm integrating adaptive goal-biased and informed ellipsoidal sampling,\n    heuristic-based vertex expansion prioritizing both traveled cost and admissible heuristic, dynamic\n    step size and rewiring radii, as well as enhanced path smoothing with repeated aggressive shortcutting.\n    The algorithm maintains robustness and efficiency by early stopping on direct goal connection,\n    pruning excessive rewiring with cost thresholds, and maintaining dynamic sampling mixes to concentrate\n    search around promising areas. This results in higher success rates, faster convergence, and smoother final paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.5   # Min step size near goal for finer control\n        self._goal_sample_rate = 0.25  # Slightly increased goal bias\n        self._informed_sample_rate = 0.3  # Probability to do informed sampling\n        self._max_iterations = 4000  # Reduced max iterations due to more efficient search\n        self._lambda_rrt_star = 45  # tuning rewiring radius factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._best_cost = float('inf')  # Track best path cost found so far\n        self._init_displays()\n        # Additional members to maintain priority queue of expansion candidates\n        self._open_set = None\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Admissible heuristic: Euclidean distance to goal\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Dynamic max step size scales smaller near goal & as tree grows larger\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        progress_factor = max(0.05, min(1.0, dist / max(grid.size)))  # normalized distance to goal\n        tree_size_factor = min(1.0, 500 / (self._graph.size + 1))  # shrink step size as tree grows\n        scaled = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * tree_size_factor\n        return scaled\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Enhanced multi-pass shortcut smoothing with aggressive pruning for smoothness and short length\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        for _ in range(5):  # More passes for aggressive smoothing\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                advanced_shortcut = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        advanced_shortcut = True\n                    else:\n                        j -= 1\n                if not advanced_shortcut:\n                    i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _select_sample(self) -> Point:\n        \"\"\"\n        Adaptive mixed sampling:\n         - goal biasing with _goal_sample_rate\n         - informed ellipsoidal sampling if best cost known with _informed_sample_rate\n         - uniform random otherwise\n        Try multiple retries if necessary\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal biased sampling near goal within min_max_dist radius\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                offset = torch.randn(self._dimension)\n                norm = torch.norm(offset)\n                if norm > 1e-8:\n                    offset = offset / norm\n                offset = offset * (torch.rand(1).item() * self._min_max_dist)\n                candidate = Point(*((goal_pos.to_tensor().float() + offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n            return goal_pos\n\n        elif (rand_val < self._goal_sample_rate + self._informed_sample_rate) and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling focused within best cost\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling valid positions in grid\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                candidate = Point(*sample_coords)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n            # fallback if all else fails\n            return self._graph.root_vertex_start.position\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        from heapq import heappush, heappop\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Priority queue holding (cost+heuristic, Vertex) for expansion candidates\n        # Initially only the start vertex\n        open_heap = []\n        heappush(open_heap, (start_vertex.cost + self._heuristic_cost(start_vertex.position, goal_pos), start_vertex))\n\n        for iteration in range(self._max_iterations):\n            # Time boundary check for early termination\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Timeout, no path found or partial\n\n            if not open_heap:\n                # No vertices to expand, end early\n                break\n\n            # Sample new point in space to guide expansion\n            q_sample = self._select_sample()\n\n            # Extract lowest f-cost vertex from open set for expansion\n            _, q_nearest = heappop(open_heap)\n\n            if q_nearest.position == q_sample:\n                # Skip trivial same position sample\n                # Reinsert q_nearest and continue to next iteration\n                heappush(open_heap, (_.pop(0), q_nearest))\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist_dir = torch.norm(dir_vec).item()\n            if dist_dir == 0:\n                heappush(open_heap, (q_nearest.cost + self._heuristic_cost(q_nearest.position, goal_pos), q_nearest))\n                continue\n\n            if dist_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                # Reinstate the nearest vertex to open set, skip adding q_new\n                heappush(open_heap, (q_nearest.cost + self._heuristic_cost(q_nearest.position, goal_pos), q_nearest))\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                heappush(open_heap, (q_nearest.cost + self._heuristic_cost(q_nearest.position, goal_pos), q_nearest))\n                continue\n\n            # Construct new vertex and cost to reach it\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Calculate adaptive radius for rewiring (RRT* style)\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent to minimize cost with valid path\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_to_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_to_new\n                if cost_candidate + 1e-8 < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path through q_new found, but prune rewiring if cost improvement insignificant\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-5 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove an old parent edge (to maintain tree structure)\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n                        # Also reinsert rewire candidate into open set for possible expansion\n                        heappush(open_heap, (q_near.cost + self._heuristic_cost(q_near.position, goal_pos), q_near))\n\n            # Add q_new to open set for further expansion prioritized by cost+heuristic\n            f_cost = q_new.cost + self._heuristic_cost(q_new.position, goal_pos)\n            heappush(open_heap, (f_cost, q_new))\n\n            # Check if q_new can connect directly to goal with valid path\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Construct goal vertex as terminal node with cost update\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early termination on good direct connection to goal, with optional smoothing\n                    break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved PathPlanning Algorithm enhancing the provided base implementation by:\n    - Adaptive max step size that decreases near the goal and as tree grows for balanced exploration/exploitation.\n    - Mixed sampling strategy combining goal-biased, uniform, and adaptive informed ellipsoidal sampling focused on current best path cost.\n    - Heuristic-guided vertex expansion prioritizing combined traveled cost and admissible heuristic (Euclidean) cost to goal.\n    - Dynamic neighborhood radius for rewiring scaling with tree size and iteration count for efficient optimal connections.\n    - Early pruning of suboptimal rewiring parents to reduce graph clutter and improve efficiency.\n    - Robust multi-pass shortcutting smoothing with randomized attempts to greatly improve path smoothness.\n    - Early termination triggered immediately upon finding a direct, valid, and smooth connection to the goal.\n    - Time limit constraint of 10 seconds enforced for robustness and to handle large or complex maps.\n    \n    These enhancements yield faster convergence, higher success rate, and smoother final paths.\n    \"\"\"\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n        import random\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Maintain a priority list to select vertices with low estimated total cost (cost + heuristic)\n        def vertex_priority(v: Vertex) -> float:\n            return v.cost + self._heuristic_cost(v.position, goal_pos)\n\n        max_no_improve_iterations = 200\n        no_improve_counter = 0\n\n        for iteration in range(1, self._max_iterations + 1):\n            # Enforce time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # --- Sampling ---\n            q_sample = self._get_random_sample()\n\n            # --- Nearest vertex to q_sample, but among a prioritized subset ---\n            # To improve efficiency, sample among vertices with low heuristic cost\n            candidates = [start_vertex]\n            if self._graph.size > 30:\n                radius_expand = max(5.0, self._get_adaptive_max_dist(goal_pos) * 1.5)\n                nearby_vertices = self._graph.get_vertices_within_radius([start_vertex], q_sample, radius_expand)\n                if len(nearby_vertices) > 0:\n                    candidates = nearby_vertices\n\n            q_nearest = self._graph.get_nearest_vertex(candidates, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_step = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir == 0:\n                continue\n\n            if norm_dir <= max_step:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / norm_dir\n                step_pos_tensor = q_nearest.position.to_tensor().float() + dir_normalized * max_step\n                q_new_pos = Point.from_tensor(step_pos_tensor.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Validate line between q_nearest and q_new_pos\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            # Compute dynamic rewiring radius based on tree size and iteration\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            base_radius = self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension))\n            # Gradually shrink rewiring radius as iterations increase for refinement\n            adaptive_radius = max(4.0, min(base_radius, 20.0)) * max(0.1, 1 - iteration / self._max_iterations)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, adaptive_radius)\n\n            # --- Choose best parent among nearby vertices with minimum cost + heuristic ---\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                candidate_cost = q_near.cost + dist_near_new\n                if candidate_cost < c_min:\n                    line_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_candidate):\n                        q_min = q_near\n                        c_min = candidate_cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # --- Rewire neighbors with improved cost through q_new ---\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_via_new = q_new.cost + dist_new_near\n                if cost_via_new + 1e-6 < q_near.cost:\n                    line_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_rewire):\n                        # Remove one existing parent edge (preserves tree)\n                        if q_near.parents:\n                            for old_parent in list(q_near.parents):\n                                # Prune only if cost is significantly better\n                                if cost_via_new + 0.01 < q_near.cost:\n                                    self._graph.remove_edge(old_parent, q_near)\n                                    break\n                        q_near.cost = cost_via_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # --- Check direct connection to goal ---\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal_vertex = goal_vertex\n                        no_improve_counter = 0\n\n                    # Early stopping if path directly to goal is found and path is valid after smoothing test\n                    # Attempt quick path smoothing test:\n                    temp_path = [goal_vertex, q_new]\n                    can_shortcut = True\n                    try_path = [q_new, goal_vertex]\n                    # If the direct segment is valid, consider done.\n                    if can_shortcut:\n                        break\n\n            else:\n                no_improve_counter += 1\n\n            # Early stopping if no improvements for many iterations to save time\n            if no_improve_counter > max_no_improve_iterations and found_goal_vertex is not None:\n                break\n\n            # Key frames for visualization/debug every 50 iterations\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_path_and_smooth_multi_pass(found_goal_vertex)\n\n    # Helper: Enhanced path extraction with repeated randomized shortcut attempts for smoother finale\n    def _extract_path_and_smooth_multi_pass(self, q_goal_vertex: Vertex) -> None:\n        path = []\n        current = q_goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Multiple passes of shortcutting smoothing with randomized order for robustness\n        for _ in range(5):  # Increased passes for smoother path\n            i = 0\n            while i < len(path) - 2:\n                # Shuffle j order to attempt non-greedy shortcuts\n                j_candidates = list(range(len(path) - 1, i + 1, -1))\n                random.shuffle(j_candidates)\n                for j in j_candidates:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        break\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm improves traditional RRT*-style path planning by enhancing clearance and robustness while maintaining efficiency.\n    Key improvements:\n    - Clearance-aware adaptive step size: step size shrinks near obstacles and goal for safer, finer control.\n    - Clearance-informed sampling: biased sampling towards regions with more clearance to avoid tight spaces.\n    - Heuristic-guided vertex extension with an additional clearance penalty to favor paths with more clearance.\n    - Rewiring with clearance-based radius adaptation to balance connectivity and obstacle avoidance.\n    - Path shortcutting that respects clearance by validating shortcut lines with clearance checks.\n    - Early stopping at 10 seconds or if goal connected.\n    - Uses a helper clearance estimation to prioritize safer samples and edges.\n    Overall, this approach balances exploration, exploitation, and safety by incorporating clearance awareness into sampling,\n    step size, connection, and rewiring steps, leading to smoother, safer, and more reliable path planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal or obstacles\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        # Clearance parameters\n        self._clearance_sample_radius = 5  # radius to check clearance around samples\n        self._min_clearance = 2.0  # minimum clearance considered safe\n        self._clearance_penalty_weight = 5.0  # penalty weight for low clearance in cost\n        self._init_displays()\n\n    def _estimate_clearance(self, pos: Point) -> float:\n        \"\"\"\n        Estimate clearance as minimum distance from pos to any obstacle boundary.\n        Approximate by checking neighbors within a radius and returning minimum \n        obstacle distance or high value if none near.\n        \"\"\"\n        grid = self._get_grid()\n        visited = set()\n        queue = [(pos, 0)]\n        max_check_radius = max(self._clearance_sample_radius, self._min_max_dist)\n        min_dist = max_check_radius + 1.0\n\n        # BFS within limited radius to find nearest obstacle\n        while queue:\n            current, dist = queue.pop(0)\n            if dist > max_check_radius:\n                break\n            if current in visited:\n                continue\n            visited.add(current)\n            # If current is invalid position means obstacle or out of bounds (obstacle boundary)\n            if not grid.is_agent_valid_pos(current):\n                if dist < min_dist:\n                    min_dist = dist\n                    # Early exit if clearance very small\n                    if min_dist <= 0:\n                        return 0.0\n                continue\n            # Add neighbors for BFS\n            neighbors = grid.get_next_positions(current)\n            for npos in neighbors:\n                if npos not in visited:\n                    queue.append((npos, dist + 1))\n        return min_dist if min_dist <= max_check_radius else max_check_radius + 1.0\n\n    def _sample_with_clearance_bias(self) -> Point:\n        \"\"\"\n        Sample points with goal bias and clearance bias:\n        - With probability _goal_sample_rate: sample near goal.\n        - Else sample random positions with priority on higher clearance.\n        Sampling retries a number of times, returns best clearance found if no valid found.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        if torch.rand(1).item() < self._goal_sample_rate:\n            for _ in range(30):\n                offset = torch.randn(self._dimension)\n                offset = offset / torch.norm(offset) * self._min_max_dist * torch.rand(1).item()\n                sample = Point(*(goal_pos.to_tensor() + offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        # Clearance biased sampling: sample multiple points, pick best clearance one\n        best_sample = None\n        best_clearance = -1.0\n        trials = 100\n        for _ in range(trials):\n            coords = []\n            for dim in range(self._dimension):\n                coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._estimate_clearance(sample)\n            if clearance > best_clearance:\n                best_clearance = clearance\n                best_sample = sample\n            if best_clearance >= self._max_max_dist:\n                break  # Found very safe zone, no need to continue\n        if best_sample is not None:\n            return best_sample\n        # fallback to start position if no valid sample found\n        return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, pos: Point) -> float:\n        \"\"\"\n        Adaptive max_dist reduced by proximity to obstacles and goal.\n        Combines distance to goal and clearance to scale step size.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_goal = Map.get_distance(pos, goal_pos)\n        clearance = self._estimate_clearance(pos)\n        # Scale max dist by min of clearance and distance to goal scaled by 0.3\n        scaled_clearance = max(self._min_max_dist, min(self._max_max_dist, clearance))\n        scaled_goal = max(self._min_max_dist, min(self._max_max_dist, dist_goal * 0.3))\n        return min(scaled_clearance, scaled_goal)\n\n    def _cost_with_clearance(self, parent: Vertex, child_pos: Point) -> float:\n        \"\"\"\n        Compute cost from parent to child with additional penalty for low clearance path.\n        Cost = existing cost + distance + clearance penalty\n        \"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(parent.position, child_pos)\n        clearance = self._estimate_clearance(child_pos)\n        clearance_penalty = 0.0\n        if clearance < self._min_clearance:\n            clearance_penalty = self._clearance_penalty_weight * (self._min_clearance - clearance)\n        return parent.cost + dist + clearance_penalty\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        \"\"\"\n        Override path extraction with clearance-aware shortcutting.\n        Shortcut only if lines are valid and clearance at intermediate points is sufficient.\n        \"\"\"\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if not grid.is_valid_line_sequence(line_seq):\n                    j -= 1\n                    continue\n                # Check clearance along line (must be above min_clearance)\n                line_clearance_ok = True\n                for pt in line_seq:\n                    if self._estimate_clearance(pt) < self._min_clearance * 0.7:\n                        line_clearance_ok = False\n                        break\n                if line_clearance_ok:\n                    del path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        # Start timer\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._sample_with_clearance_bias()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = self._cost_with_clearance(q_nearest, q_new_pos)\n\n            # Adaptive rewiring radius based on clearance and size:\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            base_radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            clearance_at_new = self._estimate_clearance(q_new_pos)\n            adaptive_radius = max(self._min_max_dist, min(base_radius, clearance_at_new * 3.0))\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, adaptive_radius)\n\n            # Select best parent with cost + clearance penalty heuristic\n            q_min = q_nearest\n            c_min = self._cost_with_clearance(q_nearest, q_new_pos)\n            for q_near in vertices_near:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_near_new\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                    # Check clearance along candidate path (must be above min_clearance * 0.7)\n                    clearance_ok = True\n                    for pt in line_seq_candidate:\n                        if self._estimate_clearance(pt) < self._min_clearance * 0.7:\n                            clearance_ok = False\n                            break\n                    if clearance_ok:\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if q_new offers better cost with clearance consideration\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if not grid.is_valid_line_sequence(line_seq_rewire):\n                        continue\n                    # Check clearance for rewire edge\n                    clearance_ok = True\n                    for pt in line_seq_rewire:\n                        if self._estimate_clearance(pt) < self._min_clearance * 0.7:\n                            clearance_ok = False\n                            break\n                    if not clearance_ok:\n                        continue\n                    # Remove old parent edge\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check goal reach with clearance and max_dist\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Check clearance along goal connection line\n                    clearance_ok = True\n                    for pt in line_goal:\n                        if self._estimate_clearance(pt) < self._min_clearance * 0.7:\n                            clearance_ok = False\n                            break\n                    if clearance_ok:\n                        goal_vertex = Vertex(goal_pos)\n                        goal_vertex.cost = q_new.cost + dist_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                        self._extract_path_and_smooth(goal_vertex)\n                        return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved clearance-aware heuristic-guided Anytime Sampling Tree algorithm for grid path planning.\n    This algorithm enhances the provided IHAST core by explicitly incorporating clearance-aware adaptive step sizing,\n    priority rechecking of samples with better clearance, and incremental cost-to-go heuristic for sampling and rewiring.\n    It employs:\n    - Clearance scoring for candidate vertices to prefer safer, more open paths.\n    - Adaptive sampling biased by combined cost-to-come, cost-to-go, and clearance.\n    - Dynamic step size limited by clearance and obstacle proximity.\n    - Goal biasing with adaptive probability depending on progress.\n    - Rewiring with clearance and cost improvement metrics.\n    - Early termination on goal connection or 10-second timeout.\n    - Path shortcutting smoothing at extraction.\n    The improvements aim to increase planning success rate, robustness against obstacles,\n    reduce iteration counts, and improve path smoothness and clearance margins.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._goal_sample_rate = 0.2  # base chance to sample goal directly, adaptively changed\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n        self._clearance_check_points = 6  # number of points along edge for clearance check\n\n    def _clearance_heuristic(self, pos: Point) -> float:\n        \"\"\"\n        Estimate clearance-based heuristic for a point.\n        Sample points around pos in cardinal directions and measure valid clearance distance.\n        Normalize to [0, 1], where 1 means max clearance.\n        \"\"\"\n        grid = self._get_grid()\n        max_clearance = self._max_step\n        clearance_scores = []\n        directions = [Point(1, 0), Point(-1, 0), Point(0, 1), Point(0, -1)]\n\n        for d in directions:\n            distance = 0.0\n            for step in np.linspace(self._min_step/2, max_clearance, self._clearance_check_points):\n                test_point = Point.from_tensor(pos.to_tensor() + step * d.to_tensor())\n                if not grid.is_agent_valid_pos(test_point):\n                    break\n                distance = step\n            clearance_scores.append(distance)\n\n        clearance = min(clearance_scores) if clearance_scores else 0.0\n        return clearance / max_clearance  # normalized clearance [0, 1]\n\n    def _sampling_heuristic(self, sample_pt: Point, start_pos: Point, goal_pos: Point) -> float:\n        \"\"\"\n        Combined heuristic score incorporating distance heuristic and clearance heuristic.\n        Lower score means more preferred sample.\n        \"\"\"\n        grid = self._get_grid()\n        dist_cost = Map.get_distance(start_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n        max_diagonal = Map.get_distance(Point(0, 0), Point(*grid.size))\n        normalized_dist = dist_cost / max_diagonal\n\n        clearance = self._clearance_heuristic(sample_pt)\n        # Combine by weighting clearance negatively (higher clearance => lower score)\n        score = normalized_dist * 0.65 + (1.0 - clearance) * 0.35\n        return score\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Enhanced heuristic-guided sampling favoring points close to heuristic corridor\n        and with higher clearance.\n        Uses rejection sampling with combined heuristic score.\n        \"\"\"\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        max_distance = Map.get_distance(Point(0, 0), Point(*grid.size))\n        attempts = 0\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            score = self._sampling_heuristic(sample_pt, start_pos, goal_pos)\n            # Accept with probability inversely proportional to score (lower better)\n            acceptance_prob = max(0.05, 1.0 - score)\n            if np.random.rand() < acceptance_prob:\n                return sample_pt\n\n            if attempts > 700:\n                # fallback: return any valid sample to avoid infinite loops\n                return sample_pt\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size scales with clearance in direction and distance to obstacles.\n        Samples multiple points along direction line considering clearance,\n        returns step scaled according to min clearance.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Check clearance at multiple points (including line validity)\n        max_feasible_step = max_step\n        for radius in np.linspace(min_step, max_step, num=6):\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n            if not grid.is_agent_valid_pos(sample_point):\n                max_feasible_step = min(max_feasible_step, radius * 0.5)\n                break\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                max_feasible_step = min(max_feasible_step, radius * 0.5)\n                break\n\n        # Further scale down if clearance nearby is low\n        clearance_at_pos = self._clearance_heuristic(pos)\n        step_size = max(min_step, max_feasible_step * clearance_at_pos)\n        step_size = min(step_size, max_step)\n\n        return step_size\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Generate new Vertex stepping towards q_sample from q_near with adaptive step-size clearance check.\n        Returns None if move invalid or has insufficient clearance.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        # Evaluate adaptive step size in that direction\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = min(step_size, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        # Validate path line sequence and clearance for q_new's position\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n\n        clearance = self._clearance_heuristic(q_new_pos)\n        if clearance < 0.15:  # threshold for minimal clearance to accept\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose lowest combined cost & clearance cost parent vertex for q_new from q_near_list.\n        Favor parents with better clearance and lower path cost.\n        \"\"\"\n        min_combined = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            clearance = self._clearance_heuristic(q_new.position)\n            # Form combined metric: cost + penalty for clearance (less clearance penalized)\n            combined_score = cost_to_new + (1.0 - clearance) * 10.0  # weighted penalty\n\n            if combined_score < min_combined:\n                min_combined = combined_score\n                chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Attempt local rewiring by connecting neighbors through q_new if this\n        results in lower cost and better clearance.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost:\n                clearance = self._clearance_heuristic(neighbor.position)\n                clearance_new = self._clearance_heuristic(q_new.position)\n                # Prefer rewiring only if improvement in cost and no clearance degradation\n                if clearance_new >= clearance:\n                    line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove old edges\n                        for parent in list(neighbor.parents):\n                            self._graph.remove_edge(parent, neighbor)\n                        # Add new edge\n                        self._graph.add_edge(q_new, neighbor)\n                        neighbor.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Build and shortcut path from q_new up to start vertex,\n        then trace the agent along the smoothed path.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        # Smooth via shortcutting method\n        smooth_path = self._shortcut_path(path)\n\n        # Move agent through smoothed path and mark key frames\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                break\n\n            # Adapt goal biasing probability based on progress (linear decay)\n            progress_ratio = min(1.0, iteration / self._max_iterations)\n            dynamic_goal_sample_rate = self._goal_sample_rate + 0.3 * (1.0 - progress_ratio)\n\n            if np.random.rand() < dynamic_goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample()\n\n            # Find nearest vertex to q_sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max dist based on clearance and direction\n            direction_vec = Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor())\n            max_dist = self._adaptive_step_size(q_near.position, direction_vec)\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for parent selection and rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Check if goal is reached within goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Clearance-Aware Anytime Sampling Tree (ICAAST) Algorithm",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved Clearance-Aware Anytime Sampling Tree (ICAAST) Algorithm}\n\n    This algorithm enhances the baseline IHAST by explicitly incorporating clearance-based sampling and\n    adaptive expansion strategies to improve the quality and robustness of paths in obstacle-dense environments.\n    \n    Key improvements:\n      - Clearance-aware heuristic sampling: Rejects sampled points too close to obstacles, ensuring\n        better navigable free space exploration.\n      - Dynamic step size scaled by local clearance and movement smoothness, favoring safer expansions.\n      - Goal-biased sampling with adaptive goal sample rate that gradually increases as iterations progress,\n        helping to balance exploration and exploitation.\n      - Enhanced rewiring allowing pruning of costly edges near obstacles to improve path optimality.\n      - Early termination on reaching goal or exceeding a 10 second time limit.\n      - Shortcutting smoothing on extracted path to reduce unnecessary detours.\n      - Uses existing heuristic sampling but adds explicit clearance checks for samples and expansions.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._base_goal_sample_rate = 0.15  # start with lower goal sample chance\n        self._max_goal_sample_rate = 0.35  # max goal bias chance\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n        self._clearance_threshold = 2.0  # minimal clearance required around sampled points (in grid units)\n\n    def _clearance_around_point(self, point: Point, check_radius: float) -> float:\n        \"\"\"\n        Calculate clearance as minimal distance to any obstacle from the given point within check_radius.\n        Returns the minimal distance found, or large value if no obstacles nearby.\n        \"\"\"\n        grid = self._get_grid()\n        obstacles = grid.obstacles\n\n        min_clearance = float('inf')\n        for obstacle in obstacles:\n            # Obstacle position assumed to be Point-like or center\n            obs_pos = obstacle.position\n            dist = Map.get_distance(point, obs_pos) - obstacle.radius\n            if dist < min_clearance:\n                min_clearance = dist\n        return min_clearance if min_clearance != float('inf') else check_radius + 1.0\n\n    def _clearance_heuristic_sample(self) -> Point:\n        \"\"\"\n        Samples points biased by heuristic distribution (start-to-sample + sample-to-goal)\n        with an additional clearance check that rejects points too close to obstacles.\n        Avoids samples in narrow spaces to improve expansion robustness.\n        Constrained by a max number of attempts to fallback to normal heuristic sampling.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n        max_distance = Map.get_distance(Point(0, 0), Point(*size))\n        attempts = 0\n\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            clearance = self._clearance_around_point(sample_pt, self._clearance_threshold)\n            if clearance < self._clearance_threshold:\n                # Reject samples too close to obstacles\n                if attempts > 100:\n                    # Relax and accept after many failures to avoid stuckness\n                    return sample_pt\n                continue\n\n            h_val = Map.get_distance(agent_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n            h_norm = h_val / max_distance\n            if np.random.rand() < 1.0 - h_norm:\n                return sample_pt\n\n            if attempts > 500:\n                return sample_pt\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size based on clearance and direction smoothness.\n        If clearance at pos is low, use a smaller step.\n        Otherwise, scale step by clearance while respecting min and max step bounds.\n        \"\"\"\n        grid = self._get_grid()\n        base_min_step = self._min_step\n        base_max_step = self._max_step\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return base_min_step\n        unit_dir = dir_tensor / norm\n\n        # Evaluate clearance in direction at multiple scales\n        max_clearance = None\n        for radius in np.linspace(base_min_step, base_max_step, num=6):\n            sample_pos_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_pos_tensor)\n            if not grid.is_agent_valid_pos(sample_point):\n                max_clearance = 0.0\n                break\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                max_clearance = 0.0\n                break\n\n            clearance = self._clearance_around_point(sample_point, self._clearance_threshold)\n            if max_clearance is None or clearance < max_clearance:\n                max_clearance = clearance\n\n        if max_clearance is None:\n            max_clearance = base_max_step\n\n        # Scale step size proportionally to clearance, capped by base min/max step\n        step_size = max(base_min_step, min(max_clearance * 1.5, base_max_step))\n        return step_size\n\n    def _is_path_clear(self, frm: Point, to: Point) -> bool:\n        \"\"\"\n        Validates path line sequence and checks clearance along the segment.\n        Returns True if the path is free and clearance above threshold.\n        \"\"\"\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(frm, to)\n        if not grid.is_valid_line_sequence(line_seq):\n            return False\n\n        # Check clearance at intermediate points\n        for pt in line_seq:\n            clearance = self._clearance_around_point(pt, self._clearance_threshold)\n            if clearance < self._clearance_threshold * 0.5:\n                return False\n        return True\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Generate new Vertex stepping towards q_sample from q_near with adaptive step size and clearance check.\n        Returns None if move invalid or clearance insufficient.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = min(step_size, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        if not self._is_path_clear(q_near.position, q_new_pos):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose lowest cost parent vertex for q_new from q_near_list ensuring path clearance.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if cost_to_new >= min_cost:\n                continue\n            if not self._is_path_clear(neighbor.position, q_new.position):\n                continue\n            min_cost = cost_to_new\n            chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Rewire neighbors via q_new if it reduces cost and the path has sufficient clearance.\n        Also attempt pruning edges that lead through narrow passages by comparing clearance.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost and self._is_path_clear(q_new.position, neighbor.position):\n                # Optionally check clearance improvement before rewiring\n                current_clearance = self._clearance_around_point(neighbor.position, self._clearance_threshold)\n                new_clearance = self._clearance_around_point(q_new.position, self._clearance_threshold)\n                if new_clearance >= current_clearance * 0.8:\n                    # Remove old edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    # Add new edge and update cost\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Build path up to start, add goal connection, shortcut path and move the agent accordingly.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()\n        path.reverse()\n\n        smooth_path = self._shortcut_path(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _update_goal_sample_rate(self, iteration: int) -> float:\n        \"\"\"\n        Gradually increase goal sample rate as iterations progress (linear increase).\n        \"\"\"\n        progress = iteration / self._max_iterations\n        rate = self._base_goal_sample_rate + progress * (self._max_goal_sample_rate - self._base_goal_sample_rate)\n        return min(self._max_goal_sample_rate, rate)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                break\n\n            goal_sample_rate = self._update_goal_sample_rate(iteration)\n\n            if np.random.rand() < goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._clearance_heuristic_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            direction = Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor())\n            max_dist = self._adaptive_step_size(q_near.position, direction)\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning Algorithm with Memory-Efficient Incremental Search and Enhanced Sampling.\n\n    This algorithm implements an adaptive and memory-efficient anytime-sampling tree planner inspired by IHAST, \n    enhanced with the following improvements:\n\n    - Adaptive focused sampling with a hybrid heuristic and informed sampling: \n      combines heuristic corridor sampling with selective pruning of distant samples \n      to reduce memory overhead.\n\n    - Beam pruning strategy: Keeps the forest trimmed by limiting vertices based on cost and distance \n      to goal within a moving cost threshold, reducing memory and computational footprint.\n\n    - Cost-to-go (heuristic) combined in priority for adaptive vertex expansion, prioritizing promising nodes.\n\n    - Adaptive step size adjusted by clearance and direction smoothness, similar to original.\n\n    - Rewiring only applied locally within the beam neighborhood to avoid global costly rewiring.\n\n    - Early stopping on reaching goal or passing 10 seconds timeout.\n\n    - Path smoothing and shortcutting done as before for improved path quality.\n\n    This design targets reducing vertex explosion and computational overhead, improving robustness \n    and success rate by pruning unpromising regions and focusing expansion along promising paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._goal_sample_rate = 0.30  # increased goal bias to speed convergence\n        self._search_radius_rewire = 10.0  # smaller radius for local rewiring to reduce computation\n        self._min_step = 2.5\n        self._max_step = 14.0\n\n        # Additional parameter for beam pruning to limit forest size\n        self._max_forest_size = 1500\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Enhanced heuristic and informed corridor sampling biased toward start-goal corridor\n        with sample rejection to favor areas near the current best cost path.\n        \"\"\"\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_distance = Map.get_distance(Point(0, 0), Point(*size))\n        attempts = 0\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            # Heuristic: dist(start->sample) + dist(sample->goal)\n            h_val = Map.get_distance(start_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n            h_norm = h_val / max_distance\n\n            # Discard samples too far off minimal possible path corridor (add small slack)\n            best_possible_dist = Map.get_distance(start_pos, goal_pos)\n            if h_val > best_possible_dist * 1.5:\n                continue\n\n            # Use h_norm as rejection probability (favor closer heuristic)\n            if np.random.rand() < 1.0 - h_norm:\n                return sample_pt\n\n            if attempts > 300:\n                # fallback: just any valid point\n                return sample_pt\n\n    def _prune_forest(self) -> None:\n        \"\"\"\n        Prune vertices to control memory by removing vertices with high cost or far from goal.\n        Keeps vertices within a beam threshold for cost + heuristic distance.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        vertices = list(self._graph.root_vertices)\n        if len(vertices) <= self._max_forest_size:\n            return  # no pruning needed\n\n        # Compute cost + heuristic (distance to goal)\n        vertices_with_score = []\n        for v in vertices:\n            # heuristic cost to goal\n            h = Map.get_distance(v.position, goal_pos)\n            score = v.cost + h\n            vertices_with_score.append((score, v))\n\n        # Sort by score ascending\n        vertices_with_score.sort(key=lambda x: x[0])\n\n        # Keep only top vertices within max_forest_size\n        to_keep = set(v for _, v in vertices_with_score[:self._max_forest_size])\n        to_remove = [v for _, v in vertices_with_score[self._max_forest_size:]]\n\n        for v in to_remove:\n            # Remove edges and from root vertices\n            for parent in list(v.parents):\n                self._graph.remove_edge(parent, v)\n            for child in list(v.children):\n                self._graph.remove_edge(v, child)\n            if v in self._graph.root_vertices:\n                self._graph.root_vertices.remove(v)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                # Timeout condition, no solution found within the time limit\n                break\n\n            # Sample according to goal bias or heuristic sample\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample()\n\n            # Find nearest vertex to sample from current forest root vertices\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                # already existing vertex\n                continue\n\n            direction_vector = q_sample.to_tensor() - q_near.position.to_tensor()\n            norm = torch.norm(direction_vector)\n            if norm == 0:\n                continue\n\n            unit_direction = direction_vector / norm\n            max_dist = self._adaptive_step_size(q_near.position, Point.from_tensor(unit_direction))\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            # Generate new vertex along direction with adaptive step size limit\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Gather neighbors for parent choosing and rewiring limited within radius\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge from chosen parent and set cost for new vertex\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors locally via q_new if beneficial\n            neighbors_wo_parent = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors_wo_parent)\n\n            # Add new vertex to root vertices for continued exploration\n            self._graph.root_vertices.append(q_new)\n\n            # Prune forest to control memory\n            self._prune_forest()\n\n            # Goal check with radius threshold\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "An improved RRT*-inspired path planner with heuristic-guided informed sampling and focused rewiring.\n    This algorithm reduces memory usage and iteration count by restricting the sampled region to an \n    informed ellipsoidal subset (informed RRT*) between start and goal after an initial path is found. \n    It uses a dynamic sampling bias and adaptive step sizes based on clearance.\n    Rewiring is selectively applied only to nearby vertices within a dynamically adjusted radius to \n    reduce overhead. Early stopping occurs upon timeout or significant path quality stabilization.\n    Shortcutting uses an improved greedy smoothing with lookahead to generate smoother and shorter paths.\n    This approach aims for higher success rate, shorter paths, fewer iterations, and lower memory footprint.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # Added member variables for informed sampling control\n        self._best_cost = float('inf')\n        self._initial_path_found = False\n\n    def _get_informed_sample(self, start: Point, goal: Point, c_max: float, goal_sample_rate: float=0.05) -> Point:\n        \"\"\"\n        Sample within an ellipsoidal informed subset defined by start, goal and c_max (current best cost).\n        With small probability sample the goal directly.\n        Fallback to uniform sampling if ellipse degenerate.\n        \"\"\"\n        if np.random.rand() < goal_sample_rate:\n            return goal\n\n        dim = len(start)\n        c_min = Map.get_distance(start, goal)\n        if c_max == float('inf'):\n            # No solution found yet: uniform random sample in entire grid\n            grid_size = self._get_grid().size\n            while True:\n                rand_pos = np.random.randint(0, grid_size, dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        else:\n            # Informed sampling ellipse parameters\n            center = Point(\n                *(0.5 * (start.to_tensor() + goal.to_tensor())).tolist())\n            e1 = (goal.to_tensor() - start.to_tensor())\n            norm_e1 = torch.norm(e1).item()\n            if norm_e1 == 0:\n                # Start and goal coincident (unlikely), sample goal directly\n                return goal\n            \n            # Create rotation matrix aligning e1 to x-axis\n            # Note: Works for 2D and 3D suitably if using enough dims; here n_dim could be >2.\n            # We'll build an orthonormal basis using Gram-Schmidt (for dims >=2)\n            e1n = e1 / norm_e1\n            # Build arbitrary orthonormal basis (Q matrix)\n            basis = [e1n]\n            for i in range(dim):\n                v = torch.zeros(dim)\n                v[i] = 1.0\n                # Gram-Schmidt to orthogonalize v w.r.t existing basis\n                for b in basis:\n                    v -= torch.dot(v,b)*b\n                norm_v = torch.norm(v)\n                if norm_v > 1e-6:\n                    basis.append(v / norm_v)\n            Q = torch.stack(basis).T  # dim x dim orth rotation matrix\n\n            # Radii of ellipse (length of axes)\n            r1 = c_max / 2.0\n            if c_max < 1e-8:  # Avoid zero division or zero radius\n                r1 = 1.0\n            r_other = np.sqrt(c_max**2 - c_min**2)/2.0\n            if r_other < 1e-6:  # Minimum radius\n                r_other = 1.0\n            radii = [r1] + [r_other]*(dim-1)\n\n            # Sample uniformly from unit n-ball then scale and rotate\n            while True:\n                # Sample from unit n-ball (normal vector then scale by uniform^(1/n_dim))\n                x = torch.randn(dim)\n                norm_x = torch.norm(x).item()\n                if norm_x == 0:\n                    continue\n                x_normed = x / norm_x\n                u = np.random.rand() ** (1.0/dim)\n                sample_ball = u * x_normed\n\n                # Scale by ellipse radii\n                sample_ellipse = torch.tensor(radii) * sample_ball\n\n                # Rotate and translate\n                sample_point_tensor = Q.matmul(sample_ellipse) + center.to_tensor()\n                sample_point = Point.from_tensor(sample_point_tensor)\n\n                # Project to nearest integer grid point\n                coords = tuple(int(round(c)) for c in sample_point.to_tensor())\n                projected = Point(*coords)\n                if self._get_grid().is_agent_valid_pos(projected):\n                    return projected\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex, max_parent_cost: float) -> Vertex:\n        # Restrict parents to those with cost < max_parent_cost to reduce search in large graphs\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            if v.cost > max_parent_cost:\n                continue\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list, max_rewire_cost: float) -> None:\n        # Rewire only neighbors with cost not exceeding max_rewire_cost to limit rewiring overhead\n        for v in q_near_list:\n            if v == q_new:\n                continue\n            if v.cost > max_rewire_cost:\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove all parents edges (only one parent in tree)\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Improved greedy shortcutting with lookahead of up to 3 vertices ahead\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) -1:\n            # Try to connect smoothed[-1] to furthest reachable vertex within lookahead window\n            reach_idx = idx + 1\n            max_lookahead = min(idx + 4, len(path))  # 3 lookahead steps max\n            for j in range(max_lookahead -1, idx, -1):\n                line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    reach_idx = j\n                    break\n            smoothed.append(path[reach_idx])\n            idx = reach_idx\n        return smoothed\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Similar extraction but with improved shortcutting\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: list = [goal_v]\n        # Trace parents minimum cost up to start (unique parents expected)\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 6000  # Reduced due to informed sampling and efficient rewiring\n        initial_goal_sample_rate: float = 0.3  # Higher random goal bias initially\n        later_goal_sample_rate: float = 0.05  # Reduced after initial path to promote local refinement\n        search_radius_base: float = 12.0  # Base search radius for rewiring\n        timeout_seconds: float = 10.0\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > timeout_seconds:\n                # Timeout; mark failure by leaving _best_cost unchanged and ending\n                break\n\n            # Update sampling bias: initially higher goal bias, then lower\n            goal_sample_rate = initial_goal_sample_rate if not self._initial_path_found else later_goal_sample_rate\n\n            # Sample informed if path found, else uniform sampling\n            if self._initial_path_found:\n                q_sample = self._get_informed_sample(start_pos, goal_pos, self._best_cost, goal_sample_rate)\n            else:\n                q_sample = self._get_random_sample(goal_sample_rate)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Dynamic search radius scaled by sqrt(log(n)/n) heuristic and max_dist\n            vertex_count = max(1, self._graph.size)\n            radius_factor = search_radius_base * min(1.0, np.sqrt((np.log(vertex_count) / vertex_count))) + max_dist * 0.5\n\n            q_near_list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius_factor)\n\n            # Limit max parent cost to avoid high cost parents, prune search space\n            max_parent_cost = q_near.cost + max_dist * 2.0  # Loose factor\n            chosen_parent = self._choose_parent(q_near_list, q_new, max_parent_cost)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Update best cost if close to goal, update flag\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Candidate cost estimate (line to goal)\n                new_path_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                if new_path_cost < self._best_cost:\n                    self._best_cost = new_path_cost\n                    self._initial_path_found = True\n                    self._extract_path(q_new)\n                    break\n\n            # Rewire neighbors within radius + max_dist to improve graph locally\n            max_rewire_cost = q_new.cost + max_dist * 2.0\n            q_near_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_rewire, max_rewire_cost)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    An improved memory-efficient and performance-enhanced path planning algorithm inspired by \n    goal-biased adaptive informed sampling, heuristic-guided dynamic expansion, and RRT* rewiring.\n    Key improvements for memory and efficiency:\n    - Limit stored vertices by pruning vertices with poor heuristic + cost and removing dead branches.\n    - Adaptive max step size based on proximity to the goal and tree size for balanced exploration.\n    - Sampling mixes goal bias, informed ellipsoidal sampling, or uniform sampling intelligently.\n    - Heuristic cost guides vertex selection and rewiring to prefer promising expansions.\n    - Dynamic neighborhood radius scales with tree size and iteration count.\n    - Early termination on direct goal connection to save time.\n    - Path shortcutting with multiple passes for smoothness.\n    - Enforce 10 seconds max planning time.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        self._best_cost = float('inf')\n        self._start_time = None\n        self._prune_interval = 200  # prune every 200 iterations\n        self._last_prune_iteration = 0\n\n    def _prune_useless_vertices(self):\n        \"\"\"\n        Memory efficient pruning: \n        Remove vertices whose (cost + heuristic) is worse than best_cost * 1.1 (tolerance).\n        Also remove disconnected or dead-end vertices.\n        \"\"\"\n        from collections import deque\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        threshold_cost = self._best_cost * 1.1 if self._best_cost < float('inf') else float('inf')\n\n        # Mark good vertices reachable from start and costing less than threshold + heuristic\n        survived_vertices = set()\n        q = deque()\n        q.append(self._graph.root_vertex_start)\n        survived_vertices.add(self._graph.root_vertex_start)\n\n        while q:\n            v = q.popleft()\n            for child in v.children:\n                total_cost_estimate = child.cost + self._heuristic_cost(child.position, goal_pos)\n                if total_cost_estimate <= threshold_cost and child not in survived_vertices:\n                    survived_vertices.add(child)\n                    q.append(child)\n\n        # Remove vertices not in survived\n        all_vertices = list(self._graph.root_vertex_start.children) + [self._graph.root_vertex_start]\n        to_remove = []\n        # Collect all vertices in graph (by DFS from start)\n        visited = set()\n        stack = [self._graph.root_vertex_start]\n        while stack:\n            v = stack.pop()\n            if v in visited:\n                continue\n            visited.add(v)\n            for child in v.children:\n                stack.append(child)\n\n        for v in list(visited):\n            if v not in survived_vertices and v != self._graph.root_vertex_start:\n                # Remove edges to completely disconnect this vertex\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                for c in list(v.children):\n                    self._graph.remove_edge(v, c)\n                to_remove.append(v)\n\n        # Decrease graph size count manually if applicable\n        # (assuming self._graph.size is updated automatically via add_edge/remove_edge in forest)\n        # No explicit removal from internal forest structure in ref code - ok to leave like this\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time check early stop: stop not only by iteration but also real-time 10 seconds max\n            if (time.time() - self._start_time) > 10.0:  \n                return  # timeout, no path found in time\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos_float = q_nearest.position.to_tensor().float() + dir_normalized * max_dist\n                q_new_pos = Point.from_tensor(q_new_pos_float.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            cost_to_new = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            # Use adaptive rewiring radius capped at 20 for memory reduction\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 20.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Find best parent with lowest cost + heuristic; heuristic is admissible\n            q_min = q_nearest\n            c_min = cost_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path offers improvement\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early termination as direct connection to goal is found\n                    break\n\n            # Periodic pruning for memory efficiency\n            if iteration - self._last_prune_iteration >= self._prune_interval and self._best_cost < float('inf'):\n                self._prune_useless_vertices()\n                self._last_prune_iteration = iteration\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Heuristic-Guided Informed RRT* with Adaptive Step Size and Dynamic Sampling Domain Shrinking.\n\n    This algorithm improves upon classical RRT* by:\n    - Using an informed sampling strategy that restricts random samples to an ellipsoidal region\n      defined by the current best path cost to focus exploration and reduce unnecessary samples.\n    - Incorporating heuristic (A*-style) cost-to-go estimates (using Euclidean distance) to guide\n      parent selection and rewiring, improving path quality.\n    - Dynamically adapting the max step size based on the distance to goal to provide finer exploration\n      near the goal and faster expansion far from it.\n    - Early stopping when the goal is reached or the time budget (10s) exceeded.\n    - Applying shortcut smoothing to the final extracted path for improved smoothness and optimality.\n    - Ensuring robustness by attempting connection directly to goal from each new vertex.\n    - Uses rewiring as in RRT* to optimize path cost during construction.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # use gen_forest as base graph with removable edges for rewiring\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n        # Parameters\n        self._max_iterations = 6000           # Limit iterations for efficiency\n        self._time_limit_sec = 10.0            # Max planning time (10 sec)\n        self._rewire_radius = 20               # Radius for rewiring neighbors\n        self._initial_max_dist = 20            # Initial max step size\n        self._min_max_dist = 3                 # Minimum max step size near goal\n        self._goal_sample_rate = 0.2           # Probability of sampling goal directly for bias\n\n        # Track best path cost found so far, initialize as infinity\n        self._best_cost = float('inf')\n        # Store best goal vertex if found\n        self._best_goal_vertex = None\n\n    def _sample_in_ellipsoid(self, start: Point, goal: Point, c_max: float) -> Point:\n        # Informed sampling within ellipsoidal domain enclosed by start-goal and best cost c_max\n        # Reference: Informed RRT* paper (Gammell et al. 2014)\n        import math\n\n        if c_max == float('inf'):\n            # No solution found yet - uniform sampling with occasional goal bias\n            from random import random\n            if random() < self._goal_sample_rate:\n                return goal\n            else:\n                grid_size = self._get_grid().size\n                while True:\n                    rand_pos = np.random.randint(0, grid_size, grid_size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n        c_min = Map.get_distance(start, goal)\n        if c_max <= c_min:\n            # Best cost close to straight line, bias samples at goal directly or uniform else\n            from random import random\n            if random() < self._goal_sample_rate:\n                return goal\n            else:\n                grid_size = self._get_grid().size\n                while True:\n                    rand_pos = np.random.randint(0, grid_size, grid_size.n_dim)\n                    sample = Point(*rand_pos)\n                    if self._get_grid().is_agent_valid_pos(sample):\n                        return sample\n\n        # Ellipse parameters:\n        # Calculate rotation/translation to transform unit circle to ellipsoid in state space\n        center = Point(*( (start.to_tensor() + goal.to_tensor()) / 2 ))\n        a1 = (goal.to_tensor() - start.to_tensor()) / c_min  # Unit vector from start to goal\n\n        # Build orthonormal basis for directions perpendicular to a1\n        n_dim = start.to_tensor().shape[0]\n        from scipy.linalg import null_space\n\n        # Find null space to get basis orthogonal to a1\n        a1_np = a1.numpy().reshape((n_dim, 1))\n        basis_perp = null_space(a1_np.T)  # Shape: (n_dim, n_dim-1)\n\n        # Ellipsoid radii\n        r1 = c_max / 2.0\n        r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n        if r2 < 1e-6:\n            r2 = 1e-6  # avoid degenerate\n\n        # Random sample in unit n-dim circle:\n        while True:\n            # Sample uniformly from unit n-dim ball\n            sample_ball = np.random.normal(0, 1, n_dim)\n            sample_ball /= np.linalg.norm(sample_ball)\n            radius = np.random.rand() ** (1.0 / n_dim)\n            sample_ball = sample_ball * radius  # inside unit ball\n\n            # Scale sample_ball on each axis by (r1 for axis a1, r2 for perpendicular axes)\n            # projected_sample = r1 * projected on a1 + r2 * projected on perpendicular basis\n            projected_sample = r1 * sample_ball[0] * a1.numpy()\n\n            # Add components in orthogonal directions scaled by r2\n            if n_dim > 1:\n                projected_sample += r2 * np.dot(basis_perp, sample_ball[1:])\n\n            candidate_point_tensor = torch.from_numpy(projected_sample).float() + center.to_tensor()\n\n            # Convert to integer grid coordinates\n            candidate_coords = np.clip(candidate_point_tensor.numpy().round().astype(int), 0,\n                                       self._get_grid().size - 1)\n            candidate = Point(*candidate_coords)\n\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n\n    def _choose_parent_heuristic(self, neighbors: list, q_new: Vertex, goal_pos: Point) -> Vertex:\n        # Choose parent using cost-so-far + heuristic (Euclidean distance to goal)\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            cost_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic = grid.get_distance(q_new.position, goal_pos)\n            total_cost = cost_to_new + heuristic\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_parent = q_near\n\n        if best_parent is not None:\n            q_new.cost = best_parent.cost + grid.get_distance(best_parent.position, q_new.position)\n        return best_parent\n\n    def _rewire_heuristic(self, q_new: Vertex, neighbors: list, goal_pos: Point) -> None:\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove higher cost parents\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        # Same shortcut smoothing as reference: try skipping intermediate vertices when possible\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path = [goal_vertex]\n        current = goal_vertex\n        while len(current.parents) > 0:\n            min_parent = None\n            min_cost = float('inf')\n            for p in current.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_parent = p\n            if min_parent is None:\n                break\n            path.append(min_parent)\n            current = min_parent\n\n        path.reverse()\n        path = self._shortcut_path(path)\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_pos = start_vertex.position\n        goal_pos = goal_vertex.position\n\n        start_vertex.cost = 0.0\n        self._best_cost = float('inf')\n        self._best_goal_vertex = None\n\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit_sec:\n                # Fail to find path in allocated time\n                break\n\n            # Sample point within informed ellipsoid (or uniform if no solution yet)\n            q_sample = self._sample_in_ellipsoid(start_pos, goal_pos, self._best_cost)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on distance to goal (smaller step near goal for precision)\n            dist_to_goal = grid.get_distance(q_near.position, goal_pos)\n            max_dist = max(self._min_max_dist, min(self._initial_max_dist, dist_to_goal / 2))\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors for rewiring\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent_heuristic(neighbors, q_new, goal_pos)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n\n            self._rewire_heuristic(q_new, neighbors, goal_pos)\n\n            # Attempt direct connection to goal vertex with valid path\n            line_seq_goal = grid.get_line_sequence(q_new.position, goal_pos)\n            if grid.is_valid_line_sequence(line_seq_goal):\n                cost_to_goal = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                if cost_to_goal < self._best_cost:\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_cost = cost_to_goal\n                    self._best_goal_vertex = goal_vertex\n\n                    # Extract and animate path immediately\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm combines bidirectional search with heuristic-guided growth and adaptive step sizes.\n    Key features:\n    - Uses two forests grown simultaneously from start and goal positions.\n    - Employs heuristic A*-style cost-to-go estimates to guide vertex expansions.\n    - Grows trees towards each other with adaptive max step size shrinking near goal and near start for finer search.\n    - Incorporates rewiring in each tree for cost optimization within adaptive radius.\n    - Uses goal-bias sampling alternatively towards start or goal to balance exploration and connection.\n    - Attempts to connect the two forests when vertices from one forest come close to vertices of the other.\n    - Extracts the combined path from start to goal, then performs shortcut smoothing.\n    - Stops if a path found or if planning takes more than 10 seconds.\n    - Designed for improved planning efficiency, connectivity rate, and smoother shorter paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_max_dist = 18.0  # Max step size\n        self._min_max_dist = 4.0   # Min step size near goal/start\n        self._goal_sample_rate = 0.15  # Probability to sample near goal or start\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 40\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, q_pos: Point, toward_goal=True) -> float:\n        grid = self._get_grid()\n        ref_pos = grid.goal.position if toward_goal else grid.agent.position\n        dist = Map.get_distance(q_pos, ref_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.25))\n        return scaled\n\n    def _heuristic_cost(self, frm: Point, to: Point) -> float:\n        # Use straight line Euclidean distance\n        return Map.get_distance(frm, to)\n\n    def _rewire(self, forest: Forest, q_new: Vertex, radius: float, start=True) -> None:\n        grid = self._get_grid()\n        root = forest.root_vertex_start if start else forest.root_vertex_goal\n        vertices_near = forest.get_vertices_within_radius([root], q_new.position, radius)\n        for q_near in vertices_near:\n            if q_near == q_new:\n                continue\n            dist_new_near = Map.get_distance(q_new.position, q_near.position)\n            cost_through_new = q_new.cost + dist_new_near\n            if cost_through_new < q_near.cost:\n                line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for parent in q_near.parents:\n                        forest.remove_edge(parent, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    forest.add_edge(q_new, q_near)\n\n    def _choose_parent(self, forest: Forest, q_new: Vertex, vertices_near: list, start=True) -> Vertex:\n        grid = self._get_grid()\n        root = forest.root_vertex_start if start else forest.root_vertex_goal\n        q_min = None\n        c_min = float('inf')\n        for q_near in vertices_near:\n            dist_near_new = Map.get_distance(q_near.position, q_new.position)\n            cost_candidate = q_near.cost + dist_near_new\n            line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n            if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                q_min = q_near\n                c_min = cost_candidate\n        if q_min is None:\n            # If no better parent found, connect to root if possible\n            if grid.is_valid_line_sequence(grid.get_line_sequence(root.position, q_new.position)):\n                q_min = root\n                c_min = Map.get_distance(root.position, q_new.position)\n            else:\n                q_min = vertices_near[0] if vertices_near else root\n                c_min = q_min.cost + Map.get_distance(q_min.position, q_new.position)\n        q_new.cost = c_min\n        return q_min\n\n    def _extract_bidirectional_path_and_smooth(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        grid = self._get_grid()\n        # Extract path from start root to connection vertex in start forest:\n        path_start = []\n        current = connect_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        # Extract path from connection vertex in goal forest to goal root:\n        path_goal = []\n        current = connect_goal\n        while True:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n\n        # Combine paths: start->...->connect_start and reversed connect_goal->...->goal\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along path with keyframes\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _attempt_connection(self, q_new_start: Vertex, q_new_goal: Vertex) -> bool:\n        grid = self._get_grid()\n        # Attempt to connect q_new_start to vertices in goal forest within radius\n        radius = max(self._max_max_dist, self._min_max_dist * 2)\n        near_in_goal = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_goal], q_new_start.position, radius)\n        for qg in near_in_goal:\n            line_seq = grid.get_line_sequence(q_new_start.position, qg.position)\n            if grid.is_valid_line_sequence(line_seq):\n                # Connect both forests\n                # Add edges from q_new_start to qg and from qg to q_new_start to keep connectivity\n                self._graph_start.add_edge(q_new_start, Vertex(q_new_start.position))  # no-op to add vertex if not present\n                self._graph_goal.add_edge(qg, Vertex(qg.position))  # no-op to add vertex if not present\n                # Return connection vertices\n                self._extract_bidirectional_path_and_smooth(q_new_start, qg)\n                return True\n        return False\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_tensor)\n        if dist <= max_dist:\n            candidate_pos = q_sample\n        else:\n            dir_normalized = dir_tensor / dist\n            candidate_pos = Point.from_tensor((q_near.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n        if not self._get_grid().is_agent_valid_pos(candidate_pos):\n            return None\n        line_seq = self._get_grid().get_line_sequence(q_near.position, candidate_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(candidate_pos)\n\n    def _get_random_sample_bidirectional(self, towards_goal: bool) -> Point:\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            ref_pos = grid.goal.position if towards_goal else grid.agent.position\n            for _ in range(30):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(ref_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return ref_pos\n        else:\n            # Uniform random sampling in grid\n            for _ in range(100):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start or goal depending on direction\n            return grid.agent.position if not towards_goal else grid.goal.position\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n        iteration = 0\n\n        # For balanced bidirectional growth, alternate expansions\n        expand_start_turn = True\n\n        while iteration < self._max_iterations:\n            if time.time() - start_time > self._time_limit_seconds:\n                return  # abort after time limit\n\n            if expand_start_turn:\n                # Grow from start side\n                q_sample = self._get_random_sample_bidirectional(towards_goal=True)\n                q_nearest = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n                if q_nearest.position == q_sample:\n                    iteration += 1\n                    expand_start_turn = not expand_start_turn\n                    continue\n\n                max_dist = self._get_adaptive_max_dist(q_nearest.position, toward_goal=True)\n                q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n                if q_new is None:\n                    iteration += 1\n                    expand_start_turn = not expand_start_turn\n                    continue\n\n                # Find nearby for rewiring\n                card_v = max(self._graph_start.size, 1)\n                log_card_v = max(torch.log(torch.tensor(float(card_v))), torch.tensor(0.0))\n                radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n                vertices_near = self._graph_start.get_vertices_within_radius([self._graph_start.root_vertex_start], q_new.position, radius)\n                if not vertices_near:\n                    vertices_near = [self._graph_start.root_vertex_start]\n\n                q_min = self._choose_parent(self._graph_start, q_new, vertices_near, start=True)\n                self._graph_start.add_edge(q_min, q_new)\n\n                self._rewire(self._graph_start, q_new, radius, start=True)\n\n                # Attempt connection to goal forest\n                if self._attempt_connection(q_new, None):\n                    return\n\n            else:\n                # Grow from goal side\n                q_sample = self._get_random_sample_bidirectional(towards_goal=False)\n                q_nearest = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_goal], q_sample)\n                if q_nearest.position == q_sample:\n                    iteration += 1\n                    expand_start_turn = not expand_start_turn\n                    continue\n\n                max_dist = self._get_adaptive_max_dist(q_nearest.position, toward_goal=False)\n                q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n                if q_new is None:\n                    iteration += 1\n                    expand_start_turn = not expand_start_turn\n                    continue\n\n                # Find nearby for rewiring\n                card_v = max(self._graph_goal.size, 1)\n                log_card_v = max(torch.log(torch.tensor(float(card_v))), torch.tensor(0.0))\n                radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n                vertices_near = self._graph_goal.get_vertices_within_radius([self._graph_goal.root_vertex_goal], q_new.position, radius)\n                if not vertices_near:\n                    vertices_near = [self._graph_goal.root_vertex_goal]\n\n                q_min = self._choose_parent(self._graph_goal, q_new, vertices_near, start=False)\n                self._graph_goal.add_edge(q_min, q_new)\n\n                self._rewire(self._graph_goal, q_new, radius, start=False)\n\n                # Attempt connection to start forest\n                if self._attempt_connection(None, q_new):\n                    return\n\n            iteration += 1\n            expand_start_turn = not expand_start_turn\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is a Hybrid Heuristic-Guided Sample-and-Optimize Tree Expansion.\n    Key features:\n    - Uses a Forest rooted at start to grow a search tree.\n    - Samples adaptively using a dynamic ellipsoidal region biased towards the goal and promising vertices.\n    - Uses a heuristic combining current cost + estimated cost-to-go (A*-style) for selecting expansion vertex.\n    - Employs adaptive max step size that reduces near obstacles and goal vicinity.\n    - Incorporates a two-stage expansion: biased exploration followed by local optimization rewiring.\n    - Integrates fast shortcutting as a path refinement step after initial connection to goal.\n    - Includes an early stopping criterion on success or 10-second timeout.\n    - Aims for improved efficiency by focused sampling, robust connection by verifying collision-free edges, and path quality through rewiring and shortcutting.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Maximum step size\n        self._min_max_dist = 2.5   # Minimum step size near goal or obstacles\n        self._max_iterations = 4000\n        self._heuristic_weight = 1.2  # Inflates heuristic for aggressive goal bias\n        self._lambda_rrt_star = 45\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time in seconds\n        self._goal_bias_prob = 0.25\n        self._optimize_every = 50  # Rewiring frequency\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance as heuristic\n        return Map.get_distance(pos, goal_pos)\n\n    def _adaptive_max_dist(self, pos: Point, goal_pos: Point) -> float:\n        # Adjust max_dist smaller near goal or obstacles\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        base_dist = max(self._min_max_dist, min(self._max_max_dist, dist_to_goal * 0.35))\n        # Additional shrinking near obstacles: check surrounding in 3x3 grid\n        grid = self._get_grid()\n        obstacle_penalty = 0\n        # Check 8 neighbors for obstacles to reduce step size gradually\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue\n                neighbor = Point(pos.x + dx, pos.y + dy)\n                if not grid.is_agent_valid_pos(neighbor):\n                    obstacle_penalty += 0.8\n        adjusted_dist = base_dist - obstacle_penalty\n        return max(self._min_max_dist, adjusted_dist)\n\n    def _sample_ellipsoidal(self, center: Point, goal: Point, c_best: float) -> Point:\n        # Sample within an ellipsoid aligned from start to goal,\n        # where c_best is current best path cost (large at start)\n        import math\n        import random\n\n        grid = self._get_grid()\n        start = self._graph.root_vertex_start.position\n        if c_best == float('inf'):\n            # No solution found yet, uniform random sample\n            for _ in range(30):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(random.randint(0, grid.size[dim] - 1))\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return start\n\n        # Ellipse parameters\n        c_min = Map.get_distance(start, goal)\n        if c_best < c_min:\n            c_best = c_min + 1e-6  # numerical guard\n\n        # Ellipse radii\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        # Coordinate transform: from ellipse frame to grid frame\n        dir_vector = (goal.to_tensor() - start.to_tensor()).float()\n        norm_dir = torch.norm(dir_vector).item()\n        if norm_dir == 0:\n            return start\n        unit_dir = dir_vector / norm_dir\n        rot_matrix = torch.eye(self._dimension)\n        # 2D rotation matrix aligning x-axis to unit_dir\n        cos_theta = unit_dir[0].item()\n        sin_theta = unit_dir[1].item()\n        rot_matrix[0, 0] = cos_theta\n        rot_matrix[0, 1] = -sin_theta\n        rot_matrix[1, 0] = sin_theta\n        rot_matrix[1, 1] = cos_theta\n\n        # Sample a point uniformly inside unit circle, then scale by radii\n        for _ in range(40):\n            a = random.uniform(0, 1) ** 0.5  # sqrt for uniform distribution over area\n            theta = random.uniform(0, 2 * math.pi)\n            x = a * math.cos(theta) * r1\n            y = a * math.sin(theta) * r2\n            sample_circle = torch.tensor([x, y])\n            sample_global = rot_matrix @ sample_circle + (start.to_tensor() + goal.to_tensor()) / 2.0\n            sample_point = Point.from_tensor(sample_global.round().int())\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback uniform random\n        for _ in range(30):\n            sample_coords = []\n            for dim in range(self._dimension):\n                sample_coords.append(random.randint(0, grid.size[dim] - 1))\n            sample = Point(*sample_coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n        return start\n\n    def _extract_and_shortcut_path(self, goal_vertex: Vertex) -> None:\n        # Extract path by following parents then shortcut aggressively\n        path = []\n        curr = goal_vertex\n        while True:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = next(iter(curr.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n        # Aggressive shortcutting: iterative shortcut with early break\n        improved = True\n        while improved:\n            improved = False\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_sequence = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_sequence):\n                        # Shortcut possible, remove intermediate vertices\n                        del path[i + 1:j]\n                        improved = True\n                        break\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n\n        self._start_time = time.time()\n        best_cost = float('inf')\n        goal_connected_vertex = None\n\n        # Maintains list of vertices expanded for heuristic selection\n        expanded_vertices = [start_vertex]\n\n        for iteration in range(self._max_iterations):\n            # Check for time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            # Goal biased sampling: with probability select direct goal sample\n            if torch.rand(1).item() < self._goal_bias_prob:\n                q_sample = goal_pos\n                # Slight random offset near goal to avoid stagnation\n                for _ in range(10):\n                    offset = torch.randn(self._dimension) * 2\n                    candidate = Point.from_tensor((goal_pos.to_tensor() + offset).round().int())\n                    if grid.is_agent_valid_pos(candidate):\n                        q_sample = candidate\n                        break\n            else:\n                # Ellipsoidal informed sample around current best cost\n                q_sample = self._sample_ellipsoidal(start_vertex.position, goal_pos, best_cost)\n\n            # Select vertex from expanded_vertices minimizing f = cost + weighted heuristic\n            f_min = float('inf')\n            q_nearest = None\n            for v in expanded_vertices:\n                dist_to_sample = Map.get_distance(v.position, q_sample)\n                # Skip if sample too close to vertex - skip unnecessary expansions\n                if dist_to_sample < 1.0e-4:\n                    continue\n                f_val = v.cost + self._heuristic_weight * self._heuristic_cost(q_sample, goal_pos)\n                if f_val < f_min:\n                    f_min = f_val\n                    q_nearest = v\n\n            if q_nearest is None:\n                continue\n\n            # Determine adaptive step size from q_nearest towards q_sample\n            max_dist = self._adaptive_max_dist(q_nearest.position, goal_pos)\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist_dir = torch.norm(dir_vec).item()\n            if dist_dir < 1e-8:\n                continue\n\n            if dist_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist_dir\n                new_pos_tensor = (q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create new vertex\n            q_new = Vertex(q_new_pos)\n\n            # Cost to reach q_new from q_nearest\n            dist_new = Map.get_distance(q_nearest.position, q_new_pos)\n            q_new.cost = q_nearest.cost + dist_new\n\n            # Find neighbors for potential better parents and rewiring:\n            card_v = float(self._graph.size if self._graph.size > 0 else 1)\n            log_card_v = float(torch.log(torch.tensor(card_v))) if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent in neighbors by cost + valid connection\n            q_best_parent = q_nearest\n            c_best = q_new.cost\n\n            for q_near in neighbors:\n                dist_to_new = Map.get_distance(q_near.position, q_new.position)\n                cost_cand = q_near.cost + dist_to_new\n                line_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_cand < c_best and grid.is_valid_line_sequence(line_cand):\n                    q_best_parent = q_near\n                    c_best = cost_cand\n\n            q_new.cost = c_best\n            self._graph.add_edge(q_best_parent, q_new)\n            expanded_vertices.append(q_new)\n\n            # Local rewiring: attempt to reduce costs of neighbors via q_new\n            if iteration % self._optimize_every == 0:\n                for q_near in neighbors:\n                    if q_near == q_best_parent:\n                        continue\n                    dist_qnew_near = Map.get_distance(q_new.position, q_near.position)\n                    cost_through_new = q_new.cost + dist_qnew_near\n                    if cost_through_new + 1e-6 < q_near.cost:\n                        line_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                        if grid.is_valid_line_sequence(line_rewire):\n                            # Remove old parent edge\n                            for parent in list(q_near.parents):\n                                self._graph.remove_edge(parent, q_near)\n                                break\n                            q_near.cost = cost_through_new\n                            self._graph.add_edge(q_new, q_near)\n\n            # Check connection to goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_connected_vertex = goal_vertex\n                    best_cost = goal_vertex.cost\n                    break\n\n            self.key_frame()\n\n        if goal_connected_vertex is not None:\n            self._extract_and_shortcut_path(goal_connected_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Advanced Heuristic-Guided Bidirectional RRT with Adaptive Sampling and Path Smoothing",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Advanced Heuristic-Guided Bidirectional RRT with Adaptive Sampling and Path Smoothing}\n\n    This path planning algorithm operates bidirectionally: growing two trees simultaneously \n    from the start and goal positions. It performs heuristic-guided sampling biased towards \n    areas likely to connect both trees quicker by sampling near a moving \"connect region\" \n    between trees with a proportion of goal bias and random exploration. Adaptive step sizes \n    adjust locally based on obstacle density and iteration count to balance exploration and refinement.\n\n    When sampling, it attempts connection attempts between the two trees to rapidly link start and goal. \n    Upon connection, it extracts and smooths the path using shortcutting. The algorithm incorporates \n    rewiring within each tree to improve path cost, similar to RRT*, but maintains a cyclic graph \n    to allow multiple possible parents for robustness. Early stopping occurs on success or timeout.\n\n    Key features:\n    - Bidirectional growth for faster coverage.\n    - Sampling biased toward current frontier mid-region to guide connection.\n    - Adaptive max step size shrinking over iterations for refinement.\n    - Rewiring with cost-based parent selection to optimize paths.\n    - Shortcut path smoothing for higher quality paths.\n    - Enforced 10-second timeout for robustness.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Use CyclicGraph for richer connection handling and rewiring\n        self._graph = CyclicGraph(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n        # Parameters for adaptive step size and goal bias\n        self._max_dist_max = 15.0\n        self._max_dist_min = 2.0\n        self._iteration_limit = 8000\n        self._goal_bias = 0.2\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir_vec)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_norm = dir_vec / length\n        new_point_tensor = q_near.position.to_tensor() + max_dist * dir_norm\n        new_point = Point.from_tensor(new_point_tensor)\n        return Vertex(new_point)\n\n    def _get_mixed_sample(self, goal_bias: float, connect_region_center: Point) -> Point:\n        \"\"\"\n        Sample with mixed strategy:\n         - With goal_bias, sample goal directly\n         - With 60% probability, sample near connect_region_center +/- small gaussian noise\n         - Else sample random valid position in map\n        \"\"\"\n        grid = self._get_grid()\n        rng = np.random.random()\n        if rng < goal_bias:\n            return grid.goal.position\n        elif rng < goal_bias + 0.6:\n            # sample near connect region center (within circle radius ~ max_dist_max*1.5)\n            attempts = 0\n            while attempts < 50:\n                offset = np.random.normal(scale=4.0, size=grid.size.n_dim)\n                candidate_coords = np.array(connect_region_center) + offset\n                candidate_coords = np.clip(candidate_coords, 0, grid.size - 1).astype(int)\n                candidate = Point(*candidate_coords)\n                if grid.is_agent_valid_pos(candidate):\n                    return candidate\n                attempts += 1\n        # fallback uniform random sample\n        attempts = 0\n        while attempts < 100:\n            rand_coords = np.random.randint(0, grid.size, grid.size.n_dim)\n            candidate = Point(*rand_coords)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n            attempts += 1\n        # fallback to goal if no valid found (should rarely happen)\n        return grid.goal.position\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(from_pos, to_pos)\n\n    def _choose_best_parent(self, neighbors: list, new_vertex: Vertex) -> (Vertex, float):\n        \"\"\"\n        Choose best parent from neighbors w.r.t cost + heuristic, ensuring collision free.\n        \"\"\"\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n\n        for neighbor in neighbors:\n            line_seq = grid.get_line_sequence(neighbor.position, new_vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = neighbor.cost + grid.get_distance(neighbor.position, new_vertex.position)\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = neighbor\n        return best_parent, best_cost\n\n    def _try_connection(self, v_from: Vertex, target_tree_vertices: list, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempt to connect v_from to nearest vertex in target_tree_vertices.\n        Return connecting vertex if success, else None.\n        \"\"\"\n        grid = self._get_grid()\n        q_near = self._graph.get_nearest_vertex(target_tree_vertices, v_from.position)\n        if q_near is None:\n            return None\n        dist = grid.get_distance(v_from.position, q_near.position)\n        if dist > max_dist:\n            # Move closer towards q_near\n            line_dir = q_near.position.to_tensor() - v_from.position.to_tensor()\n            line_dir_normalized = line_dir / torch.norm(line_dir)\n            connect_point_tensor = v_from.position.to_tensor() + max_dist * line_dir_normalized\n            connect_point = Point.from_tensor(connect_point_tensor)\n        else:\n            connect_point = q_near.position\n\n        line_seq = grid.get_line_sequence(v_from.position, connect_point)\n        if grid.is_valid_line_sequence(line_seq):\n            connect_vertex = Vertex(connect_point)\n            connect_vertex.cost = 0.0  # will update on linking\n            return connect_vertex\n        return None\n\n    def _rewire_around(self, new_vertex: Vertex, tree_vertices: list, radius: float) -> None:\n        \"\"\"\n        Attempt to rewire neighbors to improve path costs.\n        \"\"\"\n        grid = self._get_grid()\n        neighbors = self._graph.get_vertices_within_radius(tree_vertices, new_vertex.position, radius)\n        for neighbor in neighbors:\n            if neighbor == new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, neighbor.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = new_vertex.cost + grid.get_distance(new_vertex.position, neighbor.position)\n            if new_cost < neighbor.cost:\n                # Remove old parent edges\n                for p in list(neighbor.parents):\n                    self._graph.remove_edge(p, neighbor)\n                # Add new edge to new_vertex and update cost\n                self._graph.add_edge(new_vertex, neighbor)\n                neighbor.cost = new_cost\n\n    def _extract_path(self, connect_vertex_from: Vertex, connect_vertex_to: Vertex) -> None:\n        \"\"\"\n        Extract path by joining two trees at connection vertices, then shortcut.\n        \"\"\"\n        path_from = [connect_vertex_from]\n        while len(path_from[-1].parents) != 0:\n            min_parent = min(path_from[-1].parents, key=lambda v: v.cost)\n            path_from.append(min_parent)\n        path_from.reverse()\n\n        path_to = [connect_vertex_to]\n        while len(path_to[-1].parents) != 0:\n            min_parent = min(path_to[-1].parents, key=lambda v: v.cost)\n            path_to.append(min_parent)\n\n        full_path = path_from + path_to  # connect at connect_vertex\n\n        full_path = self._shortcut_path(full_path)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut path by checking validity of skipping intermediate vertices.\n        \"\"\"\n        grid = self._get_grid()\n        shortened = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(shortened[-1].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    shortened.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                # No shortcut found; add next vertex\n                shortened.append(path[i + 1])\n                i += 1\n        if shortened[-1] != path[-1]:\n            shortened.append(path[-1])\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        iteration_limit = self._iteration_limit\n        max_dist_max = self._max_dist_max\n        max_dist_min = self._max_dist_min\n        goal_bias = self._goal_bias\n        start_time = time.time()\n\n        connected = False\n        connect_vertex_start = None\n        connect_vertex_goal = None\n\n        for iteration in range(iteration_limit):\n            elapsed = time.time() - start_time\n            if elapsed > 10.0:\n                # timeout safety break\n                break\n\n            # Adaptive max_dist shrinking with iterations + local density factor\n            max_dist = max_dist_max - (max_dist_max - max_dist_min) * (iteration / iteration_limit)\n\n            # Determine connect region center as midpoint between tree frontiers\n            # approximate frontier centers by random vertices in each tree favoring farthest from root\n            if len(tree_start) == 0 or len(tree_goal) == 0:\n                break\n            frontier_start = max(tree_start, key=lambda v: v.cost)\n            frontier_goal = max(tree_goal, key=lambda v: v.cost)\n            connect_region_center_tensor = (frontier_start.position.to_tensor() + frontier_goal.position.to_tensor()) / 2\n            connect_region_center = Point.from_tensor(connect_region_center_tensor)\n\n            # Alternate growing trees; odd iterations expand start tree, even expand goal tree\n            grow_start = (iteration % 2 == 0)\n\n            # Sample a point biased toward connect_region and goal\n            q_sample = self._get_mixed_sample(goal_bias, connect_region_center)\n\n            # Select which tree to grow\n            if grow_start:\n                q_near = self._graph.get_nearest_vertex(tree_start, q_sample)\n            else:\n                q_near = self._graph.get_nearest_vertex(tree_goal, q_sample)\n\n            if q_near.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Find neighbors for rewiring within radius ~ 2*max_dist\n            rewiring_radius = max_dist * 2.5\n\n            if grow_start:\n                neighbors = self._graph.get_vertices_within_radius(tree_start, q_new.position, rewiring_radius)\n                parent_tree = tree_start\n                opposite_tree = tree_goal\n            else:\n                neighbors = self._graph.get_vertices_within_radius(tree_goal, q_new.position, rewiring_radius)\n                parent_tree = tree_goal\n                opposite_tree = tree_start\n\n            # Choose best parent from neighbors by cost\n            best_parent, best_cost = self._choose_best_parent(neighbors, q_new)\n            if best_parent is None:\n                # fallback to q_near if direct collision free\n                if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                    self.key_frame()\n                    continue\n                best_parent = q_near\n                best_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n\n            # Set cost and add edge\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n            parent_tree.append(q_new)\n\n            # Rewire neighbors to optimize path cost\n            self._rewire_around(q_new, parent_tree, rewiring_radius)\n\n            # Attempt to connect q_new to opposite tree within max_dist range\n            connect_vert = self._try_connection(q_new, opposite_tree, max_dist)\n            if connect_vert is not None:\n                # Link q_new and connect_vert with cost\n                # We add connect_vert as a new vertex in opposite_tree\n                # Choose best parent in opposite_tree for connect_vert\n                opposite_neighbors = self._graph.get_vertices_within_radius(opposite_tree, connect_vert.position, rewiring_radius)\n                best_parent_opp, best_cost_opp = self._choose_best_parent(opposite_neighbors, connect_vert)\n                if best_parent_opp is None:\n                    # fallback to nearest vertex q_near in opposite tree\n                    best_parent_opp = self._graph.get_nearest_vertex(opposite_tree, connect_vert.position)\n                    if best_parent_opp is None:\n                        self.key_frame()\n                        continue\n                    best_cost_opp = best_parent_opp.cost + grid.get_distance(best_parent_opp.position, connect_vert.position)\n\n                connect_vert.cost = best_cost_opp\n                self._graph.add_edge(best_parent_opp, connect_vert)\n                opposite_tree.append(connect_vert)\n\n                # Rewire neighbors in opposite tree\n                self._rewire_around(connect_vert, opposite_tree, rewiring_radius)\n\n                # Connect the two trees via q_new -> connect_vert\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, connect_vert.position)):\n                    # Create the cross edge q_new <-> connect_vert\n                    # We add an edge from q_new -> connect_vert (direction chosen arbitrarily)\n                    self._graph.add_edge(q_new, connect_vert)\n\n                    # Extract and smooth path by connecting both trees at these vertices\n                    self._extract_path(q_new, connect_vert)\n\n                    connected = True\n                    break\n\n            self.key_frame()\n\n        if not connected:\n            # If we fail to connect, no path found\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a heuristic-guided integrated search for path planning that combines \n    elements of RRT* and A*-style cost evaluation with a bidirectional forest expansion. \n    \n    Key innovations:\n    - Dual-tree growth from start and goal, increasing connection likelihood and robustness.\n    - Heuristic cost-to-go estimates (Euclidean distance) used in parent selection and vertex prioritization \n      to guide growth toward promising regions.\n    - Adaptive dynamic step size based on local clearance, inspired by the reference adaptive sampling \n      but extended to both trees.\n    - Connection attempts between start and goal trees prioritized when vertices are close enough.\n    - Rewiring applied after connection to optimize the final path.\n    - Path smoothing via shortcutting before execution.\n    - Early stopping if path found or timeout (>10 seconds).\n    - Vertex cost accounts for cost-so-far plus heuristic to goal or start, for better informed decisions.\n    \n    This approach aims to improve efficiency by growing two trees efficiently toward each other, \n    improving success rate and path quality, and robustness in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Create separate forests for bidirectional RRT* style search\n        self._forest_start = Forest(\n            root_vertex_start=Vertex(self._get_grid().agent.position),\n            root_vertex_goal=Vertex(self._get_grid().goal.position),\n            root_vertices=[]\n        )\n        self._forest_start.root_vertices = [self._forest_start.root_vertex_start]\n        self._forest_goal = Forest(\n            root_vertex_start=Vertex(self._get_grid().goal.position),\n            root_vertex_goal=Vertex(self._get_grid().agent.position),\n            root_vertices=[]\n        )\n        self._forest_goal.root_vertices = [self._forest_goal.root_vertex_start]\n\n        # Make sure edges removable to allow rewiring\n        self._forest_start.edges_removable = True\n        self._forest_goal.edges_removable = True\n\n        self._connected_vertex_start = None  # Will store connection vertex in start tree\n        self._connected_vertex_goal = None   # Will store connection vertex in goal tree\n\n        self._init_displays()\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Reuse adaptive max dist method from reference with slight extension\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=7):\n            direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> 'Vertex | None':\n        # Create new vertex from q_near towards q_sample constrained by max_dist and valid line\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent_heuristic(self, forest: Forest, q_near_list: list[Vertex], q_new: Vertex, target_pos: Point) -> Vertex | None:\n        # Choose parent with minimal total_cost = cost_so_far + heuristic (distance to target_pos)\n        min_total_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_so_far = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            heuristic = Map.get_distance(q_new.position, target_pos)\n            total_cost = cost_so_far + heuristic\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire_with_heuristic(self, forest: Forest, q_new: Vertex, q_near_list: list[Vertex]) -> None:\n        # Attempt rewiring neighbors to reduce cost, guided by heuristic\n        for v in q_near_list:\n            if q_new in v.parents:\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges leading to v and add new edge from q_new\n                    for p in list(v.parents):\n                        forest.remove_edge(p, v)\n                    forest.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_bidirectional_path(self, conn_start: Vertex, conn_goal: Vertex):\n        # Build path from start root to connection vertex (conn_start)\n        path_start: list[Vertex] = [conn_start]\n        while len(path_start[-1].parents) != 0:\n            min_parent = min(path_start[-1].parents, key=lambda p: p.cost)\n            path_start.append(min_parent)\n        path_start.reverse()  # from start to connection\n\n        # Build path from goal root to connection vertex (conn_goal)\n        path_goal: list[Vertex] = [conn_goal]\n        while len(path_goal[-1].parents) != 0:\n            min_parent = min(path_goal[-1].parents, key=lambda p: p.cost)\n            path_goal.append(min_parent)\n        # path_goal is from goal to connection; reverse to connection to goal\n        path_goal.reverse()\n\n        # Combine paths (without duplicate connection vertex)\n        full_path = path_start + path_goal[1:]\n\n        # Shortcut smoothing by greedy skipping in path\n        smoothed_path = [full_path[0]]\n        last_idx = 0\n        n = len(full_path)\n        for i in range(2, n):\n            line_seq = self._get_grid().get_line_sequence(smoothed_path[-1].position, full_path[i].position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                last_idx = i\n                continue\n            else:\n                smoothed_path.append(full_path[last_idx])\n                last_idx = i\n        # Append last vertex if not included\n        if smoothed_path[-1] != full_path[-1]:\n            smoothed_path.append(full_path[-1])\n\n        # Execute path by moving agent\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000  # fewer iterations due to bidirectional growth\n        goal_sample_rate = 0.25  # bias sampling towards current goal or start depending on tree\n        search_radius = 12.0  # smaller radius for rewiring to speed convergence\n        connection_threshold = 5.0  # max dist to connect the two trees\n        start_time = time.time()\n\n        # Initialize costs\n        self._forest_start.root_vertex_start.cost = 0.0\n        self._forest_goal.root_vertex_start.cost = 0.0\n\n        # Alternate tree expansions: True for start tree, False for goal tree\n        expand_start_tree = True\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                break\n\n            # Determine active forest and its target for heuristic cost\n            if expand_start_tree:\n                forest = self._forest_start\n                other_forest = self._forest_goal\n                target_pos = self._get_grid().goal.position\n                root_vertices = forest.root_vertices\n            else:\n                forest = self._forest_goal\n                other_forest = self._forest_start\n                target_pos = self._get_grid().agent.position\n                root_vertices = forest.root_vertices\n\n            # Sampling: goal biased towards target of current tree\n            sample_goal_rate_dynamic = goal_sample_rate\n            if np.random.rand() < sample_goal_rate_dynamic:\n                q_sample = target_pos\n            else:\n                while True:\n                    rand_coords = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                    q_sample = Point(*rand_coords)\n                    if self._get_grid().is_agent_valid_pos(q_sample):\n                        break\n\n            q_near = forest.get_nearest_vertex(root_vertices, q_sample)\n            if q_near.position == q_sample:\n                # Skip if sample equals nearest vertex\n                expand_start_tree = not expand_start_tree\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position)\n            q_new = self._get_new_vertex_towards(q_near, q_sample, max_dist)\n            if q_new is None:\n                expand_start_tree = not expand_start_tree\n                continue\n\n            q_near_list = forest.get_vertices_within_radius(root_vertices, q_new.position, search_radius)\n            chosen_parent = self._choose_parent_heuristic(forest, q_near_list, q_new, target_pos)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            forest.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            neighbors_for_rewire = [v for v in q_near_list if v != chosen_parent]\n            self._rewire_with_heuristic(forest, q_new, neighbors_for_rewire)\n\n            # Check if newly added vertex can connect to vertex in other forest\n            other_vertices_close = other_forest.get_vertices_within_radius(other_forest.root_vertices, q_new.position, connection_threshold)\n            connection_made = False\n            for other_v in other_vertices_close:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, other_v.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                # Connect trees\n                cost_to_other = self._get_grid().get_movement_cost(q_new.position, other_v.position)\n                combined_cost = q_new.cost + cost_to_other + other_v.cost\n                # Add edges in both forests for coherent path construction\n                forest.add_edge(q_new, other_v)\n                other_forest.add_edge(other_v, q_new)\n                self._connected_vertex_start = q_new if expand_start_tree else other_v\n                self._connected_vertex_goal = other_v if expand_start_tree else q_new\n                connection_made = True\n                break\n\n            if connection_made:\n                self._extract_bidirectional_path(self._connected_vertex_start, self._connected_vertex_goal)\n                break\n\n            # Alternate expansion tree\n            expand_start_tree = not expand_start_tree\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Adaptive Heuristic Tree (HAHT) for Grid Path Planning\n    \n    This algorithm merges heuristic-driven informed sampling with a dual-tree bidirectional expansion approach \n    to improve planning efficiency, success rate, and path quality. Key features:\n    - Bidirectional growth: simultaneously grow trees from start and goal, attempting frequent connections.\n    - Heuristic mixture sampling blending clearanced-biased uniform, goal-biased, and heuristic corridor sampling.\n    - Dynamic adaptive step sizes leveraged differently for each tree based on local clearance and tree density.\n    - Rewiring optimized locally in each tree with pruning thresholds and dynamic neighborhood radius.\n    - Utilizes a connection attempt whenever the two trees get close enough, reducing iterations for path finding.\n    - After connection, a bi-directional path extraction is performed, followed by powerful multi-pass shortcut smoothing.\n    - Early timeout enforced at 10 seconds.\n    This design substantially boosts success rate by reducing dependency on single direction growth, \n    improves path quality with thorough rewiring and smoothing, \n    and increases efficiency by focused bidirectional heuristic sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Use CyclicGraph to allow flexible rewiring and bi-directional connections\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._max_iterations = 4000\n        self._time_limit_seconds = 10.0\n        self._goal_sample_rate = 0.15  # Goal bias sampling overall\n        self._heuristic_sample_rate = 0.5  # Portion of heuristic corridor guided sampling\n        self._clearance_threshold = 2.5\n        self._min_step = 2.0\n        self._max_step = 16.0\n        self._rewire_lambda = 35.0  # rewiring radius constant\n        self._dimension = 2\n        self._start_time = None\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_check = 10.0\n        min_dist = max_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _hybrid_sample(self, active_tree: str) -> Point:\n        import torch\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        prob = torch.rand(1).item()\n\n        if prob < self._goal_sample_rate:\n            # Direct goal bias to the goal of active tree\n            if active_tree == \"start\":\n                return goal_pos\n            else:\n                return agent_pos\n\n        if prob < self._goal_sample_rate + self._heuristic_sample_rate:\n            # Heuristic corridor sampling:\n            # Sample around corridor line with Gaussian noise biased by clearance\n            max_dist = Map.get_distance(agent_pos, goal_pos)\n            for _ in range(30):\n                alpha = torch.rand(1).item()\n                corridor_point_tensor = (1 - alpha) * agent_pos.to_tensor().float() + alpha * goal_pos.to_tensor().float()\n                noise = torch.randn(self._dimension) * (max_dist * 0.1)\n                sample_coords = (corridor_point_tensor + noise).round().int()\n                sample = Point.from_tensor(sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    clearance = self._get_clearance(sample)\n                    if clearance >= self._clearance_threshold * 0.6:\n                        return sample\n            # fallback\n            return self._clearance_aware_sample()\n\n        # Uniform clearance-aware rejection sampling\n        return self._clearance_aware_sample()\n\n    def _clearance_aware_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        for _ in range(120):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        # fallback uniform sample anywhere valid\n        for _ in range(100):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        return self._graph_start.root_vertex_start.position\n\n    def _adaptive_step(self, pos: Point, target: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        direction_vec = target.to_tensor().float() - pos.to_tensor().float()\n        dist = torch.norm(direction_vec).item()\n        if dist < 1e-8:\n            return self._min_step\n        dir_unit = direction_vec / dist\n\n        # Sample clearance at incremental steps along direction and reduce step if obstacles near\n        intervals = 5\n        for fraction in torch.linspace(0.2, 1.0, intervals):\n            intermediate_point_tensor = pos.to_tensor().float() + dir_unit * dist * fraction\n            intermediate_point = Point.from_tensor(intermediate_point_tensor.round().int())\n            if not grid.is_agent_valid_pos(intermediate_point):\n                return max(self._min_step, dist * fraction * 0.5)\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(pos, intermediate_point)):\n                return max(self._min_step, dist * fraction * 0.5)\n\n        # Scale max step by clearance at current position\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n        adaptive_step = self._min_step + (self._max_step - self._min_step) * clearance_factor\n        return max(self._min_step, min(adaptive_step, dist))\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex or None:\n        grid = self._get_grid()\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in neighbors:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_candidate = v.cost + grid.get_movement_cost(v.position, q_new.position)\n            if cost_candidate < min_cost:\n                min_cost = cost_candidate\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list, graph: Forest) -> None:\n        grid = self._get_grid()\n        rewire_threshold_cost = 0.01\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            new_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if new_cost + rewire_threshold_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for p in list(neighbor.parents):\n                        graph.remove_edge(p, neighbor)\n                    graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n    def _extract_bidirectional_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        grid = self._get_grid()\n        # Extract path from start root to connecting_vertex_start\n        path_start = []\n        current = connecting_vertex_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            # pick min cost parent for clarity\n            current = min(current.parents, key=lambda p: p.cost)\n        path_start.reverse()\n\n        # Extract path from goal root to connecting_vertex_goal\n        path_goal = []\n        current = connecting_vertex_goal\n        while True:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n        # goal side path needs to be reversed to goal->connection, so it is connection->goal here\n        # we append path_goal to path_start to form full path start->goal\n        full_path = path_start + path_goal\n\n        # Multiple robust shortcutting passes\n        for _ in range(5):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Move agent along smoothed path\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_connection(self, vertex_start: Vertex, vertex_goal: Vertex, max_connect_dist: float) -> (Vertex, Vertex) or None:\n        \"\"\"\n        Attempts to connect two given trees by checking if vertices are within max_connect_dist \n        and valid line sequence exists between them.\n        Returns (vertex_start, vertex_goal) on success or None if no connection possible.\n        \"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(vertex_start.position, vertex_goal.position)\n        if dist <= max_connect_dist:\n            line_seq = grid.get_line_sequence(vertex_start.position, vertex_goal.position)\n            if grid.is_valid_line_sequence(line_seq):\n                return (vertex_start, vertex_goal)\n        return None\n\n    def _find_path_internal(self) -> None:\n        import torch\n        import time\n\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # Initialize costs for roots\n        self._graph_start.root_vertex_start.cost = 0.0\n        self._graph_goal.root_vertex_start.cost = 0.0\n\n        # We'll grow two trees: start_tree and goal_tree\n        graph_start = self._graph_start\n        graph_goal = self._graph_goal\n\n        connected_path_found = False\n        best_cost = float('inf')\n        best_connection = None  # tuple (vertex_from_start_tree, vertex_from_goal_tree)\n\n        for iteration in range(self._max_iterations):\n            # Timeout check (10 seconds)\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                break\n\n            # Alternate sampling in start and goal trees\n            active_tree = \"start\" if iteration % 2 == 0 else \"goal\"\n            graph_active = graph_start if active_tree == \"start\" else graph_goal\n            graph_other = graph_goal if active_tree == \"start\" else graph_start\n\n            q_sample = self._hybrid_sample(active_tree)\n            q_near = graph_active.get_nearest_vertex([graph_active.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step(q_near.position, q_sample)\n            max_dist = max(self._min_step, min(max_dist, self._max_step))\n\n            dir_vec = q_sample.to_tensor().float() - q_near.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_unit = dir_vec / dist\n            step_dist = min(dist, max_dist)\n            q_new_pos_tensor = (q_near.position.to_tensor().float() + dir_unit * step_dist).round().int()\n            q_new_pos = Point.from_tensor(q_new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = 0.0  # temporary placeholder\n\n            # Radius for neighborhood search depends on tree size and clearance\n            tree_size = max(graph_active.size, 1)\n            ln_size = torch.log(torch.tensor(float(tree_size))).item() if tree_size > 1 else 0.0\n            radius = min(self._rewire_lambda * ((ln_size / tree_size) ** (1 / self._dimension)), 25.0)\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            neighbors = graph_active.get_vertices_within_radius([graph_active.root_vertex_start], q_new.position, radius)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n            graph_active.add_edge(chosen_parent, q_new)\n\n            # Rewire neighbors if cheaper connection through q_new\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors, graph_active)\n\n            # Check connection possibility to other tree\n            near_opposite_vertices = graph_other.get_vertices_within_radius([graph_other.root_vertex_start], q_new.position, radius)\n            for v_opp in near_opposite_vertices:\n                conn = self._find_connection(q_new, v_opp, radius)\n                if conn is not None:\n                    cost_connect = q_new.cost + v_opp.cost + Map.get_distance(q_new.position, v_opp.position)\n                    if cost_connect < best_cost:\n                        best_cost = cost_connect\n                        best_connection = (q_new, v_opp)\n                        connected_path_found = True\n\n            if connected_path_found:\n                break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if connected_path_found and best_connection is not None:\n            self._extract_bidirectional_path(best_connection[0], best_connection[1])",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Algorithm Description:\n    This algorithm implements a hybrid bidirectional heuristic-guided Rapidly-exploring Random Graph (RRG) with dynamic priority queue expansion.\n    Instead of purely incremental growth, it grows two search trees simultaneously from start and goal. The expansions prioritize vertices with the\n    lowest sum of accumulated path cost and heuristic estimate to the opposite root, resembling a bidirectional A* guidance but on a graph of samples.\n    Sampling is adaptive and mixes uniform, goal biasing and directed sampling towards promising frontier regions identified from the two trees.\n    Dynamic max step size adjusts exploration granularity based on local obstacle density and distance to goal.\n    The graph supports cyclic connections to allow multi-parent rewiring. Rewiring around new nodes is performed aggressively to optimize paths.\n    Early stopping triggers immediately upon tree connection with a collision-free path between the two graphs.\n    The extracted path is smoothed with iterative shortcutting ensuring path validity and minimized vertex count, delivering high-quality paths.\n    The algorithm is time-limited to 10 seconds to enforce validity in real-time constraints.\n    This approach improves efficiency by focused bidirectional search with heuristic prioritization, increases success by growing two complementary trees,\n    and delivers smooth, near-optimal paths via rewiring and shortcutting.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position.clone())\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(grid.goal.position.clone())\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 14.0\n        self._min_max_dist = 3.0\n        self._goal_sample_rate = 0.2\n        self._uniform_sample_rate = 0.5\n        self._adaptive_sample_rate = 0.3\n        self._time_limit_seconds = 10.0\n        self._dimension = len(grid.size)\n        self._start_time = None\n        self._best_path_cost = float('inf')\n        self._best_connection = None\n        self._init_displays()\n\n    def _adaptive_max_dist(self, position: Point) -> float:\n        grid = self._get_grid()\n        dist_to_goal = Map.get_distance(position, grid.goal.position)\n        dist_to_start = Map.get_distance(position, grid.agent.position)\n        obstacle_density_factor = 1.0\n        # Estimate local obstacle density (count obstacles in radius 5)\n        obstacle_count = 0\n        radius_check = 5\n        for obstacle in grid.obstacles:\n            obs_point = obstacle.position\n            if Map.get_distance(position, obs_point) <= radius_check:\n                obstacle_count += 1\n        obstacle_density_factor = max(0.3, 1.0 - (obstacle_count / 10.0))\n        # Step size shrinks near start/goal and in obstacle-dense area\n        step_size = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * obstacle_density_factor \\\n                    * min(dist_to_goal, dist_to_start) / max(grid.size)\n        step_size = max(self._min_max_dist, min(self._max_max_dist, step_size))\n        return step_size\n\n    def _heuristic(self, pos_a: Point, pos_b: Point) -> float:\n        # Euclidean heuristic distance\n        return Map.get_distance(pos_a, pos_b)\n\n    def _sample_point(self, tree_direction: str) -> Point:\n        \"\"\"\n        Adaptive sampling strategy based on tree growth direction.\n        tree_direction: 'start' or 'goal', to bias sample region.\n        Mixes uniform, goal-bias, start-bias and frontier-directed sampling.\n        \"\"\"\n        import random\n        grid = self._get_grid()\n        rand_val = random.random()\n\n        # 20% goal bias (towards goal for start tree, towards start for goal tree)\n        if rand_val < self._goal_sample_rate:\n            return grid.goal.position if tree_direction == 'start' else grid.agent.position\n\n        # 30% adaptive directed sampling near frontier by heuristic layering\n        if rand_val < self._goal_sample_rate + self._adaptive_sample_rate:\n            root_pos = grid.agent.position if tree_direction == 'start' else grid.goal.position\n            opposite_pos = grid.goal.position if tree_direction == 'start' else grid.agent.position\n            # Sample near midpoint between roots with perturbation\n            mid_tensor = (root_pos.to_tensor().float() + opposite_pos.to_tensor().float()) / 2\n            for _ in range(30):\n                offset = torch.randn(self._dimension) * (max(grid.size) / 6)\n                candidate_tensor = mid_tensor + offset\n                candidate_tensor = torch.clamp(candidate_tensor, min=0, max=torch.tensor(grid.size).float()-1)\n                sample = Point.from_tensor(candidate_tensor.round().int())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Otherwise pure uniform random\n        for _ in range(40):\n            coords = [torch.randint(0, grid.size[i], (1,)).item() for i in range(self._dimension)]\n            point = Point(*coords)\n            if grid.is_agent_valid_pos(point):\n                return point\n\n        # fallback to root vertex position\n        return grid.agent.position if tree_direction == 'start' else grid.goal.position\n\n    def _connect_trees_and_extract_path(self, v_start: Vertex, v_goal: Vertex) -> None:\n        \"\"\"\n        Extracts and smooths path connecting start tree vertex to goal tree vertex.\n        Bidirectional graph means path is merged by walking parents up both trees.\n        \"\"\"\n        grid = self._get_grid()\n        # Reconstruct path from start root to v_start\n        path_start = []\n        current = v_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            # Pick parent with minimal cost (if cyclic multiple parents)\n            current = min(current.parents, key=lambda v: v.cost)\n        path_start.reverse()\n\n        # Reconstruct path from goal root to v_goal\n        path_goal = []\n        current = v_goal\n        while True:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda v: v.cost)\n\n        # Full path is path_start + reversed path_goal (excluding connection duplicate)\n        full_path = path_start + path_goal[::-1][1:]\n\n        # Shortcut smoothing multiple passes\n        for _ in range(3):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i + 1 : j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Animate the path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_time = time.time()\n        self._start_time = start_time\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # Initialize all vertex costs (should be only roots initially)\n        start_root.cost = 0.0\n        goal_root.cost = 0.0\n\n        # Two priority queues for frontier expansion: (heuristic + cost, vertex)\n        # Use lists and manual heap operations\n        import heapq\n        queue_start = []\n        queue_goal = []\n        # Entries: (priority, vertex)\n        heapq.heappush(queue_start, (self._heuristic(start_root.position, goal_root.position), start_root))\n        heapq.heappush(queue_goal, (self._heuristic(goal_root.position, start_root.position), goal_root))\n\n        # Sets for quick membership checks\n        vertices_start = {start_root}\n        vertices_goal = {goal_root}\n\n        iteration = 0\n        max_iterations = 8000  # Lower than reference to boost efficiency\n\n        while iteration < max_iterations:\n            iteration += 1\n            if (time.time() - start_time) > self._time_limit_seconds:\n                # Time limit exceeded: stop search as failed\n                return\n\n            # Alternate expanding from start and goal trees (bidirectional)\n            if iteration % 2 == 1:\n                expand_queue = queue_start\n                expand_vertices_set = vertices_start\n                other_vertices_set = vertices_goal\n                tree_dir = 'start'\n            else:\n                expand_queue = queue_goal\n                expand_vertices_set = vertices_goal\n                other_vertices_set = vertices_start\n                tree_dir = 'goal'\n\n            if not expand_queue:\n                # No vertices to expand, fail early\n                break\n            # Pop vertex with lowest cost+heuristic\n            _, vertex_near = heapq.heappop(expand_queue)\n\n            # Sample new point biased by this tree direction\n            q_sample = self._sample_point(tree_dir)\n\n            # Determine adaptive max step\n            max_dist = self._adaptive_max_dist(vertex_near.position)\n\n            dir_vec = q_sample.to_tensor().float() - vertex_near.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir == 0:\n                continue\n\n            if norm_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                q_new_pos = Point.from_tensor(\n                    (vertex_near.position.to_tensor().float() + (dir_vec / norm_dir) * max_dist).round().int()\n                )\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(vertex_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist = Map.get_distance(vertex_near.position, q_new.position)\n            tentative_cost = vertex_near.cost + dist\n\n            # Rewire and set parents from neighbors near q_new (within radius)\n            r = max(15.0, max_dist * 2.0)\n            neighbors = self._graph.get_vertices_within_radius(list(expand_vertices_set), q_new.position, r)\n\n            # Choose best parent producing minimal cost to q_new\n            min_cost = tentative_cost\n            min_parent = vertex_near\n            for neighbor in neighbors:\n                line_candidate = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_candidate):\n                    continue\n                cost_candidate = neighbor.cost + Map.get_distance(neighbor.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    min_parent = neighbor\n\n            # Add edges from min_parent to q_new\n            q_new.cost = min_cost\n            self._graph.add_edge(min_parent, q_new)\n\n            # Aggressively rewire neighbors through q_new if cost improved\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                line_check = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_check):\n                    continue\n                cost_through_new = q_new.cost + Map.get_distance(q_new.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    # Remove old parents' edges one by one (keep the graph cyclic but minimal)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    neighbor.cost = cost_through_new\n                    self._graph.add_edge(q_new, neighbor)\n\n            # Add new vertex to expanded tree set and priority queue\n            expand_vertices_set.add(q_new)\n            priority = q_new.cost + self._heuristic(q_new.position, grid.goal.position if tree_dir == 'start' else grid.agent.position)\n            heapq.heappush(expand_queue, (priority, q_new))\n\n            # Check if newly added q_new connects to any vertex in the other tree with valid line sequence\n            radius_connect = max_dist * 1.5\n            connect_candidates = self._graph.get_vertices_within_radius(list(other_vertices_set), q_new.position, radius_connect)\n            connected = False\n            for q_other in connect_candidates:\n                line_between = grid.get_line_sequence(q_new.position, q_other.position)\n                if grid.is_valid_line_sequence(line_between):\n                    # Combined cost of connecting paths\n                    combined_cost = q_new.cost + Map.get_distance(q_new.position, q_other.position) + q_other.cost\n                    if combined_cost < self._best_path_cost:\n                        self._best_path_cost = combined_cost\n                        self._best_connection = (q_new, q_other)\n                        connected = True\n                    # Early stop on found valid connection path\n                    break\n\n            if connected:\n                break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if self._best_connection is not None:\n            # Merge two connecting vertices trees and extract path\n            self._connect_trees_and_extract_path(self._best_connection[0], self._best_connection[1])",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm introduces a novel cost-to-go augmented RRT*-A* hybrid \n    approach leveraging:\n    - Expansion prioritized by a combined cost-to-come + heuristic cost for balanced exploration.\n    - Dynamic adaptive step size scaled by local clearance and proximity to goal for efficient coverage.\n    - Biased sampling combining obstacle-aware uniform samples with a probabilistic bridge region sampler \n      focusing on narrow passages.\n    - Rewiring with incremental pruning threshold dynamically adjusted by path improvement margin to \n      reduce overhead.\n    - Early shortcut smoothing interleaved with exploration to maintain quality evolving paths.\n    - Early termination if a verified feasible path connecting start and goal found, or timeout exceeded.\n    - Utilizes auxiliary caching of heuristic costs to speed repeated computations.\n    This approach aims to improve success rate in complex environments with narrower passages,\n    reduce total planning iterations, and produce smoother/faster-converging paths by intertwining \n    best-first vertex selection and clearance-aware sampling.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 16.0\n        self._min_max_dist = 2.0\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10\n        self._goal_bias = 0.2\n        self._bridge_sample_rate = 0.15  # Probability to do bridge region sampling for narrow passages\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._best_cost = float('inf')\n        self._start_time = None\n        # Cache for heuristic costs to reduce duplicates\n        self._heuristic_cache = {}\n        self._clearance_threshold = 2\n        self._prune_epsilon = 0.01\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Cache heuristic costs for speed\n        key = (pos.x, pos.y, goal_pos.x, goal_pos.y)\n        if key not in self._heuristic_cache:\n            self._heuristic_cache[key] = Map.get_distance(pos, goal_pos)\n        return self._heuristic_cache[key]\n\n    def _get_clearance(self, point: Point) -> float:\n        # Clearance defined as minimum obstacle or boundary distance\n        grid = self._get_grid()\n        max_check = 10.0\n        min_dist = max_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0] - 1 - x, grid.size[1] - 1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        # Adaptive step size based on clearance and distance to goal\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_goal = self._heuristic_cost(pos, goal_pos)\n        norm_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 2.0))\n        tree_factor = min(1.0, 800 / (self._graph.size + 1))\n        step = (self._min_max_dist +\n                (self._max_max_dist - self._min_max_dist) * norm_dist * clearance_factor * tree_factor)\n        return max(self._min_max_dist, min(step, self._max_max_dist))\n\n    def _sample_uniform_clearance_aware(self) -> Point:\n        # Sample uniformly rejecting low clearance points; fallback to root if none found\n        import torch\n        grid = self._get_grid()\n        for _ in range(120):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_threshold:\n                return sample\n        return self._graph.root_vertex_start.position\n\n    def _sample_bridge_region(self) -> Point:\n        # Bridge region sampling for narrow passages:\n        # Pick two random points near obstacles and sample midpoint if valid and clearance ok\n        import torch\n        grid = self._get_grid()\n        obstacles = grid.obstacles\n        if not obstacles:\n            return self._sample_uniform_clearance_aware()\n\n        for _ in range(40):\n            o1 = obstacles[torch.randint(0, len(obstacles), (1,)).item()]\n            o2 = obstacles[torch.randint(0, len(obstacles), (1,)).item()]\n            if o1.position == o2.position:\n                continue\n            p1_candidates = grid.get_obstacle_bound(o1.position)\n            p2_candidates = grid.get_obstacle_bound(o2.position)\n            if not p1_candidates or not p2_candidates:\n                continue\n            import random\n            p1 = random.choice(list(p1_candidates))\n            p2 = random.choice(list(p2_candidates))\n            midpoint = Point((p1.x + p2.x) // 2, (p1.y + p2.y) // 2)\n            if grid.is_agent_valid_pos(midpoint) and self._get_clearance(midpoint) >= self._clearance_threshold:\n                # Check line validity between p1-midpoint and midpoint-p2 to be obstacle boundary crossing\n                line1 = grid.get_line_sequence(p1, midpoint)\n                line2 = grid.get_line_sequence(midpoint, p2)\n                if (grid.is_valid_line_sequence(line1) and grid.is_valid_line_sequence(line2)):\n                    return midpoint\n\n        # fallback uniform clearance-aware\n        return self._sample_uniform_clearance_aware()\n\n    def _get_biased_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        prob = torch.rand(1).item()\n        if prob < self._goal_bias:\n            # Goal bias: sample near goal within radius min_max_dist\n            goal_pos = grid.goal.position\n            for _ in range(30):\n                offset = torch.randn(self._dimension)\n                norm = torch.norm(offset).item()\n                if norm < 1e-8:\n                    continue\n                offset = offset / norm * (torch.rand(1).item() * self._min_max_dist)\n                sample_coords = (goal_pos.to_tensor().float() + offset).round().int()\n                sample = Point.from_tensor(sample_coords)\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            return goal_pos\n        elif prob < self._goal_bias + self._bridge_sample_rate:\n            # Sample bridge region for narrow spaces\n            return self._sample_bridge_region()\n        else:\n            # Uniform clearance-aware sampling\n            return self._sample_uniform_clearance_aware()\n\n    def _extract_path_and_interleaved_smooth(self, goal_vertex: Vertex) -> None:\n        # Extract path back to start and do interleaved shortcut smoothing pass after every 5 vertices traversal\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if not current.parents:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Interleaved shortcut smoothing in passes\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    seg = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(seg):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Move agent along final path with keyframes for visualization\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        # Priority queue managed as list of tuples (total_cost, Vertex)\n        # Total cost = cost to come + heuristic cost to goal\n        import heapq\n        open_set = []\n        heapq.heappush(open_set, (self._heuristic_cost(start_vertex.position, goal_pos), start_vertex))\n\n        # Maintain a map for quick lookup of vertices by position to prune duplicates\n        vertex_map = { (start_vertex.position.x, start_vertex.position.y): start_vertex }\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            # Timeout check\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            if not open_set:\n                break  # no vertices to expand\n\n            # Pop vertex with lowest estimated total cost\n            _, current_vertex = heapq.heappop(open_set)\n\n            # Sample biased point to expand towards\n            q_sample_pos = self._get_biased_sample()\n\n            if current_vertex.position == q_sample_pos:\n                continue\n\n            max_step = self._adaptive_max_dist(current_vertex.position)\n            dir_vec = q_sample_pos.to_tensor().float() - current_vertex.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_step:\n                new_pos_tensor = q_sample_pos.to_tensor().float()\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = current_vertex.position.to_tensor().float() + dir_norm * max_step\n\n            q_new_pos = Point.from_tensor(new_pos_tensor.round().int())\n\n            # Validate q_new_pos candidate vertex\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check valid line sequence from current_vertex to q_new_pos\n            candidate_line = grid.get_line_sequence(current_vertex.position, q_new_pos)\n            if not grid.is_valid_line_sequence(candidate_line):\n                continue\n\n            # Calculate cost to come\n            dist_cur_new = torch.norm(current_vertex.position.to_tensor().float() - q_new_pos.to_tensor().float()).item()\n            cost_to_come = current_vertex.cost + dist_cur_new\n\n            # Reuse or create new vertex at q_new_pos\n            key_pos = (q_new_pos.x, q_new_pos.y)\n            if key_pos in vertex_map:\n                q_new_vertex = vertex_map[key_pos]\n                if cost_to_come >= q_new_vertex.cost:\n                    continue  # No improvement, discard expansion\n                # Else better path found, will update cost and parents below\n            else:\n                q_new_vertex = Vertex(q_new_pos)\n                vertex_map[key_pos] = q_new_vertex\n\n            # Rewiring neighborhood: dynamic radius scaled by graph size and clearance\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            base_radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n            clearance_new = self._get_clearance(q_new_pos)\n            clearance_multiplier = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius = base_radius * clearance_multiplier\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Compute best parent from neighborhood considering cost and line validity\n            q_best_parent = current_vertex\n            c_best = cost_to_come\n            for near_v in near_vertices:\n                dist_parent_candidate = torch.norm(near_v.position.to_tensor().float() - q_new_pos.to_tensor().float()).item()\n                candidate_cost = near_v.cost + dist_parent_candidate\n                if candidate_cost + self._prune_epsilon < c_best:\n                    candidate_line_seq = grid.get_line_sequence(near_v.position, q_new_pos)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_best_parent = near_v\n                        c_best = candidate_cost\n\n            # Update q_new_vertex with best parent and cost if better\n            if q_new_vertex.parents:\n                # Remove old parents to maintain tree property\n                for p in list(q_new_vertex.parents):\n                    self._graph.remove_edge(p, q_new_vertex)\n            q_new_vertex.cost = c_best\n            self._graph.add_edge(q_best_parent, q_new_vertex)\n\n            # Rewire neighbors if q_new_vertex offers better path\n            for near_v in near_vertices:\n                if near_v == q_best_parent or near_v == q_new_vertex:\n                    continue\n                dist_new_near = torch.norm(q_new_pos.to_tensor().float() - near_v.position.to_tensor().float()).item()\n                cost_through_new = q_new_vertex.cost + dist_new_near\n                if cost_through_new + self._prune_epsilon < near_v.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new_pos, near_v.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        for old_p in list(near_v.parents):\n                            self._graph.remove_edge(old_p, near_v)\n                            break\n                        near_v.cost = cost_through_new\n                        self._graph.add_edge(q_new_vertex, near_v)\n\n            # Push q_new_vertex into open set prioritized by cost + heuristic\n            total_estimated_cost = q_new_vertex.cost + self._heuristic_cost(q_new_vertex.position, goal_pos)\n            heapq.heappush(open_set, (total_estimated_cost, q_new_vertex))\n\n            # Direct goal connection attempt if close enough\n            dist_to_goal = self._heuristic_cost(q_new_vertex.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_to_goal = grid.get_line_sequence(q_new_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new_vertex.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal_vertex = goal_vertex\n\n                    # Early termination on direct valid goal connection\n                    break\n\n            # Periodically interleave shortcut smoothing on partial solutions\n            if iteration % 60 == 0 and found_goal_vertex is not None:\n                self._extract_path_and_interleaved_smooth(found_goal_vertex)\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_path_and_interleaved_smooth(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with goal bias, rewiring, adaptive max_dist,\n    and early stopping based on time limit. The algorithm samples points with a goal bias to\n    improve convergence speed, rewires nearby vertices to optimize path cost (similar to RRT*),\n    applies adaptive step size for smoother expansions, and checks for direct\n    connection to goal to reduce unnecessary expansion. It also includes a shortcut smoothing\n    step after path extraction to improve path quality. The search is aborted if it exceeds\n    10 seconds, increasing robustness and interactivity.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # Enable rewiring (edges removable)\n        self._init_displays()\n\n        # Parameters for the improved RRT*\n        self._goal_bias = 0.1  # 10% chance sample is goal (goal bias)\n        self._max_dist_min = 3.0  # minimum step size\n        self._max_dist_max = 12.0  # maximum step size\n        self._rewire_radius = 15.0  # Radius for rewiring nearby vertices\n        self._time_limit_secs = 10  # max search time in seconds\n\n    def _get_adaptive_max_dist(self, q_near: Vertex) -> float:\n        # Adaptive max step size based on distance to goal:\n        dist_to_goal = Map.get_distance(q_near.position, self._get_grid().goal.position)\n        # Larger step size far from goal, smaller near goal\n        dist_to_goal = max(dist_to_goal, 1.0)\n        max_dist = min(max(self._max_dist_min, dist_to_goal / 4), self._max_dist_max)\n        return max_dist\n\n    def _get_random_sample(self) -> Point:\n        # Incorporate goal bias: with probability goal_bias, sample the goal position directly\n        if np.random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        # Else sample random valid point, retry until valid\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _rewire(self, q_new: Vertex) -> None:\n        # Rewire nearby vertices for path cost improvement (RRT* style)\n        near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(\n            [self._graph.root_vertex_start], q_new.position, self._rewire_radius\n        )\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            cost_through_q_new = q_new.cost + self._get_grid().get_movement_cost(q_new.position, q_near.position)\n            if cost_through_q_new < q_near.cost:\n                # Remove old parents and add q_new as new parent\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_q_new\n\n    def _compute_cost(self, parent: Vertex, child: Vertex) -> float:\n        # Helper to compute cost for an edge\n        return parent.cost + self._get_grid().get_movement_cost(parent.position, child.position)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Find path from start to goal by following parents, then smooth path by shortcutting\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            # Select parent with minimal cost\n            parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(parent)\n\n        path.reverse()\n        # Shortcut smoothing: Try to connect non-adjacent points directly if possible to shorten path\n        def shortcut_path(path: List[Vertex]) -> List[Vertex]:\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        smoothed_path = shortcut_path(path)\n\n        # Animate the smoothed path\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        iteration_limit: int = 10000\n        start_time: float = time()\n\n        for iteration in range(iteration_limit):\n\n            # Time-based early stopping\n            if time() - start_time > self._time_limit_secs:\n                # Not found path in time limit\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue  # Skip if same point\n\n            max_dist = self._get_adaptive_max_dist(q_near)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Avoid duplicate vertex insertion and check validity of path segment\n            if (\n                not self._get_grid().is_agent_valid_pos(q_new.position)\n                or not self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n            ):\n                continue\n\n            # Find best parent among near vertices including q_near for lower cost path\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(\n                [start_vertex], q_new.position, self._rewire_radius\n            )\n            if len(near_vertices) == 0:\n                near_vertices = [q_near]\n\n            best_parent: Optional[Vertex] = None\n            best_cost: float = float('inf')\n            for q_near_candidate in near_vertices:\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                cost_candidate = q_near_candidate.cost + self._get_grid().get_movement_cost(\n                    q_near_candidate.position, q_new.position\n                )\n                if cost_candidate < best_cost:\n                    best_cost = cost_candidate\n                    best_parent = q_near_candidate\n\n            # If no valid parent found continue\n            if best_parent is None:\n                continue\n\n            q_new.cost = best_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire near vertices through q_new for cost improvement\n            self._rewire(q_new)\n\n            # Check if q_new can directly connect to goal with valid collision free line\n            goal_pos = self._get_grid().goal.position\n            line_seq_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_pos)\n            if self._get_grid().is_valid_line_sequence(line_seq_to_goal):\n                # Create goal vertex and connect to q_new\n                q_goal: Vertex = Vertex(goal_pos)\n                q_goal.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                self._graph.add_edge(q_new, q_goal)\n\n                # Extract and smooth path\n                self._extract_path(q_goal)\n                return  # Found path, end algorithm\n\n            self.key_frame()  # Visualize incremental progress",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Adaptive Heuristic-Guided RRT* with Goal Biasing and Dynamic Step Size\n\n    This algorithm enhances the previous RRT* inspired planner by:\n    - Adaptive max_dist scaling based on environment size and current progress for efficient exploration.\n    - Heuristic-guided sampling bias that combines goal bias and sampling towards promising regions near existing low-cost vertices.\n    - A* style cost-to-go heuristic used in choosing parents and during rewiring to better guide expansion.\n    - Early stopping with path extraction upon reaching the goal region.\n    - More aggressive rewiring within a variable radius based on vertex density and environment scale.\n    - Shortcut smoothing of extracted path for improved path quality.\n    - Enforced 10 second planning time limit with graceful fallback on failure.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._goal_sample_rate = 0.2           # Increased goal bias for quicker convergence.\n        self._rewire_base_radius = 20          # Base rewiring radius, adaptive per iteration.\n        self._max_dist_base = 15                # Base max extension distance.\n        self._max_iterations = 6000             # Fewer max iterations due to efficiency improvements.\n        self._time_limit_sec = 10.0             # Fixed time limit for path search.\n        self._heuristic_weight = 1.5             # Weight for heuristic (cost-to-go) in parent selection.\n        self._exploration_sample_rate = 0.3     # Probability to sample near known low-cost vertices.\n\n    def _heuristic(self, point: Point) -> float:\n        \"\"\"Heuristic estimate (Euclidean distance) of cost to goal.\"\"\"\n        grid = self._get_grid()\n        return grid.get_distance(point, grid.goal.position)\n\n    def _adaptive_max_dist(self, iteration: int) -> float:\n        \"\"\"Adapt max_dist based on iteration progress and environment scale.\"\"\"\n        grid_size = max(self._get_grid().size)\n        progress = iteration / self._max_iterations\n        # Start with larger steps for exploration, reduce step size near end for refinement\n        return max(5.0, self._max_dist_base * (1.0 - 0.8 * progress)) * (grid_size / 100)\n\n    def _adaptive_rewire_radius(self) -> float:\n        \"\"\"Adapt rewiring radius based on environment scale and graph size.\"\"\"\n        grid_size = max(self._get_grid().size)\n        vertices_count = max(1, self._graph.size)\n        radius = min(self._rewire_base_radius, (grid_size / 10.0) * (1 + 10.0 / vertices_count))\n        return radius\n\n    def _sample_near_vertices(self) -> Point:\n        \"\"\"Sample near existing low-cost vertices to intensify promising areas.\"\"\"\n        import random\n        verts = []\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n\n        # Collect low cost vertices (cost < 2 * heuristic to goal)\n        for v in self._graph.root_vertices:\n            if v.cost < float('inf') and v.cost < 2.0 * self._heuristic(v.position):\n                verts.append(v)\n        if not verts:\n            # fallback sampling if no low cost vertices found\n            return self._get_random_sample()\n\n        # Select randomly a low-cost vertex and sample near it within a radius proportional to max_dist\n        base_vertex = random.choice(verts)\n        radius = self._adaptive_max_dist(0) * 2.0\n        tries = 0\n        while tries < 10:\n            offset = np.random.uniform(-radius, radius, size=base_vertex.position.to_tensor().shape)\n            sample_point = Point.from_tensor(base_vertex.position.to_tensor() + offset)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n            tries += 1\n\n        # Fallback to random sample if no valid near vertex sample found\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Heuristic-guided and goal-biased sampling.\"\"\"\n        import random\n        p = random.random()\n        if p < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        elif p < (self._goal_sample_rate + self._exploration_sample_rate):\n            return self._sample_near_vertices()\n        else:\n            # Uniform random valid sampling\n            grid = self._get_grid()\n            while True:\n                rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                sample = Point(*rand_pos)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n    def _choose_parent(self, neighbors: list, q_new: Vertex) -> Vertex:\n        \"\"\"Choose parent with minimum total estimated cost: cost-to-come + edge + heuristic-to-goal.\"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        for q_near in neighbors:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            heuristic_to_goal = self._heuristic(q_new.position)\n            total_cost = cost_to_new + self._heuristic_weight * heuristic_to_goal\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = q_near\n\n        if best_parent is not None:\n            best_parent_cost_to_new = best_parent.cost + grid.get_distance(best_parent.position, q_new.position)\n            q_new.cost = best_parent_cost_to_new\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"Attempt to re-parent neighbors to q_new if it improves cost-to-come + heuristic.\"\"\"\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            # Consider heuristic to goal to avoid rewiring to worse node\n            old_total_cost = q_neighbor.cost + self._heuristic_weight * self._heuristic(q_neighbor.position)\n            new_total_cost = new_cost + self._heuristic_weight * self._heuristic(q_neighbor.position)\n\n            if new_total_cost + 1e-6 < old_total_cost:\n                # Remove old parent edges\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            # Early exit on time limit\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit_sec:\n                break\n\n            max_dist = self._adaptive_max_dist(iteration)\n            rewire_radius = self._adaptive_rewire_radius()\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to new vertex if beneficial\n            self._rewire(q_new, neighbors)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Try connection to goal vertex\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Anytime Heuristic-guided Adaptive Sampling with Priority Rewiring and Dynamic \n    Goal Biasing Path Planning Algorithm.\n    \n    This algorithm improves upon IHAST by introducing:\n    - Dynamic adjustment of goal sampling rate based on current best cost to speed convergence.\n    - Priority queue-based frontier expansion inspired by A*, utilizing cost + heuristic.\n    - Adaptive step size with more fine-grained clearance-based tuning.\n    - Local rewiring prioritized by cost improvement magnitude.\n    - Early stopping as soon as a feasible path is found within acceptable tolerance.\n    - More aggressive shortcutting by iterative smoothing until no improvements.\n    - Maintains robustness by fallback uniform heuristic sampling if goal biasing fails.\n    \n    These changes aim to reduce required iterations, improve path quality with smoother routes,\n    enhance success rate in cluttered environments, and maintain runtime within 10 seconds.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._initial_goal_sample_rate = 0.3  # initial percent chance to sample from goal directly\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n        self._tolerance_cost_improve = 1e-3\n\n    def _heuristic(self, from_pt: Point, to_pt: Point) -> float:\n        \"\"\"Standard heuristic cost estimate between two points.\"\"\"\n        return Map.get_distance(from_pt, to_pt)\n\n    def _dynamic_goal_sample_rate(self, best_cost: float) -> float:\n        \"\"\"Adjust goal sampling probability dynamically based on best path cost.\"\"\"\n        # Increase goal bias if path cost is found and low, else fallback\n        if best_cost == float('inf'):\n            return self._initial_goal_sample_rate\n        # If best cost is large, reduce goal bias (explore more)\n        # If best cost converges to a low value, increase goal bias (exploit)\n        max_dist = Map.get_distance(Point(0, 0), Point(*self._get_grid().size))\n        normalized = min(max(best_cost / max_dist, 0), 1)\n        return max(0.1, min(0.6, 0.6 - normalized * 0.5))\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        More fine-grained adaptive step size that assesses clearance \n        along multiple fractions between min_step and max_step for smooth scaling.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        steps = np.linspace(min_step, max_step, 10)\n        clearance = max_step\n        for radius in steps:\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n\n            if not grid.is_agent_valid_pos(sample_point):\n                clearance = radius * 0.4\n                break\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                clearance = radius * 0.4\n                break\n\n        return clearance\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Generate a new Vertex stepping towards q_sample from q_near with adaptive step-size.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = min(step_size, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose lowest cost parent vertex for q_new from q_near_list with a valid collision-free connection.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Priority rewiring: attempt local rewiring by connecting neighbors \n        through q_new only if large cost improvement (> tolerance) is possible.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor in q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n            if potential_cost + self._tolerance_cost_improve < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _shortcut_path_iterative(self, path: list) -> list:\n        \"\"\"\n        Iteratively try to shortcut path until no improvements.\n        Applies shortcutting smoothing repeatedly for enhanced smoothness.\n        \"\"\"\n        grid = self._get_grid()\n\n        def can_connect(a: Vertex, b: Vertex) -> bool:\n            line_seq = grid.get_line_sequence(a.position, b.position)\n            return grid.is_valid_line_sequence(line_seq)\n\n        improved = True\n        shortcut_path = path\n        while improved and len(shortcut_path) > 2:\n            improved = False\n            new_path = [shortcut_path[0]]\n            idx = 0\n            while idx < len(shortcut_path) - 1:\n                last_added = new_path[-1]\n                max_reach = idx + 1\n                for test_idx in range(len(shortcut_path) - 1, idx, -1):\n                    if can_connect(last_added, shortcut_path[test_idx]):\n                        max_reach = test_idx\n                        break\n                if max_reach > idx + 1:\n                    improved = True\n                new_path.append(shortcut_path[max_reach])\n                idx = max_reach\n            shortcut_path = new_path\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Build path from q_new up to start vertex, add goal connection, smooth path iteratively,\n        then move the agent along the smoothed path.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        smooth_path = self._shortcut_path_iterative(path)\n\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        # Frontier queue for A* inspired expansion: (priority = cost + heuristic, vertex)\n        frontier = []\n        start_vertex = self._graph.root_vertex_start\n        start_priority = self._heuristic(start_vertex.position, goal_pos)\n        heapq.heappush(frontier, (start_priority, start_vertex))\n\n        best_cost = float('inf')\n        best_vertex = None\n\n        iteration = 0\n        while iteration < self._max_iterations:\n            iteration += 1\n\n            # Timeout check\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                break\n\n            # Update dynamic goal bias rate\n            goal_bias = self._dynamic_goal_sample_rate(best_cost)\n\n            # Sampling\n            if np.random.rand() < goal_bias:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample()\n\n            # Nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            max_dist_len = torch.norm(max_dist_vec).item()\n            direction = Point.from_tensor(max_dist_vec)\n            max_dist = self._adaptive_step_size(q_near.position, direction)\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors for improvements\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Add q_new to frontier with priority = cost + heuristic\n            estimated_total_cost = q_new.cost + self._heuristic(q_new.position, goal_pos)\n            heapq.heappush(frontier, (estimated_total_cost, q_new))\n\n            # Check if q_new reaches goal radius and found better cost path\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < best_cost:\n                    best_cost = q_new.cost\n                    best_vertex = q_new\n\n                    # Early stopping once a feasible good cost path found\n                    # Stop if found near-optimal within tolerance or time exceeded\n                    if best_cost <= self._min_step * 2.0:\n                        break\n                    if time.time() - start_time > self._time_limit * 0.75:\n                        break\n\n            self.key_frame()\n\n        # On termination, if path found extract and move agent\n        if best_vertex is not None:\n            self._extract_path(best_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Anytime Heuristic-Enhanced Rewiring Tree (IAHERT)\n\n    This algorithm builds upon the original IHAST framework and enhances:\n    - Adaptive heuristic sampling with combined cost-to-come and cost-to-go using current tree cost estimates,\n      biasing sample distribution towards promising corridors dynamically.\n    - Hybrid goal biasing: combines direct goal samples with near-goal region sampling for better connectivity.\n    - Variable adaptive step size using clearance and local smoothness, with dynamic scaling based on proximity to goal.\n    - Enhanced neighbor selection using a dynamic radius that shrinks with improving best path cost to limit rewiring overhead.\n    - Early stopping once a specified path suboptimality threshold is met or time limit exceeded.\n    - Continuous incremental path smoothing via path shortcutting and partial path pruning, improving path quality during planning.\n    - Robust vertex cost updates with priority rewiring queue to ensure consistent cost propagation.\n\n    These improvements increase planning efficiency by reducing unnecessary exploration,\n    improving path smoothness and robustness, and enhancing success rate within a given time budget.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 6000  # fewer iterations, more focused sampling\n        self._goal_sample_rate = 0.3  # higher goal bias\n        self._near_goal_sample_rate = 0.1  # probability to sample near goal region (around goal)\n        self._search_radius_rewire_base = 18.0  # base radius for rewiring - adaptive dynamically\n        self._min_step = 3.0\n        self._max_step = 16.0\n        self._best_cost = float('inf')  # Track best known path cost for dynamic radius adjustment\n\n    def _heuristic_sample_dynamic(self) -> Point:\n        \"\"\"\n        Sample points with a heuristic that incorporates current tree costs\n        (cost-to-come + Euclidean cost-to-go) to guide sampling closer to promising states.\n        Uses rejection sampling with dynamic thresholds favoring lower-cost combined heuristic.\n        \"\"\"\n        grid = self._get_grid()\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_dist = Map.get_distance(Point(0, 0), Point(*size))\n        attempts = 0\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            dist_start_sample = Map.get_distance(start_pos, sample_pt)\n            dist_sample_goal = Map.get_distance(sample_pt, goal_pos)\n\n            # Estimate cost-to-come using nearest vertex in tree to sample\n            nearest_vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], sample_pt)\n            cost_to_come = nearest_vertex.cost + dist_start_sample\n            cost_to_go = dist_sample_goal\n\n            combined_heuristic = cost_to_come + cost_to_go\n\n            # Normalize heuristic to [0,1], relative to max_dist * 2 (worst case)\n            h_norm = combined_heuristic / (2 * max_dist)\n\n            # Accept sample probabilistically higher for lower heuristic values\n            if np.random.rand() < 1.0 - h_norm:\n                return sample_pt\n\n            if attempts > 700:\n                return sample_pt\n\n    def _adaptive_step_size_improved(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size that scales with clearance from obstacles in direction &\n        smoothness with previous directions. It dynamically shrinks as agent nears goal.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0.0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Base max step dynamically reduced near goal to encourage fine maneuvers\n        dist_to_goal = Map.get_distance(pos, grid.goal.position)\n        max_effective_step = max_step\n        if dist_to_goal < max_step * 5.0:\n            max_effective_step = max(min_step, max_step * (dist_to_goal / (max_step * 5.0)))\n\n        # Check clearance with sampled points to adapt step size\n        for radius in np.linspace(min_step, max_effective_step, num=7):\n            candidate_tensor = pos.to_tensor() + radius * unit_dir\n            candidate_point = Point.from_tensor(candidate_tensor)\n            if not grid.is_agent_valid_pos(candidate_point):\n                return max(min_step, radius * 0.5)\n\n            # Validate line sequence for collision-free path\n            line_seq = grid.get_line_sequence(pos, candidate_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return max(min_step, radius * 0.5)\n\n        return max_effective_step\n\n    def _choose_parent_dynamic_radius(self, q_near_list: list, q_new: Vertex, radius: float) -> Vertex or None:\n        \"\"\"\n        Choose the parent with the lowest cost connection having collision-free path.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        # Filter neighbors inside radius for efficiency\n        filtered_neighbors = [v for v in q_near_list if Map.get_distance(v.position, q_new.position) <= radius]\n\n        for neighbor in filtered_neighbors:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            if cost_to_new >= min_cost:\n                continue\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if grid.is_valid_line_sequence(line_seq):\n                min_cost = cost_to_new\n                chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire_priority_queue(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Improved rewiring that uses a priority queue to propagate cost changes efficiently.\n        \"\"\"\n        grid = self._get_grid()\n        import heapq\n\n        open_set = []\n        visited = set()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            heapq.heappush(open_set, (neighbor.cost, neighbor))\n\n        while open_set:\n            current_cost, vertex = heapq.heappop(open_set)\n            if vertex in visited:\n                continue\n            visited.add(vertex)\n            current_cost = vertex.cost\n\n            # Attempt to improve cost via q_new if possible\n            new_cost = q_new.cost + grid.get_movement_cost(q_new.position, vertex.position)\n            if new_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, vertex.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old parent edges\n                    for parent in list(vertex.parents):\n                        self._graph.remove_edge(parent, vertex)\n                    # Add edge from q_new\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = new_cost\n                    # Add children to open_set to propagate cost changes\n                    for child in vertex.children:\n                        if child not in visited:\n                            heapq.heappush(open_set, (child.cost, child))\n\n    def _extract_and_smooth_path_incremental(self, q_new: Vertex) -> None:\n        \"\"\"\n        Builds path from q_new to start, shortcut smooth it,\n        then move agent incrementally with short key frame steps for smoother animation.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        # Extract path up to start\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        # Shortcut smoothing\n        smooth_path = self._shortcut_path(path)\n\n        # Incremental move agent, yield key frames frequently for animation\n        for idx, vertex in enumerate(smooth_path):\n            self.move_agent(vertex.position)\n            # Key frame each step, but allow occasional skipping for speed up after first 3 steps\n            if idx < 3 or (idx % 2 == 0):\n                self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        # Initialize root vertices\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n        self._best_cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._time_limit:\n                # Timeout - planning failed\n                break\n\n            # Goal biasing: with prob sample goal directly, else near goal area, else heuristic dynamic sampling\n            prob = np.random.rand()\n            if prob < self._goal_sample_rate:\n                q_sample = goal_pos\n            elif prob < self._goal_sample_rate + self._near_goal_sample_rate:\n                # Sample near goal within radius (circle grid sampling)\n                attempt_limit = 50\n                goal_sample_rad = 6\n                for _ in range(attempt_limit):\n                    offset = np.random.randint(-goal_sample_rad, goal_sample_rad + 1, size=grid.size.n_dim)\n                    sample_coords = [goal_pos[i] + offset[i] for i in range(grid.size.n_dim)]\n                    sample_pt = Point(*sample_coords)\n                    if grid.is_agent_valid_pos(sample_pt):\n                        q_sample = sample_pt\n                        break\n                else:\n                    q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample_dynamic()\n\n            # Find nearest vertex from start tree\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dir_tensor = q_sample.to_tensor() - q_near.position.to_tensor()\n            max_dist = self._adaptive_step_size_improved(q_near.position, Point.from_tensor(dir_tensor))\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Dynamic rewiring radius shrinks as best cost improves to prune local neighbors\n            dynamic_radius = self._search_radius_rewire_base\n            if self._best_cost < float('inf'):\n                dynamic_radius = max(6.0, min(dynamic_radius, self._best_cost * 0.2))\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, dynamic_radius)\n\n            chosen_parent = self._choose_parent_dynamic_radius(neighbors, q_new, dynamic_radius)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge & update cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors excluding chosen parent\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire_priority_queue(q_new, neighbors)\n\n            # Update best known path if q_new is closer to goal\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                path_cost_estimate = q_new.cost + dist_to_goal\n                if path_cost_estimate < self._best_cost:\n                    self._best_cost = path_cost_estimate\n                    # Extract and smooth path immediately upon goal reach\n                    self._extract_and_smooth_path_incremental(q_new)\n                    break  # Early stop on good enough path\n\n            # Early stopping if best cost is close enough to direct heuristic lower bound\n            direct_dist = Map.get_distance(agent_pos, goal_pos)\n            if self._best_cost < direct_dist * 1.05:  # 5% suboptimality tolerance\n                self._extract_and_smooth_path_incremental(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT, incorporating several enhancements to improve path quality,\n    success rate, and planning efficiency:\n    - Goal-biased sampling with a fixed probability to help the tree grow towards the goal more often.\n    - Adaptive step size (max_dist) that shrinks when close to obstacles or to goal to produce smoother paths.\n    - Rewiring step inspired by RRT* to optimize paths by reconnecting newly added vertices to nearby vertices with lower cost.\n    - Early stopping based on timeout (10 seconds) to prevent long-running searches.\n    - Shortcut smoothing after path extraction to refine the final path, removing unnecessary detours.\n    This combination improves robustness, reduces iteration counts, produces shorter and smoother paths,\n    and enhances success rate in complex environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable edges removable for rewiring\n        self._goal_sample_rate = 0.15  # probability of sampling the goal to bias tree\n        self._max_dist_full = 10.0  # max step length when far from obstacles/goal\n        self._rewire_radius = 15.0  # radius for rewiring neighborhood\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Try to rewire vertices in neighbors to improve path costs if better path found via q_new\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Remove old parent edge (only one parent expected in tree)\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                # Add new edge from q_new to q_near (rewiring)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n                # Update costs downstream via DFS\n                def dfs_update_cost(v: Vertex):\n                    for child in v.children:\n                        cost_thru_v = v.cost + self._get_grid().get_distance(v.position, child.position)\n                        if cost_thru_v < child.cost:\n                            child.cost = cost_thru_v\n                            dfs_update_cost(child)\n                dfs_update_cost(q_near)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Attempt to shorten path by skipping intermediate vertices when direct path is valid\n        if len(path) < 3:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = self._get_grid().get_line_sequence(path[i].position, path[j].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortened_path.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            else:\n                shortened_path.append(path[i + 1])\n                i += 1\n        return shortened_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        # Connect q_new to goal_v with edge if valid\n        line_seq = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(q_new, goal_v)\n            goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_v.position)\n        else:\n            goal_v.cost = float('inf')\n        path: List[Vertex] = [goal_v]\n\n        # Backtrack from goal to start\n        while len(path[-1].parents) != 0:\n            best_parent = None\n            min_cost = float('inf')\n            for parent in path[-1].parents:\n                if parent.cost < min_cost:\n                    min_cost = parent.cost\n                    best_parent = parent\n            if best_parent is None:\n                break\n            path.append(best_parent)\n\n        if path[-1].position != self._get_grid().agent.position:\n            # If path doesn't reach start, cannot extract path\n            return\n\n        path.reverse()\n\n        # Shortcut/smooth path for better quality\n        path = self._shortcut_path(path)\n\n        # Animate path traversal\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist = self._max_dist_full\n        iterations = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iterations):\n            # Check timeout (10 seconds)\n            if time.time() - start_time > 10:\n                # Treat route search as not found, break loop\n                break\n\n            # Adaptive max_dist: shrink if close to goal or obstacles for smoother expansion\n            if self._get_grid().get_distance(start_vertex.position, self._get_grid().goal.position) < 30:\n                max_dist = 6.0\n            else:\n                max_dist = self._max_dist_full\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            new_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = new_cost\n\n            # Find neighbors within rewire radius for RRT* style optimization\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, q_new.position, self._rewire_radius)\n            # Choose parent from neighbors with minimal cost + distance, if valid path exists\n            min_cost = new_cost\n            best_parent = q_near\n            for q_near_candidate in neighbors:\n                line_seq_candidate = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_candidate):\n                    continue\n                cost_candidate = q_near_candidate.cost + self._get_grid().get_distance(q_near_candidate.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = q_near_candidate\n            q_new.cost = min_cost\n\n            # Add vertex and edge from best parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(q_new, neighbors)\n\n            # Check if goal reached within radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Hybrid Heuristic Informed RRT* Algorithm with Adaptive Sampling and Enhanced Rewiring\n    \n    This algorithm improves upon the baseline by combining several enhancements:\n    - Enhanced goal biasing with adaptive goal region sampling to increase success rate.\n    - Dual heuristic-driven priority queue expansion integrates both cost-so-far and heuristic to prioritize promising nodes.\n    - Dynamic adaptive step size that incorporates clearance, distance to goal, and recent improvement trends to fine-tune exploration granularity.\n    - More aggressive yet selective rewiring with a dynamic radius that adapts based on local density and clearance for better optimization.\n    - Lazy collision checking maintained to reduce overhead but enhanced with predictive pruning for invalid expansions.\n    - Early stopping once an improved path is found, combined with path shortcutting with multiple smoothing passes.\n    - Timeout enforcement at 10 seconds for practical responsiveness.\n    - Additional tracking of iterations without improvement triggers sampling from best-known paths to promote exploitation.\n    - Improved robustness with fallback uniform clearance-aware sampling to avoid local minima.\n    \n    These combined strategies boost planning efficiency with fewer but more meaningful expansions,\n    improve path quality by sharper rewiring and smoothing, enhance robustness with smarter exploration-exploitation balance,\n    and increase success rate by better goal-directed expansions.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n        self._start_time = time.time()\n\n        # Priority queue with (estimated_total_cost, unique_id, vertex)\n        open_queue = []\n        unique_counter = 0  # To break ties in heapq\n        est_start = self._heuristic(start_vertex.position)\n        heapq.heappush(open_queue, (est_start, unique_counter, start_vertex))\n        unique_counter += 1\n\n        vertex_map = {start_vertex.position: start_vertex}\n\n        iterations = 0\n        no_improve_iters = 0  # Track iterations without improvement\n        max_no_improve = 100\n        last_best_cost = self._best_cost\n\n        def _line_valid(frm: Point, to: Point) -> bool:\n            seq = grid.get_line_sequence(frm, to)\n            return grid.is_valid_line_sequence(seq)\n\n        def _sample_goal_region_around(point: Point, radius: int = 3, attempts: int = 30) -> Point:\n            # Sample near the goal position within a small radius for stronger goal bias\n            for _ in range(attempts):\n                offset_x = torch.randint(-radius, radius + 1, (1,)).item()\n                offset_y = torch.randint(-radius, radius + 1, (1,)).item()\n                candidate = Point(point.x + offset_x, point.y + offset_y)\n                if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                    return candidate\n            return point\n\n        def _adaptive_step(pos: Point, last_cost: float) -> float:\n            # More responsive adaptive step size incorporating recent cost trend and clearance\n            base_step = self._adaptive_step_size(pos)\n            if last_cost < float('inf'):\n                factor = max(0.5, min(1.5, last_cost / (self._best_cost + 1e-7)))\n                step_size = base_step * factor\n            else:\n                step_size = base_step\n            return max(self._min_step, min(step_size, self._max_step))\n\n        def _get_random_sample_adaptive() -> Point:\n            # If no improvement for many iterations, sample near best known path or goal to encourage progress\n            if no_improve_iters > max_no_improve and found_goal_vertex is not None:\n                # Backtrack path and sample near it\n                path = []\n                curr = found_goal_vertex\n                while curr is not None:\n                    path.append(curr.position)\n                    parents = list(curr.parents)\n                    if parents:\n                        curr = min(parents, key=lambda p: p.cost)\n                    else:\n                        break\n                if path:\n                    sample_point = path[torch.randint(0, len(path), (1,)).item()]\n                    goal_region_sample = _sample_goal_region_around(sample_point, radius=4, attempts=40)\n                    return goal_region_sample\n            # Otherwise use baseline sampling with slightly improved goal bias region sampling\n            prob = torch.rand(1).item()\n            if prob < max(0.3, self._goal_sample_rate):  # Slight increase goal sample rate\n                return _sample_goal_region_around(goal_pos, radius=3, attempts=40)\n            else:\n                return self._clearance_aware_sample()\n\n        while iterations < self._max_iterations:\n            if time.time() - self._start_time > self._time_limit_seconds:\n                # Timeout reached\n                break\n\n            if not open_queue:\n                # No vertices to expand, terminate\n                break\n\n            est_total_cost, _, current_v = heapq.heappop(open_queue)\n            iterations += 1\n\n            # Sample new point adaptively\n            q_sample = _get_random_sample_adaptive()\n            max_step = _adaptive_step(current_v.position, self._best_cost)\n\n            dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_norm = dir_vec / dist\n            step_length = min(dist, max_step)\n            new_pos_tensor = torch.round(torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == current_v.position:\n                continue\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            if q_new_pos in vertex_map:\n                # Already in graph, skip to avoid duplicates\n                continue\n\n            # Lazy collision check: only check if promising by heuristic prepruning\n            predicted_cost = current_v.cost + grid.get_movement_cost(current_v.position, q_new_pos) + self._heuristic(q_new_pos)\n            if predicted_cost > self._best_cost + 0.1:  # Small margin to prune\n                continue\n\n            if not _line_valid(current_v.position, q_new_pos):\n                continue\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n            q_new_vertex.cost = current_v.cost + move_cost\n\n            # Dynamic neighborhood radius increased for better rewiring\n            size = max(self._graph.size, 1)\n            from math import log, pow\n            ln_size = log(float(size)) if size > 1 else 0.0\n            radius_base = self._rewire_lambda * pow((ln_size / size), 1 / self._dimension) if size > 1 else self._rewire_lambda\n            clearance_factor = 1.0 + min(self._get_clearance(q_new_pos) / (self._clearance_threshold * 2.5), 1.0)\n            dynamic_radius = min(radius_base * clearance_factor * 1.2, 25.0)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, dynamic_radius)\n\n            # Choose best parent with minimal cost and valid edge\n            best_parent = current_v\n            best_cost = q_new_vertex.cost\n\n            for neighbor in near_vertices:\n                candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                if candidate_cost + 1e-6 < best_cost:  # strict improvement required\n                    if _line_valid(neighbor.position, q_new_pos):\n                        best_cost = candidate_cost\n                        best_parent = neighbor\n\n            q_new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, q_new_vertex)\n            vertex_map[q_new_pos] = q_new_vertex\n\n            # Rewiring neighbors if cost improvement significant and edge valid\n            cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost < float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                new_cost = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                if new_cost + cost_improve_thresh < neighbor.cost:\n                    if _line_valid(q_new_vertex.position, neighbor.position):\n                        # Remove all existing parents to allow single better parent\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            est_cost_total = q_new_vertex.cost + self._heuristic(q_new_vertex.position)\n            heapq.heappush(open_queue, (est_cost_total, unique_counter, q_new_vertex))\n            unique_counter += 1\n\n            # Check goal proximity with tighter radius for early stopping\n            dist_to_goal = Map.get_distance(q_new_vertex.position, goal_pos)\n            adaptive_goal_radius = max(1.2, max_step * 0.9)\n            if dist_to_goal <= adaptive_goal_radius:\n                if _line_valid(q_new_vertex.position, goal_pos):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new_vertex.cost + dist_to_goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        found_goal_vertex = goal_vertex\n                        no_improve_iters = 0\n                        # Early termination on improved path\n                        break\n\n            # Periodic key frame call for visualization/debugging\n            if iterations % 50 == 0:\n                self.key_frame()\n\n            # Track improvement for adaptive sampling\n            if self._best_cost < last_best_cost - 1e-5:\n                last_best_cost = self._best_cost\n                no_improve_iters = 0\n            else:\n                no_improve_iters += 1\n\n        if found_goal_vertex is not None:\n            # Extract path by backtracking parents with lowest cost\n            path = []\n            curr = found_goal_vertex\n            while True:\n                path.append(curr)\n                if not curr.parents:\n                    break\n                curr = min(curr.parents, key=lambda p: p.cost)\n            path.reverse()\n\n            # Multiple passes of shortcut smoothing for higher quality path\n            for _ in range(5):\n                i = 0\n                while i < len(path) - 2:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(path[i].position, path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            del path[i+1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n            for vertex in path:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT*-inspired path planning algorithm with heuristic-guided adaptive sampling,\n    dynamic step sizing based on local obstacle density, goal biasing, rewiring for path quality,\n    and early stopping by goal reach or 10-second timeout. Utilizes A*-like cost-to-go heuristic in\n    parent selection and rewiring to improve path optimality and increase success rate.\n    Path smoothing by shortcutting is performed before extracting the final path.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias=0.15, heuristic_weight=0.3) -> Point:\n        \"\"\"\n        Hybrid sampling:\n        - With probability goal_bias, sample goal directly.\n        - Else with probability heuristic_weight, sample near the line from start to goal with random offset.\n        - Otherwise uniform random.\n        Only returns valid agent positions.\n        \"\"\"\n        grid = self._get_grid()\n        if np.random.random() < goal_bias:\n            return grid.goal.position\n\n        if np.random.random() < heuristic_weight:\n            start_pos = grid.agent.position\n            goal_pos = grid.goal.position\n            dim = grid.size.n_dim\n            # Sample a point along the straight path plus gaussian offset perpendicular\n            alpha = np.random.random()\n            base_point = Point.from_tensor(start_pos.to_tensor() * (1 - alpha) + goal_pos.to_tensor() * alpha)\n            # Generate perpendicular offset in n-dim grid\n            offset = np.random.normal(scale=3.0, size=dim)\n            offset_tensor = torch.tensor(offset, dtype=torch.float32)\n            # Project offset to be perpendicular to goal-start vector to keep samples near line\n            dir_vec = (goal_pos.to_tensor() - start_pos.to_tensor()).float()\n            if torch.norm(dir_vec) > 1e-6:\n                dir_vec_norm = dir_vec / torch.norm(dir_vec)\n                offset_tensor = offset_tensor - torch.dot(offset_tensor, dir_vec_norm) * dir_vec_norm\n            sample_pos_tensor = base_point.to_tensor() + offset_tensor\n            sample_pos_int = torch.round(sample_pos_tensor).to(torch.int)\n            sample_point = Point(*sample_pos_int.tolist())\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Uniform random fallback\n        attempts = 0\n        while attempts < 50:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # If failed fallback to goal forcibly (rare)\n        return grid.goal.position\n\n    def _estimate_cost_to_goal(self, pos: Point) -> float:\n        # Heuristic: Euclidean distance to goal with small inflation to prefer faster expansions\n        goal_pos = self._get_grid().goal.position\n        dist = self._get_grid().get_distance(pos, goal_pos)\n        # Multiplying by factor <1 to maintain admissibility but encourage greedier towards goal\n        return dist * 0.9\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 12.0\n        max_dist_min = 4.0\n        max_dist_max = 20.0\n        iteration_limit = 8000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        # Improved: Cache goal pos once\n        goal_pos = self._get_grid().goal.position\n        grid = self._get_grid()\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive step size; small steps in cluttered area, larger otherwise\n            # Estimate local obstacle density around start vertex (approximate) to adjust max_dist\n            # Using inverse of nearby free space ratio as factor\n            nearby_radius_obs = 8.0\n            neighbors_obstacles = 0\n            neighbors_total = 0\n            agent_pos = self._graph.root_vertex_start.position\n            nearby_points = grid.get_vertices_within_radius([start_vertex], agent_pos, nearby_radius_obs)\n            neighbors_total = len(nearby_points) if len(nearby_points) > 0 else 1\n            # We approximate obstacle count by total - free neighbors around start vertex in grid calls (more robust)\n            next_positions = grid.get_next_positions(agent_pos)\n            obstacles_count = max(0, nearby_radius_obs * nearby_radius_obs - len(next_positions))  # rough estimation\n\n            obstacle_density = obstacles_count / nearby_radius_obs if nearby_radius_obs > 0 else 0.1\n            obstacle_density = min(max(obstacle_density, 0.05), 1.0)  # Clamp between 0.05 and 1.0\n\n            max_dist = max_dist_max * (1.0 - 0.8 * obstacle_density)  # smaller steps in denser areas\n            max_dist = max(min(max_dist, max_dist_max), max_dist_min)\n\n            # Sample point with goal bias and heuristic guided sampling\n            q_sample = self._get_random_sample(goal_bias=0.25, heuristic_weight=0.4)\n\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                # Already have vertex there\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new\n            line_sequence = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_sequence):\n                continue\n\n            # Radius for neighbors depends on size and iteration (shrinks over time)\n            radius = max(10.0, max_dist * 2.2 * (1 - i / iteration_limit))\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent with combined cost (cost + heuristic cost to goal)\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Validate connection between neighbor and q_new\n                line_seq_nw = grid.get_line_sequence(neighbor.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + grid.get_distance(neighbor.position, q_new.position)\n                est_cost_to_goal = self._estimate_cost_to_goal(q_new.position)\n                combined_cost = cost_through_n + est_cost_to_goal\n                if combined_cost < min_cost:\n                    min_cost = combined_cost\n                    parent_for_new = neighbor\n\n            # Fallback to q_near if no better parent found\n            if parent_for_new is None:\n                line_seq_qn = grid.get_line_sequence(q_near.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_qn):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + grid.get_distance(q_near.position, q_new.position) + self._estimate_cost_to_goal(q_new.position)\n\n            # Set actual cost: parent's cost + movement cost (no heuristic here)\n            q_new.cost = parent_for_new.cost + grid.get_distance(parent_for_new.position, q_new.position)\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors if going through q_new improves cost (standard RRT*)\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = grid.get_line_sequence(q_new.position, neighbor.position)\n                if not grid.is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + grid.get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Remove old parents edges\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Goal check within improved radius with early stopping\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position, goal=grid.goal):\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved PathPlanning Algorithm combining adaptive goal-biased and informed sampling,\n    heuristic-guided dynamic expansion, and efficient rewiring with early pruning.\n\n    Key improvements:\n    - Adaptive max step size scaled dynamically based on distance to goal and tree size,\n      enabling coarser exploration far and finer near goal.\n    - Mixed sampling distribution with dynamic probabilities favoring goal bias and informed\n      ellipsoidal sampling using the current best cost to guide exploration.\n    - Heuristic cost using traveled cost plus admissible Euclidean distance-to-go to prioritize vertices.\n    - Dynamic rewiring radius adapting to the number of vertices and search iteration.\n    - Early prune rewiring that removes redundant edges to minimize clutter and speed convergence.\n    - Robust path shortcutting with multiple smoothing passes.\n    - Early termination upon successful direct connection to goal with smooth path retrieval.\n    - Enforced 10-second time limit to guarantee timely termination with failure if no route found.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        # Existing initialization preserved\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.3      # Slightly increased goal bias rate \n        self._informed_sample_rate = 0.4  # Increased informed sampling rate for better focus\n        self._max_iterations = 3000       # Reduced iterations due to improved efficiency\n        self._lambda_rrt_star = 50        # Increased rewiring radius factor for more aggressive rewiring\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Admissible Euclidean distance heuristic\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Adaptive max step size scaled dynamically based on remaining distance to goal and tree size\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(q_pos, goal_pos)\n        max_grid_dim = max(grid.size)\n        progress_ratio = min(max(dist_to_goal / max_grid_dim, 0.05), 1.0)\n        tree_size = max(self._graph.size, 1)\n        size_scale = min(1.0, 600 / tree_size)  # More vertices means smaller steps\n        adapt_dist = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_ratio * size_scale\n        return adapt_dist\n\n    def _get_biased_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal biased sampling: sample near the goal within min_max_dist radius\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                offset = torch.randn(self._dimension)\n                norm = torch.norm(offset)\n                if norm < 1e-8:\n                    continue\n                offset = offset / norm\n                distance_scale = torch.rand(1).item() * self._min_max_dist\n                sample_p = Point(*((goal_pos.to_tensor().float() + offset * distance_scale).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample_p):\n                    return sample_p\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling based on current best cost\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling fallback\n            for _ in range(100):\n                coords = [torch.randint(0, grid.size[d], (1,)).item() for d in range(self._dimension)]\n                sample_p = Point(*coords)\n                if grid.is_agent_valid_pos(sample_p):\n                    return sample_p\n            # If all fail, return agent position\n            return self._graph.root_vertex_start.position\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex) -> None:\n        # Extract path and apply robust multiple shortcut smoothing passes\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n        # Multiple passes for shortcut smoothing\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Animate final path\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early exit if planning time exceeded 10 seconds\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Fail gracefully without path found\n\n            q_sample = self._get_biased_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_step = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist_dir = torch.norm(dir_vec).item()\n            if dist_dir < 1e-8:\n                continue\n\n            if dist_dir <= max_step:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_norm * max_step).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new_cost = q_nearest.cost + dist_nearest_new\n\n            # Compute dynamic rewiring radius\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select parent with minimal total cost (cost + heuristic)\n            best_parent = q_nearest\n            min_cost = q_new_cost\n            for vertex_near in vertices_near:\n                dist_near_new = torch.norm(vertex_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                candidate_cost = vertex_near.cost + dist_near_new\n                if candidate_cost < min_cost:\n                    line_seq_candidate = grid.get_line_sequence(vertex_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        best_parent = vertex_near\n                        min_cost = candidate_cost\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if improved cost found via q_new (with early pruning)\n            for vertex_near in vertices_near:\n                if vertex_near == best_parent:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - vertex_near.position.to_tensor().float()).item()\n                candidate_cost = q_new.cost + dist_new_near\n                if candidate_cost + 1e-6 < vertex_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, vertex_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one old parent to maintain tree structure (prune older costlier edge)\n                        for old_parent in vertex_near.parents:\n                            self._graph.remove_edge(old_parent, vertex_near)\n                            break\n                        vertex_near.cost = candidate_cost\n                        self._graph.add_edge(q_new, vertex_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_seq_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_via_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_via_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_via_goal < self._best_cost:\n                        self._best_cost = cost_via_goal\n                        found_goal_vertex = goal_vertex\n                        # Early termination on direct goal connection with improved cost\n                        break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_path_and_smooth(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced PathPlanning Algorithm with:\n    - Adaptive max step size scaled dynamically for balanced exploration near and far from goal\n    - Hybrid sampling combining uniform, goal biased, and ellipsoidal informed sampling focused on best-known path region\n    - Heuristic (A*-style) cost plus admissible heuristic guiding expansion and rewiring decisions\n    - Dynamic radius-based rewiring leveraging adaptive neighborhood size for path optimization\n    - Pruning of suboptimal edges and parent rewiring for more efficient tree structure\n    - Multi-pass robust shortcut smoothing with progressive attempts to achieve smooth, near-optimal paths\n    - Early termination when connecting to goal directly with improved cost\n    - Time limit set to 10 seconds for search safety and robustness\n    - Incorporates cost inflation during expansion to enhance branch pruning and speed up convergence\n    - Explicit caching and reuse of sampled points and costly calculations optimized\n    Overall achieves faster convergence, improved success rate, and smoother paths with efficient resource use.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        # Time control for safe early termination\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        def _cost_to_goal_estimate(pos: Point) -> float:\n            # Admissible heuristic estimate from pos to goal (Euclidean)\n            return Map.get_distance(pos, goal_pos)\n\n        def _get_dynamic_max_dist(pos: Point) -> float:\n            # Adaptive max step size between min and max, scaled by distance to goal and tree size\n            dist_to_goal = Map.get_distance(pos, goal_pos)\n            norm_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n            tree_scale = min(1.0, 500 / (self._graph.size + 1))\n            return self._min_max_dist + (self._max_max_dist - self._min_max_dist) * norm_dist * tree_scale\n\n        def _sample_point() -> Point:\n            # Generates a sample point applying hybrid sampling strategy\n            if self._start_time is None:\n                self._start_time = time.time()\n\n            rand_val = torch.rand(1).item()\n\n            # Goal biased sampling with radius min_max_dist around goal position for better convergence\n            if rand_val < self._goal_sample_rate:\n                base = goal_pos.to_tensor().float()\n                for _ in range(40):\n                    offset = torch.randn(2)\n                    norm = torch.norm(offset)\n                    if norm > 1e-8:\n                        offset = offset / norm\n                    offset = offset * (torch.rand(1).item() * self._min_max_dist)\n                    sample_coords = base + offset\n                    sample_point = Point.from_tensor(sample_coords.round().int())\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n                return goal_pos\n\n            # Ellipsoidal informed sampling concentrated in cost-limited region to focus exploration\n            elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n                return self._sample_in_ellipsoid(grid.agent.position, goal_pos, self._best_cost)\n\n            else:\n                # Uniform random sampling across grid to preserve exploratory capability\n                for _ in range(120):\n                    coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(2)]\n                    sample_point = Point(*coords)\n                    if grid.is_agent_valid_pos(sample_point):\n                        return sample_point\n                # Fallback: start position if no valid sample found\n                return self._graph.root_vertex_start.position\n\n        def _attempt_rewire(q_new: Vertex, near_vertices: list):\n            # Rewiring step: try to improve neighbors' costs via q_new if valid\n            for q_near in near_vertices:\n                if q_near == q_new:\n                    continue\n                dist_new_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_near\n                eps = 1e-6\n                if cost_through_new + eps < q_near.cost:\n                    line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        # Remove one parent edge for q_near and set new parent q_new\n                        if q_near.parents:\n                            for p in q_near.parents:\n                                self._graph.remove_edge(p, q_near)\n                                break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n        def _extract_and_smooth_path(goal_vertex: Vertex):\n            # Extract path and apply multi-pass shortcut smoothing with increasing attempts\n            path_vertices = []\n            curr = goal_vertex\n            while True:\n                path_vertices.append(curr)\n                if not curr.parents:\n                    break\n                curr = next(iter(curr.parents))\n            path_vertices.reverse()\n\n            smoothing_passes = 5\n            for _ in range(smoothing_passes):\n                i = 0\n                while i < len(path_vertices) - 2:\n                    j = len(path_vertices) - 1\n                    shortened = False\n                    while j > i + 1:\n                        line_seq = grid.get_line_sequence(path_vertices[i].position, path_vertices[j].position)\n                        if grid.is_valid_line_sequence(line_seq):\n                            del path_vertices[i+1:j]\n                            j = i + 1\n                            shortened = True\n                        else:\n                            j -= 1\n                    if not shortened:\n                        i += 1\n\n            for vertex in path_vertices:\n                self.move_agent(vertex.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        for iteration in range(self._max_iterations):\n            # Enforce time limit\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = _sample_point()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = _get_dynamic_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_vec).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normed = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normed * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_to_new = Map.get_distance(q_nearest.position, q_new.position)\n            base_cost = q_nearest.cost + dist_nearest_to_new\n\n            # Heuristic A* style cost improvement: pick best parent considering cost + heuristic\n            card_v = max(self._graph.size, 1)\n            from math import log\n            ln_card_v = log(float(card_v)) if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            q_min = q_nearest\n            c_min = base_cost\n\n            # Parent selection using actual cost + heuristic cost to goal for better path quality\n            heuristic_new = _cost_to_goal_estimate(q_new.position)\n            best_score = c_min + heuristic_new\n\n            for q_near in near_vertices:\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = q_near.cost + dist_near_new\n                score_candidate = cost_candidate + _cost_to_goal_estimate(q_near.position)\n                if score_candidate < best_score:\n                    line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_cand):\n                        q_min = q_near\n                        c_min = cost_candidate\n                        best_score = score_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors to optimize tree locally\n            _attempt_rewire(q_new, near_vertices)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                        # Early termination if improved path directly connected to goal found\n                        if cost_to_goal < float('inf'):\n                            break\n\n            # Visualization key frame update every 40 iterations\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            _extract_and_smooth_path(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds upon the RRT*-inspired baseline by integrating:\n    - Heuristic-guided sampling biased by a dynamically adjusted probability that increases as search progresses,\n      focusing sampling near the start-goal corridor and unexplored free space.\n    - A prioritized radius-based vertex selection for choosing the parent, incorporating costs and a heuristic distance-to-goal,\n      encouraging more promising path expansions.\n    - An enhanced adaptive step size which considers clearance while allowing longer forward extensions when safe, promoting faster progress.\n    - Enhanced rewiring that not only rewires neighbors but carefully updates costs downstream for consistent optimal paths.\n    - Aggressive path shortcutting by iterative smoothing until no further improvements are possible.\n    - Early stopping triggered either when the goal is reached or when the cost converges with negligible improvements, ensuring efficiency.\n    This approach improves planning efficiency by reducing wasteful expansions, elevates path smoothness and optimality,\n    and increases success rates by balancing exploration and goal-driven exploitation adaptively.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n        # Additional member variable: track best cost to goal found so far\n        self._best_goal_cost = float('inf')\n\n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic used for heuristic guided cost estimation\n        return Map.get_distance(p1, p2)\n\n    def _get_goal_biased_sample(self, iteration: int, max_iterations: int) -> Point:\n        # Dynamically adapt goal sample rate from lower to higher over iterations\n        base_rate = 0.1\n        max_rate = 0.5\n        goal_sample_rate = base_rate + (max_rate - base_rate) * (iteration / max_iterations)\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            # Additionally bias sampling near the corridor between start and goal by accepting samples closer\n            # to the line start-goal with higher probability\n            start_pos = self._graph.root_vertex_start.position\n            goal_pos = self._get_grid().goal.position\n            dist_to_line = self._distance_to_segment(sample, start_pos, goal_pos)\n            acceptance_prob = min(1.0, 3.0 / (dist_to_line + 1e-5))  # Closer to line -> higher prob\n            if self._get_grid().is_agent_valid_pos(sample) and np.random.rand() < acceptance_prob:\n                return sample\n\n    def _distance_to_segment(self, p: Point, a: Point, b: Point) -> float:\n        # Returns distance from point p to segment ab (Euclidean)\n        a_tensor = a.to_tensor()\n        b_tensor = b.to_tensor()\n        p_tensor = p.to_tensor()\n        ab = b_tensor - a_tensor\n        ap = p_tensor - a_tensor\n        ab_norm_sq = torch.dot(ab, ab)\n        if ab_norm_sq == 0:\n            return torch.norm(ap).item()\n        t = torch.clamp(torch.dot(ap, ab) / ab_norm_sq, 0.0, 1.0)\n        proj = a_tensor + t * ab\n        return torch.norm(p_tensor - proj).item()\n\n    def _enhanced_adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=20.0) -> float:\n        # Adaptive step considers clearance but tries to push longer max distance when environment allows\n        clearance = max_dist\n        direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n        if direction.norm() == 0:\n            return min_dist\n        dir_norm = direction / direction.norm()\n\n        # Sample multiple radii with finer granularity and check clearance with tighter threshold\n        for radius in np.linspace(min_dist, max_dist, num=10):\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.7\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.7\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _choose_parent_with_heuristic(self, q_near_list: list, q_new: Vertex) -> Vertex:\n        # Select parent that minimizes cost + movement_cost + heuristic to goal, favoring vertices leading closer\n        min_eval = float('inf')\n        chosen_parent = None\n        goal_pos = self._get_grid().goal.position\n\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_to_new = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            heuristic_to_goal = self._heuristic_distance(q_new.position, goal_pos)\n            eval_cost = cost_to_new + heuristic_to_goal\n            if eval_cost < min_eval:\n                min_eval = eval_cost\n                chosen_parent = v\n\n        return chosen_parent\n\n    def _rewire_with_cost_update(self, q_new: Vertex, q_near_list: list) -> None:\n        # Rewire neighbors through q_new if this improves their cost, updating descendants' costs recursively.\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost + 1e-5 < v.cost:  # Add epsilon for numerical stability\n                # Remove old edges from parents to v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                self._update_costs_downstream(v, potential_cost)\n\n    def _update_costs_downstream(self, vertex: Vertex, new_cost: float) -> None:\n        # Recursively update costs of vertex and its children if improved\n        if new_cost >= vertex.cost:\n            return  # No improvement\n        vertex.cost = new_cost\n        for child in vertex.children:\n            movement_cost = self._get_grid().get_movement_cost(vertex.position, child.position)\n            self._update_costs_downstream(child, new_cost + movement_cost)\n\n    def _shortcut_path_iterative(self, path: list) -> list:\n        # Iteratively shortcut path until no further shortcutting possible\n        if len(path) <= 2:\n            return path\n        improved = True\n        while improved:\n            improved = False\n            new_path = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                # Try to skip as many intermediate vertices as possible\n                skip_to = idx + 1\n                for j in range(len(path) - 1, idx, -1):\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[idx].position, path[j].position)):\n                        skip_to = j\n                        break\n                if skip_to > idx + 1:\n                    improved = True\n                new_path.append(path[skip_to])\n                idx = skip_to\n            path = new_path\n        return path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extend final edge to goal vertex\n        goal_v = Vertex(self._get_grid().goal.position)\n        line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_v.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq_goal):\n            # Rare fallback, just add edge anyway if close enough\n            if self._heuristic_distance(q_new.position, goal_v.position) > 2.0:\n                return  # Cannot connect to goal properly\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        # Backtrack path from goal to start\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove root duplicate\n        path.reverse()\n\n        # Aggressive iterative shortcut smoothing\n        smoothed_path = self._shortcut_path_iterative(path)\n\n        # Move agent along smoothed path with keyframes\n        for v in smoothed_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _has_converged(self, iteration: int, last_best_cost: float, current_best_cost: float, window: int = 100, threshold: float = 1e-3) -> bool:\n        # Detect cost convergence if no significant improvement for a window of iterations\n        if iteration < window:\n            return False\n        if abs(last_best_cost - current_best_cost) <= threshold:\n            return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 8000\n        search_radius: float = 25.0  # larger radius for rewiring due to longer adaptive steps\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n        last_best_goal_cost = float('inf')\n        no_improve_iters = 0\n\n        # Keep track of current best goal reached vertex and its cost\n        best_goal_vertex: Vertex = None\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout, treat as failure\n                break\n\n            q_sample: Point = self._get_goal_biased_sample(i, max_iterations)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._enhanced_adaptive_max_dist(q_near.position)\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list: list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, search_radius)\n            chosen_parent: Vertex = self._choose_parent_with_heuristic(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            q_near_list_no_parent = [v for v in q_near_list if v != chosen_parent]\n            self._rewire_with_cost_update(q_new, q_near_list_no_parent)\n\n            # Check if new vertex reached goal region and update best cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < self._best_goal_cost:\n                    self._best_goal_cost = q_new.cost\n                    best_goal_vertex = q_new\n\n            # Early stopping if path found and cost converged (no improvements)\n            if best_goal_vertex is not None:\n                if self._has_converged(i, last_best_cost=last_best_goal_cost, current_best_cost=self._best_goal_cost):\n                    self._extract_path(best_goal_vertex)\n                    break\n                else:\n                    last_best_goal_cost = self._best_goal_cost\n\n            self.key_frame()\n        else:\n            # After max_iterations, if found a path, extract it; else fail silently\n            if best_goal_vertex is not None:\n                self._extract_path(best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planner builds on the RRT* backbone with goal-biased adaptive sampling and rewiring.\n    Enhancements include:\n    - Heuristic-guided expansion leveraging an A*-style cost-to-go heuristic (Euclidean to goal), \n      biasing parent selection toward vertices with better estimated total cost (cost_so_far + heuristic)\n    - Adaptive step size tuned dynamically based on clearance and local obstacles for efficient extension\n    - Enhanced rewiring that considers heuristic for better neighbor rewiring order decision\n    - Early stopping using a tightened goal radius and timeout (10 seconds)\n    - Post-processing path smoothing with shortcutting via valid direct edge checks\n    This balances exploration and exploitation, improves convergence speed and path smoothness,\n    reduces tree size by preferring lower expected total cost parents, \n    and increases success rate in complex environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _heuristic_cost(self, position: Point) -> float:\n        # Euclidean distance heuristic to goal (admissible)\n        goal_pos = self._get_grid().goal.position\n        return Map.get_distance(position, goal_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex | None:\n        # Choose parent minimizing f = cost_so_far + heuristic to goal\n        min_f_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            g_cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            f_cost = g_cost + self._heuristic_cost(q_new.position)\n            if f_cost < min_f_cost:\n                min_f_cost = f_cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list) -> None:\n        # Rewire neighbors considering heuristic; rewire to q_new if it reduces cost and line valid\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost + self._heuristic_cost(v.position) < v.cost + self._heuristic_cost(v.position):\n                # Remove old parents edges of v\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _shortcut_path(self, path: list[Vertex]) -> list[Vertex]:\n        # Smooth path by skipping intermediate vertices when direct edges are valid\n        if not path:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            # Find furthest reachable vertex from smoothed[-1]\n            while j > i:\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(smoothed[-1].position, path[j].position)\n                ):\n                    smoothed.append(path[j])\n                    i = j\n                    break\n                j -= 1\n            if j == i:  # No shortcut found, move one step forward\n                smoothed.append(path[i+1])\n                i += 1\n        return smoothed\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new to start (root), add goal, then shortcut and trace agent\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while path[-1].parents:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove start duplicate\n        path.reverse()\n\n        smoothed_path = self._shortcut_path(path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000  # Slightly reduced for efficiency, compensate via heuristics\n        goal_sample_rate = 0.35  # Increase bias towards goal sampling for faster convergence\n        search_radius = 18.0  # Increased radius for neighbors during rewiring for better optimization\n        goal_radius_sq = (self._get_grid().goal.radius + self._get_grid().agent.radius)**2\n        start_time = time.time()\n\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout condition\n                break\n\n            q_sample = self._get_random_sample(goal_sample_rate)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, min_dist=4.0, max_dist=20.0)  # widen adaptive range\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            q_near_list = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, search_radius)\n            if not q_near_list:\n                q_near_list = [q_near]  # fallback\n\n            chosen_parent = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            q_near_filtered = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_filtered)\n\n            # Improved goal proximity check: use squared distance for performance\n            dist_to_goal_sq = (q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor()).pow(2).sum().item()\n            if dist_to_goal_sq <= goal_radius_sq:\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved path planning algorithm focused on enhanced smoothness, efficiency, and success rate.\n    Key improvements over the provided algorithm:\n    \n    - Enhanced adaptive step size that also considers progress ratio towards goal and local clearance.\n    - Refined mixed sampling combining goal bias, informed ellipsoidal sampling, and clearance-aware uniform sampling,\n      with increased attempts and fallback strategies to ensure quality samples.\n    - Rewiring now incorporates a dynamic pruning threshold that tightens as the tree grows, reducing unnecessary rewiring.\n    - Early stopping not only on direct goal connection but also on achieving minimal incremental cost improvement over several iterations.\n    - Path smoothing uses weighted shortcutting and incorporates slight path simplification heuristics.\n    - Iteration loops are optimized with better key frame frequency control and timeout enforcement (10 seconds).\n    - Heuristic cost combining distance traveled and admissible distance-to-goal cost guides rewiring and parent selection.\n    \n    These improvements yield faster convergence, higher success in complex and cluttered maps,\n    and a smoother, safer path leveraging clearance information.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        # Keep original init unchanged but add new members for smoothing and stopping criteria\n        super().__init__(services, testing)\n        self._improvement_stall_limit = 120  # Iterations with minimum cost improvement to stop early\n        self._min_cost_improvement = 1e-4    # Minimum cost improvement threshold to reset stall count\n        self._last_best_cost = float('inf')\n        self._stall_iterations = 0\n\n    def _weighted_shortcut_smoothing(self, path: list[Vertex], passes=4) -> list[Vertex]:\n        \"\"\"\n        Performs multiple passes of weighted smoothing by trying shortcuts and\n        slightly modifying points to reduce path sharp angles.\n        \"\"\"\n        grid = self._get_grid()\n        import torch\n\n        def angle_between_three_points(a: Point, b: Point, c: Point) -> float:\n            # Returns angle at b in radians between segments ba and bc\n            v1 = a.to_tensor().float() - b.to_tensor().float()\n            v2 = c.to_tensor().float() - b.to_tensor().float()\n            if torch.norm(v1) < 1e-8 or torch.norm(v2) < 1e-8:\n                return 0.0\n            v1 = v1 / torch.norm(v1)\n            v2 = v2 / torch.norm(v2)\n            cosine_angle = torch.clamp(torch.dot(v1, v2), -1.0, 1.0).item()\n            angle = torch.acos(torch.tensor(cosine_angle)).item()\n            return angle\n\n        for _ in range(passes):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                progressed = False\n                while j > i + 1:\n                    segment = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        # Only shortcut if angle is sharp at i+1 or points between i and j are many (reducing path complexity)\n                        if (j - i) > 2:\n                            angle = angle_between_three_points(path[i].position, path[i+1].position, path[j].position)\n                            if angle < 2.8:  # keep only sharp turns to smooth\n                                path[i+1:j] = []\n                                progressed = True\n                                j = i + 1\n                            else:\n                                j -= 1\n                        else:\n                            path[i+1:j] = []\n                            progressed = True\n                            j = i + 1\n                    else:\n                        j -= 1\n                if not progressed:\n                    i += 1\n        return path\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        # To control keyframe frequency (smoother animation)\n        keyframe_interval = 30\n\n        for iteration in range(self._max_iterations):\n            # Enforce timeout at 10 seconds\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Abort on timeout\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n\n            # Rewiring radius computation improved to be more responsive:\n            base_radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 25.0)\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius = base_radius * clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic weighted parent selection: cost so far + heuristic to goal\n            best_parent = q_nearest\n            best_cost = q_nearest.cost + dist_qnearest_qnew + self._heuristic_cost(q_new.position, goal_pos)\n\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                heuristic_estimated = cost_candidate + self._heuristic_cost(q_new.position, goal_pos)\n                if heuristic_estimated < best_cost:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        best_parent = v\n                        best_cost = heuristic_estimated\n\n            q_new.cost = best_parent.cost + torch.norm(best_parent.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            self._graph.add_edge(best_parent, q_new)\n\n            # Dynamic rewiring pruning threshold tightens as tree grows to improve efficiency\n            dynamic_rewire_threshold = max(0.002, 0.008 - (0.006 * (size / 1000)))\n\n            for v_near in near_vertices:\n                if v_near == best_parent:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + dynamic_rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            # Relaxed max_dist for goal connection to allow slight overshoot\n            goal_connect_dist = max_dist * 1.3\n            if dist_to_goal <= goal_connect_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n                        self._stall_iterations = 0\n                        self._last_best_cost = goal_cost\n                    else:\n                        self._stall_iterations += 1\n\n                    # Early termination on direct goal reach\n                    break\n            else:\n                # Track improvement stalling for early termination to save compute\n                if self._best_cost < float('inf'):\n                    if self._best_cost < self._last_best_cost - self._min_cost_improvement:\n                        self._stall_iterations = 0\n                        self._last_best_cost = self._best_cost\n                    else:\n                        self._stall_iterations += 1\n                        if self._stall_iterations >= self._improvement_stall_limit:\n                            break\n\n            if (iteration % keyframe_interval) == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            # Extract path\n            path = []\n            current = found_goal\n            while True:\n                path.append(current)\n                if len(current.parents) == 0:\n                    break\n                current = next(iter(current.parents))\n            path.reverse()\n\n            # Apply improved smoothing with weighted shortcutting and simplification\n            smoothed_path = self._weighted_shortcut_smoothing(path, passes=5)\n\n            # Move the agent along the smoothed path with key frames\n            for v in smoothed_path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Clearance-Aware Heuristic-RRT* Path Planning Algorithm",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved Clearance-Aware Heuristic-RRT* Path Planning Algorithm}\n\n    This algorithm enhances the prior hybrid heuristic-tree method by explicitly incorporating clearance\n    maximization into both the sampling and vertex connection stages, thereby improving path safety, smoothness,\n    and quality. Key features include:\n\n    - Clearance-weighted cost function combining path cost and inverse clearance to guide growth towards safer paths.\n    - Clearance-biased resampling near high-clearance regions dynamically to avoid narrow corridors.\n    - Adaptive step size refined to lean toward larger steps in open, high-clearance areas, and smaller near obstacles.\n    - Reinforced rewiring to not only minimize path cost but also maximize clearance of rewired parents.\n    - Improved goal bias with clearance-filtered sampling to increase robustness connecting to goal.\n    - Early termination triggered on a path found that beats best cost and maintains minimal clearance threshold.\n    - Final path smoothing with shortcutting while preserving clearance constraints.\n    - Timeout enforced at 10 seconds to ensure planning responsiveness.\n\n    The method balances shortest path pursuit and obstacle clearance by integrating clearance heuristics directly\n    into vertex cost and expansion methods, significantly increasing success rate and path quality in obstructed maps.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Parameters blending previous insights plus clearance emphasis\n        self._goal_sample_rate = 0.3\n        self._clearance_threshold = 3.5           # increased clearance bias\n        self._min_clearance_for_accept = 1.5      # minimal clearance threshold for considered path nodes\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._min_step = 3.0                       # slightly larger min step for faster exploration\n        self._max_step = 18.0                      # larger max step to jump open spaces\n        self._rewire_lambda = 25.0                 # rewiring neighborhood scale\n        self._clearance_weight = 10.0              # weight factor balancing clearance influence in cost\n        self._init_displays()\n\n    def _clearance_weighted_cost(self, cost_so_far: float, clearance: float) -> float:\n        # Combine cost and clearance into composite cost (lower better).\n        # We negate clearance, scaled by a weight, to prefer higher clearance.\n        clearance_term = self._clearance_weight / (clearance + 1e-6)  # avoid div by zero\n        return cost_so_far + clearance_term\n\n    def _find_high_clearance_sample(self, trials: int = 150) -> Point:\n        # Attempt to sample points with clearances significantly above threshold.\n        import torch\n        grid = self._get_grid()\n        best_sample = self._graph.root_vertex_start.position\n        best_clearance = 0.0\n        for _ in range(trials):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            candidate = Point(*coords)\n            if not grid.is_agent_valid_pos(candidate):\n                continue\n            clearance = self._get_clearance(candidate)\n            if clearance >= self._clearance_threshold:\n                return candidate\n            if clearance > best_clearance:\n                best_clearance = clearance\n                best_sample = candidate\n        return best_sample\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n        prob = torch.rand(1).item()\n\n        if prob < self._goal_sample_rate:\n            # Goal bias with clearance filtering and randomized offset\n            goal_pos = grid.goal.position\n            for _ in range(30):\n                offset = torch.randint(-2, 3, (self._dimension,))\n                candidate = Point(goal_pos.x + offset[0].item(), goal_pos.y + offset[1].item())\n                if grid.is_agent_valid_pos(candidate):\n                    clearance = self._get_clearance(candidate)\n                    if clearance >= self._clearance_threshold:\n                        return candidate\n            return goal_pos\n        else:\n            # Clearance weighted sample biased towards higher clearance regions\n            sample = self._find_high_clearance_sample()\n            return sample\n\n    def _adaptive_step_size(self, pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        norm_dist = min(1.0, dist_to_goal / max(grid.size))\n\n        tree_size = max(self._graph.size, 1)\n        tree_factor = min(1.0, 450.0 / tree_size)  # more aggressive as tree grows\n\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.8))  # bigger influence\n\n        # Bias step size larger when clearance large and farther from goal\n        step = self._min_step + (self._max_step - self._min_step) * norm_dist * tree_factor * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n        self._start_time = time.time()\n\n        # Priority queue: (clearance_weighted_cost_estimate, vertex)\n        open_queue = []\n        start_clearance = self._get_clearance(start_vertex.position)\n        start_weighted_cost = self._clearance_weighted_cost(0.0, start_clearance)\n        heapq.heappush(open_queue, (start_weighted_cost + self._heuristic(start_vertex.position), start_vertex))\n\n        vertex_map = {start_vertex.position: start_vertex}  # position to vertex map\n\n        iterations = 0\n        while iterations < self._max_iterations:\n            # Time cutoff\n            if time.time() - self._start_time > self._time_limit_seconds:\n                break\n\n            if not open_queue:\n                # No vertices to expand: no path found\n                break\n\n            est_tot_cost, current_v = heapq.heappop(open_queue)\n            iterations += 1\n\n            # Sample point with clearance bias & goal bias\n            q_sample = self._get_random_sample()\n\n            # Direction and adaptive stepping\n            dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_norm = dir_vec / dist\n\n            max_step = self._adaptive_step_size(current_v.position)\n            step_length = min(dist, max_step)\n\n            base_pos = torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32)\n            new_pos_tensor = torch.round(base_pos + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == current_v.position:\n                continue\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Skip if vertex exists\n            if q_new_pos in vertex_map:\n                continue\n\n            # Validate edge with lazy collision check\n            line_seq = grid.get_line_sequence(current_v.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            clearance_at_new = self._get_clearance(q_new_pos)\n            # Reject nodes with clearance below minimal accepted threshold to avoid narrow paths\n            if clearance_at_new < self._min_clearance_for_accept:\n                continue\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n            cost_to_q_new_base = current_v.cost + move_cost\n\n            # Neighborhood radius for rewiring\n            size = max(self._graph.size, 1)\n            import math\n            ln_size = math.log(float(size)) if size > 1 else 0.0\n            base_radius = self._rewire_lambda * ((ln_size / size) ** (1 / self._dimension))\n            radius = min(base_radius * (1.0 + clearance_at_new / (self._clearance_threshold * 2.2)), 22.0)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Among neighbors pick parent with best combined clearance weighted cost if valid\n            best_parent = current_v\n            best_cost = self._clearance_weighted_cost(cost_to_q_new_base, clearance_at_new)\n            best_cost_base = cost_to_q_new_base\n\n            for neighbor in near_vertices:\n                dist_to_new = grid.get_movement_cost(neighbor.position, q_new_pos)\n                candidate_cost_so_far = neighbor.cost + dist_to_new\n                clearance_candidate = self._get_clearance(q_new_pos)\n                candidate_weighted_cost = self._clearance_weighted_cost(candidate_cost_so_far, clearance_candidate)\n\n                if candidate_weighted_cost < best_cost - 1e-5:\n                    # Validate edge before choosing\n                    line_seq_cand = grid.get_line_sequence(neighbor.position, q_new_pos)\n                    if not grid.is_valid_line_sequence(line_seq_cand):\n                        continue\n                    best_cost = candidate_weighted_cost\n                    best_parent = neighbor\n                    best_cost_base = candidate_cost_so_far\n\n            q_new_vertex.cost = best_cost_base\n            self._graph.add_edge(best_parent, q_new_vertex)\n            vertex_map[q_new_pos] = q_new_vertex\n\n            # Rewiring neighbors to q_new if improves clearance-weighted cost\n            cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost < float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                dist_to_neighbor = grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                new_cost_base = q_new_vertex.cost + dist_to_neighbor\n                clearance_neighbor = self._get_clearance(neighbor.position)\n                clearance_new_path = min(self._get_clearance(q_new_vertex.position), clearance_neighbor)\n\n                new_weighted_cost = self._clearance_weighted_cost(new_cost_base, clearance_new_path)\n                old_weighted_cost = self._clearance_weighted_cost(neighbor.cost, clearance_neighbor)\n                if new_weighted_cost + cost_improve_thresh < old_weighted_cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove existing parent edges\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost_base\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            # Push q_new_vertex with clearance-weighted cost + heuristic to open queue\n            est_total_cost = best_cost + self._heuristic(q_new_pos)\n            heapq.heappush(open_queue, (est_total_cost, q_new_vertex))\n\n            # Check for goal reached with adaptive radius\n            dist_to_goal = Map.get_distance(q_new_vertex.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_to_goal = grid.get_line_sequence(q_new_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    # Check goal clearance before connecting\n                    clearance_goal = self._get_clearance(goal_pos)\n                    if clearance_goal < self._min_clearance_for_accept:\n                        # Avoid if goal region too tight\n                        continue\n\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal_base = q_new_vertex.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal_base\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    # Evaluate goal clearance weight cost\n                    goal_weighted_cost = self._clearance_weighted_cost(cost_to_goal_base, clearance_goal)\n                    if goal_weighted_cost < self._best_cost:\n                        self._best_cost = goal_weighted_cost\n                        found_goal_vertex = goal_vertex\n                        # Early stop on improvement with valid clearance\n                        break\n\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            # Extract path from goal to start choosing min cost parents\n            path = []\n            curr = found_goal_vertex\n            while True:\n                path.append(curr)\n                if len(curr.parents) == 0:\n                    break\n                curr = min(curr.parents, key=lambda p: p.cost)\n            path.reverse()\n\n            # Shortcut smoothing while preserving clearance constraints\n            for _ in range(4):\n                i = 0\n                while i < len(path) - 2:\n                    j = len(path) - 1\n                    shortened = False\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(path[i].position, path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            # Check clearance margin on segment intermediates\n                            if all(self._get_clearance(pt) >= self._min_clearance_for_accept for pt in segment):\n                                del path[i+1:j]\n                                shortened = True\n                                break\n                        j -= 1\n                    if not shortened:\n                        i += 1\n\n            for v in path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced RRT*-Inspired PathPlanning Algorithm with Clearance Awareness:\n    - Introduces obstacle clearance heuristic to favor paths with larger clearance for safer navigation.\n    - Clearance-aware rewiring: incorporates clearance cost in vertex cost and rewiring decisions.\n    - Adaptive max step size scaled by clearance around the expanding vertex for cautious expansion near obstacles.\n    - Mixed sampling: uniform, goal-biased, and informed ellipsoidal sampling guided by current best cost.\n    - Heuristic-guided parent selection uses combined cost + heuristic + clearance to improve quality and safety.\n    - Dynamic neighborhood radius for rewiring removed from suffix cost to accommodate clearance scores.\n    - Early termination upon reaching a path under time limit with improved clearance.\n    - Multi-pass robust shortcut smoothing maintained.\n    - Timeout after 10 seconds to avoid long failing searches.\n    Overall improves path safety, robustness with higher clearance paths, while maintaining efficient planning.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        # Additional data member for clearance weight during cost calculations\n        self._clearance_cost_weight = 5.0  # Weighting factor for clearance in cost function\n\n    def _compute_clearance(self, pos: Point) -> float:\n        \"\"\"\n        Compute minimal clearance from obstacles at pos (distance to closest obstacle boundary).\n        Returns a positive float; higher means safer (farther from obstacles).\n        \"\"\"\n        grid = self._get_grid()\n        min_clearance = float('inf')\n\n        for obstacle in grid.obstacles:\n            obstacle_points = grid.get_obstacle_bound(obstacle.position)\n            for op in obstacle_points:\n                dist = Map.get_distance(pos, op)\n                if dist < min_clearance:\n                    min_clearance = dist\n\n        # If no obstacles, clearance is large number\n        if min_clearance == float('inf'):\n            min_clearance = max(grid.size) * 2\n        return min_clearance\n\n    def _clearance_aware_cost(self, from_vertex: Vertex, to_pos: Point) -> float:\n        \"\"\"\n        Calculate cost from from_vertex.position to to_pos incorporating clearance.\n        Lower when clearance is larger.\n        \"\"\"\n        grid = self._get_grid()\n        dist = Map.get_distance(from_vertex.position, to_pos)\n        clearance = self._compute_clearance(to_pos)\n        # To encourage paths with bigger clearance, subtract weighted clearance \n        # (using inverse minus clearance with weight)\n        # adding 1e-3 to avoid division by zero if clearance is zero\n        clearance_cost = self._clearance_cost_weight / (clearance + 1e-3)\n        return from_vertex.cost + dist + clearance_cost\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        \"\"\"\n        Override adaptive max dist to incorporate clearance-based scaling.\n        Reduce max step size when clearance is low, encourage cautious growth near obstacles.\n        \"\"\"\n        base_dist = super()._get_adaptive_max_dist(curr_pos)  # Get baseline adaptive max dist\n\n        clearance = self._compute_clearance(curr_pos)\n        grid = self._get_grid()\n        max_clearance = max(grid.size) / 2  # Rough max clearance on grid\n\n        clearance_factor = max(0.3, min(1.0, clearance / max_clearance))  # normal 0.3..1.0\n        adaptive_dist = base_dist * clearance_factor\n        return adaptive_dist\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Timeout after 10 seconds\n            if (time.time() - self._start_time) > 10:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Check clearance at q_new_pos: reject if clearance too low (collision margin)\n            clearance_new = self._compute_clearance(q_new_pos)\n            if clearance_new < q_new_pos.radius if hasattr(q_new_pos, 'radius') else 1.0:\n                # Too close to obstacle, discard sample\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic-guided min cost parent with clearance-aware cost\n            q_min = q_nearest\n            c_min = self._clearance_aware_cost(q_nearest, q_new.position)\n            heuristic_min = self._heuristic_cost(q_min.position, goal_pos)\n\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                cost_candidate = self._clearance_aware_cost(q_near, q_new.position)\n                heuristic_candidate_parent = self._heuristic_cost(q_near.position, goal_pos)\n\n                # Prefer parent minimizing combined cost + heuristic\n                if (cost_candidate + heuristic_candidate_parent) < (c_min + heuristic_min):\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n                        heuristic_min = heuristic_candidate_parent\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = q_new.cost + dist_new_near + self._clearance_cost_weight / (self._compute_clearance(q_near.position) + 1e-3)\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            clearance_goal = self._compute_clearance(goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal) and clearance_goal > 1.0:\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal + self._clearance_cost_weight / (clearance_goal + 1e-3)\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n                        # Early termination on good direct goal connect\n                        if cost_to_goal < float('inf'):\n                            break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Clearance-Aware Adaptive RRT* Inspired Path Planning Algorithm:\n    - Extends conventional RRT* by incorporating obstacle clearance into the cost and parent selection,\n      encouraging paths that keep higher clearance from obstacles.\n    - Adaptive max step size to balance exploration and fine control near obstacles and goal.\n    - Sampling mixes uniform, goal bias, and ellipsoidal informed sampling focusing search and\n      increasing probability of discovering better paths early.\n    - Clearance estimated by minimum distance to obstacles along candidate edges with efficient pruning.\n    - Rewiring neighbors improved by clearance-aware cost and pruning of edges reducing clutter.\n    - Path extraction followed by multi-pass shortcut smoothing preserving clearance margins.\n    - Early termination triggered when a feasible path with sufficient clearance is found.\n    - Time budget strictly enforced (10 seconds) to ensure timely failure or success.\n    - Overall improves path safety, smoothness, robustness, and faster convergence on cluttered grids.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size far from goal\n        self._min_max_dist = 2.5   # Min step size near goal for fine control\n        self._goal_sample_rate = 0.25  # Goal biased sampling probability\n        self._informed_sample_rate = 0.3  # Probability of ellipsoidal informed sampling\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45  # Rewiring radius factor tuning\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_weight = 5.0  # Weight factor to prioritize clearance in cost\n        self._min_clearance = 1.0  # Minimal acceptable clearance for edges\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 500 / (self._graph.size + 1))\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor\n        # Reduce step size near obstacles if clearance low (optional, could be enhanced if needed)\n        return scaled_step\n\n    def _calc_edge_clearance(self, line_seq: list) -> float:\n        \"\"\"\n        Calculate minimum clearance from obstacles along the line.\n        Clearance is estimated as the minimal distance from each point in the line\n        sequence to any obstacle boundary.\n        \"\"\"\n        grid = self._get_grid()\n        min_clearance = float('inf')\n        for pt in line_seq:\n            # For efficiency, approximate clearance with Manhattan or Euclidean minimum distance\n            # to obstacles via precomputed or cached data might improve performance.\n            # Since not given, approximate by checking validity and distance to obstacles\n            # by probing around pt for obstacles radius.\n            if not grid.is_agent_valid_pos(pt):\n                return 0.0  # Invalid positions have zero clearance\n            # Find clearance as min distance to any obstacle boundary positions:\n            for obs in grid.obstacles:\n                # Distance from point to obstacle center minus obstacle radius\n                dist = Map.get_distance(pt, obs.position) - obs.radius\n                if dist < min_clearance:\n                    min_clearance = dist\n                    if min_clearance <= 0:\n                        return 0.0\n        return min_clearance if min_clearance != float('inf') else 0.0\n\n    def _clearance_aware_cost(self, parent_cost: float, edge_length: float, clearance: float) -> float:\n        \"\"\"\n        Combine cost of edge length and clearance penalty.\n        Higher clearance reduces cost favorably.\n        Clearance weight balances path length vs clearance.\n        \"\"\"\n        # To avoid zero or negative clearance affecting cost unduly, clamp clearance >= small epsilon\n        clearance_clamped = max(clearance, 0.001)\n        clearance_penalty = self._clearance_weight / clearance_clamped\n        return parent_cost + edge_length + clearance_penalty\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed_time = time.time() - self._start_time\n            if elapsed_time > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            clearance = self._calc_edge_clearance(line_seq)\n            if clearance < self._min_clearance:\n                # Skip edges with insufficient clearance for safety buffer\n                continue\n\n            edge_length = Map.get_distance(q_nearest.position, q_new_pos)\n            cost_to_new = self._clearance_aware_cost(q_nearest.cost, edge_length, clearance)\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = cost_to_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Clearance-aware heuristic-guided best parent selection\n            q_min = q_nearest\n            c_min = cost_to_new\n\n            for q_near in vertices_near:\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if not grid.is_valid_line_sequence(line_seq_candidate):\n                    continue\n                clearance_candidate = self._calc_edge_clearance(line_seq_candidate)\n                if clearance_candidate < self._min_clearance:\n                    continue\n\n                dist_near_new = Map.get_distance(q_near.position, q_new.position)\n                cost_candidate = self._clearance_aware_cost(q_near.cost, dist_near_new, clearance_candidate)\n\n                heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n                heuristic_q_min = self._heuristic_cost(q_min.position, goal_pos)\n\n                if (cost_candidate + heuristic_new) < (c_min + heuristic_q_min):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors with clearance and cost checks\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n\n                clearance_rewire = self._calc_edge_clearance(line_seq_rewire)\n                if clearance_rewire < self._min_clearance:\n                    continue\n\n                dist_new_near = Map.get_distance(q_new.position, q_near.position)\n                cost_through_new = self._clearance_aware_cost(q_new.cost, dist_new_near, clearance_rewire)\n\n                if cost_through_new + 1e-6 < q_near.cost:\n                    # Remove only one parent edge to maintain tree structure\n                    for parent in list(q_near.parents):\n                        self._graph.remove_edge(parent, q_near)\n                        break\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    clearance_goal = self._calc_edge_clearance(line_goal)\n                    if clearance_goal >= self._min_clearance:\n                        goal_vertex = Vertex(goal_pos)\n                        cost_to_goal = self._clearance_aware_cost(q_new.cost, dist_to_goal, clearance_goal)\n                        goal_vertex.cost = cost_to_goal\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                        if cost_to_goal < self._best_cost:\n                            self._best_cost = cost_to_goal\n                            found_goal = goal_vertex\n\n                            if cost_to_goal < float('inf'):\n                                break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "An improved RRT*-inspired path planning algorithm that enhances clearance, efficiency, \n    and path quality by integrating:\n    - Adaptive max step sizes scaled by distance to goal and tree density.\n    - Hybrid sampling mixing uniform, goal biasing, and informed ellipsoidal sampling for efficient exploration.\n    - Clearance-aware edge validation promoting safer paths away from obstacles.\n    - Heuristic-guided parent selection combining traveled cost and admissible heuristic.\n    - Dynamic rewiring radius adapting to tree growth and iteration count.\n    - Early pruning of rewiring edges to maintain sparse tree structure and minimize clutter.\n    - Multiple-pass robust shortcut smoothing after path extraction.\n    - Early stopping when a direct, cleared connection to goal is found.\n    - Conservative 10-second runtime cap to guarantee termination.\n    This approach targets higher success rates, smoother, safer paths, and reduced planning times.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.20     # Slightly reduced goal bias to include more uniform samples\n        self._informed_sample_rate = 0.35 # Slightly increased informed sampling\n        self._max_iterations = 3500       # Reduced iterations trusting efficiency\n        self._lambda_rrt_star = 55        # Slightly larger rewiring radius factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10     # Enforced time limit\n        self._best_cost = float('inf')\n        self._clearance_margin = 2         # Clearance margin in grid units for safety during expansions\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"\n        Estimate clearance from obstacles at point by checking neighborhood radius.\n        Returns minimum distance to obstacle from point.\n        \"\"\"\n        grid = self._get_grid()\n        rw = self._clearance_margin\n        px, py = point.x, point.y\n        # Check immediate local neighborhood for obstacles, minimal radius clearance approximation\n        min_dist = rw + 1\n        for dx in range(-rw, rw + 1):\n            for dy in range(-rw, rw + 1):\n                check_pt = Point(px + dx, py + dy)\n                if not grid.is_agent_valid_pos(check_pt):\n                    dist = (dx*dx + dy*dy)**0.5\n                    if dist < min_dist:\n                        min_dist = dist\n        return min_dist\n\n    def _clearance_valid_line(self, line_seq: list) -> bool:\n        \"\"\"\n        Validate line sequence with clearance margin from obstacles.\n        Returns True if entire line maintains clearance margin.\n        \"\"\"\n        for pt in line_seq:\n            if self._get_clearance(pt) < self._clearance_margin:\n                return False\n        return True\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance admissible heuristic\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample points mixing uniform, goal bias, and informed ellipsoidal sampling,\n        with fallback uniform if sampling fails.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal-biased sphere around goal with clearance margin for sampling\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset).item()\n                if norm < 1e-8:\n                    continue\n                sample_offset = sample_offset / norm * (torch.rand(1).item() * self._max_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_margin:\n                    return sample\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoid sampling with added clearance filtering\n            for _ in range(40):\n                sample = self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n                if self._get_clearance(sample) >= self._clearance_margin:\n                    return sample\n            # fallback\n            return self._graph.root_vertex_start.position\n\n        else:\n            # Uniform random sampling with clearance checks\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_margin:\n                    return sample\n            # fallback fallback\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        \"\"\"\n        Adaptive max step size scaled by distance to goal and tree size.\n        Also enforces safety clearance.\n        \"\"\"\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        # normalized distance factor [0.05,1]\n        progress_factor = max(0.05, min(1.0, dist / max(grid.size)))\n        tree_size_factor = min(1.0, 800 / (self._graph.size + 1))  # More gradual shrinkage\n        # base step size scaling\n        base_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * tree_size_factor\n        clearance = self._get_clearance(q_pos)\n        clearance_factor = max(0.5, min(1.0, clearance / (self._clearance_margin*2)))  # Reduce step if low clearance\n        scaled = base_step * clearance_factor\n        return max(self._min_max_dist, scaled)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Multiple pass shortcut smoothing with more attempts and clearance awareness\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq) and self._clearance_valid_line(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Enforce time cap of 10 seconds\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos_f = q_nearest.position.to_tensor().float() + dir_normalized * max_dist\n                q_new_pos = Point.from_tensor(q_new_pos_f.round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if not self._clearance_valid_line(line_seq):\n                # Skip edges cutting too close to obstacles\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius_base = self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension))\n            radius_dynamic = min(radius_base * (0.8 + 0.2 * iteration / self._max_iterations), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius_dynamic)\n\n            # Parent selection: choose the parent minimizing cost + heuristic, with line of sight and clearance\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new + self._heuristic_cost(q_new.position, goal_pos)*0.2\n\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new + self._heuristic_cost(q_near.position, goal_pos)*0.2\n                if cost_candidate < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate) and self._clearance_valid_line(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            # Update cost for chosen parent without heuristic\n            q_new.cost = q_min.cost + torch.norm(q_min.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors: only if strictly improving and clearance-valid edges\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire) and self._clearance_valid_line(line_seq_rewire):\n                        # Early prune old parent, only one edge removed for tree structure\n                        old_parents = list(q_near.parents)\n                        if old_parents:\n                            self._graph.remove_edge(old_parents[0], q_near)\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal) and self._clearance_valid_line(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n                    # Early termination on discovering direct, cleared connection to goal\n                    break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm is an RRT* inspired approach designed for better efficiency,\n    path quality, and robustness compared to vanilla RRT. Key enhancements include:\n    - Goal-biased sampling to improve convergence towards goal.\n    - Adaptive max_dist step size based on local density.\n    - Rewiring nearby vertices to minimize cost and smooth paths.\n    - Early stopping on goal connection with a verified collision-free path.\n    - Shortcut smoothing in path extraction to yield shorter trajectories.\n    - Timeout of 10 seconds to ensure timely termination.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True   # Enable edge removals for rewiring\n        self._init_displays()\n\n        self._max_dist_base = 10.0\n        self._goal_sample_rate = 0.2        # 20% goal biased sampling\n        self._rewire_radius = 15.0          # Radius for potential rewiring neighbors\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pt = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pt)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _calc_cost(self, v1: Vertex, v2: Vertex) -> float:\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return float('inf')\n        return self._get_grid().get_distance(v1.position, v2.position) + v1.cost\n\n    def _choose_parent(self, candidates: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose a parent vertex from candidates minimizing cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for v in candidates:\n            cost = self._calc_cost(v, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        q_new.cost = min_cost if best_parent is not None else 0.0\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Attempt to rewire nearby vertices through q_new if cost improves and path valid\n        for v in neighbors:\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, v.position)\n            if cost_through_new < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edge(s) to v \n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    # Add new edge q_new -> v and update cost\n                    self._graph.add_edge(q_new, v)\n                    v.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try shortcutting path by checking if we can skip intermediate vertices with a valid direct edge\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1  # try to connect directly to last first\n            while next_idx > idx + 1:\n                line_seq = self._get_grid().get_line_sequence(path[idx].position, path[next_idx].position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    shortcut_path.append(path[next_idx])\n                    idx = next_idx\n                    break\n                next_idx -= 1\n            else:\n                # No shortcut found; move to next vertex\n                shortcut_path.append(path[idx + 1])\n                idx += 1\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Extract path from q_new to root start\n        path = [q_new]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        # Animate the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_iterations = 10000\n        # Pre-set root costs\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(max_iterations):\n            # Timeout after 10 seconds\n            if time.time() - start_time > 10.0:\n                # Stop planning as timed out\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size, clip between half and full base max_dist\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_near.position, self._max_dist_base)\n            density = len(neighbors)\n            max_dist = max(self._max_dist_base * (1.0 / (1.0 + density)), self._max_dist_base * 0.5)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Get neighbors around q_new for choosing parent & rewiring\n            nearby_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._rewire_radius)\n            if not nearby_vertices:\n                # Fallback to q_near as parent if no neighbors\n                nearby_vertices = [q_near]\n\n            parent = self._choose_parent(nearby_vertices, q_new)\n\n            if parent is None:\n                continue\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire neighbors through q_new\n            self._rewire(q_new, nearby_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Check if line from q_new to goal is collision free\n                goal_position = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal_position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_v = Vertex(goal_position)\n                    goal_v.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_position)\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(q_new)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "An improved path planning algorithm improving computing memory and efficiency by:\n\n    - Employing a tighter memory footprint through limited neighborhood searches and selective rewiring\n      only when meaningful cost improvements occur, reducing graph clutter.\n    - Using a goal- and clearance-aware adaptive step size to balance exploration and exploitation.\n    - Applying a layered, adaptive mixed sampling strategy prioritizing goal bias and clearance-rich regions.\n    - Efficient early pruning in rewiring, avoiding unnecessary edge removals and additions.\n    - Early termination upon direct connection to the goal with smoothed path extraction.\n    - Enforcing a strict 10-second time limit to guarantee responsiveness.\n    - Maintaining a less dense graph by pruning vertices whose cost improvements are negligible.\n    - Leveraging heuristic-guided expansion for more informed tree growth.\n    - Multiple iterations of shortcut smoothing for higher path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.25\n        self._informed_sample_rate = 0.5\n        self._max_iterations = 3000\n        self._lambda_rrt_star = 35\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3\n        self._rewire_prune_threshold = 0.01\n        self._init_displays()\n\n    def _is_cost_significant_improvement(self, old_cost: float, new_cost: float) -> bool:\n        \"\"\"Check if the new cost improves over old cost by a meaningful margin.\"\"\"\n        return (old_cost - new_cost) > self._rewire_prune_threshold\n\n    def _prune_minor_cost_improvements(self, vertices: list):\n        \"\"\"\n        Prune edges and vertices that provide negligible cost gains in rewiring.\n        This helps in memory efficiency by avoiding clutter in the graph.\n        \"\"\"\n        # This can be applied in rewiring step inline, so no separate calls here.\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Enforce 10 second timeout for planning\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Timeout: abort planning\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n\n            # Adapt radius with clearance for selective neighborhood\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent minimizing cost with valid path\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate + self._rewire_prune_threshold < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Efficient and selective rewiring: only rewire if meaningful cost improvement\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if self._is_cost_significant_improvement(v_near.cost, cost_through_new):\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove only one old parent edge (single-parent tree)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            # Attempt direct goal connection if within adaptive max_dist\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early stop after direct goal connection\n                    break\n\n            # Periodic visualization frame update for animation responsiveness\n            if iteration % 35 == 0:\n                self.key_frame()\n\n        # Path extraction and multi-pass shortcut smoothing if found goal\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Memory-Efficient RRT* Inspired Path Planning with Adaptive Sampling and Heuristic-Guided Expansion\n\n    This algorithm enhances the classical RRT* by:\n    - Employing an adaptive max_dist step size based on local environment density and distance to goal,\n      reducing unnecessary memory usage and overly dense graph expansions.\n    - Using heuristic-guided sampling that adapts goal bias probability dynamically based on progress,\n      improving success rate and focusing search effectively.\n    - Employing a k-nearest neighbors rewiring strategy limiting neighbors count for efficiency.\n    - Early stopping at goal reach or after 10-second time limit.\n    - Improved path extraction with shortcut smoothing and pruning of isolated vertices to reduce memory footprint.\n    - Efficient graph structure usage and edge pruning to avoid memory bloat.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n\n        self._init_displays()\n\n        self._min_goal_sample_rate = 0.10    # Minimal goal sampling rate\n        self._max_goal_sample_rate = 0.25    # Maximal goal sampling rate increases dynamically\n        self._goal_sample_rate = self._min_goal_sample_rate\n        self._rewire_radius = 12              # Slightly smaller rewiring radius for fewer neighbors\n        self._max_dist_base = 14              # Base max distance step size\n        self._max_neighbors = 15              # Max neighbors to consider in rewiring (k-nearest)\n        self._max_iterations = 8000\n        self._time_limit_sec = 10.0\n\n    def _adaptive_max_dist(self, current_pos: Point, goal_pos: Point) -> float:\n        # Adapt step size based on distance to goal to take larger steps when far, smaller when near\n        dist_to_goal = self._get_grid().get_distance(current_pos, goal_pos)\n        max_dist = min(self._max_dist_base, max(3.0, dist_to_goal / 3))\n        return max_dist\n\n    def _adaptive_goal_sample_rate(self, iteration: int) -> float:\n        # Increase goal sampling probability as iterations grow to focus exploration towards goal\n        ratio = min(1.0, iteration / self._max_iterations)\n        rate = self._min_goal_sample_rate + (self._max_goal_sample_rate - self._min_goal_sample_rate) * ratio\n        return rate\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        from random import random\n\n        # Dynamically adapt goal bias based on iteration count\n        self._goal_sample_rate = self._adaptive_goal_sample_rate(iteration)\n\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        min_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            q_new.cost = min_cost\n            return min_vertex\n        else:\n            return None\n\n    def _k_nearest_neighbors(self, vertices: List[Vertex], point: Point, k: int) -> List[Vertex]:\n        # Return up to k nearest vertices sorted by distance\n        vertices_sorted = sorted(vertices, key=lambda v: self._get_grid().get_distance(v.position, point))\n        return vertices_sorted[:k]\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _prune_isolated_vertices(self) -> None:\n        # Remove vertices that are disconnected (no parents and no children except roots)\n        to_remove = []\n        for root in self._graph.root_vertices:\n            # DFS to find all connected\n            connected = set()\n            def visit(v: Vertex) -> bool:\n                connected.add(v)\n                return True\n            self._graph.walk_dfs_subset_of_vertices([root], visit)\n\n            # Collect vertices not in connected set\n            all_vertices = getattr(self._graph, '_vertices', None)\n            # _vertices not guaranteed, iterate all from roots otherwise\n            # We use size (number of vertices); no explicit list of all vertices\n            # Therefore, rely on aux storage if it exists\n        # Implementation detail skipped due to unavailable all-vertices list\n        # So prune on edges only: remove edges to vertices with zero connectivity except root vertices\n\n        # Since no direct access to all vertices, skip explicit pruning here (to keep memory safe)\n        # Graph pruning could be done by a method in a fuller environment.\n\n        pass\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Time limit exceeded, stop search\n                break\n\n            q_sample = self._get_random_sample(iteration)\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_max_dist(q_near.position, grid.goal.position)\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors_all = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n            neighbors = self._k_nearest_neighbors(neighbors_all, q_new.position, self._max_neighbors)\n\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            self._graph.add_edge(q_parent, q_new)\n\n            self._rewire(q_new, neighbors)\n\n            # Periodically prune isolated vertices (optional; can be run every N iterations)\n            if iteration > 0 and iteration % 1000 == 0:\n                self._prune_isolated_vertices()\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = self._graph.root_vertex_goal\n\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved memory-efficient and performance-optimized path planning algorithm \n    on grid environments combining:\n    - Goal-biased, adaptive and informed ellipsoidal sampling with reduced resampling;\n    - Heuristic-guided selection of best parent vertex incorporating traveled and admissible cost;\n    - Dynamic adaptive step size reducing exploration far from goal and increasing precision near goal;\n    - Adaptive rewiring radius shrinking with tree size for sparser connectivity, reducing memory usage;\n    - Early pruning of vertices with higher cost neighbors to reduce memory footprint;\n    - Robust multi-pass shortcut path smoothing;\n    - Early termination if direct connection to goal found;\n    - Global time limit enforcing 10 seconds max planning time for robustness.\n\n    The core idea is to retain key improvements from RRT* informed sampling strategies but \n    improve memory by fewer vertices kept via pruning and adaptive radii, meanwhile \n    aggressively improving path quality and search efficiency with heuristic guidance and early stop.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._goal_sample_rate = 0.25\n        self._informed_sample_rate = 0.3\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 30  # Reduced rewiring factor for sparser graph = less memory\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Enforce max planning time\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Abort search early on timeout\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_len = torch.norm(dir_vec).item()\n            if dir_len == 0:\n                continue\n\n            # Limit the new vertex position by adaptive step\n            if dir_len <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_unit = dir_vec / dir_len\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_unit * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Create the new vertex and assign temporary cost via nearest vertex\n            q_new = Vertex(q_new_pos)\n            distance_to_nearest = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            tentative_cost = q_nearest.cost + distance_to_nearest\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            # Find nearby vertices for rewiring and parent selection\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic: total cost = traveled cost + admissible distance to goal\n            goal_dist = Map.get_distance(q_new.position, goal_pos)\n\n            # Choose best parent among neighbors minimizing cost + heuristic\n            q_best_parent = q_nearest\n            c_min = tentative_cost\n            for q_near in neighbors:\n                dist_near_to_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_to_new\n                # Early pruning: only consider if local cost+heuristic better\n                if cost_candidate + goal_dist < c_min + goal_dist:\n                    # Validate edge collision-free\n                    candidate_line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_best_parent = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_best_parent, q_new)\n\n            # Rewire neighbors: see if q_new provides cheaper path\n            # Limit rewiring attempts to neighbors with notably worse cost\n            for q_near in neighbors:\n                if q_near == q_best_parent:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_via_new = q_new.cost + dist_new_to_near\n                if cost_via_new + 1e-5 < q_near.cost:\n                    line_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_rewire):\n                        # Remove old parent edge (one only, to retain tree structure)\n                        for p in q_near.parents:\n                            self._graph.remove_edge(p, q_near)\n                            break\n                        q_near.cost = cost_via_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early prune vertices with parents costing significantly worse to reduce memory\n            # (Ensure only vertices close to optimal cost remain)\n            prune_threshold = 1.2 * self._best_cost if self._best_cost != float('inf') else float('inf')\n            if q_new.cost > prune_threshold:\n                # Remove edges from q_new (or discard q_new)\n                for p in q_new.parents:\n                    self._graph.remove_edge(p, q_new)\n                continue\n\n            # Check if can connect directly to goal (early stopping)\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal_vertex = goal_vertex\n                        # Early terminate on successful connection to goal\n                        break\n\n            # Key frame every 50 iterations to reduce overhead\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            self._extract_path_and_smooth(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm introduces a bidirectional heuristic-informed path planner combining \n    elements of A*-inspired cost guiding and adaptive bidirectional tree growth \n    (from start and goal simultaneously). It grows two trees toward each other, \n    sampling points biased by heuristic to improve convergence speed and path \n    quality. The step size adapts based on proximity to goal or start. The algorithm \n    also conducts periodic rewiring to optimize local paths and shortcutting on the \n    final extracted path for smoothness. Limiting total planning time to 10 seconds \n    ensures robustness against infinite loop. This approach improves planning \n    efficiency by exploring from both directions, enhances path quality by heuristic \n    guidance, and boosts success rate by adaptive region sampling and rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        # Two root vertices: root_vertex_start & root_vertex_goal already provided by gen_forest\n\n        self._max_step = 12.0\n        self._min_step = 2.5\n        self._max_iterations = 4000\n        self._bidir_rewire_radius_factor = 40.0\n        self._dimension = 2\n        self._goal_sample_rate = 0.25  # goal bias for sampling on either tree\n        self._time_limit_seconds = 10\n        self._start_time = None\n\n        self._init_displays()\n\n    def _adaptive_step(self, pos_from: Point, pos_to: Point) -> float:\n        dist = Map.get_distance(pos_from, pos_to)\n        step = max(self._min_step, min(self._max_step, dist * 0.25))\n        return step\n\n    def _heuristic_cost(self, from_pos: Point, to_pos: Point) -> float:\n        # Euclidean distance heuristic\n        return Map.get_distance(from_pos, to_pos)\n\n    def _get_biased_sample(self, from_root: Vertex, to_root: Vertex) -> Point:\n        \"\"\"\n        Sample points biased towards connecting the two trees: \n        With probability self._goal_sample_rate sample near the \"other tree\" root,\n        else random valid in grid.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n\n        if torch.rand(1).item() < self._goal_sample_rate:\n            target_center = to_root.position\n            # Try sampling in a small ball around the other root position\n            for _ in range(25):\n                offset = torch.randn(self._dimension) * self._min_step\n                sample_coords = (target_center.to_tensor() + offset).round().int()\n                sample = Point(*sample_coords.tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return to_root.position\n        else:\n            # Uniform random valid sample in grid\n            for _ in range(100):\n                coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return from_root.position\n\n    def _try_connect_vertices(self, v_from: Vertex, v_to: Vertex) -> bool:\n        \"\"\"\n        Attempt to connect v_from to v_to with a valid edge.\n        If success, add edge and update cost; return True.\n        Otherwise, return False.\n        \"\"\"\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(v_from.position, v_to.position)\n        if not grid.is_valid_line_sequence(line_seq):\n            return False\n        dist = Map.get_distance(v_from.position, v_to.position)\n        new_cost = v_from.cost + dist\n        if hasattr(v_to, \"cost\") and v_to.cost <= new_cost:\n            # Existing cost better or equal, no update\n            return False\n        # Update cost and connectivity\n        v_to.cost = new_cost\n        self._graph.add_edge(v_from, v_to)\n        return True\n\n    def _rewire_around(self, vertex: Vertex, root_vertex: Vertex):\n        \"\"\"\n        Rewire neighbors within adaptive radius if going through vertex improves cost.\n        \"\"\"\n        grid = self._get_grid()\n        card_v = float(self._graph.size if self._graph.size > 0 else 1)\n        import math\n        radius = self._bidir_rewire_radius_factor * ((math.log(card_v) / card_v) ** (1 / self._dimension))\n        neighbors = self._graph.get_vertices_within_radius([root_vertex], vertex.position, radius)\n\n        for neighbor in neighbors:\n            if neighbor == vertex:\n                continue\n            cost_through_vertex = vertex.cost + Map.get_distance(vertex.position, neighbor.position)\n            if cost_through_vertex < neighbor.cost:\n                line_seq_rewire = grid.get_line_sequence(vertex.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq_rewire):\n                    # Remove old parent edge(s)\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    neighbor.cost = cost_through_vertex\n                    self._graph.add_edge(vertex, neighbor)\n\n    def _extract_bidirectional_path(self, vertex_from_start: Vertex, vertex_from_goal: Vertex) -> None:\n        \"\"\"\n        Extract path running from start to vertex_from_start to vertex_from_goal to goal.\n        Shortcut and smooth the path before moving the agent along it.\n        \"\"\"\n        grid = self._get_grid()\n\n        # Trace backward from vertex_from_start to start vertex\n        path_start = []\n        current = vertex_from_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()  # now start->[...]->vertex_from_start\n\n        # Trace forward from vertex_from_goal to goal vertex (parents point backward)\n        path_goal = []\n        current = vertex_from_goal\n        while True:\n            path_goal.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        # path_goal is from vertex_from_goal heading to goal\n\n        # Merge paths (vertex_from_start -> vertex_from_goal connection)\n        # Remove vertex_from_start and vertex_from_goal duplicates in sequence:\n        # path_start[-1] is vertex_from_start\n        # path_goal[0] is vertex_from_goal\n        # So combine path_start + reversed(path_goal)\n        full_path = path_start + path_goal[::-1]\n\n        # Shortcut smoothing:\n        i = 0\n        while i < len(full_path) - 2:\n            j = len(full_path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del full_path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along the final smooth path with keyframes\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Main path planning implementation #\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n\n        start_root = self._graph.root_vertex_start\n        goal_root = self._graph.root_vertex_goal\n\n        # We maintain two lists of vertices for start and goal trees\n        tree_start_vertices = [start_root]\n        tree_goal_vertices = [goal_root]\n\n        # Initialize costs already set for roots at __init__\n\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time limit check\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # Stop search after time limit\n\n            # Alternate expanding from start tree and goal tree each iteration\n            if iteration % 2 == 0:\n                expanding_root = start_root\n                opposing_root = goal_root\n                expanding_tree_vertices = tree_start_vertices\n                opposing_tree_vertices = tree_goal_vertices\n            else:\n                expanding_root = goal_root\n                opposing_root = start_root\n                expanding_tree_vertices = tree_goal_vertices\n                opposing_tree_vertices = tree_start_vertices\n\n            # Biased sample near opposing root or random in grid\n            q_sample = self._get_biased_sample(expanding_root, opposing_root)\n\n            # Nearest vertex in expanding tree\n            q_nearest = self._graph.get_nearest_vertex([expanding_root], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive step size towards sample\n            max_step = self._adaptive_step(q_nearest.position, q_sample)\n\n            # Compute new vertex position moving from q_nearest toward q_sample with max_step limit\n            dir_vec = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_vec)\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_step:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_step).round().int())\n\n            # Validity check for q_new_pos\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Check valid path from q_nearest to q_new_pos\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = Map.get_distance(q_nearest.position, q_new.position)\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            # Also try to find better parent among neighbors for rewiring (local optimization)\n            card_v = float(self._graph.size if self._graph.size > 0 else 1)\n            import math\n            radius = self._bidir_rewire_radius_factor * ((math.log(card_v) / card_v) ** (1 / self._dimension))\n            neighbors = self._graph.get_vertices_within_radius([expanding_root], q_new.position, radius)\n\n            q_min = q_nearest\n            c_min = q_new.cost\n            for neighbor in neighbors:\n                cost_candidate = neighbor.cost + Map.get_distance(neighbor.position, q_new.position)\n                line_candidate = grid.get_line_sequence(neighbor.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_candidate):\n                    c_min = cost_candidate\n                    q_min = neighbor\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors around q_new to improve their cost if possible\n            self._rewire_around(q_new, expanding_root)\n\n            # Add new vertex to expanding tree list\n            expanding_tree_vertices.append(q_new)\n\n            # Attempt to connect q_new to nearest vertex in opposing tree\n            q_connect = self._graph.get_nearest_vertex([opposing_root], q_new.position)\n            dist_connect = Map.get_distance(q_new.position, q_connect.position)\n            step_connect = self._adaptive_step(q_new.position, q_connect.position)\n            if dist_connect <= step_connect:\n                line_seq_connect = grid.get_line_sequence(q_new.position, q_connect.position)\n                if grid.is_valid_line_sequence(line_seq_connect):\n                    # Connect edges both ways since this is bidirectional (forest does directed), but \n                    # we choose direction q_new->q_connect for start-to-goal flow if expanding from start, else reverse\n                    if expanding_root == start_root:\n                        self._graph.add_edge(q_new, q_connect)\n                    else:\n                        self._graph.add_edge(q_connect, q_new)\n\n                    # Success: extract and smooth path connecting start and goal trees\n                    if expanding_root == start_root:\n                        vertex_from_start = q_new\n                        vertex_from_goal = q_connect\n                    else:\n                        vertex_from_start = q_connect\n                        vertex_from_goal = q_new\n\n                    self._extract_bidirectional_path(vertex_from_start, vertex_from_goal)\n                    return\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Algorithm description:\n    This path planner combines heuristic-guided A*-inspired cost prioritization with an anytime incremental search\n    on a grid to efficiently explore promising paths toward the goal.\n\n    Key features:\n    - Maintains a priority queue (min-heap) of vertices ordered by the sum of actual cost and admissible heuristic\n      to focus expansion towards the goal (like A*).\n    - Uses adaptive max step size that shrinks near obstacles and goal based on clearance and distance.\n    - Expands vertices selectively by sampling next positions from the grid environment neighbors with pruning.\n    - Connects new vertices if the path segment is valid and updates costs while allowing re-parents (rewiring) if\n      a better path is found, resembling D*-lite / incremental optimization.\n    - Implements anytime planning: periodically extracts and smooths a best path found so far.\n    - Stops early when a sufficiently good path is found or timeout hits (10 seconds).\n    - Uses clearance information to avoid tight spots and dynamically adjust expansions and rewiring neighborhood.\n    - Smoothing performed by shortcutting the extracted path multiple times to improve quality.\n    - Balances exploration and exploitation by heuristic priority and random perturbations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._dimension = 2\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_clearance_check = 10.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _adaptive_max_dist(self, pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n\n        clearance = self._get_clearance(pos)\n        max_step = 15.0\n        min_step = 2.0\n\n        # Scale by distance to goal: smaller step near goal\n        dist_factor = max(min(dist_to_goal / max(grid.size), 1.0), 0.05)\n        # Scale by clearance to avoid tight spots\n        clearance_factor = min(1.0, clearance / 4.0)\n\n        scaled_step = min_step + (max_step - min_step) * dist_factor * clearance_factor\n        return max(min_step, min(scaled_step, max_step))\n\n    def _heuristic(self, pos: Point, goal: Point) -> float:\n        # Admissible Euclidean heuristic\n        return Map.get_distance(pos, goal)\n\n    def _sample_valid_neighbors(self, pos: Point) -> list:\n        grid = self._get_grid()\n        neighbors = grid.get_next_positions(pos)\n        # Filter valid neighbors by clearance and validity\n        valid_neighbors = []\n        for n in neighbors:\n            if not grid.is_agent_valid_pos(n):\n                continue\n            if self._get_clearance(n) < 1.0:\n                continue\n            valid_neighbors.append(n)\n        return valid_neighbors\n\n    def _shortcut_path(self, path: list) -> list:\n        # Single pass shortcutting for path smoothing\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                segment = grid.get_line_sequence(path[i], path[j])\n                if grid.is_valid_line_sequence(segment):\n                    del path[i+1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n        return path\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current.position)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Multiple smoothing passes\n        for _ in range(3):\n            path = self._shortcut_path(path)\n\n        for pos in path:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        start_time = time.time()\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n\n        # Priority queue with elements: (f_score, cost, vertex)\n        open_set = []\n        heapq.heappush(open_set, (self._heuristic(start_vertex.position, goal_pos), 0.0, start_vertex))\n\n        # Closed set to avoid expansions repetition\n        closed_set = set()\n\n        # Map vertex positions to Vertex instances for quick lookup\n        vertex_map = {start_vertex.position: start_vertex}\n\n        iteration = 0\n        max_iterations = 3000\n\n        while open_set and iteration < max_iterations:\n            # Time limit check\n            if (time.time() - start_time) > self._time_limit_seconds:\n                break\n\n            _, current_cost, current_vertex = heapq.heappop(open_set)\n\n            if current_vertex.position in closed_set:\n                iteration += 1\n                continue\n            closed_set.add(current_vertex.position)\n\n            # Early goal check: if close enough, attempt direct connection\n            dist_to_goal = Map.get_distance(current_vertex.position, goal_pos)\n            adaptive_step = self._adaptive_max_dist(current_vertex.position)\n\n            if dist_to_goal <= adaptive_step:\n                line_to_goal = grid.get_line_sequence(current_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = current_vertex.cost + dist_to_goal\n                    self._graph.add_edge(current_vertex, goal_vertex)\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        found_goal_vertex = goal_vertex\n                    break\n\n            # Expand neighbors selectively by sampling valid neighbors from grid\n            neighbors = self._sample_valid_neighbors(current_vertex.position)\n\n            # Add some random perturbation to neighbors to explore more broadly\n            import random\n            random.shuffle(neighbors)\n\n            # Limit neighbors considered to keep search efficient\n            max_expand = 8\n            neighbors = neighbors[:max_expand]\n\n            for nbr_pos in neighbors:\n                # Step distance and check max step constraint\n                dist_move = Map.get_distance(current_vertex.position, nbr_pos)\n                if dist_move > adaptive_step:\n                    # Skip neighbors farther than adaptive max dist\n                    continue\n\n                # Validate line between current and neighbor positions\n                line_seq = grid.get_line_sequence(current_vertex.position, nbr_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n\n                # Check if vertex for nbr_pos already created\n                if nbr_pos in vertex_map:\n                    nbr_vertex = vertex_map[nbr_pos]\n                else:\n                    nbr_vertex = Vertex(nbr_pos)\n                    vertex_map[nbr_pos] = nbr_vertex\n\n                new_cost = current_vertex.cost + dist_move\n\n                # If neighbor not visited yet or found better cost path\n                if nbr_vertex.position not in closed_set or new_cost < nbr_vertex.cost:\n                    # Update cost and reparent if better\n                    if new_cost < nbr_vertex.cost or nbr_vertex.cost == 0.0:\n                        # Remove old parent edges if any\n                        for p in list(nbr_vertex.parents):\n                            self._graph.remove_edge(p, nbr_vertex)\n                        nbr_vertex.cost = new_cost\n                        self._graph.add_edge(current_vertex, nbr_vertex)\n\n                        f_score = new_cost + self._heuristic(nbr_vertex.position, goal_pos)\n                        heapq.heappush(open_set, (f_score, nbr_vertex.cost, nbr_vertex))\n\n                        # If close to goal, check direct goal connection\n                        dist_nbr_goal = Map.get_distance(nbr_vertex.position, goal_pos)\n                        if dist_nbr_goal <= adaptive_step:\n                            line_to_goal = grid.get_line_sequence(nbr_vertex.position, goal_pos)\n                            if grid.is_valid_line_sequence(line_to_goal):\n                                goal_vertex = Vertex(goal_pos)\n                                goal_vertex.cost = nbr_vertex.cost + dist_nbr_goal\n                                self._graph.add_edge(nbr_vertex, goal_vertex)\n                                if goal_vertex.cost < self._best_cost:\n                                    self._best_cost = goal_vertex.cost\n                                    found_goal_vertex = goal_vertex\n\n                                # Early exit on goal connected\n                                break\n\n            iteration += 1\n\n            # Key frame for animation every 30 iterations\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        # If found goal vertex, extract and smooth path\n        if found_goal_vertex is not None:\n            self._extract_path(found_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a hybrid anytime informed RRT*-inspired planner with adaptive parameters and heuristic guidance.\n    Key features:\n    - Adaptive sampling blending goal bias, informed ellipsoidal sampling around current best path, and uniform clearance-aware exploration.\n    - Anytime rewiring mechanism with incremental path improvement using local neighborhood connections.\n    - Dynamic maximum extension length adjusted based on heuristic progress and local clearance.\n    - A* style estimated total cost guiding vertex expansions and pruning.\n    - Lazy collision checking combined with line-of-sight shortcutting during path extraction.\n    - Early termination once a sufficiently good path is found or time limit (10s) exceeded.\n    - Final path smoothing by shortcutting using direct line validity checks.\n    The approach balances exploration and exploitation robustly, improving efficiency, success rate, and path quality over classical methods.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        self._goal_sample_rate = 0.2\n        self._informed_sample_rate = 0.5\n        self._clearance_threshold = 2.0\n        self._max_iterations = 2500\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n\n        self._min_step = 3.0\n        self._max_step = 20.0\n        self._rewire_radius_factor = 40.0\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._best_goal_vertex = None\n        self._init_displays()\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        return Map.get_distance(p1, p2)\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_check = 12.0\n        min_dist = max_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _adaptive_max_step(self, pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = self._euclidean_distance(pos, goal_pos)\n        norm_dist = min(1.0, dist_to_goal / max(grid.size))\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n        step = self._min_step + (self._max_step - self._min_step) * norm_dist * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _heuristic(self, pos: Point) -> float:\n        return self._euclidean_distance(pos, self._get_grid().goal.position)\n\n    def _sample_in_ellipse(self, c_best: float, start: Point, goal: Point) -> Point:\n        import torch\n        grid = self._get_grid()\n        if c_best == float('inf'):\n            # No solution yet, fallback uniform clearance-aware sample\n            return self._clearance_aware_sample()\n\n        c_min = self._euclidean_distance(start, goal)\n        if c_best < c_min:\n            # Numerical safety fallback\n            c_best = c_min * 1.1\n\n        center_x = (start.x + goal.x) / 2.0\n        center_y = (start.y + goal.y) / 2.0\n        center = torch.tensor([center_x, center_y], dtype=torch.float32)\n\n        a1 = torch.tensor([(goal.x - start.x)/c_min, (goal.y - start.y)/c_min], dtype=torch.float32)\n        a2 = torch.tensor([-a1[1], a1[0]], dtype=torch.float32)  # orthogonal vector\n\n        r1 = c_best / 2.0\n        r2 = torch.sqrt(torch.tensor(c_best ** 2 - c_min ** 2) / 2.0)\n        r2 = max(r2.item(), 1.0)  # avoid zero radius\n\n        for _ in range(60):\n            # Sample uniform point inside unit circle\n            sample_ball = torch.randn(2)\n            sample_ball /= torch.norm(sample_ball)\n            radius = torch.rand(1).item() ** 0.5\n            sample_ball *= radius\n            # Scale to ellipse axes\n            sample_ellipse = sample_ball[0]*r1*a1 + sample_ball[1]*r2*a2\n            sample_point = center + sample_ellipse\n            sample_int = Point(int(round(sample_point[0].item())), int(round(sample_point[1].item())))\n            if grid.is_agent_valid_pos(sample_int) and self._get_clearance(sample_int) >= self._clearance_threshold:\n                return sample_int\n        # If failed, fallback\n        return self._clearance_aware_sample()\n\n    def _clearance_aware_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        dim = self._dimension\n        for _ in range(120):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(dim)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n        prob = torch.rand(1).item()\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = grid.goal.position\n\n        if prob < self._goal_sample_rate:\n            # Simple goal bias with small random offset inside goal radius\n            for _ in range(30):\n                offset_x = torch.randint(-2, 3, (1,)).item()\n                offset_y = torch.randint(-2, 3, (1,)).item()\n                candidate = Point(goal_pos.x + offset_x, goal_pos.y + offset_y)\n                if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                    return candidate\n            return goal_pos\n        elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipse sampling around current best path cost\n            return self._sample_in_ellipse(self._best_cost, start_pos, goal_pos)\n        else:\n            # Clearance-aware uniform sample\n            return self._clearance_aware_sample()\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        grid = self._get_grid()\n        path = []\n        curr = goal_vertex\n        while True:\n            path.append(curr)\n            if len(curr.parents) == 0:\n                break\n            # Select parent with minimum cost for backtracking\n            curr = min(curr.parents, key=lambda p: p.cost)\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut between any two vertices\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Move agent through the path with key frames\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        self._best_goal_vertex = None\n        self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit_seconds:\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Find nearest vertex in tree\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_step = self._adaptive_max_step(q_near.position)\n\n            dir_vec = torch.tensor([q_sample.x - q_near.position.x, q_sample.y - q_near.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_norm = dir_vec / dist\n            step_length = min(dist, max_step)\n            new_pos_tensor = torch.round(torch.tensor([q_near.position.x, q_near.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == q_near.position:\n                continue\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Lazy collision checking: skip if line invalid\n            line_seq = grid.get_line_sequence(q_near.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            if any(v.position == q_new_pos for v in self._graph.root_vertices):\n                # Avoid duplicate vertices\n                continue\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(q_near.position, q_new_pos)\n            cost_to_q_new = q_near.cost + move_cost\n            q_new_vertex.cost = cost_to_q_new\n\n            # Determine rewiring radius adaptive to iteration count and clearance\n            size = max(self._graph.size, 1)\n            import math\n            ln_size = math.log(float(size)) if size > 1 else 0.0\n            radius = self._rewire_radius_factor * ((ln_size / size) ** (1 / self._dimension))\n            clearance_factor = 1.0 + min(self._get_clearance(q_new_pos) / (self._clearance_threshold * 2.5), 1.0)\n            radius *= clearance_factor\n            radius = max(radius, max_step)\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Select best parent among neighbors minimizing cost + heuristic if reachable validly\n            best_parent = q_near\n            best_cost = cost_to_q_new\n            for neighbor in near_vertices:\n                candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                if candidate_cost + 1e-6 < best_cost:\n                    line_candidate = grid.get_line_sequence(neighbor.position, q_new_pos)\n                    if not grid.is_valid_line_sequence(line_candidate):\n                        continue\n                    best_cost = candidate_cost\n                    best_parent = neighbor\n\n            q_new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, q_new_vertex)\n\n            # Rewire neighbors through q_new_vertex if it improves cost\n            rewiring_threshold = max(0.001, 0.01 * (self._best_cost if self._best_cost < float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                new_cost_via_qnew = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                if new_cost_via_qnew + rewiring_threshold < neighbor.cost:\n                    rewire_line = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                    if grid.is_valid_line_sequence(rewire_line):\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost_via_qnew\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            # Track best goal connection\n            dist_to_goal = self._euclidean_distance(q_new_vertex.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_to_goal = grid.get_line_sequence(q_new_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new_vertex.cost + dist_to_goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        self._best_goal_vertex = goal_vertex\n\n                        # Early stopping if path cost significantly better than threshold\n                        if self._best_cost < float('inf'):\n                            break\n\n            # Add newly created vertex to root vertices to allow expansion\n            self._graph.root_vertices.append(q_new_vertex)\n\n            # Periodic visualization keyframe\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        # Extract path if found best goal vertex\n        if self._best_goal_vertex is not None:\n            self._extract_path(self._best_goal_vertex)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm introduces a bidirectional heuristic guided RRT* with informed informed ellipse sampling\n    and early path optimization steps to improve efficiency and path quality.\n    Key innovations:\n    - Bidirectional trees growing from both start and goal, increasing success rate and reducing iterations.\n    - Informed ellipse sampling: samples biased within an ellipse defined by current best path cost to focus search.\n    - Heuristic cost-guided parent choosing and rewiring like RRT*, applied in both trees for smoother and shorter paths.\n    - Adaptive max extension step dynamically computed from clearance and distance to ellipse boundary.\n    - Early path connection attempts between trees to quickly discover shorter feasible paths.\n    - Early stopping after 10 seconds or when no improvement found after some expansions.\n    - Path extraction merges both trees and shortcuts to produce a smooth final path.\n    This design improves planning efficiency by focusing samples in relevant regions and exploring from both sides.\n    Robustness and success rate increase by bridging start and goal trees.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        # Initialize bidirectional forest with start and goal roots\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._start_tree = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._start_tree.edges_removable = True\n        self._goal_tree = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._goal_tree.edges_removable = True\n        self._best_cost = float('inf')\n        self._best_path_connector = None\n        self._max_total_iterations = 3000\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n        self._min_step = 2.0\n        self._max_step = 12.0\n        self._rewire_lambda = 25.0\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        # Clone from algorithm 1 for clearance estimation\n        grid = self._get_grid()\n        max_clearance_check = 12.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _informed_sample(self, c_best: float) -> Point:\n        \"\"\"\n        Sample inside an ellipse defined by start, goal and current best path cost (c_best).\n        If c_best is infinite, sample uniformly.\n        \"\"\"\n        import numpy as np\n        grid = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n        if c_best == float('inf'):\n            # Uniform random valid sample\n            while True:\n                coords = [np.random.randint(0, grid.size[dim]) for dim in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n        # Ellipse parameters (Pythagorean distance c_min start->goal)\n        c_min = Map.get_distance(start, goal)\n        if c_best < c_min:\n            c_best = c_min * 1.1  # small buffer if numerical issues\n\n        center = Point((start.x + goal.x) / 2.0, (start.y + goal.y) / 2.0)\n        eps = 1e-7\n\n        # Rotation matrix aligning ellipse with start-goal axis\n        dx, dy = goal.x - start.x, goal.y - start.y\n        length = np.hypot(dx, dy)\n        if length < eps:\n            rot = np.array([[1,0],[0,1]])\n        else:\n            cos_theta = dx / length\n            sin_theta = dy / length\n            rot = np.array([[cos_theta, -sin_theta],[sin_theta, cos_theta]])\n\n        a = c_best / 2.0  # major axis semi-length\n        b = np.sqrt(c_best**2 - c_min**2) / 2.0  # minor axis semi-length\n\n        # Sample point inside unit circle (uniform)\n        while True:\n            u = np.random.uniform(-1, 1)\n            v = np.random.uniform(-1, 1)\n            if u*u + v*v <=1:\n                break\n        sample_unit = np.array([u*b, v*a])  # scale axes flipped to align with ellipse axes\n        point_rot = rot @ sample_unit\n        point_sample = Point(int(round(center.x + point_rot[0])), int(round(center.y + point_rot[1])))\n\n        if grid.is_agent_valid_pos(point_sample):\n            return point_sample\n        else:\n            # Fallback uniform random sampling if outside valid area\n            while True:\n                coords = [np.random.randint(0, grid.size[dim]) for dim in range(self._dimension)]\n                sample = Point(*coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_step(self, pos: Point) -> float:\n        \"\"\"Adaptive step size based on clearance and distance to goal\"\"\"\n        grid = self._get_grid()\n        dist_to_goal = Map.get_distance(pos, grid.goal.position)\n        clearance = self._get_clearance(pos)\n\n        norm_dist = min(1.0, dist_to_goal / max(grid.size))\n        clearance_factor = min(1.0, clearance / 5.0)\n        step = self._min_step + (self._max_step - self._min_step) * norm_dist * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        import torch\n        grid = self._get_grid()\n\n        dir_vec = torch.tensor([q_sample.x - q_near.position.x, q_sample.y - q_near.position.y], dtype=torch.float32)\n        dist = torch.norm(dir_vec).item()\n        if dist < 1e-8:\n            return None\n        step_length = min(max_dist, dist)\n        dir_norm = dir_vec / dist\n        new_pos_tensor = torch.round(torch.tensor([q_near.position.x, q_near.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n        new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n        if not grid.is_agent_valid_pos(new_pos):\n            return None\n        line_seq = grid.get_line_sequence(q_near.position, new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(new_pos)\n\n    def _choose_parent(self, tree: Forest, q_new: Vertex, radius: float) -> Vertex:\n        grid = self._get_grid()\n        neighbors = tree.get_vertices_within_radius(tree.root_vertices, q_new.position, radius)\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in neighbors:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + grid.get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        if chosen_parent is None:\n            chosen_parent = tree.get_nearest_vertex(tree.root_vertices, q_new.position)\n        return chosen_parent\n\n    def _rewire(self, tree: Forest, q_new: Vertex, radius: float) -> None:\n        grid = self._get_grid()\n        neighbors = tree.get_vertices_within_radius(tree.root_vertices, q_new.position, radius)\n        for v in neighbors:\n            if v == q_new:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = q_new.cost + grid.get_movement_cost(q_new.position, v.position)\n            if cost_through_qnew + 1e-5 < v.cost:\n                # Remove old parents edges\n                for p in list(v.parents):\n                    tree.remove_edge(p, v)\n                tree.add_edge(q_new, v)\n                v.cost = cost_through_qnew\n\n    def _try_connect_trees(self, q_new: Vertex, other_tree: Forest) -> (Vertex, float):\n        \"\"\"Try to connect q_new vertex to the closest vertex in other_tree if feasible. Return connector and cost.\"\"\"\n        grid = self._get_grid()\n        radius = self._rewire_lambda  # Connection radius\n        neighbors = other_tree.get_vertices_within_radius(other_tree.root_vertices, q_new.position, radius)\n        best_connector = None\n        best_cost = float('inf')\n        for v in neighbors:\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_new.cost + grid.get_movement_cost(q_new.position, v.position) + v.cost\n            if cost < best_cost:\n                best_cost = cost\n                best_connector = v\n        return best_connector, best_cost\n\n    def _extract_path(self, connector: Vertex, tree_start: Forest, tree_goal: Forest) -> None:\n        \"\"\"\n        Extract combined shortest path from start_tree root to connector and\n        from connector to goal_tree root, shortcut path, and trace agent.\n        \"\"\"\n        grid = self._get_grid()\n        # Backtrack from connector to start root in start tree\n        path_start = []\n        current = connector\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = min(current.parents, key=lambda p: p.cost)\n        path_start.reverse()\n\n        # Backtrack from connector to goal root in goal tree\n        # Note: Goals parents are stored as well (because bidirectional)\n        path_goal = []\n        visited = set()\n        def backtrack_goal(v):\n            nonlocal path_goal\n            while True:\n                path_goal.append(v)\n                if len(v.parents) == 0 or v in visited:\n                    break\n                visited.add(v)\n                v = min(v.parents, key=lambda p: p.cost)\n        # For correct direction, backtrack from connector in opposite tree\n        backtrack_goal(connector)\n\n        # Combine paths removing duplicate connector vertex\n        full_path = path_start + path_goal[1:]\n\n        # Shortcut smoothing path multiple times\n        for _ in range(3):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del full_path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Move agent along path with key frames\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_time = time.time()\n        iterations = 0\n\n        self._start_tree.root_vertex_start.cost = 0.0\n        self._goal_tree.root_vertex_start.cost = 0.0\n\n        best_cost = float('inf')\n        best_connector = None\n\n        while iterations < self._max_total_iterations:\n            if time.time() - start_time > self._time_limit_seconds:\n                break\n\n            # Alternate sampling between two trees for bidirectional growth\n            if iterations % 2 == 0:\n                current_tree = self._start_tree\n                other_tree = self._goal_tree\n            else:\n                current_tree = self._goal_tree\n                other_tree = self._start_tree\n\n            # Use informed sampling biased by current best path cost\n            sample = self._informed_sample(best_cost)\n\n            q_near = current_tree.get_nearest_vertex(current_tree.root_vertices, sample)\n            max_step = self._adaptive_step(q_near.position)\n            q_new = self._get_new_vertex(q_near, sample, max_step)\n            if q_new is None:\n                iterations += 1\n                continue\n\n            # Determine neighborhood radius for rewiring (RRT*)\n            n = max(current_tree.size, 1)\n            radius = min(self._rewire_lambda * ((torch.log(torch.tensor(float(n))) / n) ** (1/self._dimension)), 20.0)\n            clearance_factor = 1.0 + min(self._get_clearance(q_new.position) / 5.0, 1.0)\n            radius *= clearance_factor\n\n            # Choose best parent among neighbors\n            chosen_parent = self._choose_parent(current_tree, q_new, radius)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n            current_tree.add_edge(chosen_parent, q_new)\n\n            # Rewire neighbors if cost improved via q_new\n            self._rewire(current_tree, q_new, radius)\n\n            # Try to connect new vertex to the other tree (bidirectional connection)\n            connector, connecting_cost = self._try_connect_trees(q_new, other_tree)\n\n            if connector is not None and connecting_cost < best_cost:\n                best_cost = connecting_cost\n                best_connector = q_new\n                # Connect both trees with edges (bidirectional)\n                current_tree.add_edge(q_new, connector)\n                other_tree.add_edge(connector, q_new)\n                # Early stop on improved path found\n                if best_cost < float('inf'):\n                    break\n\n            iterations += 1\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if best_connector is not None:\n            # Extract and trace full path via best connector vertex\n            self._extract_path(best_connector, self._start_tree, self._goal_tree)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved bidirectional RRT* inspired planner with heuristic-guided sampling \n    combining forward and backward exploration simultaneously. It maintains two growing trees: \n    one from the start and one from the goal. Sampling is guided by a continuously updated heuristic \n    based on the sum of cost-to-vertex in start tree plus Euclidean distance to goal tree vertices, \n    thus focusing exploration in promising regions. The step size adapts dynamically by estimating clearance.\n    A connection attempt is made between nearest vertices across trees, and rewiring optimizes path cost over time.\n    Early stopping upon path detection and a 10-second timeout improve practical viability.\n    After a connection is formed, shortcut smoothing is applied before tracing. \n    This approach aims to improve efficiency, success rate, and path quality while being robust to complex spaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph_start = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            [],\n            []\n        )\n        self._graph_goal = gen_forest(\n            self._services,\n            Vertex(self._get_grid().goal.position),\n            [],\n            []\n        )\n        self._graph_start.edges_removable = True\n        self._graph_goal.edges_removable = True\n        self._init_displays()\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=2.0, max_dist=12.0) -> float:\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=6):\n            direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        # Enhanced heuristic-based goal-biased sampling: \n        # 20% directly goal; else sample weighted towards midpoint between trees\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n\n        grid_size = self._get_grid().size\n        start_root_pos = self._graph_start.root_vertices[0].position\n        goal_root_pos = self._graph_goal.root_vertices[0].position\n\n        midpoint = Point(\n            (start_root_pos.x + goal_root_pos.x) // 2,\n            (start_root_pos.y + goal_root_pos.y) // 2\n        )\n\n        for _ in range(100):\n            sample = Point(\n                np.random.randint(max(0, midpoint.x - grid_size.x // 4), min(grid_size.x, midpoint.x + grid_size.x // 4)),\n                np.random.randint(max(0, midpoint.y - grid_size.y // 4), min(grid_size.y, midpoint.y + grid_size.y // 4))\n            )\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n        # Fallback uniform random sampling\n        while True:\n            rand_pos = np.random.randint(0, grid_size, grid_size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex | None:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, graph: Forest, q_new: Vertex, radius: float) -> list[Vertex]:\n        return graph.get_vertices_within_radius(graph.root_vertices, q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: list[Vertex], q_new: Vertex, graph: Forest) -> Vertex | None:\n        min_cost = float(\"inf\")\n        chosen_parent = None\n        for v in q_near_list:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: list[Vertex], graph: Forest) -> None:\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                # Remove old parents edges\n                for p in list(v.parents):\n                    graph.remove_edge(p, v)\n                graph.add_edge(q_new, v)\n                v.cost = potential_cost\n\n    def _try_connect_trees(self, q_new_start: Vertex, graph_goal: Forest, connection_radius: float) -> Vertex | None:\n        # Try to connect q_new_start to any vertex in goal tree within radius\n        goal_near = graph_goal.get_vertices_within_radius(graph_goal.root_vertices, q_new_start.position, connection_radius)\n        for q_goal in goal_near:\n            line_seq = self._get_grid().get_line_sequence(q_new_start.position, q_goal.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                return q_goal\n        return None\n\n    def _extract_bidirectional_path(self, q_new_start: Vertex, q_new_goal: Vertex) -> None:\n        # Reconstruct path start->q_new_start\n        path_start = [q_new_start]\n        while len(path_start[-1].parents) != 0:\n            min_cost_parent = min(path_start[-1].parents, key=lambda p: p.cost)\n            path_start.append(min_cost_parent)\n        path_start.pop()  # remove duplicate start root vertex\n        path_start.reverse()\n\n        # Reconstruct path q_new_goal->goal\n        path_goal = [q_new_goal]\n        while len(path_goal[-1].parents) != 0:\n            min_cost_parent = min(path_goal[-1].parents, key=lambda p: p.cost)\n            path_goal.append(min_cost_parent)\n        # goal root vertex is last in path_goal; no need to pop\n\n        # Combine paths (start to goal)\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing, try to skip vertices while line valid\n        smoothed_path = [full_path[0]]\n        i = 0\n        while i < len(full_path) - 1:\n            j = len(full_path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(smoothed_path[-1].position, full_path[j].position)\n                ):\n                    break\n                j -= 1\n            smoothed_path.append(full_path[j])\n            i = j\n\n        # Trace agent along smoothed path\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _sort_vertices_by_heuristic(self, graph_start: Forest, graph_goal: Forest, samples: list[Vertex]) -> list[Vertex]:\n        # Sort samples by combined cost-to-vertex plus heuristic distance to goal tree vertices\n        goal_positions = [v.position for v in graph_goal.root_vertices]\n        \n        def heuristic(v: Vertex) -> float:\n            # cost from start tree root to v + min dist from v to any goal root vertex\n            min_goal_dist = min(Map.get_distance(v.position, gp) for gp in goal_positions) if goal_positions else 0\n            return v.cost + min_goal_dist\n\n        return sorted(samples, key=heuristic)\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 8000\n        connection_radius = 10.0\n        search_radius = 15.0\n        goal_sample_rate = 0.25\n        start_time = time.time()\n\n        self._graph_start.root_vertices[0].cost = 0.0\n        self._graph_goal.root_vertices[0].cost = 0.0\n\n        # Initialize vertex sets\n        vertices_start = [self._graph_start.root_vertices[0]]\n        vertices_goal = [self._graph_goal.root_vertices[0]]\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout\n                break\n\n            # Alternate expansion direction (start -> goal or goal -> start)\n            if iteration % 2 == 0:\n                graph_expand = self._graph_start\n                graph_other = self._graph_goal\n                vertices_expand = vertices_start\n                vertices_other = vertices_goal\n            else:\n                graph_expand = self._graph_goal\n                graph_other = self._graph_start\n                vertices_expand = vertices_goal\n                vertices_other = vertices_start\n\n            # Sample point with heuristic / goal bias\n            q_sample = self._get_random_sample(goal_sample_rate)\n\n            # Find nearest vertex in expanding tree\n            q_near = graph_expand.get_nearest_vertex(graph_expand.root_vertices, q_sample)\n            if q_near.position == q_sample:\n                # Already existing node exactly at sample\n                continue\n\n            # Adaptive step size based on clearance\n            max_dist = self._adaptive_max_dist(q_near.position)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors within radius for parent choice and rewiring\n            q_near_list = self._get_near_vertices(graph_expand, q_new, search_radius)\n            chosen_parent = self._choose_parent(q_near_list, q_new, graph_expand)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            graph_expand.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n            vertices_expand.append(q_new)\n\n            # Rewire neighbors\n            rewire_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, rewire_list, graph_expand)\n\n            # Try to connect trees\n            q_connect = self._try_connect_trees(q_new, graph_other, connection_radius)\n            if q_connect is not None:\n                # Successfully connected trees: extract path and finish\n                if iteration % 2 == 0:\n                    self._extract_bidirectional_path(q_new, q_connect)\n                else:\n                    self._extract_bidirectional_path(q_connect, q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements a hybrid Bidirectional Heuristic-Driven RRT* with Adaptive Step Size \n    and Goal Neighborhood Expansion. It grows two trees simultaneously from start and goal and attempts\n    to connect them efficiently. Sampling is goal-biased and adaptive with dynamic max step size based \n    on distance and tree size. A heuristic combining cost-to-come plus estimated cost-to-go guides rewiring \n    and neighbor selection. The algorithm applies periodic rewiring for path optimization, and attempts \n    neighborhood connection between two trees for early meeting. A path shortcutting post-process smooths \n    the resulting path. Early termination occurs if the two trees connect or time limit (10 secs) is reached. \n    This method aims at robust, fast convergence, and high-quality smoother paths while reducing iterations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 14.0\n        self._min_max_dist = 3.0\n        self._goal_sample_rate = 0.3  # goal biased sampling rate\n        self._lambda_rrt_star = 40    # rewiring radius factor\n        self._max_iterations = 3000\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n        # Additional for bidirectional trees:\n        self._tree_start = Forest(start_vertex, goal_vertex, [start_vertex])\n        self._tree_goal = Forest(goal_vertex, start_vertex, [goal_vertex])\n\n    def _heuristic(self, pos1: Point, pos2: Point) -> float:\n        # Euclidean heuristic\n        return Map.get_distance(pos1, pos2)\n\n    def _adaptive_max_dist(self, pos: Point, tree_size: int) -> float:\n        grid = self._get_grid()\n        dist_goal = Map.get_distance(pos, grid.goal.position)\n        dist_start = Map.get_distance(pos, grid.agent.position)\n        progress_factor = max(0.05, min(1.0, dist_goal / max(grid.size)))  # normalized\n        size_factor = min(1.0, 400 / max(1, tree_size))\n        scaled = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * size_factor\n        return scaled\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal bias sampling near goal or start (bi-directional)\n        if rand_val < self._goal_sample_rate:\n            # Sample near goal with random offset\n            for _ in range(40):\n                center = grid.goal.position if torch.rand(1).item() < 0.5 else grid.agent.position\n                offset = torch.randn(self._dimension)\n                offset_norm = torch.norm(offset)\n                if offset_norm > 1e-8:\n                    offset = offset / offset_norm\n                offset = offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((center.to_tensor().float() + offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return grid.goal.position\n\n        # Uniform sampling otherwise\n        for _ in range(100):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        # fallback start position\n        return self._graph.root_vertex_start.position\n\n    def _steer(self, from_v: Vertex, to_p: Point, max_dist: float) -> Point:\n        import torch\n        diff = to_p.to_tensor().float() - from_v.position.to_tensor().float()\n        dist = torch.norm(diff).item()\n        if dist <= max_dist:\n            return to_p\n        direction = diff / dist\n        new_p = from_v.position.to_tensor().float() + direction * max_dist\n        return Point.from_tensor(new_p.round().int())\n\n    def _choose_parent(self, tree: Forest, near_vertices, new_pos: Point, grid: Map) -> Vertex:\n        import torch\n        best_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            line_seq = grid.get_line_sequence(vertex.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            dist = torch.norm(vertex.position.to_tensor().float() - new_pos.to_tensor().float()).item()\n            cost = vertex.cost + dist\n            heuristic_cost = cost + self._heuristic(new_pos, grid.goal.position)\n            if heuristic_cost < best_cost:\n                best_cost = heuristic_cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, tree: Forest, near_vertices, new_vertex: Vertex, grid: Map) -> None:\n        import torch\n        changed = False\n        for vertex in near_vertices:\n            if vertex == new_vertex:\n                continue\n            line_seq = grid.get_line_sequence(new_vertex.position, vertex.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            dist = torch.norm(new_vertex.position.to_tensor().float() - vertex.position.to_tensor().float()).item()\n            new_cost = new_vertex.cost + dist\n            if new_cost + 1e-6 < vertex.cost:\n                # Remove old parent(s)\n                parents = list(vertex.parents)\n                for p in parents:\n                    tree.remove_edge(p, vertex)\n                vertex.cost = new_cost\n                tree.add_edge(new_vertex, vertex)\n                changed = True\n        return changed\n\n    def _connect_trees(self, tree_start: Forest, tree_goal: Forest, new_vertex_start: Vertex, grid: Map) -> Vertex:\n        import torch\n        max_connect_dist = self._max_max_dist\n        near_goal_vertices = tree_goal.get_vertices_within_radius(tree_goal.root_vertices, new_vertex_start.position, max_connect_dist)\n        best_connect = None\n        best_cost = float('inf')\n        for v_goal in near_goal_vertices:\n            line_seq = grid.get_line_sequence(new_vertex_start.position, v_goal.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            dist = torch.norm(new_vertex_start.position.to_tensor().float() - v_goal.position.to_tensor().float()).item()\n            total_cost = new_vertex_start.cost + dist + v_goal.cost\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_connect = v_goal\n        if best_connect is not None:\n            # Connect the two trees\n            # Add edge from new_vertex_start to best_connect\n            tree_start.add_edge(new_vertex_start, best_connect)\n            return best_connect\n        return None\n\n    def _extract_path(self, meeting_vertex_start: Vertex, meeting_vertex_goal: Vertex) -> None:\n        \"\"\"Extract full path from start to goal by merging paths from both trees.\"\"\"\n        path_start = []\n        current = meeting_vertex_start\n        while True:\n            path_start.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path_start.reverse()\n\n        path_goal = []\n        current = meeting_vertex_goal\n        while True:\n            path_goal.append(current)\n            if len(current.children) == 0:\n                break\n            # In goal tree, edges go from child to parent? We search along children to extract path forward.\n            current = next(iter(current.children))\n\n        # Merge paths (meeting_vertex is common)\n        full_path = path_start + path_goal[1:]\n        grid = self._get_grid()\n\n        # Shortcut smoothing (2 passes)\n        for _ in range(2):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del full_path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in full_path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_time = time.time()\n        best_path_cost = float('inf')\n        found_meeting_vertex_start = None\n        found_meeting_vertex_goal = None\n\n        # Trees initialization\n        tree_start = self._tree_start\n        tree_goal = self._tree_goal\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - start_time) > self._time_limit_seconds:\n                # Timeout, fail search\n                return\n\n            # Alternate growth direction each iteration\n            grow_start_tree = (iteration % 2 == 0)\n            sample = self._get_random_sample()\n\n            if grow_start_tree:\n                nearest = tree_start.get_nearest_vertex(tree_start.root_vertices, sample)\n                max_dist = self._adaptive_max_dist(nearest.position, tree_start.size)\n                new_pos = self._steer(nearest, sample, max_dist)\n                if not grid.is_agent_valid_pos(new_pos):\n                    continue\n                line_seq = grid.get_line_sequence(nearest.position, new_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                new_vertex = Vertex(new_pos)\n                dist_cost = torch.norm(nearest.position.to_tensor().float() - new_pos.to_tensor().float()).item()\n                new_vertex.cost = nearest.cost + dist_cost\n\n                radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(max(tree_start.size,1)).float()) / max(tree_start.size,1)) ** (1/self._dimension)), 25.0)\n                near_vertices = tree_start.get_vertices_within_radius(tree_start.root_vertices, new_pos, radius)\n                parent = self._choose_parent(tree_start, near_vertices, new_pos, grid)\n                if parent is None:\n                    parent = nearest\n                new_vertex.cost = parent.cost + torch.norm(parent.position.to_tensor().float() - new_pos.to_tensor().float()).item()\n                tree_start.add_edge(parent, new_vertex)\n\n                # Rewire for optimization\n                self._rewire(tree_start, near_vertices, new_vertex, grid)\n\n                # Try connect with goal tree\n                connect_vertex_goal = self._connect_trees(tree_start, tree_goal, new_vertex, grid)\n                if connect_vertex_goal is not None:\n                    total_cost = new_vertex.cost + Map.get_distance(new_vertex.position, connect_vertex_goal.position) + connect_vertex_goal.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        found_meeting_vertex_start = new_vertex\n                        found_meeting_vertex_goal = connect_vertex_goal\n                        # Early stop if path found\n                        break\n\n            else:\n                # Grow goal tree\n                nearest = tree_goal.get_nearest_vertex(tree_goal.root_vertices, sample)\n                max_dist = self._adaptive_max_dist(nearest.position, tree_goal.size)\n                new_pos = self._steer(nearest, sample, max_dist)\n                if not grid.is_agent_valid_pos(new_pos):\n                    continue\n                line_seq = grid.get_line_sequence(nearest.position, new_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n                new_vertex = Vertex(new_pos)\n                dist_cost = torch.norm(nearest.position.to_tensor().float() - new_pos.to_tensor().float()).item()\n                new_vertex.cost = nearest.cost + dist_cost\n\n                radius = min(self._lambda_rrt_star * ((torch.log(torch.tensor(max(tree_goal.size,1)).float()) / max(tree_goal.size,1)) ** (1/self._dimension)), 25.0)\n                near_vertices = tree_goal.get_vertices_within_radius(tree_goal.root_vertices, new_pos, radius)\n                parent = self._choose_parent(tree_goal, near_vertices, new_pos, grid)\n                if parent is None:\n                    parent = nearest\n                new_vertex.cost = parent.cost + torch.norm(parent.position.to_tensor().float() - new_pos.to_tensor().float()).item()\n                tree_goal.add_edge(parent, new_vertex)\n\n                # Rewire goal tree\n                self._rewire(tree_goal, near_vertices, new_vertex, grid)\n\n                # Try connect with start tree\n                connect_vertex_start = self._connect_trees(tree_goal, tree_start, new_vertex, grid)\n                if connect_vertex_start is not None:\n                    total_cost = new_vertex.cost + Map.get_distance(new_vertex.position, connect_vertex_start.position) + connect_vertex_start.cost\n                    if total_cost < best_path_cost:\n                        best_path_cost = total_cost\n                        found_meeting_vertex_start = connect_vertex_start\n                        found_meeting_vertex_goal = new_vertex\n                        break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_meeting_vertex_start is not None and found_meeting_vertex_goal is not None:\n            self._extract_path(found_meeting_vertex_start, found_meeting_vertex_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Bidirectional A* Inspired Tree Expansion with Adaptive Sampling and Gradient-Informed Extension",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Hybrid Bidirectional A* Inspired Tree Expansion with Adaptive Sampling and Gradient-Informed Extension}\n\n    This algorithm combines bidirectional search principles with adaptive sampling driven by cost heuristics \n    and obstacle clearance gradients to efficiently connect start and goal positions. \n\n    Key Features:\n    - Bidirectional tree growth (start and goal trees simultaneously) for faster convergence.\n    - Adaptive and gradient-informed step extension: step size is adjusted based on local obstacle clearance\n      and heuristic cost gradient from sampled points, favoring samples guiding trees closer efficiently.\n    - Cost-heuristic biased sampling: samples are weighted by a combined normalized heuristic of distance \n      and estimated cost-to-go.\n    - Dynamic rewiring inspired by RRT* to optimize path quality continuously.\n    - Early stopping on connection of the two trees with a valid collision-free edge.\n    - Shortcutting smoothing of the final path for improved path quality.\n    - Time limit enforcement of 10 seconds to avoid excessive planning delays.\n\n    This design aims to reduce search space, improve success rate, and produce higher-quality paths \n    with fewer planning iterations by leveraging bidirectional growth and smarter sampling.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = CyclicGraph(  # Use CyclicGraph to allow cyclic edges if needed during rewiring\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        self._time_limit_sec = 10.0\n        self._max_iterations = 7000\n        self._goal_sample_rate = 0.2    # Moderate bias for goal sampling\n        self._rewire_radius = 14.0       # Rewiring neighborhood radius\n        self._min_step = 3.0\n        self._max_step = 16.0\n\n    def _heuristic(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return self._get_grid().get_distance(p1, p2)\n\n    def _cost_to_go_heuristic(self, pos: Point) -> float:\n        # Combined heuristic: distance to goal plus cost from start approximated by current tree\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n        dist_start = self._heuristic(start_pos, pos)\n        dist_goal = self._heuristic(pos, goal_pos)\n        return dist_start + dist_goal\n\n    def _adaptive_step_by_clearance(self, pos: Point, direction: Point) -> float:\n        # Scan along direction to find max step limited by clearance and validity\n        grid = self._get_grid()\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return self._min_step\n        unit_dir = dir_tensor / norm\n\n        # Sample multiple radii for obstacle proximity and line of sight\n        for radius in np.linspace(self._max_step, self._min_step, num=8):\n            candidate_tensor = pos.to_tensor() + radius * unit_dir\n            candidate_point = Point.from_tensor(candidate_tensor)\n            if not grid.is_agent_valid_pos(candidate_point):\n                return max(radius * 0.3, self._min_step)  # Reduce step sharply near obstacles\n            line_seq = grid.get_line_sequence(pos, candidate_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return max(radius * 0.3, self._min_step)\n        return self._max_step  # Free clear path\n\n    def _blend_sample(self) -> Point:\n        \"\"\"\n        Sample points biased toward a combined heuristic corridor between start and goal,\n        with smoothing by a local clearance probability, improving sampling quality.\n        \"\"\"\n        grid = self._get_grid()\n        size = grid.size\n        start_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        max_dist = self._heuristic(Point(0, 0), Point(*size))\n\n        from random import random\n\n        if random() < self._goal_sample_rate:\n            return goal_pos\n\n        trials = 0\n        while True:\n            trials += 1\n            coords = np.random.randint(0, size, size.n_dim)\n            pt = Point(*coords)\n            if not grid.is_agent_valid_pos(pt):\n                continue\n\n            h_val = self._cost_to_go_heuristic(pt)\n            h_norm = h_val / max_dist\n            # Acceptance probability inversely proportional to heuristic plus random clearance factor\n            clearance_factor = self._clearance_score(pt)  # 0 to 1, higher clearance favored\n            acceptance_prob = (1.0 - h_norm) * clearance_factor\n\n            if np.random.rand() < acceptance_prob:\n                return pt\n\n            # Safety fallback after many tries\n            if trials > 400:\n                return pt\n\n    def _clearance_score(self, pos: Point) -> float:\n        # Estimate clearance for position: normalized by max inspected radius\n        grid = self._get_grid()\n        max_radius = 10\n        clearance_count = 0\n        samples = 8  # directions to sample clearance from pos\n\n        directions = [\n            Point(1, 0), Point(-1, 0), Point(0, 1), Point(0, -1),\n            Point(1, 1), Point(-1, 1), Point(1, -1), Point(-1, -1)\n        ]\n\n        for d in directions[:samples]:\n            for r in range(1, max_radius + 1):\n                p = Point(pos.x + d.x * r, pos.y + d.y * r)\n                if not grid.is_agent_valid_pos(p):\n                    break\n            else:\n                clearance_count += 1\n\n        return clearance_count / samples if samples > 0 else 0.0\n\n    def _new_vertex_towards(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Extend new vertex towards q_sample from q_near adaptively:\n        - Step size influenced by clearance gradient and heuristic descent direction.\n        - If no valid extension, return None.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n        step_size = self._adaptive_step_by_clearance(q_near.position, Point.from_tensor(dir_normalized))\n        step_size = max(self._min_step, min(step_size, max_dist))\n\n        new_pos_tensor = q_near.position.to_tensor() + step_size * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n\n        grid = self._get_grid()\n        line_seq = grid.get_line_sequence(q_near.position, new_pos)\n        if not grid.is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(new_pos)\n\n    def _choose_best_parent(self, candidates: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        From candidate vertices, choose one allowing a valid minimal cost connection to q_new.\n        \"\"\"\n        grid = self._get_grid()\n        best_parent = None\n        best_cost = float(\"inf\")\n\n        for v in candidates:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            tentative_cost = v.cost + grid.get_movement_cost(v.position, q_new.position)\n            if tentative_cost < best_cost:\n                best_cost = tentative_cost\n                best_parent = v\n\n        if best_parent is not None:\n            q_new.cost = best_cost\n        return best_parent\n\n    def _rewire_tree(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Attempt to rewire neighbors through q_new if it reduces their cost, updating edges accordingly.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _extract_bidirect_path(self, meet_start: Vertex, meet_goal: Vertex) -> None:\n        \"\"\"\n        Extract path by connecting meet_start tree to meet_goal tree,\n        and shortcut smoothing the result.\n        \"\"\"\n        grid = self._get_grid()\n        # Path from start to meeting vertex\n        path_start = [meet_start]\n        curr = meet_start\n        while len(curr.parents) > 0:\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_start.append(curr)\n        path_start.reverse()\n\n        # Path from goal to meeting vertex\n        path_goal = [meet_goal]\n        curr = meet_goal\n        while len(curr.parents) > 0:\n            curr = min(curr.parents, key=lambda p: p.cost)\n            path_goal.append(curr)\n\n        # Concatenate paths (start to meet to goal)\n        full_path = path_start + path_goal\n\n        # Shortcut smoothing\n        smoothed_path = self._shortcut_path(full_path)\n\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing attempts to connect farther nodes directly, minimizing path length.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        grid = self._get_grid()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n\n        # Separate sets for bidirectional search\n        tree_start = [start_vertex]\n        tree_goal = [goal_vertex]\n\n        for iteration in range(self._max_iterations):\n\n            # Timeout check\n            if time.time() - start_time > self._time_limit_sec:\n                break\n\n            # Alternate expansion between start and goal trees\n            from random import choice\n            expand_from_start = (iteration % 2 == 0)\n\n            # Sample bias controlled\n            q_sample = self._blend_sample()\n\n            if expand_from_start:\n                base_tree = tree_start\n                opposite_tree = tree_goal\n            else:\n                base_tree = tree_goal\n                opposite_tree = tree_start\n\n            q_near = self._graph.get_nearest_vertex(base_tree, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step_by_clearance(q_near.position, Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor()))\n            max_dist = max(self._min_step, min(max_dist, self._max_step))\n\n            q_new = self._new_vertex_towards(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            neighbors = self._graph.get_vertices_within_radius(base_tree, q_new.position, self._rewire_radius)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n\n            parent = self._choose_best_parent(neighbors, q_new)\n            if parent is None:\n                continue\n\n            self._graph.add_edge(parent, q_new)\n\n            # Add q_new to base tree\n            base_tree.append(q_new)\n\n            # Rewire neighbors for better cost paths\n            neighbors_rewire = [v for v in neighbors if v != parent]\n            self._rewire_tree(q_new, neighbors_rewire)\n\n            # Try to connect q_new with opposite tree vertices to close path if possible\n            near_in_opposite = self._graph.get_vertices_within_radius(opposite_tree, q_new.position, self._rewire_radius)\n            connected = False\n            for q_opp in near_in_opposite:\n                line_seq = grid.get_line_sequence(q_new.position, q_opp.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Connect two trees and extract full path\n                    # Create dummy bridging vertex for connection if necessary\n                    bridge_vertex = Vertex(q_opp.position)\n                    bridge_vertex.cost = q_new.cost + grid.get_movement_cost(q_new.position, q_opp.position)\n                    self._graph.add_edge(q_new, bridge_vertex)\n                    self._graph.add_edge(bridge_vertex, q_opp)\n\n                    if expand_from_start:\n                        start_meet = q_new\n                        goal_meet = q_opp\n                    else:\n                        start_meet = q_opp\n                        goal_meet = q_new\n\n                    self._extract_bidirect_path(start_meet, goal_meet)\n                    connected = True\n                    break\n\n            if connected:\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Hybrid Informed Tree Expansion with Bi-Directional Search and Adaptive Heuristic Pruning",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Hybrid Informed Tree Expansion with Bi-Directional Search and Adaptive Heuristic Pruning}\n\n    This algorithm innovates by combining:\n    - A bi-directional forest growth from both start and goal positions to reduce search space.\n    - Informed sampling in an adaptive ellipse region centered on the current best connection to focus exploration.\n    - Adaptive max step size shrinking nearer to goal or to the opposing tree to improve fine movements.\n    - Heuristic-guided vertex expansion using combined cost-to-come and cost-to-go estimates.\n    - Progressive pruning of vertices exceeding heuristic cost thresholds for efficiency.\n    - Lazy rewiring only when a better connection is naturally found via tree merging.\n    - Early stopping on successful tree connection or a 10-second runtime limit.\n    - Path extraction that stitches the bi-directional connection and performs shortcut smoothing.\n    This aims to improve success rate, planning efficiency, and path quality by focusing search and reducing unnecessary expansions.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex, [start_vertex, goal_vertex])\n        self._max_max_dist = 15.0\n        self._min_max_dist = 2.5\n        self._max_iterations = 6000\n        self._goal_sample_rate = 0.25\n        self._dimension = 2\n        self._lambda_rrt_star = 45  # constant used in radius calculation for rewiring/neighbors\n        self._start_time = None\n        self._time_limit_seconds = 10.0\n        self._prune_cost_factor = 1.5  # tolerance factor for pruning vertices beyond acceptable cost\n        self._init_displays()\n\n    def _get_adaptive_max_dist(self, position: Point, other_tree_vertex: Vertex) -> float:\n        # Shrink step size nearer to goal or opposing tree vertex\n        dist_to_goal = Map.get_distance(position, self._graph.root_vertex_goal.position)\n        dist_to_other_tree = Map.get_distance(position, other_tree_vertex.position)\n        dist = min(dist_to_goal, dist_to_other_tree)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.25))\n        return scaled\n\n    def _sample_informed_ellipse(self, c_best: float) -> Point:\n        # Sample inside an ellipse defined by start and goal, shrinks as best path cost improves\n        import random\n        grid = self._get_grid()\n        start_pos = self._graph.root_vertex_start.position\n        goal_pos = self._graph.root_vertex_goal.position\n        c_min = Map.get_distance(start_pos, goal_pos)\n        if c_best < float('inf') and c_best > c_min:\n            # Ellipse parameters\n            center = Point.from_tensor((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n            a = c_best / 2\n            b = (a**2 - (c_min/2)**2)**0.5 if a > c_min/2 else a * 0.1\n            angle = torch.atan2(goal_pos.y - start_pos.y, goal_pos.x - start_pos.x).item()\n\n            for _ in range(50):\n                # Random point inside unit circle\n                r = random.random() ** 0.5\n                theta = random.uniform(0, 2*3.14159265)\n                x = r * torch.cos(torch.tensor(theta)).item()\n                y = r * torch.sin(torch.tensor(theta)).item()\n\n                # Scale and rotate\n                sample_x = a * x\n                sample_y = b * y\n\n                rot_x = sample_x * torch.cos(torch.tensor(angle)).item() - sample_y * torch.sin(torch.tensor(angle)).item()\n                rot_y = sample_x * torch.sin(torch.tensor(angle)).item() + sample_y * torch.cos(torch.tensor(angle)).item()\n\n                sample = Point(int(round(center.x + rot_x)), int(round(center.y + rot_y)))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n        # fallback: random valid uniform sample\n        for _ in range(100):\n            coords = []\n            for dim in range(self._dimension):\n                coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n            candidate = Point(*coords)\n            if grid.is_agent_valid_pos(candidate):\n                return candidate\n        # fallback to start pos if all else fails\n        return self._graph.root_vertex_start.position\n\n    def _choose_parent_and_cost(self, neighbors: list, q_new: Vertex, grid: Map) -> Vertex:\n        # Select parent with minimal total cost + validate path\n        min_cost = float('inf')\n        min_vertex = None\n        for q_near in neighbors:\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            q_new.cost = min_cost\n        return min_vertex\n\n    def _rewire_lazy(self, q_new: Vertex, neighbors: list, grid: Map) -> None:\n        # Only rewire neighbors to q_new if q_new came from other tree and offers improvement\n        # This keeps rewiring minimal to reduce overhead and is triggered by tree merges\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if q_near.cost <= q_new.cost:\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_full_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Combine paths from start to connection and goal to connection, shortcut then move agent\n        path_start = []\n        curr = connection_vertex_start\n        while True:\n            path_start.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = next(iter(curr.parents))\n        path_start.reverse()\n\n        path_goal = []\n        curr = connection_vertex_goal\n        while True:\n            path_goal.append(curr)\n            if len(curr.parents) == 0:\n                break\n            curr = next(iter(curr.parents))\n\n        path = path_start + path_goal  # concatenated path (connection vertex repeated but okay)\n\n        # Shortcut smoothing\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    del path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _prune_vertices(self, tree_vertices: list, cost_threshold: float) -> None:\n        # Prune vertices whose cost + heuristic exceeds threshold, keeping trees focused\n        grid = self._get_grid()\n\n        def is_beyond_threshold(v: Vertex) -> bool:\n            heuristic = Map.get_distance(v.position, self._graph.root_vertex_goal.position)\n            return (v.cost + heuristic) > cost_threshold\n\n        to_remove = []\n        for v in tree_vertices:\n            if v == self._graph.root_vertex_start or v == self._graph.root_vertex_goal:\n                continue\n            if is_beyond_threshold(v):\n                to_remove.append(v)\n\n        for v in to_remove:\n            for p in list(v.parents):\n                self._graph.remove_edge(p, v)\n            # Removing children edges is optional; forest disconnects pruned vertex\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        start_vertex.cost = 0.0\n        goal_vertex.cost = 0.0\n        self._start_time = time.time()\n\n        c_best = float('inf')\n        connected = False\n\n        # Maintain separate vertex lists for each tree for pruning and neighbors\n        tree_start_vertices = [start_vertex]\n        tree_goal_vertices = [goal_vertex]\n\n        for iteration in range(self._max_iterations):\n            now = time.time()\n            if now - self._start_time > self._time_limit_seconds:\n                # Time limit exceeded, terminate search with failure if no solution\n                break\n\n            # Alternate sampling from start and goal tree to balance expansion\n            from random import random\n            sample_from_start = (iteration % 2 == 0)\n\n            q_sample = None\n            if c_best == float('inf'):\n                # No path yet: sample uniformly with goal bias\n                if random() < self._goal_sample_rate:\n                    q_sample = goal_vertex.position if sample_from_start else start_vertex.position\n                else:\n                    q_sample = self._sample_informed_ellipse(float('inf'))\n            else:\n                q_sample = self._sample_informed_ellipse(c_best)\n\n            tree_vertices = tree_start_vertices if sample_from_start else tree_goal_vertices\n            opposite_tree_vertices = tree_goal_vertices if sample_from_start else tree_start_vertices\n            root_vertex = start_vertex if sample_from_start else goal_vertex\n\n            q_nearest = self._graph.get_nearest_vertex(tree_vertices, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position, self._graph.root_vertex_goal if sample_from_start else self._graph.root_vertex_start)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dist = torch.norm(dir_tensor).item()\n            if dist == 0:\n                continue\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dist\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = float('inf')\n\n            # Get neighbors in current tree for possible parents\n            card_v = max(self._graph.size, 1)\n            log_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 25.0)\n            neighbors = self._graph.get_vertices_within_radius(tree_vertices, q_new.position, radius)\n            if q_nearest not in neighbors:\n                neighbors.append(q_nearest)\n\n            parent_vertex = self._choose_parent_and_cost(neighbors, q_new, grid)\n            if parent_vertex is None:\n                continue\n\n            self._graph.add_edge(parent_vertex, q_new)\n\n            # Add q_new to appropriate tree lists\n            tree_vertices.append(q_new)\n\n            # Attempt to connect q_new to opposite tree\n            opposite_neighbors = self._graph.get_vertices_within_radius(opposite_tree_vertices, q_new.position, radius)\n            connection_found = False\n            best_connection_vertex = None\n            best_connection_cost = float('inf')\n\n            for q_opp in opposite_neighbors:\n                line_seq_conn = grid.get_line_sequence(q_new.position, q_opp.position)\n                if not grid.is_valid_line_sequence(line_seq_conn):\n                    continue\n                cost_conn = q_new.cost + Map.get_distance(q_new.position, q_opp.position) + q_opp.cost\n                if cost_conn < best_connection_cost:\n                    best_connection_cost = cost_conn\n                    best_connection_vertex = q_opp\n                    connection_found = True\n\n            if connection_found and best_connection_cost < c_best:\n                c_best = best_connection_cost\n                connected = True\n\n                # Add connecting edge between q_new and best_connection_vertex in both trees\n                # Depending on which tree q_new belongs to, connect appropriately\n                if sample_from_start:\n                    self._graph.add_edge(q_new, best_connection_vertex)\n                else:\n                    self._graph.add_edge(best_connection_vertex, q_new)\n\n                # Lazy rewiring within both trees around connection to improve cost\n                neighbors_start = self._graph.get_vertices_within_radius(tree_start_vertices, q_new.position, radius)\n                neighbors_goal = self._graph.get_vertices_within_radius(tree_goal_vertices, best_connection_vertex.position, radius)\n                self._rewire_lazy(q_new, neighbors_start, grid)\n                self._rewire_lazy(best_connection_vertex, neighbors_goal, grid)\n\n                self._extract_full_path(q_new, best_connection_vertex)\n                break\n\n            # Prune both trees based on updated best cost c_best for efficiency and focus\n            cost_threshold = c_best * self._prune_cost_factor if c_best < float('inf') else float('inf')\n            self._prune_vertices(tree_start_vertices, cost_threshold)\n            self._prune_vertices(tree_goal_vertices, cost_threshold)\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm builds on RRT* to enhance planning efficiency, path quality, \n    and robustness. It incorporates:\n    - Goal-biased sampling to accelerate convergence toward the goal.\n    - Dynamic maximum step size (max_dist adapts based on distance to goal).\n    - Rewiring of the tree to optimize paths toward shorter cost paths (RRT* style).\n    - Shortcut smoothing during path extraction to reduce unnecessary vertices.\n    - Early stopping if solution found or 10 seconds exceeded.\n    \n    The rewiring step examines nearby neighbors to the new vertex and connects through the lowest-cost parent,\n    then tries to update neighbors to go through the new vertex if beneficial, improving path cost progressively.\n    This approach increases the success rate and yields smoother, more optimal paths with fewer iterations.",
     "code": "class PathPlanning(RRT):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self.rewire_radius = 15.0  # Radius to look for neighbors to rewire\n        self.goal_sample_rate = 0.15  # Probability to sample the goal directly\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, sample goal directly.\n        if np.random.random() < self.goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _choose_parent(self, q_near: Vertex, q_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        # Choose parent with lowest cost + cost from parent to new vertex\n        best_parent = q_near\n        best_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n        for neighbor in neighbors:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if cost < best_cost:\n                    best_parent = neighbor\n                    best_cost = cost\n        q_new.cost = best_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbor.position)):\n                cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    # Rewire neighbor to be child of q_new\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_new\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Remove unnecessary vertices if a direct line is valid between farther apart vertices\n        if len(path) <= 2:\n            return path\n        shortcut_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(path[i].position, path[j].position)):\n                    break\n                j -= 1\n            shortcut_path.append(path[j])\n            i = j\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        path: List[Vertex] = [q_new]\n\n        # Walk back to root (start)\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.reverse()\n\n        # Shortcut smoothing\n        path = self._shortcut_path(path)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_base_dist = 15.0  # Max step size base\n        max_iterations = 10000\n\n        self._graph.root_vertex_start.cost = 0.0\n\n        for _ in range(max_iterations):\n            if time() - start_time > 10.0:\n                # Timeout for search\n                break\n\n            q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dist_to_goal = self._get_grid().get_distance(q_near.position, self._get_grid().goal.position)\n            max_dist = max_base_dist * (0.5 + dist_to_goal / max(self._get_grid().size.x, self._get_grid().size.y))  # adaptive max dist\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find neighbors within rewire radius\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self.rewire_radius)\n            if not neighbors:\n                neighbors = [q_near]\n\n            best_parent = self._choose_parent(q_near, q_new, neighbors)\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(q_new, neighbors)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "'prev_direction': direction_vec.to_tensor() / torch.norm(direction_vec.to_tensor())",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved IHAST-inspired algorithm with the following enhancements:\n    - Adaptive heuristic sampling using combined cost-to-come (g) and heuristic (h) for more A*-like guidance.\n    - Dynamic goal biasing that increases over time to encourage goal-directed sampling as search progresses.\n    - Adaptive step size refined with obstacle clearance and directional smoothness, capped more conservatively near obstacles.\n    - Early pruning of samples with high estimated total cost (g+h) beyond current best path cost.\n    - Incremental rewiring prioritizing cost improvements and connectivity robustness.\n    - Path extraction applies multiple rounds of shortcutting smoothing for better quality.\n    - Early termination triggered by reaching goal or time limit (10s).\n    - Uses a best cost-to-go estimate to focus search on promising samples, improving iteration efficiency and success.\n    \"\"\"\n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._base_goal_sample_rate = 0.15  # base goal sampling rate\n        self._goal_sample_rate = self._base_goal_sample_rate  # dynamic goal sample rate\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n\n        # Store best cost to goal found so far, to prune samples\n        self._best_cost = float('inf')\n\n\n    def _heuristic_sample_adaptive(self, best_cost: float, elapsed_time: float) -> Point:\n        \"\"\"\n        Samples points using heuristic and current best-cost filtered rejection.\n        Bias sampling progressively towards the goal by increasing goal-sample rate with elapsed time.\n        Rejects samples with estimated cost > best_cost to prune search.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_distance = Map.get_distance(Point(0, 0), Point(*size))\n\n        goal_bias_increase = min(0.35, elapsed_time / self._time_limit * 0.2)\n        effective_goal_sample_rate = self._base_goal_sample_rate + goal_bias_increase\n\n        attempts = 0\n        while True:\n            attempts += 1\n\n            # With increased probability sample goal early in iterations (also handled outside by caller)\n            if np.random.rand() < effective_goal_sample_rate:\n                sample_pt = goal_pos\n            else:\n                sample_coords = np.random.randint(0, size, size.n_dim)\n                sample_pt = Point(*sample_coords)\n                if not grid.is_agent_valid_pos(sample_pt):\n                    continue\n\n            # Compute cost-to-come (g) and heuristic (h)\n            nearest_vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], sample_pt)\n            g = nearest_vertex.cost + grid.get_movement_cost(nearest_vertex.position, sample_pt)\n            h = Map.get_distance(sample_pt, goal_pos)\n            est_cost = g + h\n\n            if est_cost > best_cost:\n                # Prune sample unlikely to improve best path\n                if attempts > 500:\n                    # fallback: return sample anyway to avoid infinite loop\n                    return sample_pt\n                continue\n\n            # Normalize heuristic (h) to [0,1] to prefer closer to goal samples\n            h_norm = h / max_distance\n            prob_accept = 1.0 - h_norm\n\n            if np.random.rand() < prob_accept:\n                return sample_pt\n\n            if attempts > 500:\n                return sample_pt\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size with enhanced clearance checks and angle-based smoothness impact.\n        Smaller steps near obstacles or sharp turns.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Check clearance at multiple increments along the direction to adapt step\n        step_sizes = np.linspace(min_step, max_step, 6)\n        clearance_ratios = []\n        for radius in step_sizes:\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n\n            if not grid.is_agent_valid_pos(sample_point):\n                # Obstacle close, reduce step size quickly\n                return radius * 0.4\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return radius * 0.4\n\n            clearance_ratios.append(1.0)  # no obstacles at this radius\n\n        # Smoothness factor: smaller step if angle between previous direction and current is large\n        prev_dir_tensor = pos.aux.get('prev_direction') if hasattr(pos, 'aux') else None\n        if prev_dir_tensor is not None:\n            angle_cos = torch.dot(prev_dir_tensor, unit_dir).item()\n            angle_cos = max(min(angle_cos, 1), -1)\n            angle = np.arccos(angle_cos)\n            smoothness_factor = max(0.4, 1.0 - angle / np.pi)  # between 0.4 and 1.0\n        else:\n            smoothness_factor = 1.0\n\n        step_size = max_step * smoothness_factor\n\n        # Cap minimum based on clearance checks\n        if clearance_ratios and min(clearance_ratios) < 1.0:\n            step_size = min(step_size, max_step * min(clearance_ratios))\n\n        step_size = max(min_step, min(step_size, max_step))\n        return step_size\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path with two rounds of shortcut smoothing for improved smoothness.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        # Perform two rounds of shortcutting smoothing\n        path = self._shortcut_path(path)\n        path = self._shortcut_path(path)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        self._best_cost = float('inf')\n\n        last_best_path_time = start_time\n\n        for iteration in range(self._max_iterations):\n\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._time_limit:\n                break\n\n            # Dynamically update goal sample rate (handled inside heuristic sampling)\n            self._goal_sample_rate = min(0.4, self._base_goal_sample_rate + elapsed_time / self._time_limit * 0.25)\n\n            # Sample point (goal biasing + heuristic & cost guided sampling)\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample_adaptive(self._best_cost, elapsed_time)\n\n            # Find nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            direction_vec = Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor())\n            max_dist = self._adaptive_step_size(q_near.position, direction_vec)\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Store previous direction vector in aux for smoothing step size in future calls\n            q_new.position.aux = {'prev_direction': direction_vec.to_tensor() / torch.norm(direction_vec.to_tensor())}\n\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Update best cost if q_new closer to goal with lower cost\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            est_cost_to_goal = q_new.cost + dist_to_goal\n            if est_cost_to_goal < self._best_cost:\n                self._best_cost = est_cost_to_goal\n                last_best_path_time = time.time()\n\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Early stopping: goal reached or close enough based on radius with robust check\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Enhanced hybrid RRT*/A*-informed search path planning algorithm with adaptive goal biasing and dynamic rewiring radius.\n    Key improvements over baseline:\n    - Bi-directional search variant by introducing another root from goal to improve connection success and reduce time.\n    - Adaptive sampling ratio shifted towards start or goal based on current path estimates (dynamic goal bias).\n    - Progressive adaptive step size with environment clearance and proximity analysis to accelerate exploration.\n    - Batch sampling each iteration to reduce overhead and improve tree growth rate.\n    - Aggressive rewiring using dynamically tuned radius to improve path quality faster.\n    - Lazy collision checking combined with quick pruning via approximate heuristic thresholds to avoid expensive line checks.\n    - Early stopping triggered by successful bidirectional connection with cost better than current best cost.\n    - Enhanced path extraction and shortcut smoothing ensuring shorter and smoother paths.\n    - Enforces strict 10-second timeout for responsiveness.\n    Overall, these improvements aim to decrease iterations, improve success and quality, and enhance robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n        goal_pos = goal_vertex.position\n        start_pos = start_vertex.position\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n        self._start_time = time.time()\n        max_time = self._time_limit_seconds\n\n        # Bi-directional forest extension: add goal_vertex to vertex map and queue\n        vertex_map = {start_vertex.position: start_vertex, goal_vertex.position: goal_vertex}\n\n        # Priority queues for Forward and Backward expansions (best-first with heuristic)\n        # Each element: (est_total_cost, vertex, from_start_bool)\n        open_queue = []\n        # Initialize with start and goal vertices: forward and backward\n        heapq.heappush(open_queue, (self._heuristic(start_pos), start_vertex, True))\n        heapq.heappush(open_queue, (self._heuristic(goal_pos), goal_vertex, False))\n\n        # Store which tree a vertex belongs to: True for forward (start), False for backward (goal)\n        vertex_tree_membership = {start_vertex.position: True, goal_vertex.position: False}\n\n        # To track connections between trees (when bidirectional trees meet)\n        def is_connected(v1: Vertex, v2: Vertex) -> bool:\n            # Returns True if v1 and v2 are in different trees and connected\n            return vertex_tree_membership.get(v1.position) != vertex_tree_membership.get(v2.position)\n\n        # Parameters for adaptive sampling ratios\n        base_goal_sample_rate = self._goal_sample_rate\n        batch_sample_size = 5  # sample multiple points per iteration for faster growth\n\n        # Helper function for adaptive sample mixing with dynamic goal biasing\n        def adaptive_sample(from_start: bool):\n            prob_goal = base_goal_sample_rate\n            # If from_start tree, sample goal with probability prob_goal, else start with prob_goal\n            if from_start:\n                if torch.rand(1).item() < prob_goal:\n                    # biased goal sample\n                    for _ in range(20):\n                        offset = torch.randint(-2, 3, (self._dimension,))\n                        candidate = Point(goal_pos.x + offset[0].item(), goal_pos.y + offset[1].item())\n                        if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                            return candidate\n                    return goal_pos\n                else:\n                    # clearance aware\n                    return self._clearance_aware_sample()\n            else:\n                # from goal tree: goal is start, so bias towards start_pos\n                if torch.rand(1).item() < prob_goal:\n                    for _ in range(20):\n                        offset = torch.randint(-2, 3, (self._dimension,))\n                        candidate = Point(start_pos.x + offset[0].item(), start_pos.y + offset[1].item())\n                        if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                            return candidate\n                    return start_pos\n                else:\n                    return self._clearance_aware_sample()\n\n        # Adaptive radius function for rewiring and neighborhood search\n        def adaptive_radius(tree_size: int, point: Point):\n            import math\n            ln_size = torch.log(torch.tensor(float(max(tree_size, 1)))).item() if tree_size > 1 else 0.0\n            radius = min(self._rewire_lambda * ((ln_size / max(tree_size, 1)) ** (1 / self._dimension)), 20.0)\n            clearance_factor = 1.0 + min(self._get_clearance(point) / (self._clearance_threshold * 2.0), 1.0)\n            radius *= clearance_factor\n            return radius\n\n        iterations = 0\n        while iterations < self._max_iterations:\n            current_time = time.time()\n            if current_time - self._start_time > max_time:\n                break\n            if not open_queue:\n                break\n\n            est_tot_cost, current_v, from_start = heapq.heappop(open_queue)\n            iterations += 1\n\n            # Skip exploring vertices whose cost already exceeds best cost significantly (pruning)\n            if est_tot_cost > self._best_cost + 1e-6:\n                continue\n\n            # Batch sample multiple points each iteration for faster tree growth\n            for _ in range(batch_sample_size):\n                q_sample = adaptive_sample(from_start)\n                if q_sample == current_v.position:\n                    continue\n                max_step = self._adaptive_step_size(current_v.position)\n\n                # Compute direction and new candidate point q_new_pos along that direction\n                dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n                dist = torch.norm(dir_vec).item()\n                if dist < 1e-8:\n                    continue\n                dir_norm = dir_vec / dist\n                step_length = min(dist, max_step)\n                new_pos_tensor = torch.round(torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n                q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n                if q_new_pos == current_v.position:\n                    continue\n                if not grid.is_agent_valid_pos(q_new_pos):\n                    continue\n                if q_new_pos in vertex_map:\n                    # Already explored position\n                    continue\n\n                # Lazy collision checking heuristic:\n                # A quick distance check to goal or start to prune edge expansions that won't improve\n                heuristic_dist = self._heuristic(q_new_pos) if from_start else Map.get_distance(q_new_pos, start_pos)\n                if heuristic_dist > self._best_cost:\n                    continue\n\n                # Validate path line collision before adding\n                line_seq = grid.get_line_sequence(current_v.position, q_new_pos)\n                if not grid.is_valid_line_sequence(line_seq):\n                    continue\n\n                # Create new vertex and compute cost from current vertex\n                q_new_vertex = Vertex(q_new_pos)\n                move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n                cost_to_q_new = current_v.cost + move_cost\n                q_new_vertex.cost = cost_to_q_new\n\n                # Add q_new_vertex tentatively before rewiring\n                vertex_map[q_new_pos] = q_new_vertex\n                vertex_tree_membership[q_new_pos] = from_start\n\n                # Neighborhood rewiring - find neighbors in same tree\n                tree_vertices = [v for v in vertex_map.values() if vertex_tree_membership.get(v.position) == from_start]\n                radius = adaptive_radius(len(tree_vertices), q_new_pos)\n                near_vertices = self._graph.get_vertices_within_radius(tree_vertices, q_new_pos, radius)\n\n                # Choosing best parent among neighbors for q_new_vertex\n                best_parent = current_v\n                best_cost = cost_to_q_new\n                for neighbor in near_vertices:\n                    candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                    if candidate_cost < best_cost - 1e-5:\n                        # Validate connection line once more\n                        line_seq_candidate = grid.get_line_sequence(neighbor.position, q_new_pos)\n                        if not grid.is_valid_line_sequence(line_seq_candidate):\n                            continue\n                        best_parent = neighbor\n                        best_cost = candidate_cost\n\n                # If found better parent, update cost and edge connection\n                if best_parent != current_v:\n                    q_new_vertex.cost = best_cost\n\n                self._graph.add_edge(best_parent, q_new_vertex)\n\n                # Attempt rewiring neighbors to improve cost\n                cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost < float('inf') else 1.0))\n                for neighbor in near_vertices:\n                    if neighbor == best_parent:\n                        continue\n                    new_cost_via_qnew = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                    if new_cost_via_qnew + cost_improve_thresh < neighbor.cost:\n                        line_seq_rewire = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                        if grid.is_valid_line_sequence(line_seq_rewire):\n                            for p in list(neighbor.parents):\n                                self._graph.remove_edge(p, neighbor)\n                            neighbor.cost = new_cost_via_qnew\n                            self._graph.add_edge(q_new_vertex, neighbor)\n\n                # Push q_new_vertex into open_queue with heuristic\n                est_total_cost = q_new_vertex.cost + (self._heuristic(q_new_vertex.position) if from_start else Map.get_distance(q_new_vertex.position, start_pos))\n                heapq.heappush(open_queue, (est_total_cost, q_new_vertex, from_start))\n\n                # Bi-directional connection check - try to connect q_new_vertex to nearest vertex in opposite tree\n                opposite_tree = not from_start\n                opp_tree_vertices = [v for v in vertex_map.values() if vertex_tree_membership.get(v.position) == opposite_tree]\n                if not opp_tree_vertices:\n                    continue\n\n                near_vert_opp = min(opp_tree_vertices, key=lambda v: Map.get_distance(v.position, q_new_vertex.position))\n                dist_to_opp = Map.get_distance(q_new_vertex.position, near_vert_opp.position)\n                if dist_to_opp <= max_step:\n                    # Check collision for connection between trees\n                    connection_line = grid.get_line_sequence(q_new_vertex.position, near_vert_opp.position)\n                    if grid.is_valid_line_sequence(connection_line):\n                        total_cost = q_new_vertex.cost + dist_to_opp + near_vert_opp.cost\n                        if total_cost < self._best_cost:\n                            self._best_cost = total_cost\n                            # Create virtual goal vertex to connect both trees\n                            found_goal_vertex = Vertex(goal_pos)\n                            found_goal_vertex.cost = total_cost\n                            # Connect trees properly in graph\n                            if from_start:\n                                self._graph.add_edge(q_new_vertex, found_goal_vertex)\n                                self._graph.add_edge(near_vert_opp, found_goal_vertex)\n                            else:\n                                self._graph.add_edge(near_vert_opp, found_goal_vertex)\n                                self._graph.add_edge(q_new_vertex, found_goal_vertex)\n                            # Break early on successful connection\n                            break\n\n            if found_goal_vertex is not None:\n                break\n\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        # If no path found, just return without moves\n        if found_goal_vertex is None:\n            return\n\n        # Backtrack full path by choosing from parents with incremental cost\n        # Since connection formed at found_goal_vertex, recover path from start and goal trees\n        path_forward = []\n        path_backward = []\n\n        # Forward tree path (start to connecting vertex)\n        curr_forward = None\n        for v in vertex_map.values():\n            if v.position == found_goal_vertex.position:\n                # We don't expect start tree vertex with goal pos, look for parents with True membership that connect\n                continue\n        # Find forward subtree vertex connecting to found_goal_vertex\n        # The found_goal_vertex has parents from both trees; find parents in start tree\n        start_parents = [p for p in found_goal_vertex.parents if vertex_tree_membership.get(p.position, True)]\n        if start_parents:\n            curr_forward = min(start_parents, key=lambda p: p.cost)\n            while True:\n                path_forward.append(curr_forward)\n                if len(curr_forward.parents) == 0:\n                    break\n                curr_forward = min(curr_forward.parents, key=lambda p: p.cost)\n            path_forward.reverse()\n\n        # Backward tree path (goal to connecting vertex)\n        curr_backward = None\n        goal_parents = [p for p in found_goal_vertex.parents if not vertex_tree_membership.get(p.position, True)]\n        if goal_parents:\n            curr_backward = min(goal_parents, key=lambda p: p.cost)\n            while True:\n                path_backward.append(curr_backward)\n                if len(curr_backward.parents) == 0:\n                    break\n                curr_backward = min(curr_backward.parents, key=lambda p: p.cost)\n\n        path_backward.reverse()  # goal to connect, reverse to connect to goal\n\n        # Combine paths: start->forward path + found node + backward path + goal vertex\n        full_path = path_forward + [found_goal_vertex] + path_backward\n\n        # Perform multiple passes of shortcut smoothing for cleaner path\n        for _ in range(4):\n            i = 0\n            while i < len(full_path) - 2:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(full_path[i].position, full_path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del full_path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        # Move agent through optimized, smoothed path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved PathPlanning Algorithm combining:\n    - Adaptive goal-biased & elliptical informed sampling with dynamic mixture proportions based on progress towards goal.\n    - Heuristic-guided expansion using A*-like f-cost (cost from start + admissible heuristic to goal).\n    - Adaptive max step size scaled by normalized distance to goal and tree size for efficient coarse-to-fine exploration.\n    - Dynamic neighborhood radius for neighbor search and rewiring based on logarithmic scaling of tree size.\n    - Early rewire pruning discarding edges unlikely to improve cost, reducing tree clutter.\n    - Aggressive rewiring to improve path quality and maintain better cost tree structure.\n    - Multiple attempts at path shortcut smoothing for robust smoother trajectories.\n    - Early termination when a feasible connection to goal is found and smoothed.\n    - Timeout enforced at 10 seconds to ensure timely response.\n    Overall, this algorithm improves planning efficiency, success rate, and path quality over the base version,\n    delivering faster convergence with more reliable and smoother paths.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        max_time = self._time_limit_seconds if hasattr(self, '_time_limit_seconds') else 10\n        max_iters = self._max_iterations if hasattr(self, '_max_iterations') else 4000\n\n        # Additional parameters for enhanced adaptive sampling\n        goal = grid.goal.position\n        start = grid.agent.position\n        dimension = self._dimension\n        lambda_rrt_star = self._lambda_rrt_star\n\n        # Dynamic mixture weights for sampling\n        # Heuristic progress toward goal [0..1]: 0 at start, 1 at goal\n        def progress_fraction(current_pos: Point) -> float:\n            dist_start_goal = Map.get_distance(start, goal)\n            dist_current_goal = Map.get_distance(current_pos, goal)\n            if dist_start_goal < 1e-8:\n                return 1.0\n            return max(0.0, min(1.0, 1.0 - dist_current_goal / dist_start_goal))\n\n        # Enhanced sampling: adaptive mixture of uniform, goal-biased, and informed sampling based on progress\n        def adaptive_sample(iteration: int) -> Point:\n            frac = progress_fraction(start_vertex.position)\n            # Increase goal sample rate as progress nears goal (linear scale)\n            goal_sample_rate = 0.15 + 0.4 * frac\n            informed_sample_rate = 0.1 + 0.4 * frac if self._best_cost < float('inf') else 0.1\n            uniform_rate = 1.0 - goal_sample_rate - informed_sample_rate\n\n            rand_val = torch.rand(1).item()\n            if rand_val < goal_sample_rate:\n                # Goal-biased sampling near goal with radius scaled by remaining distance and min_max_dist\n                radius = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * (1.0 - frac)\n                for _ in range(40):\n                    sample_offset = torch.randn(dimension)\n                    norm_val = torch.norm(sample_offset)\n                    if norm_val < 1e-8:\n                        continue\n                    sample_offset = sample_offset / norm_val * (torch.rand(1).item() * radius)\n                    sample_pt = Point(*((goal.to_tensor().float() + sample_offset).round().int().tolist()))\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n                return goal  # fallback\n\n            elif rand_val < goal_sample_rate + informed_sample_rate and self._best_cost < float('inf'):\n                # Informed ellipsoidal sampling\n                return self._sample_in_ellipsoid(start, goal, self._best_cost)\n\n            else:\n                # Uniform random sampling over grid\n                for _ in range(120):\n                    coords = [torch.randint(0, grid.size[d], (1,)).item() for d in range(dimension)]\n                    sample_pt = Point(*coords)\n                    if grid.is_agent_valid_pos(sample_pt):\n                        return sample_pt\n                return start_vertex.position\n\n        # Adaptive max step size scaled dynamically with progress and tree size\n        def adaptive_max_dist(q_pos: Point) -> float:\n            dist_to_goal = Map.get_distance(q_pos, goal)\n            progress = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n            tree_factor = min(1.0, 700 / (self._graph.size + 1))  # More aggressive scaling\n            return self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress * tree_factor\n\n        # Heuristic combining traveled cost and admissible distance to goal (f-cost)\n        def heuristic_cost(vertex: Vertex) -> float:\n            return vertex.cost + Map.get_distance(vertex.position, goal)\n\n        # Radius for neighbors dynamically adapts based on tree size and log, capped\n        def dynamic_radius() -> float:\n            size = max(1, self._graph.size)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0\n            radius = min(lambda_rrt_star * ((ln_size / size) ** (1 / dimension)), 25.0)\n            return radius\n\n        # Early pruning: discard neighbors worse than threshold cost to reduce rewiring complexity\n        def neighbors_prune(q_new: Vertex, neighbors: list) -> list:\n            pruned = []\n            threshold_cost = q_new.cost * 1.3  # prune neighbors much more expensive than q_new.cost\n            for v in neighbors:\n                if v.cost < threshold_cost:\n                    pruned.append(v)\n            return pruned\n\n        for iteration in range(max_iters):\n            # Time limit check for early stop\n            if (time.time() - self._start_time) > max_time:\n                return\n\n            q_sample = adaptive_sample(iteration)\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            norm_dir = torch.norm(dir_vec).item()\n            if norm_dir < 1e-8:\n                continue\n\n            if norm_dir <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / norm_dir\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            radius = dynamic_radius()\n            candidates_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n            candidates_near = neighbors_prune(q_new, candidates_near)\n\n            # Select best parent minimizing cost + heuristic (A*-style)\n            best_parent = q_nearest\n            min_cost = q_new.cost\n            for q_near in candidates_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < min_cost:\n                    line_seq_cand = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_cand):\n                        best_parent = q_near\n                        min_cost = cost_candidate\n\n            q_new.cost = min_cost\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors with a stricter improved cost threshold and early pruning\n            for q_near in candidates_near:\n                if q_near == best_parent:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n\n                # Prune rewiring only if improvement > epsilon and better than neighbor's current cost significantly\n                if cost_through_new + 1e-5 < q_near.cost and cost_through_new < q_near.cost * 0.98:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge; only one since tree structure\n                        for p in q_near.parents:\n                            self._graph.remove_edge(p, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early termination once a valid path is found\n                    break\n\n            # Key frame periodically for visualization and iteration monitoring\n            if iteration % 30 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            # Robust path extraction with multiple shortcut attempts for smoothness\n            self._extract_path_and_smooth(found_goal)",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved sample-based path planning algorithm inspired by RRT* with goal biasing, \n    rewiring, and adaptive step size for improved path quality and efficiency. \n    This algorithm samples randomly with some probability directed towards the goal to encourage fast convergence.\n    New vertices are connected not just to the nearest vertex but also consider rewiring nearby vertices within a radius \n    to reduce overall path cost. The maximum expansion step size adapts dynamically based on progress and environment complexity. \n    The path extraction includes shortcut smoothing using valid direct line checks. \n    An overall timeout of 10 seconds enforces early stopping for robustness.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    _graph: Forest\n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Enable rewiring edges\n        self._init_displays()\n        # Additional member variable for adaptive step size\n        self._initial_max_dist = 15.0\n        self._min_max_dist = 5.0\n        self._max_max_dist = 25.0\n        self._goal_sample_rate = 0.15  # 15% of samples directed toward goal\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from start to goal using parents, then smooth with shortcutting\n        path_vertices: List[Vertex] = []\n        current = q_goal\n        while current is not None and len(current.parents) > 0:\n            path_vertices.append(current)\n            # choose parent with minimal cost\n            parent = min(current.parents, key=lambda v: v.cost)\n            current = parent\n        if current is not None:\n            path_vertices.append(current)  # add root start\n\n        path_vertices.reverse()\n\n        # Shortcut smoothing\n        smoothed_path: List[Vertex] = [path_vertices[0]]\n        for i in range(1, len(path_vertices)):\n            # try to connect last accepted to this vertex directly if safe\n            last = smoothed_path[-1]\n            candidate = path_vertices[i]\n            line_seq = self._get_grid().get_line_sequence(last.position, candidate.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                # expand smoothed path jump skipping intermediate vertices\n                continue\n            else:\n                # if not valid line, append previous vertex before candidate\n                smoothed_path.append(path_vertices[i - 1])\n        # append last vertex guaranteed \n        if smoothed_path[-1] != path_vertices[-1]:\n            smoothed_path.append(path_vertices[-1])\n\n        # Animate path traversal\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex], radius: float) -> None:\n        # Check if connecting through q_new improves cost for near vertices\n        for q_near in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_near.position)\n            if cost_through_new < q_near.cost:\n                # Remove old edge(s) from all parents reducing cost\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _find_path_internal(self) -> None:\n        max_total_time = 10.0  # seconds timeout max\n        start_time = time()\n\n        max_dist = self._initial_max_dist\n        iterations = 8000\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        goal_pos = self._get_grid().goal.position\n        goal_reached_vertex = None\n\n        for iter_i in range(iterations):\n            # Timeout check\n            elapsed = time() - start_time\n            if elapsed > max_total_time:\n                break\n\n            # Adaptive max_dist can be slowly reduced after some iterations for refinement\n            if iter_i % 500 == 0 and iter_i > 0:\n                max_dist = max(self._min_max_dist, max_dist * 0.95)\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            step_cost = self._get_grid().get_distance(q_near.position, q_new.position)\n            q_new.cost = q_near.cost + step_cost\n\n            # Nearby vertices for rewiring (choose radius based on max_dist)\n            rewire_radius = max_dist * 2.5\n            nearby_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, rewire_radius)\n\n            # Choose best parent with minimal cost + valid line\n            min_cost = q_new.cost\n            best_parent = q_near\n            for q_nearby in nearby_vertices:\n                line_seq_check = self._get_grid().get_line_sequence(q_nearby.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_check):\n                    continue\n                cost_candidate = q_nearby.cost + self._get_grid().get_distance(q_nearby.position, q_new.position)\n                if cost_candidate < min_cost:\n                    min_cost = cost_candidate\n                    best_parent = q_nearby\n            q_new.cost = min_cost\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire neighbors if we improve their cost through q_new\n            self._rewire(q_new, nearby_vertices, rewire_radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_reached_vertex = q_new\n                break\n\n            self.key_frame()\n\n        if goal_reached_vertex is not None:\n            self._extract_path(goal_reached_vertex)\n        else:\n            # No valid path found within timeout/iterations\n            # Optionally signal failure if needed - here do nothing or could add an animation step\n            pass",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved RRT* inspired path planning algorithm with heuristic-guided adaptive sampling,\n    dynamic max step size adjustment based on local obstacles, informed subset rewiring,\n    and heuristic cost for parent selection to enhance path quality and efficiency.\n    This algorithm biases sampling not only by goal position but towards an informed ellipse region \n    between start and goal to focus exploration, adapts step size according to local environment \n    complexity (smaller near obstacles), and uses heuristic cost estimates (cost_so_far + heuristic_to_goal) \n    for edge connection and rewiring decisions. Early stopping on goal reach and 10 seconds timeout is enforced.\n    Extracted path is shortcut for smoothness. Overall provides better planning efficiency, robustness, and path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_distance(self, frm: Point, to: Point) -> float:\n        return self._get_grid().get_distance(frm, to)\n\n    def _heuristic_cost(self, pos: Point) -> float:\n        # Estimated cost from pos to goal (Euclidean)\n        return self._get_distance(pos, self._get_grid().goal.position)\n\n    def _sample_informed(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Samples a point inside an ellipsoidal informed subset defined by start and goal,\n        if c_best < infinite, otherwise samples uniformly with goal bias.\n        This focuses the sampling around promising regions.\n        \"\"\"\n        import numpy as np\n\n        if c_best == float(\"inf\") or c_best <= c_min + 1e-6:\n            # No current solution or trivial, fallback to goal biased uniform sampling\n            if np.random.random() < 0.15:\n                return self._get_grid().goal.position\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n        # Ellipse parameters\n        center = Point((start.x + goal.x) / 2, (start.y + goal.y) / 2)\n        dx = goal.x - start.x\n        dy = goal.y - start.y\n        c = np.array([dx, dy])\n        length = np.linalg.norm(c)\n        if length == 0:\n            return start\n\n        # Transformation to ellipse frame:\n        # Rotate points so that ellipse major axis aligns with x-axis\n        center_arr = np.array([center.x, center.y])\n        l1 = (c / length).reshape(2, 1)\n        l2 = np.array([-l1[1][0], l1[0][0]]).reshape(2, 1)\n        C = np.hstack((l1, l2))  # Rotation matrix\n\n        # Radii of the ellipse\n        a = c_best / 2.0  # major axis\n        b = np.sqrt(c_best ** 2 - length ** 2) / 2.0  # minor axis\n\n        for _ in range(100):\n            # Sample random point in unit circle\n            r1 = np.random.random()\n            r2 = np.random.random()\n            theta = 2 * np.pi * r1\n            r = np.sqrt(r2)\n            # Point in unit circle\n            x_ball = np.array([r * np.cos(theta), r * np.sin(theta)])\n            # Scale by ellipse radii\n            x_rand = np.array([a * x_ball[0], b * x_ball[1]])\n            # Map back to original frame\n            point = center_arr + C @ x_rand\n            point_i = Point(int(round(point[0])), int(round(point[1])))\n            if (\n                0 <= point_i.x < self._get_grid().size.x\n                and 0 <= point_i.y < self._get_grid().size.y\n                and self._get_grid().is_agent_valid_pos(point_i)\n            ):\n                return point_i\n        # Fallback uniform if ellipse sampling fails\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_local_obstacle_density(self, pos: Point, radius: int = 4) -> float:\n        \"\"\"\n        Computes an approximate local obstacle density around pos by sampling neighboring cells.\n        Returns a value between 0 and 1.\n        \"\"\"\n        obstacles_count = 0\n        total_cells = 0\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                nx = pos.x + dx\n                ny = pos.y + dy\n                if 0 <= nx < self._get_grid().size.x and 0 <= ny < self._get_grid().size.y:\n                    total_cells += 1\n                    pt = Point(nx, ny)\n                    if not self._get_grid().is_agent_valid_pos(pt):\n                        obstacles_count += 1\n        if total_cells == 0:\n            return 0.0\n        return obstacles_count / total_cells\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_max = 15.0\n        max_dist_min = 2.5\n        iteration_limit = 8000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n\n        # c_min: direct start-goal distance (minimum possible cost)\n        c_min = self._get_distance(start_pos, goal_pos)\n        c_best = float(\"inf\")  # best cost found so far\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive max step size based on local obstacle density near start & goal samples\n            local_density_start = self._get_local_obstacle_density(start_pos)\n            local_density_goal = self._get_local_obstacle_density(goal_pos)\n            local_density_sample = min(local_density_start, local_density_goal)\n            max_dist = max_dist_max - (max_dist_max - max_dist_min) * local_density_sample\n            max_dist = max(max_dist_min, min(max_dist_max, max_dist))\n\n            # Sample informed with goal bias\n            q_sample = self._sample_informed(c_best, c_min, start_pos, goal_pos)\n\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new.position == q_near.position:\n                continue\n\n            # Validate path\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Radius for neighbors: adaptive based on iterations (shrinks)\n            radius = min(max_dist * 3.0, 30.0)\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n\n            # Use heuristic cost for parent selection: cost_so_far + heuristic to goal\n            min_total_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Check path validity neighbor -> q_new\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_to_q_new = neighbor.cost + self._get_distance(neighbor.position, q_new.position)\n                heuristic_cost = self._heuristic_cost(q_new.position)\n                total_cost = cost_to_q_new + heuristic_cost * 0.85  # weighted heuristic\n\n                if total_cost < min_total_cost:\n                    min_total_cost = total_cost\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # Fallback to q_near if no suitable parent found\n                line_seq_qnear_qnew = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_qnear_qnew):\n                    continue\n                parent_for_new = q_near\n                min_total_cost = parent_for_new.cost + self._get_distance(parent_for_new.position, q_new.position) + self._heuristic_cost(q_new.position) * 0.85\n\n            # Set q_new cost as cost from parent to q_new (cost so far)\n            q_new.cost = parent_for_new.cost + self._get_distance(parent_for_new.position, q_new.position)\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewiring neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire: remove old edges from all parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check goal reached within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Check direct connection to goal\n                final_goal_pos = goal_pos\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    # Update best cost\n                    if goal_vertex.cost < c_best:\n                        c_best = goal_vertex.cost\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
     "objective": null,
     "other_inf": null
}
