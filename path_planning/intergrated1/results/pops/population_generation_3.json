[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved PathPlanning Algorithm with enhanced smoothness and efficiency:\n    - Adaptive max step size dynamically scales with progress and tree size for balanced exploration.\n    - Mixed sampling combining uniform, goal-biased, and adaptive informed ellipsoidal to focus sampling.\n    - Heuristic-guided vertex expansion incorporating traveled cost and admissible distance to goal.\n    - Dynamic neighborhood radius for rewiring, scaled with logarithm of tree size, supporting RRT*-style optimization.\n    - Early neighbor pruning during rewiring to reduce clutter and improve path quality.\n    - Robust multi-pass path shortcutting smoothing with attempts to produce smooth final trajectory.\n    - Early termination upon detecting a direct valid connection to goal with a shorter path.\n    - Overall improves planning speed, success rate, and path smoothness under time constraints.\n    \"\"\"\n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size far from goal\n        self._min_max_dist = 2.5   # Min step size near goal for fine control\n        self._goal_sample_rate = 0.25  # Goal biased sampling probability\n        self._informed_sample_rate = 0.3  # Probability of ellipsoidal informed sampling\n        self._max_iterations = 4000\n        self._lambda_rrt_star = 45  # Rewiring radius factor tuning\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10\n        self._best_cost = float('inf')\n        self._init_displays()\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance heuristic (admissible)\n        return Map.get_distance(pos, goal_pos)\n\n    def _get_adaptive_max_dist(self, curr_pos: Point) -> float:\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(curr_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_to_goal / max(grid.size)))\n        tree_factor = min(1.0, 500 / (self._graph.size + 1))\n        scaled_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor\n        return scaled_step\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        import math\n        import torch\n\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(*(((start_pos.to_tensor().float() + goal_pos.to_tensor().float()) / 2).tolist()))\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        e1 = diff / dist_start_goal\n\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        a = c_max / 2.0\n        b = math.sqrt(max(c_max ** 2 - dist_start_goal ** 2, 1e-6)) / 2.0\n\n        for _ in range(40):\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        # Goal biased sampling with radius min_max_dist around goal\n        if rand_val < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                norm = torch.norm(sample_offset)\n                if norm > 1e-8:\n                    sample_offset = sample_offset / norm\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        # Informed ellipsoidal sampling focused within current best cost bound\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling across valid grid\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n            # Fallback to start position if no valid sample found\n            return self._graph.root_vertex_start.position\n\n    def _extract_path_and_smooth(self, goal_vertex: Vertex):\n        # Extract path from root to goal vertex\n        path = []\n        current = goal_vertex\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Multi-pass robust shortcut smoothing with more attempts per pass\n        smoothing_attempts = 4\n        for _pass in range(smoothing_attempts):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                shortened = False\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                        shortened = True\n                    else:\n                        j -= 1\n                if not shortened:\n                    i += 1\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n\n            dist_nearest_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 30.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Heuristic-guided minimum cost parent selection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_new\n\n            # Combine actual cost + heuristic to goal in parent selection for better exploration\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                heuristic_new = self._heuristic_cost(q_new.position, goal_pos)\n                heuristic_candidate_parent = self._heuristic_cost(q_near.position, goal_pos)\n\n                # Prefer parents with lower cost + heuristic to goal\n                if (cost_candidate + heuristic_new) < (c_min + self._heuristic_cost(q_min.position, goal_pos)):\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Early pruning neighbors with regressive cost\n            neighbors_to_consider = [q for q in vertices_near if q != q_min]\n\n            for q_near in neighbors_to_consider:\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                # Include small epsilon stability to avoid float issues\n                if cost_through_new + 1e-6 < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one parent edge (tree structure maintenance)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                        # Early termination on direct goal connect with best path\n                        if cost_to_goal < float('inf'):\n                            break\n\n            # Mark key frame visualization every 40 iterations for smooth animation\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
          "objective": 561.525,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.97,
               "average_distance": 11.76,
               "average_smoothness": 0.34,
               "average_clearance": 2.14,
               "average_time": 0.0356,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 33.3,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -20.02,
               "average_distance_improvement": -21.74,
               "average_smoothness_improvement": -30.77,
               "average_clearance_improvement": 7.0,
               "average_time_improvement": -374.67,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 2.0999999999999996,
               "average_memory_improvement": 10.56
          }
     },
     {
          "algorithm": "PathPlanning: \n    This algorithm is an improved version combining goal-biased informed sampling with heuristic-guided tree expansion for efficient pathfinding.\n    Key features:\n    - Uses a Forest graph to maintain a tree rooted at the start.\n    - Employs an adaptive max step size that shrinks as the tree approaches the goal, allowing finer movements near the goal for smoother paths.\n    - Incorporates goal bias with a probability of sampling directly near the goal.\n    - Uses a heuristic cost (distance to goal) to prioritize expansion towards more promising vertices.\n    - Implements rewiring optimization similar to RRT* but with an adaptive neighborhood radius based on graph size/log and distance to goal.\n    - Applies a path shortcutting technique on the extracted path to smooth and shorten it by attempting direct-valid line shortcuts.\n    - Early stopping if goal reached or if total planning time exceeds 10 seconds.\n    - The approach focuses on reducing total iterations, improving path smoothness, and enhancing success rate by adaptive sampling and rewiring.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 3.0   # Min step size near goal\n        self._goal_sample_rate = 0.2  # Probability to sample near goal\n        self._max_iterations = 5000\n        self._lambda_rrt_star = 50\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased sampling: with certain probability sample near goal, else random in space\n        import time\n        \n        if self._start_time is None:\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            goal_pos = grid.goal.position\n            # Sample in a small ball around goal for goal bias\n            for _ in range(30):  # max retry for valid pos\n                sample_offset = torch.randn(self._dimension)\n                sample_offset *= self._min_max_dist\n                sample = Point(*(goal_pos.to_tensor() + sample_offset).round().int().tolist())\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback if can't sample near goal\n            return goal_pos\n        else:\n            for _ in range(100):\n                sample_coords = []\n                for dim in range(self._dimension):\n                    sample_coords.append(torch.randint(0, grid.size[dim], (1,)).item())\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # If no valid sampled point found after retries (very rare), fallback to start pos\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Adaptive max move distance: smaller near goal, larger far away\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        scaled = max(self._min_max_dist, min(self._max_max_dist, dist * 0.3))\n        return scaled\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Choose first parent (assumes tree structure)\n            current = next(iter(current.parents))\n        path.reverse()\n\n        # Shortcut smoothing: try to shortcut path by skipping intermediate points\n        grid = self._get_grid()\n        i = 0\n        while i < len(path) - 2:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove intermediate vertices between i and j\n                    del path[i + 1:j]\n                    j = i + 1\n                else:\n                    j -= 1\n            i += 1\n\n        # Move agent along smoothed path with keyframes\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        for iteration in range(self._max_iterations):\n            # Check time limit\n            if self._start_time is None:\n                self._start_time = time.time()\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Stop searching after time limit\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor() - q_nearest.position.to_tensor()\n            dir_norm = torch.norm(dir_tensor)\n            if dir_norm == 0:\n                continue\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            # Cost from start through q_nearest to q_new\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            # Find nearby vertices for rewiring using adaptive radius\n            card_v = torch.tensor(float(self._graph.size if self._graph.size>0 else 1))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)), 30.0)\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose best parent among nearby vertices using cost + heuristic (distance to q_new)\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                if cost_candidate < c_min and grid.is_valid_line_sequence(line_seq_candidate):\n                    q_min = q_near\n                    c_min = cost_candidate\n\n            # Reassign q_new with best parent found\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if q_new provides lower cost paths\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new < q_near.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove old parent edge\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        # Add new edge from q_new to q_near\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if close enough to goal to consider connected\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                # Verify connection to goal is valid\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Extract and smooth path, then stop\n                    self._extract_path_and_smooth(goal_vertex)\n                    return\n\n            self.key_frame()",
          "objective": 1885.82,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 9.91,
               "average_distance": 10.46,
               "average_smoothness": 0.35,
               "average_clearance": 2.06,
               "average_time": 0.0969,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 49.9,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -8.42,
               "average_distance_improvement": -8.28,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 3.0,
               "average_time_improvement": -1192.0,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 0.8000000000000007,
               "average_memory_improvement": -34.03
          }
     },
     {
          "algorithm": "This algorithm implements an Improved Heuristic-Based Anytime Sampling Tree (IHAST)\n    algorithm for grid path planning.\n    It combines heuristic-guided sampling inspired by A* with adaptive step size and goal biasing,\n    while maintaining a dynamically rewired tree structure for quality improvement.\n    Key ideas:\n      - Samples are generated using a heuristic distribution that favors points closer to the\n        estimated optimal path (start to goal distances combined).\n      - Adaptive step size is adjusted based on clearance from obstacles and direction smoothness.\n      - A priority-based rewiring next to new vertices attempts local path optimization continuously.\n      - Uses early termination if goal is reached or 10 seconds exceeded.\n      - Implements a shortcutting smoothing step when extracting the path.\n      - This method aims to reduce iterations by focused sampling and improve path smoothness and robustness.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        # Parameters\n        self._time_limit = 10.0  # seconds timeout\n        self._max_iterations = 8000  # iterations limit\n        self._goal_sample_rate = 0.25  # percent chance to sample from goal directly\n        self._search_radius_rewire = 12.0  # radius to search neighbors for rewiring\n        self._min_step = 2.5\n        self._max_step = 14.0\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Samples points biased by heuristic distribution combining distance from start and to goal.\n        Uses rejection sampling to favor points closer to the optimal heuristic corridor.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n        size = grid.size\n\n        max_distance = Map.get_distance(Point(0, 0), Point(*size))\n        attempts = 0\n        while True:\n            attempts += 1\n            sample_coords = np.random.randint(0, size, size.n_dim)\n            sample_pt = Point(*sample_coords)\n\n            if not grid.is_agent_valid_pos(sample_pt):\n                continue\n\n            # Heuristic = dist(start->sample) + dist(sample->goal)\n            h_val = Map.get_distance(agent_pos, sample_pt) + Map.get_distance(sample_pt, goal_pos)\n\n            # Normalize heuristic into [0,1]\n            h_norm = h_val / max_distance\n\n            # Use h_norm as probability threshold (lower h_norm favored)\n            if np.random.rand() < 1.0 - h_norm:\n                return sample_pt\n\n            if attempts > 500:\n                # fallback: return any valid sample to avoid infinite loops\n                return sample_pt\n\n    def _adaptive_step_size(self, pos: Point, direction: Point) -> float:\n        \"\"\"\n        Adaptive step size scales with clearance in the direction of movement and alignment smoothness.\n        Smaller steps near obstacles or sharp turns.\n        \"\"\"\n        grid = self._get_grid()\n        min_step = self._min_step\n        max_step = self._max_step\n\n        # Normalize direction vector to tensor\n        dir_tensor = direction.to_tensor()\n        norm = torch.norm(dir_tensor)\n        if norm == 0:\n            return min_step\n        unit_dir = dir_tensor / norm\n\n        # Sample distances at intervals along direction to detect obstacle clearance\n        for radius in np.linspace(min_step, max_step, num=6):\n            sample_tensor = pos.to_tensor() + radius * unit_dir\n            sample_point = Point.from_tensor(sample_tensor)\n\n            if not grid.is_agent_valid_pos(sample_point):\n                # Obstacle close, reduce step proportionally\n                return radius * 0.5\n\n            line_seq = grid.get_line_sequence(pos, sample_point)\n            if not grid.is_valid_line_sequence(line_seq):\n                return radius * 0.5\n\n        return max_step\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex or None:\n        \"\"\"\n        Generate new Vertex stepping towards q_sample from q_near with adaptive step-size check.\n        Returns None if move invalid.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        dir_normalized = dir_vec / norm\n\n        # Evaluate adaptive step size in that direction\n        step_size = self._adaptive_step_size(q_near.position, Point.from_tensor(dir_normalized))\n\n        step_size = min(step_size, max_dist)\n\n        if norm <= step_size:\n            q_new_pos = q_sample\n        else:\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + step_size * dir_normalized)\n\n        # Validate path line sequence\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: list, q_new: Vertex) -> Vertex or None:\n        \"\"\"\n        Choose lowest cost parent vertex for q_new from q_near_list with a valid collision-free connection.\n        \"\"\"\n        min_cost = float('inf')\n        chosen_parent = None\n        grid = self._get_grid()\n\n        for neighbor in q_near_list:\n            cost_to_new = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new.position)\n            line_seq = grid.get_line_sequence(neighbor.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                chosen_parent = neighbor\n\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: list) -> None:\n        \"\"\"\n        Attempt local rewiring by connecting neighbors through q_new if it decreases cost.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parents:\n                continue\n            current_cost = neighbor.cost\n            potential_cost = q_new.cost + grid.get_movement_cost(q_new.position, neighbor.position)\n\n            if potential_cost < current_cost:\n                line_seq = grid.get_line_sequence(q_new.position, neighbor.position)\n                if grid.is_valid_line_sequence(line_seq):\n                    # Remove old edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    # Add new edge\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = potential_cost\n\n    def _shortcut_path(self, path: list) -> list:\n        \"\"\"\n        Shortcut smoothing tries to connect farther away vertices directly to minimize path length.\n        \"\"\"\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path  # Nothing to shortcut\n\n        shortcut_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            last_added = shortcut_path[-1]\n            # Try to connect farthest reachable node directly ahead\n            max_reachable_idx = idx + 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                line_seq = grid.get_line_sequence(last_added.position, path[test_idx].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    max_reachable_idx = test_idx\n                    break\n            shortcut_path.append(path[max_reachable_idx])\n            idx = max_reachable_idx\n        return shortcut_path\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Build path from q_new up to start vertex, add goal connection, smooth path,\n        then move the agent along the smoothed path.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        grid = self._get_grid()\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + grid.get_movement_cost(q_new.position, goal_v.position)\n\n        path = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Pick minimal cost parent among multiple parents\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove duplicated start vertex\n        path.reverse()\n\n        # Smooth via shortcutting\n        smooth_path = self._shortcut_path(path)\n\n        # Trace agent through smoothed path\n        for vertex in smooth_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_pos = grid.agent.position\n        goal_pos = grid.goal.position\n\n        self._graph.root_vertex_start.cost = 0.0\n        self._graph.root_vertex_goal.cost = float('inf')\n\n        for iteration in range(self._max_iterations):\n\n            if time.time() - start_time > self._time_limit:\n                # Timeout condition, no solution found within time\n                break\n\n            # Goal biasing: sample goal directly with probability\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample = goal_pos\n            else:\n                q_sample = self._heuristic_sample()\n\n            # Find nearest vertex to sample\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist = self._adaptive_step_size(q_near.position, Point.from_tensor(q_sample.to_tensor() - q_near.position.to_tensor()))\n            max_dist = max(min(max_dist, self._max_step), self._min_step)\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for parent selection and rewiring\n            neighbors = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._search_radius_rewire)\n            chosen_parent = self._choose_parent(neighbors, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and update cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + grid.get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors through q_new if beneficial\n            neighbors = [v for v in neighbors if v != chosen_parent]\n            self._rewire(q_new, neighbors)\n\n            # Check for goal reach with radius consider start with smaller radius threshold\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
          "objective": 2790.77,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.67,
               "average_steps": 9.41,
               "average_distance": 10.01,
               "average_smoothness": 0.33,
               "average_clearance": 2.05,
               "average_time": 0.1358,
               "average_distance_from_goal": 0.31,
               "average_original_distance_from_goal": 8.42,
               "average memory": 55.23,
               "goal_found_perc_improvement": -0.68,
               "average_steps_improvement": -4.21,
               "average_distance_improvement": -4.82,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 1.99,
               "average_time_improvement": -1735.14,
               "average_distance_from_goal_improvement": -55.0,
               "average_path_deviation": 0.4599999999999991,
               "average_memory_improvement": -48.35
          }
     },
     {
          "algorithm": "Improved PathPlanning Algorithm combining goal-biased adaptive informed sampling, \n    heuristic-guided dynamic expansion, and efficient rewiring optimization aiming for \n    faster convergence, higher success rate, and smoother paths. \n    Key improvements over the base include:\n    - Adaptive max step size scaled dynamically with progress towards goal and tree size,\n      allowing coarser exploration far and finer near goal.\n    - Enhanced sampling distribution mixing uniform, goal-biased, and informed ellipsoidal sampling \n      based on current best path cost to focus search.\n    - Heuristic cost incorporating both traveled cost and admissible distance-to-go to prioritize vertices.\n    - Dynamic neighborhood radius for rewiring scaled with tree size and iteration.\n    - Early rewire pruning to decrease tree clutter and improve paths.\n    - Path shortcutting with robust multiple attempts for smoothing.\n    - Early termination on finding direct connect to goal with smooth path.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 15.0  # Max step size\n        self._min_max_dist = 2.5   # Min step size near goal for finer control\n        self._goal_sample_rate = 0.25  # Slightly increased goal bias\n        self._informed_sample_rate = 0.3  # Probability to do informed sampling\n        self._max_iterations = 4000  # Reduced max iterations due to more efficient search\n        self._lambda_rrt_star = 45  # tuning rewiring radius factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Maximum planning time\n        self._best_cost = float('inf')  # Track best path cost found so far\n        self._init_displays()\n\n    def _sample_in_ellipsoid(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        # Sample inside an ellipsoid defined by start, goal, and current best cost c_max (informed sampling)\n        import math\n        import torch\n\n        # If no current best cost (or infinite), fallback to uniform sampling\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        center = Point(\n            *(((start_pos.to_tensor().float()+goal_pos.to_tensor().float())/2).tolist())\n        )\n        diff = goal_pos.to_tensor().float() - start_pos.to_tensor().float()\n        dist_start_goal = torch.norm(diff).item()\n        if dist_start_goal < 1e-8:\n            return start_pos\n        # Unit vector from start to goal\n        e1 = diff / dist_start_goal\n\n        # Compute rotation matrix (2D)\n        # Since dimension=2, rotation matrix R aligns x-axis with vector start->goal\n        cos_theta = e1[0].item()\n        sin_theta = e1[1].item()\n        R = torch.tensor([[cos_theta, -sin_theta],\n                          [sin_theta, cos_theta]])\n\n        # Define ellipsoid axes lengths\n        a = c_max / 2.0  # major axis length\n        b = math.sqrt(max(c_max**2 - dist_start_goal**2, 1e-6)) / 2.0  # minor axis length\n\n        for _ in range(40):  # max retries\n            # Sample uniformly inside unit ball in 2D\n            theta = 2 * math.pi * torch.rand(1).item()\n            r = torch.sqrt(torch.rand(1)).item()\n            x_ball = torch.tensor([r * torch.cos(torch.tensor(theta)).item(), r * torch.sin(torch.tensor(theta)).item()])\n\n            # Scale by ellipsoid axes\n            sample_local = torch.tensor([a * x_ball[0].item(), b * x_ball[1].item()])\n            # Rotate and translate back to world frame\n            sample_world = R @ sample_local + center.to_tensor().float()\n            sample_point = Point.from_tensor(sample_world.round().int())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # fallback uniform random sample if informed fails\n        return self._get_random_sample()\n\n    def _get_random_sample(self) -> Point:\n        import torch\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        grid = self._get_grid()\n        rand_val = torch.rand(1).item()\n\n        if rand_val < self._goal_sample_rate:\n            # Goal biased sampling: sample near the goal within min_max_dist radius\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                sample_offset = torch.randn(self._dimension)\n                sample_offset = sample_offset / torch.norm(sample_offset) if torch.norm(sample_offset) > 1e-8 else sample_offset\n                sample_offset = sample_offset * (torch.rand(1).item() * self._min_max_dist)\n                sample = Point(*((goal_pos.to_tensor().float() + sample_offset).round().int().tolist()))\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            return goal_pos\n\n        elif rand_val < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling to focus search within cost bound\n            return self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n\n        else:\n            # Uniform random sampling in grid valid positions\n            for _ in range(120):\n                sample_coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n                sample = Point(*sample_coords)\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n            # fallback to start position\n            return self._graph.root_vertex_start.position\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        # Dynamic max step size, also depends on tree size for finer control as more vertices are added\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist = Map.get_distance(q_pos, goal_pos)\n        progress_factor = max(0.05, min(1.0, dist / max(grid.size)))  # normalized distance to goal\n        tree_size_factor = min(1.0, 500 / (self._graph.size + 1))  # shrink step size as tree grows\n        scaled = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * progress_factor * tree_size_factor\n        return scaled\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Admissible heuristic: Euclidean distance to goal\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex):\n        # Same as reference but enhanced shortcutting with multiple tries for robustness\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n\n        grid = self._get_grid()\n\n        # Robust shortcut smoothing: multiple passes\n        for _ in range(3):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(line_seq):\n                        del path[i + 1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Time check early stop\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                # Abort if planning too long\n                return\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_tensor = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dir_norm = torch.norm(dir_tensor).item()\n            if dir_norm == 0:\n                continue\n\n            if dir_norm <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_tensor / dir_norm\n                q_new_pos = Point.from_tensor((q_nearest.position.to_tensor().float() + dir_normalized * max_dist).round().int())\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Construct new vertex and calculate cost to reach\n            q_new = Vertex(q_new_pos)\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_nearest_to_new\n\n            card_v = max(self._graph.size, 1)\n            ln_card_v = torch.log(torch.tensor(float(card_v))).item() if card_v > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_card_v / card_v) ** (1 / self._dimension)), 25.0)\n\n            vertices_near = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Choose the best parent with minimum cost + heuristic\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_nearest_to_new\n            for q_near in vertices_near:\n                dist_near_new = torch.norm(q_near.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = q_near.cost + dist_near_new\n                if cost_candidate < c_min:\n                    line_seq_candidate = grid.get_line_sequence(q_near.position, q_new.position)\n                    if grid.is_valid_line_sequence(line_seq_candidate):\n                        q_min = q_near\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if new path is better\n            for q_near in vertices_near:\n                if q_near == q_min:\n                    continue\n                dist_new_near = torch.norm(q_new.position.to_tensor().float() - q_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_near\n                if cost_through_new + 1e-5 < q_near.cost:  # add a small epsilon for numerical stability\n                    line_seq_rewire = grid.get_line_sequence(q_new.position, q_near.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove one old parent edge (tree structure)\n                        for parent in q_near.parents:\n                            self._graph.remove_edge(parent, q_near)\n                            break\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_goal):\n                    # Construct or update goal vertex connection\n                    goal_vertex = Vertex(goal_pos)\n                    cost_to_goal = q_new.cost + dist_to_goal\n                    goal_vertex.cost = cost_to_goal\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    # Check and update best path cost found\n                    if cost_to_goal < self._best_cost:\n                        self._best_cost = cost_to_goal\n                        found_goal = goal_vertex\n\n                    # Early stop on valid goal connection\n                    break\n\n            if iteration % 50 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
          "objective": 3134.495,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.0,
               "average_steps": 10.89,
               "average_distance": 11.68,
               "average_smoothness": 0.33,
               "average_clearance": 2.15,
               "average_time": 0.1508,
               "average_distance_from_goal": 0.34,
               "average_original_distance_from_goal": 8.42,
               "average memory": 50.95,
               "goal_found_perc_improvement": -1.37,
               "average_steps_improvement": -20.07,
               "average_distance_improvement": -22.05,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 6.97,
               "average_time_improvement": -1937.84,
               "average_distance_from_goal_improvement": -70.0,
               "average_path_deviation": 2.1099999999999994,
               "average_memory_improvement": -36.85
          }
     },
     {
          "algorithm": "This algorithm implements an RRT* inspired path planner that combines goal-biased adaptive sampling,\n    rewiring for path optimization, and an adaptive step size for efficient exploration and smoother paths.\n    It balances exploration and exploitation by sampling towards the goal with a bias while considering the\n    environment's clearance to adjust the extension step. The rewiring step tries to reduce total path cost dynamically,\n    improving path quality and success rate. An early timeout of 10 seconds ensures practical responsiveness.\n    A final path shortcutting step smooths the found path before tracing it.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring which involves edge removals.\n        self._init_displays()\n\n    def _get_random_sample(self, goal_sample_rate=0.2) -> Point:\n        # Goal-biased sampling: with probability goal_sample_rate, return goal point directly\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, pos: Point, min_dist=3.0, max_dist=15.0) -> float:\n        # Adapt step size by estimating clearance to nearest obstacle bound or environment border.\n        # Sample neighbors; if free space large, increase max_dist, else reduce it.\n        clearance = max_dist\n        for radius in np.linspace(min_dist, max_dist, num=5):\n            # Check a line from pos in direction towards goal scaled by radius if collision-free\n            direction = self._get_grid().goal.position.to_tensor() - pos.to_tensor()\n            if direction.norm() == 0:\n                break\n            dir_norm = direction / direction.norm()\n            test_point_tensor = pos.to_tensor() + radius * dir_norm\n            test_point = Point.from_tensor(test_point_tensor)\n            if not self._get_grid().is_agent_valid_pos(test_point):\n                clearance = radius * 0.5\n                break\n            # Also validate line sequence\n            line_seq = self._get_grid().get_line_sequence(pos, test_point)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                clearance = radius * 0.5\n                break\n        return np.clip(clearance, min_dist, max_dist)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir_vec)\n        if norm == 0:\n            return None\n        if norm <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir_vec / norm\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        \n        # Check validity of the line along new connection\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent from neighbors that minimize cost + movement cost if edge is valid\n        min_cost = float('inf')\n        chosen_parent = None\n        for v in q_near_list:\n            dist = Map.get_distance(v.position, q_new.position)\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + self._get_grid().get_movement_cost(v.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                chosen_parent = v\n        return chosen_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # Try to rewire neighbors through q_new if it reduces cost and line is valid\n        for v in q_near_list:\n            if v == q_new.parents:\n                continue\n            dist = Map.get_distance(q_new.position, v.position)\n            potential_cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, v.position)\n            if potential_cost < v.cost:\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edges from parents to v and add edge from q_new to v\n                    for p in list(v.parents):\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = potential_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reconstruct path from q_new up to start, add goal edge, shortcut path and trace agent\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_v.position)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # Pick parent with minimum cost (could be multiple parents)\n            min_cost_parent = min(path[-1].parents, key=lambda p: p.cost)\n            path.append(min_cost_parent)\n        path.pop()  # Remove the start duplicate\n        path.reverse()\n\n        # Shortcut smoothing to improve path quality: try to skip intermediate vertices if direct line is valid\n        smoothed_path = [path[0]]\n        for v in path[1:]:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(smoothed_path[-1].position, v.position)):\n                # can connect directly\n                continue\n            else:\n                # add previous vertex since current direct connection invalid\n                prev_index = path.index(v) - 1\n                smoothed_path.append(path[prev_index])\n        # Always append last vertex (goal)\n        smoothed_path.append(path[-1])\n\n        # Trace the path to move agent\n        for vertex in smoothed_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_iterations: int = 10000\n        goal_sample_rate: float = 0.3\n        search_radius: float = 15.0  # radius for rewiring\n        start_time = time.time()\n        \n        # Initialize start cost\n        self._graph.root_vertex_start.cost = 0.0\n\n        for i in range(max_iterations):\n            if time.time() - start_time > 10.0:\n                # Timeout: treat as failed\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            max_dist: float = self._adaptive_max_dist(q_near.position)\n            q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            # Find neighbors for potential parents\n            q_near_list: List[Vertex] = self._get_near_vertices(q_new, search_radius)\n            chosen_parent: Optional[Vertex] = self._choose_parent(q_near_list, q_new)\n            if chosen_parent is None:\n                chosen_parent = q_near\n\n            # Add edge and set cost\n            self._graph.add_edge(chosen_parent, q_new)\n            q_new.cost = chosen_parent.cost + self._get_grid().get_movement_cost(chosen_parent.position, q_new.position)\n\n            # Rewire neighbors\n            q_near_list = [v for v in q_near_list if v != chosen_parent]\n            self._rewire(q_new, q_near_list)\n\n            # Check for goal reach with some radius threshold\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()",
          "objective": 3714.345,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 9.9,
               "average_distance": 10.5,
               "average_smoothness": 0.33,
               "average_clearance": 2.08,
               "average_time": 0.1897,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 46.74,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -8.32,
               "average_distance_improvement": -8.7,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 4.0,
               "average_time_improvement": -2429.33,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 0.8399999999999999,
               "average_memory_improvement": -25.54
          }
     },
     {
          "algorithm": "Improved RRT* inspired path planning algorithm with goal biasing and rewiring for path quality improvement.\n    The algorithm samples points with a goal bias, dynamically adjusts max step distance, connects new vertices \n    by minimizing cost considering nearby vertices, and rewires the graph to improve path optimality.\n    Early stopping on goal reach and time limit (10 seconds) is enforced to enhance efficiency.\n    The extracted path is smoothed by shortcutting invalid intermediate points for better path quality.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = True  # needed for rewiring of RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self, goal_bias=0.1) -> Point:\n        # With probability goal_bias, sample the goal position directly to bias growth toward goal\n        if np.random.random() < goal_bias:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        # Trace from goal to start through parents, build path\n        path = [q_last]\n        while len(path[-1].parents) != 0:\n            # Since rewiring can cause multiple parents, pick parent with minimum cost\n            min_parent = min(path[-1].parents, key=lambda v: v.cost)\n            path.append(min_parent)\n        path.reverse()\n\n        # Shortcut path to smooth it\n        path = self._shortcut_path(path)\n\n        # Animate path moving agent\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Try to skip intermediate vertices if direct line is valid between vertices\n        shortened = [path[0]]\n        for i in range(1, len(path)):\n            # Check if direct line from last added vertex to this vertex is valid\n            line_seq = self._get_grid().get_line_sequence(shortened[-1].position, path[i].position)\n            if i == len(path) - 1 or not self._get_grid().is_valid_line_sequence(line_seq):\n                # Can't skip, add previous vertex i-1\n                shortened.append(path[i - 1])\n        # Always append last vertex if not included\n        if shortened[-1] != path[-1]:\n            shortened.append(path[-1])\n        return shortened\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist_init = 10.0\n        max_dist_min = 3.0\n        max_dist_max = 15.0\n        iteration_limit = 10000\n        goal_radius = max(self._get_grid().goal.radius, 1)\n        start_time = time.time()\n\n        # Initialize costs for start vertex\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n\n        for i in range(iteration_limit):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10.0:\n                # Timeout: path not found within 10 seconds\n                break\n\n            # Adaptive step size based on iteration progress (shrink over time)\n            max_dist = max(\n                max_dist_max - (max_dist_max - max_dist_min) * (i / iteration_limit),\n                max_dist_min,\n            )\n\n            # Sample point with goal biasing\n            q_sample = self._get_random_sample(goal_bias=0.15)\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Validate line between q_near and q_new\n            line_sequence = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_sequence):\n                continue\n\n            # Find neighbors within a radius for rewiring (RRT* style)\n            radius = min(max_dist * 2.5, 30)\n            neighbors = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n\n            # Choose parent with lowest cost+distance in neighbors\n            min_cost = float(\"inf\")\n            parent_for_new = None\n            for neighbor in neighbors:\n                # Check if path from neighbor to q_new is collision free\n                line_seq_nw = self._get_grid().get_line_sequence(neighbor.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_nw):\n                    continue\n                cost_through_n = neighbor.cost + self._get_grid().get_distance(neighbor.position, q_new.position)\n                if cost_through_n < min_cost:\n                    min_cost = cost_through_n\n                    parent_for_new = neighbor\n\n            if parent_for_new is None:\n                # If no suitable parent, fallback to q_near\n                if not self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    continue\n                parent_for_new = q_near\n                min_cost = q_near.cost + self._get_grid().get_distance(q_near.position, q_new.position)\n\n            # Add q_new vertex with parent_for_new\n            q_new.cost = min_cost\n            self._graph.add_edge(parent_for_new, q_new)\n\n            # Rewire neighbors if going through q_new improves cost\n            for neighbor in neighbors:\n                if neighbor == parent_for_new:\n                    continue\n                line_seq_new_neigh = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_neigh):\n                    continue\n                new_cost = q_new.cost + self._get_grid().get_distance(q_new.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire: remove old edges from all parents to neighbor\n                    for p in list(neighbor.parents):\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = new_cost\n\n            # Check goal reached under radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add final goal vertex connected from q_new (if valid)\n                final_goal_pos = self._get_grid().goal.position\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, final_goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    goal_vertex = Vertex(final_goal_pos)\n                    goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, final_goal_pos)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Mark key frame for visualization\n            self.key_frame()",
          "objective": 7286.58,
          "other_inf": null,
          "results": {
               "goal_found_perc": 97.33,
               "average_steps": 10.58,
               "average_distance": 11.21,
               "average_smoothness": 0.35,
               "average_clearance": 2.13,
               "average_time": 0.3649,
               "average_distance_from_goal": 0.2,
               "average_original_distance_from_goal": 8.42,
               "average memory": 58.72,
               "goal_found_perc_improvement": 0.0,
               "average_steps_improvement": -15.75,
               "average_distance_improvement": -16.05,
               "average_smoothness_improvement": -34.62,
               "average_clearance_improvement": 6.5,
               "average_time_improvement": -4765.33,
               "average_distance_from_goal_improvement": -0.0,
               "average_path_deviation": 1.5500000000000007,
               "average_memory_improvement": -57.72
          }
     },
     {
          "algorithm": "This algorithm introduces a hybrid heuristic-tree approach inspired by both RRT-star and A*-informed search,\n    designed to improve planning efficiency, path quality, robustness, and success rate.\n\n    Key innovations:\n    - Dual graph tracking: maintains a growing exploration tree (Forest) combined with a priority queue-driven\n      best-first search over vertices to prioritize expansions based on estimated full path cost (cost-so-far + heuristic).\n    - Adaptive step size tuned dynamically by both clearance and heuristic distance to goal, allowing flexible zoom-in/out.\n    - Sampling combines goal bias and clearance-aware uniform sampling to balance exploitation and safe exploration.\n    - Lazy collision checking: line sequence validity is deferred until a promising expansion is found to reduce overhead.\n    - Rewiring with cost-improvement pruning, but only applied when improvement exceeds a dynamic threshold scaled to current best cost.\n    - Early stopping triggered immediately upon discovering a path improving over best known cost, and final path smoothing.\n    - Timeout enforced after 10 seconds to ensure practical responsiveness.\n    - Path extraction uses graph-parent pointers with post-processing shortcut smoothing for high-quality output.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None):\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph.edges_removable = True\n\n        # Parameters blending previous insights\n        self._goal_sample_rate = 0.25\n        self._clearance_threshold = 2.5\n        self._max_iterations = 3000\n        self._time_limit_seconds = 10.0\n        self._dimension = 2\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._min_step = 2.0\n        self._max_step = 15.0\n        self._rewire_lambda = 30.0  # radius scaling factor for neighborhood rewiring\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        grid = self._get_grid()\n        max_clearance_check = 12.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _clearance_aware_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        for _ in range(120):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n        prob = torch.rand(1).item()\n        if prob < self._goal_sample_rate:\n            # goal biased with small random offset inside goal radius\n            goal_pos = grid.goal.position\n            for _ in range(30):\n                offset = torch.randint(-2, 3, (self._dimension,))\n                candidate = Point(goal_pos.x + offset[0].item(), goal_pos.y + offset[1].item())\n                if grid.is_agent_valid_pos(candidate) and self._get_clearance(candidate) >= self._clearance_threshold:\n                    return candidate\n            return goal_pos\n        else:\n            # clearance-aware uniform sample\n            return self._clearance_aware_sample()\n\n    def _adaptive_step_size(self, pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_to_goal = Map.get_distance(pos, goal_pos)\n        norm_dist = min(1.0, dist_to_goal / max(grid.size))\n\n        tree_size = max(self._graph.size, 1)\n        tree_factor = min(1.0, 500.0 / tree_size)\n\n        clearance = self._get_clearance(pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 1.5))\n\n        step = self._min_step + (self._max_step - self._min_step) * norm_dist * tree_factor * clearance_factor\n        return max(self._min_step, min(step, self._max_step))\n\n    def _heuristic(self, pos: Point) -> float:\n        return Map.get_distance(pos, self._get_grid().goal.position)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import heapq\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal_vertex = None\n        self._start_time = time.time()\n\n        # Priority queue for best-first expansion: (estimated_total_cost, vertex)\n        open_queue = []\n        # Init with start vertex: cost_so_far + heuristic\n        heapq.heappush(open_queue, (self._heuristic(start_vertex.position), start_vertex))\n\n        # We'll store a lookup for vertices by position for quick prune/add\n        vertex_map = {start_vertex.position: start_vertex}\n\n        iterations = 0\n        while iterations < self._max_iterations:\n            if time.time() - self._start_time > self._time_limit_seconds:\n                break\n\n            if not open_queue:\n                # No vertices to expand => failure to find path\n                break\n\n            est_tot_cost, current_v = heapq.heappop(open_queue)\n            iterations += 1\n\n            # Sample a new point biased by heuristics and clearance-aware sample\n            q_sample = self._get_random_sample()\n\n            # Adaptive step towards sample from current vertex\n            max_step = self._adaptive_step_size(current_v.position)\n            dir_vec = torch.tensor([q_sample.x - current_v.position.x, q_sample.y - current_v.position.y], dtype=torch.float32)\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n            dir_norm = dir_vec / dist\n            step_length = min(dist, max_step)\n            new_pos_tensor = torch.round(torch.tensor([current_v.position.x, current_v.position.y], dtype=torch.float32) + dir_norm * step_length).int()\n            q_new_pos = Point(new_pos_tensor[0].item(), new_pos_tensor[1].item())\n\n            if q_new_pos == current_v.position:\n                continue\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            # Lazy collision checking: only check edge if promising cost\n            # Check if q_new_pos is already in graph: skip duplicates\n            if q_new_pos in vertex_map:\n                continue\n\n            # Validate line sequence between current and q_new\n            line_seq = grid.get_line_sequence(current_v.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new_vertex = Vertex(q_new_pos)\n            move_cost = grid.get_movement_cost(current_v.position, q_new_pos)\n            cost_to_q_new = current_v.cost + move_cost\n            q_new_vertex.cost = cost_to_q_new\n\n            # Neighborhood radius for rewiring, adapt with clearance and iteration\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._rewire_lambda * ((ln_size / size) ** (1 / self._dimension)), 20.0)\n            clearance_factor = 1.0 + min(self._get_clearance(q_new_pos) / (self._clearance_threshold * 2.0), 1.0)\n            radius *= clearance_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new_pos, radius)\n\n            # Among neighbors pick parent with minimum cost + heuristic if connection valid\n            best_parent = current_v\n            best_cost = cost_to_q_new\n            for neighbor in near_vertices:\n                candidate_cost = neighbor.cost + grid.get_movement_cost(neighbor.position, q_new_pos)\n                if candidate_cost < best_cost - 1e-5:\n                    # Validate edge before choosing parent\n                    line_seq_candidate = grid.get_line_sequence(neighbor.position, q_new_pos)\n                    if not grid.is_valid_line_sequence(line_seq_candidate):\n                        continue\n                    best_cost = candidate_cost\n                    best_parent = neighbor\n\n            q_new_vertex.cost = best_cost\n            self._graph.add_edge(best_parent, q_new_vertex)\n            vertex_map[q_new_pos] = q_new_vertex\n\n            # Rewiring neighbors to q_new if improved cost and valid\n            cost_improve_thresh = max(0.001, 0.005 * (self._best_cost if self._best_cost< float('inf') else 1.0))\n            for neighbor in near_vertices:\n                if neighbor == best_parent:\n                    continue\n                new_cost_via_qnew = q_new_vertex.cost + grid.get_movement_cost(q_new_vertex.position, neighbor.position)\n                if new_cost_via_qnew + cost_improve_thresh < neighbor.cost:\n                    line_seq_rewire = grid.get_line_sequence(q_new_vertex.position, neighbor.position)\n                    if grid.is_valid_line_sequence(line_seq_rewire):\n                        # Remove existing parent edges\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        neighbor.cost = new_cost_via_qnew\n                        self._graph.add_edge(q_new_vertex, neighbor)\n\n            # Push q_new_vertex into priority queue with estimated total cost heuristic\n            est_total_cost = q_new_vertex.cost + self._heuristic(q_new_vertex.position)\n            heapq.heappush(open_queue, (est_total_cost, q_new_vertex))\n\n            # Check for goal reach with adaptive radius (using step size)\n            dist_to_goal = Map.get_distance(q_new_vertex.position, goal_pos)\n            if dist_to_goal <= max_step:\n                line_to_goal = grid.get_line_sequence(q_new_vertex.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_vertex.cost = q_new_vertex.cost + dist_to_goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n\n                    if goal_vertex.cost < self._best_cost:\n                        self._best_cost = goal_vertex.cost\n                        found_goal_vertex = goal_vertex\n\n                    # Early termination with path smoothing\n                    break\n\n            # Periodic key frame for visualizations or debugging\n            if iterations % 50 == 0:\n                self.key_frame()\n\n        if found_goal_vertex is not None:\n            # Extract path from found goal to root\n            path = []\n            curr = found_goal_vertex\n            while True:\n                path.append(curr)\n                if len(curr.parents) == 0:\n                    break\n                # Choose minimum cost parent to backtrack path\n                curr = min(curr.parents, key=lambda p: p.cost)\n            path.reverse()\n\n            # Path shortcut smoothing: multiple passes trying to remove intermediate vertices\n            for _ in range(3):\n                i = 0\n                while i < len(path) - 2:\n                    j = len(path) - 1\n                    while j > i + 1:\n                        segment = grid.get_line_sequence(path[i].position, path[j].position)\n                        if grid.is_valid_line_sequence(segment):\n                            del path[i+1:j]\n                            j = i + 1\n                        else:\n                            j -= 1\n                    i += 1\n\n            for v in path:\n                self.move_agent(v.position)\n                self.key_frame(ignore_key_frame_skip=True)",
          "objective": 8013.07,
          "other_inf": null,
          "results": {
               "goal_found_perc": 27.33,
               "average_steps": 7.49,
               "average_distance": 7.71,
               "average_smoothness": 0.31,
               "average_clearance": 3.31,
               "average_time": 0.0366,
               "average_distance_from_goal": 6.62,
               "average_original_distance_from_goal": 8.42,
               "average memory": 21.11,
               "goal_found_perc_improvement": -71.92,
               "average_steps_improvement": -8.08,
               "average_distance_improvement": -8.59,
               "average_smoothness_improvement": -24.0,
               "average_clearance_improvement": 2.16,
               "average_time_improvement": -590.57,
               "average_distance_from_goal_improvement": -3210.0,
               "average_path_deviation": 0.6100000000000003,
               "average_memory_improvement": 43.3
          }
     },
     {
          "algorithm": "Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    {Improved RRT* Inspired Path Planning Algorithm with Goal Bias and Rewiring}\n\n    This algorithm extends the classical RRT by incorporating the following enhancements:\n    - Goal-biased sampling to encourage exploration towards the goal, improving success rate and efficiency.\n    - Adaptive rewiring of vertices within a neighborhood radius (RRT* style) to optimize path cost and quality.\n    - Dynamic max_dist step size tuned by environment scale.\n    - Early stopping by time limit (10 seconds) and immediate path extraction upon reaching goal region.\n    - Shortcut smoothing applied after path extraction to reduce unnecessary detours.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edges to be removed during rewiring.\n        self._init_displays()\n\n        self._goal_sample_rate = 0.15   # Probability of sampling the goal to bias sampling towards it.\n        self._rewire_radius = 15        # Radius for rewiring neighbors for optimization.\n        self._max_dist = 12             # Max extension distance per step.\n        self._max_iterations = 8000     # Max iterations to limit planning effort.\n        self._time_limit_sec = 10.0     # Time limit in seconds to stop search if no path found.\n\n    def _get_random_sample(self) -> Point:\n        # Goal-biased random sampling to increase goal reach chance.\n        from random import random\n\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as base, clipped to max_dist step.\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose parent that gives lowest cost path to q_new considering cost + movement cost\n        min_cost = float('inf')\n        min_vertex = None\n        grid = self._get_grid()\n        for q_near in q_near_list:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = q_near.cost + grid.get_distance(q_near.position, q_new.position)\n            if cost < min_cost:\n                min_cost = cost\n                min_vertex = q_near\n        if min_vertex is not None:\n            q_new.cost = min_cost\n            return min_vertex\n        else:\n            return None\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        # Rewire neighbors to q_new if beneficial (lower cost and valid path)\n        grid = self._get_grid()\n        for q_neighbor in neighbors:\n            if q_neighbor == q_new:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_neighbor.position)):\n                continue\n            new_cost = q_new.cost + grid.get_distance(q_new.position, q_neighbor.position)\n            if new_cost < q_neighbor.cost:\n                # Remove old parent edges of q_neighbor leading to higher cost\n                for parent in list(q_neighbor.parents):\n                    self._graph.remove_edge(parent, q_neighbor)\n                # Add new edge from q_new\n                self._graph.add_edge(q_new, q_neighbor)\n                q_neighbor.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        # Extract path from start to q_goal by traversing parents with lowest cost path\n        path: List[Vertex] = [q_goal]\n        curr = q_goal\n        while len(curr.parents) > 0:\n            # Select parent with least cost\n            min_cost_parent = None\n            min_cost = float('inf')\n            for p in curr.parents:\n                if p.cost < min_cost:\n                    min_cost = p.cost\n                    min_cost_parent = p\n            if min_cost_parent is None:\n                break\n            path.append(min_cost_parent)\n            curr = min_cost_parent\n\n        path.reverse()\n\n        # After path extraction, apply shortcut smoothing to improve path quality\n        path = self._shortcut_path(path)\n\n        # Move the agent along the path with animation key frames\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shortcut_path(self, path: List[Vertex]) -> List[Vertex]:\n        # Shortcut smoothing: iteratively try to connect non-adjacent vertices directly\n        grid = self._get_grid()\n        if len(path) <= 2:\n            return path\n\n        shortened_path = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                line_seq = grid.get_line_sequence(path[i].position, path[j].position)\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            shortened_path.append(path[j])\n            i = j\n        return shortened_path\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        grid = self._get_grid()\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0  # Cost to start vertex is zero\n\n        for iteration in range(self._max_iterations):\n            # Check time limit for early termination\n            if (time.time() - start_time) > self._time_limit_sec:\n                # Fail to find path in allocated time\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            # Validate path from q_near to q_new\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Near neighbors for rewiring\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], q_new.position, self._rewire_radius)\n\n            # Select best parent from neighbors (including q_near)\n            if q_near not in neighbors:\n                neighbors.append(q_near)\n            q_parent = self._choose_parent(neighbors, q_new)\n            if q_parent is None:\n                continue\n\n            # Add q_new with selected parent\n            self._graph.add_edge(q_parent, q_new)\n\n            # Rewire neighbors to improve path cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new reached goal region\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal vertex with edge and cost calculation\n                goal_vertex = self._graph.root_vertex_goal\n\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + grid.get_distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()",
          "objective": 8621.68,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.0,
               "average_steps": 10.35,
               "average_distance": 11.01,
               "average_smoothness": 0.34,
               "average_clearance": 2.1,
               "average_time": 0.4177,
               "average_distance_from_goal": 0.34,
               "average_original_distance_from_goal": 8.42,
               "average memory": 63.84,
               "goal_found_perc_improvement": -1.37,
               "average_steps_improvement": -14.11,
               "average_distance_improvement": -15.05,
               "average_smoothness_improvement": -30.77,
               "average_clearance_improvement": 4.48,
               "average_time_improvement": -5544.59,
               "average_distance_from_goal_improvement": -70.0,
               "average_path_deviation": 1.4399999999999995,
               "average_memory_improvement": -71.47
          }
     },
     {
          "algorithm": "Improved path planning algorithm leveraging adaptive, clearance-aware sampling, \n    heuristic-guided expansion, and efficient rewiring optimization for faster convergence, \n    higher success, and safer paths. Key innovations include:\n\n    - Clearance-augmented sampling: biased toward higher clearance regions by rejecting low-clearance samples,\n      improving robustness by steering away from tight obstacles.\n    - Adaptive step size scaled dynamically with progress and tree size, tuned by local clearance, \n      allowing coarse exploration in open spaces and finer near clutter or goal.\n    - Enhanced mixed sampling strategy combining goal bias, informed ellipsoidal sampling, and clearance-aware uniform sampling \n      to focus samples in promising and safe areas.\n    - Neighborhood radius for rewiring dynamically computed based on tree size and incorporates clearance factors.\n    - Early pruning of rewiring if cost improvement is negligible, reducing clutter and improving runtime.\n    - Multiple passes of robust shortcut smoothing to ensure path quality and smoothness.\n    - Early termination upon direct goal connection and smoothing, positing improved efficiency.\n    - Enforces a 10-second timeout for planning to guarantee timely response.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: 'Services', testing: 'BasicTesting' = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._max_max_dist = 18.0  # Slightly increased max step size for faster exploration in open areas\n        self._min_max_dist = 2.5   # Minimum step size near goal or clutter for precision\n        self._goal_sample_rate = 0.2  # Balanced goal bias\n        self._informed_sample_rate = 0.4  # Increased informed sampling to focus effort\n        self._max_iterations = 3500  # Lower max iterations due to increased efficiency\n        self._lambda_rrt_star = 40  # Rewiring radius tuning factor\n        self._dimension = 2\n        self._start_time = None\n        self._time_limit_seconds = 10  # Enforce 10 second planning limit\n        self._best_cost = float('inf')\n        self._clearance_threshold = 3  # Minimum clearance radius for accepting samples\n        self._init_displays()\n\n    def _get_clearance(self, point: Point) -> float:\n        \"\"\"Estimate clearance as minimum distance to any obstacle or boundary.\"\"\"\n        grid = self._get_grid()\n        max_clearance_check = 10.0\n        min_dist = max_clearance_check\n        for obstacle in grid.obstacles:\n            dist = Map.get_distance(point, obstacle.position) - obstacle.radius\n            if dist < min_dist:\n                min_dist = dist\n        # Also consider distance to map boundary\n        x, y = point.x, point.y\n        boundary_clearance = min(x, y, grid.size[0]-1 - x, grid.size[1]-1 - y)\n        return max(0.0, min(min_dist, boundary_clearance))\n\n    def _clearance_aware_sample(self) -> Point:\n        \"\"\"\n        Returns a random valid sample that has clearance above threshold by rejection sampling.\n        Tries uniformly but rejects low clearance points.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        for _ in range(150):\n            coords = [torch.randint(0, grid.size[dim], (1,)).item() for dim in range(self._dimension)]\n            sample = Point(*coords)\n            if not grid.is_agent_valid_pos(sample):\n                continue\n            clearance = self._get_clearance(sample)\n            if clearance >= self._clearance_threshold:\n                return sample\n        # fallback uniformly if no high-clearance sample found\n        return self._graph.root_vertex_start.position\n\n    def _get_random_sample(self) -> Point:\n        import torch\n        grid = self._get_grid()\n\n        if self._start_time is None:\n            import time\n            self._start_time = time.time()\n\n        prob = torch.rand(1).item()\n        if prob < self._goal_sample_rate:\n            # Goal biased sampling inside goal radius zone expanded by min_max_dist\n            goal_pos = grid.goal.position\n            for _ in range(40):\n                offset_vec = torch.randn(self._dimension)\n                norm = torch.norm(offset_vec).item()\n                if norm < 1e-8:\n                    continue\n                offset_vec = offset_vec / norm\n                offset_len = torch.rand(1).item() * self._min_max_dist\n                sample_coords = (goal_pos.to_tensor().float() + offset_vec * offset_len).round().int()\n                sample = Point.from_tensor(sample_coords)\n                if grid.is_agent_valid_pos(sample) and self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            return goal_pos\n\n        elif prob < self._goal_sample_rate + self._informed_sample_rate and self._best_cost < float('inf'):\n            # Informed ellipsoidal sampling with clearance check\n            for _ in range(30):\n                sample = self._sample_in_ellipsoid(grid.agent.position, grid.goal.position, self._best_cost)\n                if self._get_clearance(sample) >= self._clearance_threshold:\n                    return sample\n            # fallback\n            return self._clearance_aware_sample()\n\n        else:\n            # Clearance-aware uniform sampling\n            return self._clearance_aware_sample()\n\n    def _get_adaptive_max_dist(self, q_pos: Point) -> float:\n        import torch\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n        dist_goal = Map.get_distance(q_pos, goal_pos)\n        normalized_dist = max(0.05, min(1.0, dist_goal / max(grid.size)))\n\n        # Tree size factors: larger tree => smaller step size to allow refinement near goal\n        tree_factor = min(1.0, 600 / (self._graph.size + 1))\n\n        # Clearance scaling: smaller step size if clearance is small, larger if clearance high (up to max dist)\n        clearance = self._get_clearance(q_pos)\n        clearance_factor = min(1.0, clearance / (self._clearance_threshold * 2.0))  # Normalize clearance factor (0 to 1+)\n\n        step = (self._min_max_dist + \n                (self._max_max_dist - self._min_max_dist) * normalized_dist * tree_factor * clearance_factor)\n        return max(self._min_max_dist, min(step, self._max_max_dist))\n\n    def _heuristic_cost(self, pos: Point, goal_pos: Point) -> float:\n        # Euclidean distance admissible heuristic for consistency with costs\n        return Map.get_distance(pos, goal_pos)\n\n    def _extract_path_and_smooth(self, q_goal_parent: Vertex) -> None:\n        # Extract path and perform multiple robust shortcut passes\n        path = []\n        current = q_goal_parent\n        while True:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            current = next(iter(current.parents))\n        path.reverse()\n        grid = self._get_grid()\n\n        # Multiple shortcutting passes for smoothing\n        for _ in range(4):\n            i = 0\n            while i < len(path) - 2:\n                j = len(path) - 1\n                while j > i + 1:\n                    segment = grid.get_line_sequence(path[i].position, path[j].position)\n                    if grid.is_valid_line_sequence(segment):\n                        del path[i+1:j]\n                        j = i + 1\n                    else:\n                        j -= 1\n                i += 1\n\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        import torch\n\n        grid = self._get_grid()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = grid.goal.position\n\n        self._best_cost = float('inf')\n        found_goal = None\n\n        if self._start_time is None:\n            self._start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Early timeout abort\n            if (time.time() - self._start_time) > self._time_limit_seconds:\n                return  # abort planning after 10 seconds\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([start_vertex], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            max_dist = self._get_adaptive_max_dist(q_nearest.position)\n            dir_vec = q_sample.to_tensor().float() - q_nearest.position.to_tensor().float()\n            dist = torch.norm(dir_vec).item()\n            if dist < 1e-8:\n                continue\n\n            if dist <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_norm = dir_vec / dist\n                new_pos_tensor = (q_nearest.position.to_tensor().float() + dir_norm * max_dist).round().int()\n                q_new_pos = Point.from_tensor(new_pos_tensor)\n\n            if not grid.is_agent_valid_pos(q_new_pos):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            q_new = Vertex(q_new_pos)\n            dist_qnearest_qnew = torch.norm(q_nearest.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n            q_new.cost = q_nearest.cost + dist_qnearest_qnew\n\n            size = max(self._graph.size, 1)\n            ln_size = torch.log(torch.tensor(float(size))).item() if size > 1 else 0.0\n            radius = min(self._lambda_rrt_star * ((ln_size / size) ** (1 / self._dimension)), 25.0)\n\n            # Inflate radius slightly adapting to clearance to allow more neighbors in open areas\n            clearance_new = self._get_clearance(q_new.position)\n            clearance_radius_factor = 1.0 + min(clearance_new / self._clearance_threshold, 1.0)\n            radius *= clearance_radius_factor\n\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], q_new.position, radius)\n\n            # Select best parent with minimal cost plus heuristic and valid connection\n            q_min = q_nearest\n            c_min = q_nearest.cost + dist_qnearest_qnew\n            for v in near_vertices:\n                dist_v_to_new = torch.norm(v.position.to_tensor().float() - q_new.position.to_tensor().float()).item()\n                cost_candidate = v.cost + dist_v_to_new\n                if cost_candidate < c_min:\n                    candidate_line_seq = grid.get_line_sequence(v.position, q_new.position)\n                    if grid.is_valid_line_sequence(candidate_line_seq):\n                        q_min = v\n                        c_min = cost_candidate\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Efficient rewire neighbors if improved cost (with pruning threshold)\n            rewire_threshold = 0.005\n            for v_near in near_vertices:\n                if v_near == q_min:\n                    continue\n                dist_new_to_near = torch.norm(q_new.position.to_tensor().float() - v_near.position.to_tensor().float()).item()\n                cost_through_new = q_new.cost + dist_new_to_near\n                if cost_through_new + rewire_threshold < v_near.cost:\n                    rewire_line_seq = grid.get_line_sequence(q_new.position, v_near.position)\n                    if grid.is_valid_line_sequence(rewire_line_seq):\n                        # Remove old parent edge (single-parent tree structure)\n                        for p in list(v_near.parents):\n                            self._graph.remove_edge(p, v_near)\n                            break\n                        v_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, v_near)\n\n            dist_to_goal = Map.get_distance(q_new.position, goal_pos)\n            if dist_to_goal <= max_dist:\n                line_to_goal = grid.get_line_sequence(q_new.position, goal_pos)\n                if grid.is_valid_line_sequence(line_to_goal):\n                    goal_vertex = Vertex(goal_pos)\n                    goal_cost = q_new.cost + dist_to_goal\n                    goal_vertex.cost = goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n\n                    if goal_cost < self._best_cost:\n                        self._best_cost = goal_cost\n                        found_goal = goal_vertex\n\n                    # Early termination: direct goal reach with smooth path extraction\n                    break\n\n            if iteration % 40 == 0:\n                self.key_frame()\n\n        if found_goal is not None:\n            self._extract_path_and_smooth(found_goal)",
          "objective": 13819.04,
          "other_inf": null,
          "results": {
               "goal_found_perc": 49.33,
               "average_steps": 7.78,
               "average_distance": 8.03,
               "average_smoothness": 0.28,
               "average_clearance": 2.63,
               "average_time": 0.3236,
               "average_distance_from_goal": 4.97,
               "average_original_distance_from_goal": 8.42,
               "average memory": 43.0,
               "goal_found_perc_improvement": -49.32,
               "average_steps_improvement": -6.28,
               "average_distance_improvement": -7.21,
               "average_smoothness_improvement": -21.74,
               "average_clearance_improvement": 2.73,
               "average_time_improvement": -5892.59,
               "average_distance_from_goal_improvement": -2385.0,
               "average_path_deviation": 0.5399999999999991,
               "average_memory_improvement": -15.5
          }
     }
]