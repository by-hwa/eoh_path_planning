[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.708512676293243,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0016797542572021484,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 82.1887506035762,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 27.56608404471968
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008045697212219238,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 45.39050704503417,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 0.27572040411595267
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0035561323165893555,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 87.72898880878513,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 22.283733580044093
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified, unified bidirectional RRT* planner that balances exploration efficiency and path quality. It grows two trees from the start and goal positions alternately, samples points with adaptive goal biasing, extends nearest nodes towards samples using a fixed step size, and employs local rewiring around new nodes to improve path cost and smoothness. Rigorous collision and edge feasibility checks ensure safety. Upon connection of the trees, the shortest path is reconstructed by merging paths from both connected nodes. The planner avoids excessive complexity while maintaining robustness, smoothness, and efficient convergence.",
          "planning_mechanism": "The planner alternates growth between start and goal trees, samples points with goal bias to encourage connections, extends the nearest node towards samples with a capped step size, rewires neighbors within a radius inversely related to tree size to reduce path cost, and verifies collision-free conditions for nodes and edges. When the trees connect, the optimal path is extracted by backtracking and merged. This approach balances exploration and exploitation to find shorter, smoother feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Parent node or None\n        self.cost = cost                      # Cost from root\n        self.children = []\n        self.valid = True                     # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=20.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes, extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.03871,
          "time_improvement": 44.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0039825916290283205,
                    "num_nodes_avg": 76.2,
                    "path_length_avg": 172.59475061003724,
                    "success_improvement": 0.0,
                    "time_improvement": 57.770648626374324,
                    "length_improvement": 13.738802538996584,
                    "objective_score": 20.078955095711613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013543009757995605,
                    "num_nodes_avg": 249.1,
                    "path_length_avg": 290.1072272486077,
                    "success_improvement": 0.0,
                    "time_improvement": 8.077960621600676,
                    "length_improvement": 3.732607234605092,
                    "objective_score": 3.169909633401221
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009406518936157227,
                    "num_nodes_avg": 162.7,
                    "path_length_avg": 149.7826015352379,
                    "success_improvement": 0.0,
                    "time_improvement": 67.54128112795729,
                    "length_improvement": 8.02445960163917,
                    "objective_score": 21.86727625871502
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines bidirectional RRT* with adaptive heuristic sampling, dynamic radius rewiring, and node pruning to balance exploration and exploitation. It alternates tree growth between start and goal, uses informed sampling with goal-start bias, applies incremental rewiring within dynamically adjusted radii, and prunes dead-end nodes periodically to enhance efficiency. Collision checks for nodes and edges guarantee safety, while the planner focuses on improving path quality, success rate, and computational speed by maintaining balanced trees and pruning suboptimal branches.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points biased towards them. Each sampled point is used to extend the smaller tree via steering and collision-checked addition of nodes. A dynamic radius, shrinking with node count, determines local neighborhood for rewiring to optimize path costs. After each extension, attempts are made to connect the opposing tree. Periodic pruning removes unproductive nodes, improving search efficiency and aiding smooth, shorter paths. Upon connection, the best path is reconstructed by backtracking and merging the two trees\u2019 paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.35589,
          "time_improvement": 30.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004592251777648926,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 167.45106691181843,
                    "success_improvement": 0.0,
                    "time_improvement": 51.30612626687802,
                    "length_improvement": 16.309566212866937,
                    "objective_score": 18.65375112263679
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018631529808044434,
                    "num_nodes_avg": 213.8,
                    "path_length_avg": 286.29479981745214,
                    "success_improvement": 0.0,
                    "time_improvement": -26.45994112820878,
                    "length_improvement": 4.997699636422811,
                    "objective_score": -6.938442411178071
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010195708274841309,
                    "num_nodes_avg": 119.7,
                    "path_length_avg": 139.18069216669,
                    "success_improvement": 0.0,
                    "time_improvement": 64.81805534645213,
                    "length_improvement": 14.53467062369323,
                    "objective_score": 22.352350728674285
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
          "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -9.55661,
          "time_improvement": 23.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053680181503295895,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 168.24816019864105,
                    "success_improvement": 0.0,
                    "time_improvement": 43.08029901986809,
                    "length_improvement": 15.911186649372569,
                    "objective_score": 16.106327035834944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01864187717437744,
                    "num_nodes_avg": 256.6,
                    "path_length_avg": 287.4569206517525,
                    "success_improvement": 0.0,
                    "time_improvement": -26.530173006684965,
                    "length_improvement": 4.612068627304342,
                    "objective_score": -7.036638176544621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013377833366394042,
                    "num_nodes_avg": 183.6,
                    "path_length_avg": 134.76801275171147,
                    "success_improvement": 0.0,
                    "time_improvement": 53.83761673112537,
                    "length_improvement": 17.24432160877036,
                    "objective_score": 19.600149341091683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid bidirectional RRT* planner integrates adaptive goal bias sampling from both start and goal, dynamic rewiring with node neighborhood radius based on logarithmic scaling, and incremental path cost optimization to achieve efficient and robust path planning. It balances exploration by alternating growth on the smaller tree, performs strict collision and edge feasibility checks before node/edge addition, and incorporates local rewiring for path quality and smoothness. The algorithm adaptively adjusts sampling and rewiring radii to reduce search space and improve convergence speed. On connection, the optimal path is reconstructed by merging the shortest cost paths from both trees, ensuring shorter, smoother, and collision-free paths.",
          "planning_mechanism": "The planner alternates extension steps between start and goal trees, always growing the smaller tree to balance exploration. Sampling uses a combined goal bias for both start and goal to encourage fast connection. New nodes are created via a steering function capped by a fixed step size, with explicit collision and edge checks before insertion. Rewiring is done dynamically within a neighborhood radius that shrinks logarithmically with tree size, incrementally improving path cost and smoothness. When the two trees connect via feasible edges, the optimal path is extracted by backtracking from connection nodes and merging them, resulting in efficient convergence to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample either start or goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            r = random.random()\n            # Sample with combined goal bias to start or goal to enhance connectivity\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.5 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            # Shrink radius logarithmically for efficient rewiring as tree grows\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            # Check if node position is valid: inside map bounds & not in obstacle\n            for d, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_target = distance(new_pos, node.position)\n                if dist_to_target <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_target\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.93552,
          "time_improvement": 21.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003909516334533692,
                    "num_nodes_avg": 71.2,
                    "path_length_avg": 171.18510106638226,
                    "success_improvement": 0.0,
                    "time_improvement": 58.545501429622384,
                    "length_improvement": 14.443331832073264,
                    "objective_score": 20.452316795301368
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01824326515197754,
                    "num_nodes_avg": 269.4,
                    "path_length_avg": 270.5479880821555,
                    "success_improvement": 0.0,
                    "time_improvement": -23.824627439303637,
                    "length_improvement": 10.22302450854493,
                    "objective_score": -5.102783330082104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020744752883911134,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 138.9767873393387,
                    "success_improvement": 0.0,
                    "time_improvement": 28.41686637756919,
                    "length_improvement": 14.659880471120387,
                    "objective_score": 11.457036007494834
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid bidirectional RRT* planner merges strengths from both prior approaches. It grows two trees from start and goal points, alternately extending the smaller tree. Sampling incorporates adaptive goal bias with a probabilistic start/goal preference. Tree extension uses a fixed step size steering function with strict node and edge collision checks and map boundary enforcement. The rewiring radius shrinks dynamically with tree size, enabling local optimization. Incremental rewiring improves path cost and smoothness. Periodic pruning removes dead-end nodes to maintain efficiency. Connection attempts between trees utilize incremental steering, and final path reconstruction merges the best-cost branches. This combination targets enhanced efficiency, robustness, smoothness, reduced path length, and higher success rates.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling free points with a biased probability toward start/goal to balance exploration and exploitation. Each iteration, it extends the smaller tree toward a sampled point with steering constrained to a step size and includes comprehensive collision and boundary checking. After extension, it attempts to incrementally connect the opposing tree using the same steering method. Local rewiring within a shrinking radius dynamically optimizes the trees\u2019 costs. Periodic pruning removes dead-end nodes to keep the tree size manageable. Upon connection, the final path is retrieved by concatenating the paths from both trees, producing an efficient, smooth, and collision-free trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 25.0,\n                 radius_min: float = 4.5, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            rand_val = random.random()\n            if rand_val < self.goal_sample_rate:\n                # With 70% chance goal, else start\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children and node.valid:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        node.valid = False\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first to keep trees balanced\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Periodic pruning to improve efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.86231,
          "time_improvement": 28.0,
          "length_improvement": 10.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0052844762802124025,
                    "num_nodes_avg": 81.4,
                    "path_length_avg": 175.03859137343892,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 43.966134002765706,
                    "length_improvement": 12.5173944144161,
                    "objective_score": 10.693319083712934
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018130898475646973,
                    "num_nodes_avg": 175.7,
                    "path_length_avg": 288.73219942497633,
                    "success_improvement": 0.0,
                    "time_improvement": -23.061948076957304,
                    "length_improvement": 4.188887985747617,
                    "objective_score": -6.0808068259376675
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01048731803894043,
                    "num_nodes_avg": 135.7,
                    "path_length_avg": 139.80011568287077,
                    "success_improvement": 0.0,
                    "time_improvement": 63.81180857041547,
                    "length_improvement": 14.15430727005782,
                    "objective_score": 21.974404025136206
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive informed sampling biased towards both start and goal, dynamic radius rewiring with pruning of dead-ends to maintain tree efficiency, and iterative shortcut smoothing after successful path connection. It alternately extends the smaller tree to balance exploration, rigorously applies collision checks for nodes and edges, and performs path smoothing to ensure shorter and smoother trajectories. These strategies collectively improve planning speed, path optimality, robustness, success rate, and reduce computational overhead and search time.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree by sampling points within the map bounds with goal and start bias. It uses a dynamic radius for neighbor selection to locally optimize path costs via rewiring. After successfully connecting the two trees, it extracts the path and applies iterative shortcut smoothing. Periodic pruning removes dead-end nodes to reduce complexity and enhance efficiency. Comprehensive collision and edge feasibility checks are enforced to ensure valid and safe path construction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size               # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start      # Tuple[float, ...]\n        goal_position = map.goal        # Tuple[float, ...]\n        obstacles = map.obstacles       # List of obstacles rectangles/cuboids\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate extending smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.55322,
          "time_improvement": 12.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006933975219726563,
                    "num_nodes_avg": 72.8,
                    "path_length_avg": 163.3649260494454,
                    "success_improvement": 0.0,
                    "time_improvement": 26.475696419497474,
                    "length_improvement": 18.35178014195116,
                    "objective_score": 11.613064954239475
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020410585403442382,
                    "num_nodes_avg": 254.5,
                    "path_length_avg": 244.16867087718578,
                    "success_improvement": 0.0,
                    "time_improvement": -38.53513131257554,
                    "length_improvement": 18.976574409173768,
                    "objective_score": -7.765224511937907
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014882683753967285,
                    "num_nodes_avg": 157.4,
                    "path_length_avg": 128.50251110260547,
                    "success_improvement": 0.0,
                    "time_improvement": 48.644886454788,
                    "length_improvement": 21.091717061491025,
                    "objective_score": 18.811809348734606
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with balanced tree growth, adaptive neighbor radius for rewiring, and shortcut path smoothing to improve path quality, efficiency, and success rate. The planner alternates extending the smaller tree towards sampled points biased towards start and goal, attempts connection with the opposite tree after each extension, prunes dead-end nodes periodically to control complexity, and provides collision-free, smooth, and near-optimal paths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with bias towards these roots to guide growth. It extends the smaller tree towards samples within step size limits, rewires locally using adaptively shrinking neighbor radius to lower path cost, and attempts to connect the opposite tree at each extension. Invalid or dead nodes are pruned intermittently. Upon connection, the path is extracted and refined through iterative shortcut smoothing, providing a collision-free, shorter, and smoother path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                  # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.95653,
          "time_improvement": 10.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0070808172225952145,
                    "num_nodes_avg": 92.9,
                    "path_length_avg": 161.14819930966323,
                    "success_improvement": 0.0,
                    "time_improvement": 24.918659416168012,
                    "length_improvement": 19.45967886043232,
                    "objective_score": 11.367533596936868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0237623929977417,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 238.90444583071044,
                    "success_improvement": 0.0,
                    "time_improvement": -61.28524337611435,
                    "length_improvement": 20.723422376253854,
                    "objective_score": -14.240888537583533
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00985403060913086,
                    "num_nodes_avg": 123.5,
                    "path_length_avg": 130.73786629590094,
                    "success_improvement": 0.0,
                    "time_improvement": 65.99706953559297,
                    "length_improvement": 19.71907431274517,
                    "objective_score": 23.74293572322693
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius rewiring, balanced tree growth, dead-end pruning, and iterative shortcut smoothing to efficiently search in complex environments. It integrates fast connection attempts like RRT-Connect, while maintaining asymptotic optimality and robustness through rewiring and pruning.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to balance expansion. Samples are adaptively biased towards start and goal for directed exploration. Each extension uses a dynamic radius depending on tree size to perform rewiring optimizing path cost. Dead-end pruning is periodically applied to remove unnecessary nodes and reduce computational burden. Upon connecting the two trees without collision, the resultant path is shortcut-smoothed iteratively to improve path quality and smoothness. Collision and edge validity checks are enforced rigorously, ensuring robustness and feasibility.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Choose between goal and start with bias p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.83895,
          "time_improvement": 9.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009789466857910156,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 163.5535741174694,
                    "success_improvement": 0.0,
                    "time_improvement": -3.8024668886310224,
                    "length_improvement": 18.257495650743063,
                    "objective_score": 2.5107590635593064
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01988651752471924,
                    "num_nodes_avg": 202.9,
                    "path_length_avg": 241.16005059975564,
                    "success_improvement": 0.0,
                    "time_improvement": -34.97806467482155,
                    "length_improvement": 19.974936403379097,
                    "objective_score": -6.498432121770645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009808039665222168,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 124.92422072194663,
                    "success_improvement": 0.0,
                    "time_improvement": 66.15576874505864,
                    "length_improvement": 23.28900291505477,
                    "objective_score": 24.504531206528544
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.68311,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.007598710060119629,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 161.4550453822259,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 19.42719038120736,
                    "length_improvement": 19.306320142615537,
                    "objective_score": 4.689421142885316
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.013997030258178712,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 259.63765747646863,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 4.9963346727016456,
                    "length_improvement": 13.8434413164237,
                    "objective_score": -0.7324113349047652
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.012314391136169434,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 131.58176022985964,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.507196585457756,
                    "length_improvement": 19.200872600268642,
                    "objective_score": 16.092333495691054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined bidirectional RRT planner integrating adaptive step sizing near obstacles and frontier-biased sampling for enhanced exploration efficiency. It alternately grows two trees from start and goal, performs strict collision and edge checks, and applies path shortcut smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner samples points biased towards frontiers near obstacles with adaptive step sizes that shrink near obstacles to improve precision. Two trees grow toward each other's new nodes while avoiding collisions. Once connected, the concatenated path is shortcut-smoothed iteratively to reduce unnecessary waypoints and produce a shorter, smoother path before returning the final plan.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: list = []\n        nodes: list = []\n        edges: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for i in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased near frontiers\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            cost_a = nearest_a.cost + math.dist(nearest_a.position, new_pos_a)\n            new_node_a = Node(new_pos_a, parent=nearest_a, cost=cost_a)\n            nearest_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_a, new_node_a))\n\n            # Try connecting tree_b to new_node_a\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos_a))\n            connected = False\n            current_node_b = nearest_b\n\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = current_node_b.cost + math.dist(current_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=current_node_b, cost=cost_b)\n                current_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((current_node_b, new_node_b))\n                current_node_b = new_node_b\n\n                if math.dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist <= query_radius:\n                return self.base_step_size * 0.5\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": -6.65571,
          "time_improvement": 8.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005708551406860352,
                    "num_nodes_avg": 99.5,
                    "path_length_avg": 159.4405888448925,
                    "success_improvement": 0.0,
                    "time_improvement": 39.46945967605338,
                    "length_improvement": 20.313126158032215,
                    "objective_score": 15.903463134422458
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02300090789794922,
                    "num_nodes_avg": 396.3,
                    "path_length_avg": 242.17424129074578,
                    "success_improvement": 0.0,
                    "time_improvement": -56.11672732392269,
                    "length_improvement": 19.638393620510445,
                    "objective_score": -12.907339473074716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01748318672180176,
                    "num_nodes_avg": 311.6,
                    "path_length_avg": 121.5714299751307,
                    "success_improvement": 0.0,
                    "time_improvement": 39.67142928835457,
                    "length_improvement": 25.34781840911247,
                    "objective_score": 16.970992468328866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with adaptive rewiring and dynamic radius adjustment, while incorporating heuristic informed sampling towards the goal and enhanced collision checks. It dynamically balances exploration and exploitation by alternating tree expansions, improves path quality via local rewiring around new nodes, and enforces strict collision-free checks for nodes and edges. The method prunes suboptimal nodes iteratively to enhance planning efficiency, leading to smoother and shorter paths with higher success rates and reduced search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling free points biased towards the goal. Each extension uses a steering function with a fixed step size, adding nodes only after thorough collision checks. Rewiring is performed locally with a dynamically shrinking radius to optimize path costs incrementally. The trees attempt to connect after each extension, and upon success, the optimal path is constructed by backtracking. This blend of bidirectional search, incremental optimization, adaptive sampling, and pruning yields efficient, robust, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Heuristic guided sampling with goal bias and start bias for efficient tree growth\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search with linear scan (can be improved with spatial indexing if needed)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes+1) / (n_nodes+1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Rewire radius scales inversely with node count\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            # Add edge record\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Rewire neighbors around new_node for local path cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # epsilon to avoid floating error loops\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge feasibility check before adding terminal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees with start and goal roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Merge paths, avoid duplicated connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Optional pruning of nodes with no children and higher cost to improve efficiency\n            if itr % 250 == 0 and len(nodes) > 100:\n                pruned = []\n                for node in nodes[:]:\n                    if not node.children and node is not start_root and node is not goal_root:\n                        try:\n                            node.parent.children.remove(node)\n                            nodes.remove(node)\n                            # Remove edges related to node\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            pruned.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.15402,
          "time_improvement": 15.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004810810089111328,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 182.51310029888023,
                    "success_improvement": 0.0,
                    "time_improvement": 48.98864644717982,
                    "length_improvement": 8.781706694699151,
                    "objective_score": 16.452935273093775
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02035815715789795,
                    "num_nodes_avg": 178.3,
                    "path_length_avg": 287.3732004707603,
                    "success_improvement": 0.0,
                    "time_improvement": -38.17927900665584,
                    "length_improvement": 4.639849815737334,
                    "objective_score": -10.525813738849285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01868715286254883,
                    "num_nodes_avg": 139.1,
                    "path_length_avg": 147.54383101693634,
                    "success_improvement": 0.0,
                    "time_improvement": 35.516948894576494,
                    "length_improvement": 9.399199565681393,
                    "objective_score": 12.534924581509227
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines the strengths of both previous algorithms into a bidirectional RRT* variant with adaptive and heuristic-informed sampling, dynamic and decaying rewiring radius, and balanced tree growth. It incorporates mutual rewiring and connection attempts between trees, periodic pruning of dead-end nodes for efficiency, and advanced path shortcutting smoothing. Collision checks rigorously ensure safety, while adaptive sampling focuses exploration near promising regions as iterations progress. This results in improved efficiency, robustness, success rate, and smoother, shorter paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balance. It samples points adaptively and heuristically to balance exploration and exploitation. Each extension uses a dynamic, decaying radius to find near nodes for rewiring and cost optimization. After each expansion, the planner attempts to connect the other tree. Dead-end nodes are pruned periodically to keep the search tree efficient. Upon successful connection, a shortcut smoothing post-process refines the path. Collision checks are enforced for all nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Heuristic adaptive sampling shifting from aggressive goal/start bias to exploration near connection midpoints\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free sample\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                # Use the shorter path between raw, shortcuted and smoothed to improve quality\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.86,
          "time_improvement": 5.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009752225875854493,
                    "num_nodes_avg": 84.4,
                    "path_length_avg": 160.30622257797762,
                    "success_improvement": 0.0,
                    "time_improvement": -3.407582686779978,
                    "length_improvement": 19.880490738272123,
                    "objective_score": 2.9538233416204314
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018081092834472658,
                    "num_nodes_avg": 184.4,
                    "path_length_avg": 235.45185784316172,
                    "success_improvement": 0.0,
                    "time_improvement": -22.723896477563834,
                    "length_improvement": 21.869107876772635,
                    "objective_score": -2.4433473679146225
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017218947410583496,
                    "num_nodes_avg": 175.8,
                    "path_length_avg": 122.99644452541483,
                    "success_improvement": 0.0,
                    "time_improvement": 40.583229878560964,
                    "length_improvement": 24.472773630917217,
                    "objective_score": 17.069523689751733
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.6829227155522615,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011509346961975097,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -22.03919010817601,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -4.1314597250548815
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016402530670166015,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -11.330797002361011,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -0.5611573357999351
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010229659080505372,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 64.70090258632817,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 21.741385207511602
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards the goal and start to balance exploration and exploitation. It uses a dynamically shrinking radius for rewiring to optimize path costs continually. The algorithm grows two trees from start and goal, alternately extending the smaller tree for balanced growth. After each extension, the planner attempts to connect the two trees to form a complete path. Dead-end nodes are periodically pruned to enhance efficiency. Additionally, a path smoothing and shortcut procedure is applied post path extraction to reduce path length and improve smoothness. Collision checks ensure safety. This results in improved planning speed, higher success rates, and shorter, smoother paths.",
          "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal positions. It samples points within the map bounds with bias towards the goal and start, steering and extending the smaller tree first. A dynamic radius is used to find neighbors to rewire and reduce path cost locally. After extension, attempts are made to connect the opposing tree to complete a path. Periodic pruning removes dead nodes. Upon successful connection, the path is extracted and post-processed via shortcut smoothing to minimize length and enhance smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                # Post-process with smoothing\n                smoothed_path = path_smoothing(raw_path)\n                # Use the shorter path among raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.61374,
          "time_improvement": 7.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008043766021728516,
                    "num_nodes_avg": 85.5,
                    "path_length_avg": 163.6645421149303,
                    "success_improvement": 0.0,
                    "time_improvement": 14.708046081621204,
                    "length_improvement": 18.202034912180657,
                    "objective_score": 8.052820806922492
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018214941024780273,
                    "num_nodes_avg": 211.3,
                    "path_length_avg": 250.73203836217277,
                    "success_improvement": 0.0,
                    "time_improvement": -23.632379808820406,
                    "length_improvement": 16.798627029050724,
                    "objective_score": -3.7299885368359766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020520853996276855,
                    "num_nodes_avg": 169.4,
                    "path_length_avg": 132.2218958906299,
                    "success_improvement": 0.0,
                    "time_improvement": 29.189465794931664,
                    "length_improvement": 18.80779074213471,
                    "objective_score": 12.518397886906442
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of enhanced bidirectional RRT* with adaptive goal biasing and incremental rewiring along with a dynamic radius and balanced tree growth. It integrates dynamic radius rewiring for local cost improvements, adaptive sampling bias toward both start and goal, and smart tree balancing to improve convergence speed, robustness, and path quality. The algorithm also incorporates rewiring from both trees when extending and connecting nodes, enhancing overall path smoothness and shortness while preserving collision checks and pruning possible redundant edges.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with adaptive biasing favoring goal and start to promote exploration. It extends the smaller tree first toward sampled points, rewiring neighbors within a dynamically shrinking radius to optimize costs. When a new node is created in one tree, it attempts to connect and rewire the opposite tree toward it. Path extraction occurs at the first successful connection by merging both trees' paths. Rigorous obstacle and edge collision checks ensure safe expansions, while adaptive radius and rewiring improve convergence to optimal, smooth paths effectively across 2D or 3D environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive goal biasing: bias toward goal 70% and start 10% when goal_sample_rate applies\n            if random.random() < self.goal_sample_rate:\n                p = goal_position if random.random() < 0.7 else start_position\n                # Verify p does not lie inside obstacle (rare but safe)\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Uniform random sample in bounds and free space\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Dynamic radius shrinking with node count, minimum radius enforced\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if within step_size to target_node\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final edge feasibility check\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Main loop, balanced bidirectional growth alternating tree extension attempts\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            # On successful extension on one tree, attempt connection & rewiring on the other\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found feasible connection: reconstruct path\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                # Merge paths without duplicating connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.55242,
          "time_improvement": 10.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0072095394134521484,
                    "num_nodes_avg": 92.4,
                    "path_length_avg": 171.03662888960565,
                    "success_improvement": 0.0,
                    "time_improvement": 23.55375557122958,
                    "length_improvement": 14.517536798986361,
                    "objective_score": 9.969634031166146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014955592155456544,
                    "num_nodes_avg": 238.0,
                    "path_length_avg": 282.8514380030673,
                    "success_improvement": 0.0,
                    "time_improvement": -1.5098235626334042,
                    "length_improvement": 6.140323580550488,
                    "objective_score": 0.7751176473200765
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026245260238647462,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 137.75874664227172,
                    "success_improvement": 0.0,
                    "time_improvement": 9.436473833552576,
                    "length_improvement": 15.407830835125619,
                    "objective_score": 5.9125083170908965
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This is a simplified yet robust bidirectional RRT* planner that grows two trees simultaneously from start and goal positions. It employs adaptive goal bias sampling to efficiently guide exploration and uses a steering function capped by a fixed step size to create new nodes. Collision checks ensure nodes and edges are feasible. The algorithm rewires locally within a dynamically computed neighborhood radius that shrinks as the trees grow, improving path cost and smoothness incrementally. By always extending the smaller tree first, it balances exploration, and upon connection of the two trees, it reconstructs an optimal and collision-free path by merging both paths. This approach enhances planning efficiency, path quality, and success rate while maintaining simplicity for generalization.",
          "planning_mechanism": "The planner iteratively samples free points with goal bias and extends the smaller of the two trees toward these points using a steering function respecting step size. It performs collision checks before adding nodes and edges. Local rewiring is done within a radius that decreases logarithmically with the number of nodes, improving path cost and smoothness. When the two trees connect via collision-free edges, the planner reconstructs the combined optimal path and terminates.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if random.random() < 0.5 else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def radius_by_nodes(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.74412,
          "time_improvement": 7.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007792139053344726,
                    "num_nodes_avg": 83.7,
                    "path_length_avg": 168.4674621509865,
                    "success_improvement": 0.0,
                    "time_improvement": 17.376168915383047,
                    "length_improvement": 15.801581641410323,
                    "objective_score": 8.373167002896977
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01925923824310303,
                    "num_nodes_avg": 273.7,
                    "path_length_avg": 286.1481153491476,
                    "success_improvement": 0.0,
                    "time_improvement": -30.72045932295822,
                    "length_improvement": 5.046374505562686,
                    "objective_score": -8.206862895774929
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01880514621734619,
                    "num_nodes_avg": 223.8,
                    "path_length_avg": 134.08189579520482,
                    "success_improvement": 0.0,
                    "time_improvement": 35.10979369102769,
                    "length_improvement": 17.665638752446302,
                    "objective_score": 14.066065857797566
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* variant with enhanced adaptive sampling and rewiring strategies focusing on minimizing path length and improving convergence speed. It employs dynamic radius calculations, balanced tree growth, and mutual rewiring between trees. Additionally, this version incorporates heuristic-informed sampling bias that adapts over iterations to concentrate exploration around promising areas, employs a decaying radius for finer local optimizations, and implements a path shortcutting smoothing post-processing step. The planner rigorously checks for collisions at nodes and edges while maintaining efficient rewiring to produce shorter, smoother, and more robust paths efficiently in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternately grows and rewires two trees rooted at start and goal positions, sampling points using an adaptive heuristic bias that shifts towards promising regions as iterations increase. It always extends the smaller tree first to maintain balance and dynamically adjusts the rewiring radius decreasing over time for refined local improvements. Mutual tree connection attempts and rewiring enhance path quality and smoothness. Upon finding a connection, a shortcutting process smooths the path by removing unnecessary nodes, thereby minimizing path length and improving traversal efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node({self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_by_nodes(n_nodes, itr):\n            # Dynamic radius shrinking with node count & iteration progress; radius shrinks faster as iteration count increases\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            # Decay radius as iter increases (slow exponential decay, min bound enforced)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            return (self._is_in_obstacle(pos, obstacles, is_3d) == False)\n\n        def is_free_edge(p1, p2):\n            return (self._is_edge_in_obstacle(p1, p2, obstacles, is_3d) == False)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic informed sampling:\n            # - Early: higher goal bias (goal: 70%, start: 10%)\n            # - Later: increase uniform exploration and biased sampling around best known connection nodes\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    # Sample near best connection region for better local refinement (after some progress)\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        # Pick random midpoint from recent connection attempts or random nodes\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i]+mid_from_goal[i])/2 for i in range(dim))\n                        # Sample in small ball around mid\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):  # try up to 5 samples in this biased region\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sample in free space\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            # fallback to start if stuck\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing nodes where direct connection is collision-free\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                # Search for farthest reachable node from current shortened[-1]\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n\n            rand_point = adaptive_sample(itr)\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Post-process: shortcutting for smoother path\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.53314,
          "time_improvement": 0.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010382628440856934,
                    "num_nodes_avg": 93.1,
                    "path_length_avg": 159.97272222093744,
                    "success_improvement": 0.0,
                    "time_improvement": -10.092046951276549,
                    "length_improvement": 20.047171011283186,
                    "objective_score": 0.9818201168736733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020576214790344237,
                    "num_nodes_avg": 272.6,
                    "path_length_avg": 237.41024721166414,
                    "success_improvement": 0.0,
                    "time_improvement": -39.659326842009,
                    "length_improvement": 21.219248029042483,
                    "objective_score": -7.653948446794204
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014211153984069825,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 122.2769154763927,
                    "success_improvement": 0.0,
                    "time_improvement": 50.96210881549838,
                    "length_improvement": 24.914607812175976,
                    "objective_score": 20.27155420708471
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates a bidirectional RRT* algorithm with adaptive, informed sampling and dynamic radius rewiring, combined with efficient tree balancing, dead-end pruning, and iterative shortcut smoothing. It balances exploration and exploitation to improve planning speed, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal positions, always extending the smaller tree. Sampling is adaptively biased towards the start and goal to guide growth. Each extension steers towards samples within a fixed step size and performs rewiring with a neighbor radius that shrinks as the tree grows, optimizing path costs. Between iterations, dead-end pruning removes unnecessary nodes to reduce complexity. Upon connection of trees, the resultant path is shortcut-smoothed iteratively, ensuring collision-free and shorter paths. Collision and edge feasibility checks are rigorously enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random, math\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.43558,
          "time_improvement": 2.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008450722694396973,
                    "num_nodes_avg": 97.5,
                    "path_length_avg": 167.3582062549438,
                    "success_improvement": 0.0,
                    "time_improvement": 10.392887028230934,
                    "length_improvement": 16.355977076642965,
                    "objective_score": 6.389061523797873
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020722436904907226,
                    "num_nodes_avg": 196.3,
                    "path_length_avg": 240.72557835123666,
                    "success_improvement": 0.0,
                    "time_improvement": -40.651797143148414,
                    "length_improvement": 20.119108994288037,
                    "objective_score": -8.171717344086916
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018723511695861818,
                    "num_nodes_avg": 159.8,
                    "path_length_avg": 126.43746692465507,
                    "success_improvement": 0.0,
                    "time_improvement": 35.391486844584186,
                    "length_improvement": 22.35977858710682,
                    "objective_score": 15.08940177079662
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This enhanced hybrid bidirectional RRT* planner dynamically adjusts goal bias, uses a KDTree for efficient nearest-neighbor searches, and incorporates batch rewiring limited to a tuned adaptive radius. It balances tree growth by always extending the smaller tree first with step steering and collision checks optimized for early rejection. The planner includes an efficient path shortcutting smoothing pass and prunes redundant nodes post-connection for reduced complexity. Adaptive radius shrinks with node count for faster rewiring and improved path convergence, thus reducing planning time while improving path quality, success rate, smoothness, and robustness.",
          "planning_mechanism": "The planner initializes two trees rooted at start and goal, and iteratively samples points biased adaptively toward the goal. At each iteration, it extends the smaller tree toward the sampled point using fixed-step steering, verifies collisions for new nodes and edges, and locally rewires neighbors within a radius computed adaptively based on node count. Following extension, it attempts to connect the opposite tree toward the new node. Upon successful connection, the path is reconstructed by concatenating branches from both trees, followed by a shortcut smoothing pass. The use of KDTree accelerates nearest neighbor queries, and adaptive goal bias accelerates convergence to the goal while maintaining exploration.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.35,\n                 radius_constant: float = 25.0, radius_min: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from bisect import insort\n        from collections import deque\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None  # fallback if scipy not available\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                for _ in range(50):  # limit attempts\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback to start if no free sampled found\n                return start_position\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            # Use KDTree if available, else linear search\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                radius_sq = radius * radius\n                return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire neighbors improved cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d)\n                            and not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_redundant_nodes(tree):\n            # Optionally prune nodes not connected to root (or orphan nodes)\n            # Queue BFS from root\n            root = tree[0] if tree else None\n            if root is None:\n                return\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            # Remove nodes not in visited\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Build kdtrees for efficient NN queries\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Smooth resulting path\n                extracted_path = smooth_path(merged_path, max_trials=150)\n\n                # Optional prune to reduce tree size after success\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.43151,
          "time_improvement": -0.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012529683113098145,
                    "num_nodes_avg": 63.3,
                    "path_length_avg": 155.3730580323225,
                    "success_improvement": 0.0,
                    "time_improvement": -32.85830937989023,
                    "length_improvement": 22.346038963095314,
                    "objective_score": -5.388285021348006
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01742854118347168,
                    "num_nodes_avg": 234.6,
                    "path_length_avg": 232.5926149824971,
                    "success_improvement": 0.0,
                    "time_improvement": -18.294757044629613,
                    "length_improvement": 22.817901390432237,
                    "objective_score": -0.9248468353024366
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014329338073730468,
                    "num_nodes_avg": 175.4,
                    "path_length_avg": 126.68648538319522,
                    "success_improvement": 0.0,
                    "time_improvement": 50.554295450375854,
                    "length_improvement": 22.20686625243884,
                    "objective_score": 19.60766188560052
               }
          ],
          "success_rate": 1.0
     }
]