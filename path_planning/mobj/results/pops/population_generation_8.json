[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.708512676293243,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0016797542572021484,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 82.1887506035762,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 27.56608404471968
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008045697212219238,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 45.39050704503417,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 0.27572040411595267
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0035561323165893555,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 87.72898880878513,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 22.283733580044093
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified, unified bidirectional RRT* planner that balances exploration efficiency and path quality. It grows two trees from the start and goal positions alternately, samples points with adaptive goal biasing, extends nearest nodes towards samples using a fixed step size, and employs local rewiring around new nodes to improve path cost and smoothness. Rigorous collision and edge feasibility checks ensure safety. Upon connection of the trees, the shortest path is reconstructed by merging paths from both connected nodes. The planner avoids excessive complexity while maintaining robustness, smoothness, and efficient convergence.",
          "planning_mechanism": "The planner alternates growth between start and goal trees, samples points with goal bias to encourage connections, extends the nearest node towards samples with a capped step size, rewires neighbors within a radius inversely related to tree size to reduce path cost, and verifies collision-free conditions for nodes and edges. When the trees connect, the optimal path is extracted by backtracking and merged. This approach balances exploration and exploitation to find shorter, smoother feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Parent node or None\n        self.cost = cost                      # Cost from root\n        self.children = []\n        self.valid = True                     # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=20.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes, extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.03871,
          "time_improvement": 44.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0039825916290283205,
                    "num_nodes_avg": 76.2,
                    "path_length_avg": 172.59475061003724,
                    "success_improvement": 0.0,
                    "time_improvement": 57.770648626374324,
                    "length_improvement": 13.738802538996584,
                    "objective_score": 20.078955095711613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013543009757995605,
                    "num_nodes_avg": 249.1,
                    "path_length_avg": 290.1072272486077,
                    "success_improvement": 0.0,
                    "time_improvement": 8.077960621600676,
                    "length_improvement": 3.732607234605092,
                    "objective_score": 3.169909633401221
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009406518936157227,
                    "num_nodes_avg": 162.7,
                    "path_length_avg": 149.7826015352379,
                    "success_improvement": 0.0,
                    "time_improvement": 67.54128112795729,
                    "length_improvement": 8.02445960163917,
                    "objective_score": 21.86727625871502
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner integrates the bidirectional incremental rewiring with a dynamically adapting neighbor radius, balanced tree growth, and enhanced adaptive goal/start biasing. It alternates expansions between two trees grown from start and goal, prioritizing the smaller tree to maintain balanced exploration. Both trees use dynamic radius rewiring to locally optimize paths, with extensive collision and edge feasibility checks for safety. Upon tree connection, the planner reconstructs the optimal path by merging both trees' node ancestry, thus improving efficiency, path quality, smoothness, and success rate in diverse 2D/3D environments.",
          "planning_mechanism": "The planner samples points with adaptive biasing toward start and goal, steering the smaller tree toward these samples, rewiring neighbors within a dynamically shrinking radius to improve costs. On successful extension, it attempts to connect and rewire the opposite tree toward the new node. This balanced, bidirectional incremental rewiring approach ensures faster convergence to smooth, short paths while rigorously avoiding obstacles through node and edge collision checks.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate     # Probability of sampling goal/start bias point\n        self.radius_constant = radius_constant       # For dynamic radius calculation\n        self.radius_min = radius_min                  \n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Adaptive biasing: sample goal (60%), start (15%), else uniform random free space\n            r = random.random()\n            if r < self.goal_sample_rate:\n                choice = random.random()\n                if choice < 0.6:\n                    p = goal_position\n                elif choice < 0.75:\n                    p = start_position\n                else:\n                    p = None\n                if p is not None and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def dynamic_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = dynamic_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to improve paths\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:  # epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node) -> Node or None:\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = dynamic_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors near new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if new node is close enough to target_node to connect final edge\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Main loop: balanced bidirectional growth with incremental rewiring and dynamic radius\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List[Tuple], is_3d: bool, resolution: float=1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -14.13591,
          "time_improvement": 38.0,
          "length_improvement": 14.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00398409366607666,
                    "num_nodes_avg": 56.5,
                    "path_length_avg": 166.67048580564182,
                    "success_improvement": 0.0,
                    "time_improvement": 57.75472179877086,
                    "length_improvement": 16.699693147181204,
                    "objective_score": 20.666355169067497
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014491534233093262,
                    "num_nodes_avg": 238.8,
                    "path_length_avg": 280.3071486939616,
                    "success_improvement": 0.0,
                    "time_improvement": 1.639930544879629,
                    "length_improvement": 6.9846048504499745,
                    "objective_score": 1.8889001335538835
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013275337219238282,
                    "num_nodes_avg": 198.9,
                    "path_length_avg": 133.5772826124493,
                    "success_improvement": 0.0,
                    "time_improvement": 54.1912963068086,
                    "length_improvement": 17.975501645067755,
                    "objective_score": 19.852489221056132
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines bidirectional RRT* with adaptive heuristic sampling, dynamic radius rewiring, and node pruning to balance exploration and exploitation. It alternates tree growth between start and goal, uses informed sampling with goal-start bias, applies incremental rewiring within dynamically adjusted radii, and prunes dead-end nodes periodically to enhance efficiency. Collision checks for nodes and edges guarantee safety, while the planner focuses on improving path quality, success rate, and computational speed by maintaining balanced trees and pruning suboptimal branches.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points biased towards them. Each sampled point is used to extend the smaller tree via steering and collision-checked addition of nodes. A dynamic radius, shrinking with node count, determines local neighborhood for rewiring to optimize path costs. After each extension, attempts are made to connect the opposing tree. Periodic pruning removes unproductive nodes, improving search efficiency and aiding smooth, shorter paths. Upon connection, the best path is reconstructed by backtracking and merging the two trees\u2019 paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.35589,
          "time_improvement": 30.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004592251777648926,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 167.45106691181843,
                    "success_improvement": 0.0,
                    "time_improvement": 51.30612626687802,
                    "length_improvement": 16.309566212866937,
                    "objective_score": 18.65375112263679
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018631529808044434,
                    "num_nodes_avg": 213.8,
                    "path_length_avg": 286.29479981745214,
                    "success_improvement": 0.0,
                    "time_improvement": -26.45994112820878,
                    "length_improvement": 4.997699636422811,
                    "objective_score": -6.938442411178071
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010195708274841309,
                    "num_nodes_avg": 119.7,
                    "path_length_avg": 139.18069216669,
                    "success_improvement": 0.0,
                    "time_improvement": 64.81805534645213,
                    "length_improvement": 14.53467062369323,
                    "objective_score": 22.352350728674285
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
          "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -9.55661,
          "time_improvement": 23.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053680181503295895,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 168.24816019864105,
                    "success_improvement": 0.0,
                    "time_improvement": 43.08029901986809,
                    "length_improvement": 15.911186649372569,
                    "objective_score": 16.106327035834944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01864187717437744,
                    "num_nodes_avg": 256.6,
                    "path_length_avg": 287.4569206517525,
                    "success_improvement": 0.0,
                    "time_improvement": -26.530173006684965,
                    "length_improvement": 4.612068627304342,
                    "objective_score": -7.036638176544621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013377833366394042,
                    "num_nodes_avg": 183.6,
                    "path_length_avg": 134.76801275171147,
                    "success_improvement": 0.0,
                    "time_improvement": 53.83761673112537,
                    "length_improvement": 17.24432160877036,
                    "objective_score": 19.600149341091683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid bidirectional RRT* planner integrates adaptive goal bias sampling from both start and goal, dynamic rewiring with node neighborhood radius based on logarithmic scaling, and incremental path cost optimization to achieve efficient and robust path planning. It balances exploration by alternating growth on the smaller tree, performs strict collision and edge feasibility checks before node/edge addition, and incorporates local rewiring for path quality and smoothness. The algorithm adaptively adjusts sampling and rewiring radii to reduce search space and improve convergence speed. On connection, the optimal path is reconstructed by merging the shortest cost paths from both trees, ensuring shorter, smoother, and collision-free paths.",
          "planning_mechanism": "The planner alternates extension steps between start and goal trees, always growing the smaller tree to balance exploration. Sampling uses a combined goal bias for both start and goal to encourage fast connection. New nodes are created via a steering function capped by a fixed step size, with explicit collision and edge checks before insertion. Rewiring is done dynamically within a neighborhood radius that shrinks logarithmically with tree size, incrementally improving path cost and smoothness. When the two trees connect via feasible edges, the optimal path is extracted by backtracking from connection nodes and merging them, resulting in efficient convergence to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample either start or goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            r = random.random()\n            # Sample with combined goal bias to start or goal to enhance connectivity\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.5 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            # Shrink radius logarithmically for efficient rewiring as tree grows\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            # Check if node position is valid: inside map bounds & not in obstacle\n            for d, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_target = distance(new_pos, node.position)\n                if dist_to_target <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_target\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.93552,
          "time_improvement": 21.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003909516334533692,
                    "num_nodes_avg": 71.2,
                    "path_length_avg": 171.18510106638226,
                    "success_improvement": 0.0,
                    "time_improvement": 58.545501429622384,
                    "length_improvement": 14.443331832073264,
                    "objective_score": 20.452316795301368
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01824326515197754,
                    "num_nodes_avg": 269.4,
                    "path_length_avg": 270.5479880821555,
                    "success_improvement": 0.0,
                    "time_improvement": -23.824627439303637,
                    "length_improvement": 10.22302450854493,
                    "objective_score": -5.102783330082104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020744752883911134,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 138.9767873393387,
                    "success_improvement": 0.0,
                    "time_improvement": 28.41686637756919,
                    "length_improvement": 14.659880471120387,
                    "objective_score": 11.457036007494834
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid bidirectional RRT* planner merges strengths from both prior approaches. It grows two trees from start and goal points, alternately extending the smaller tree. Sampling incorporates adaptive goal bias with a probabilistic start/goal preference. Tree extension uses a fixed step size steering function with strict node and edge collision checks and map boundary enforcement. The rewiring radius shrinks dynamically with tree size, enabling local optimization. Incremental rewiring improves path cost and smoothness. Periodic pruning removes dead-end nodes to maintain efficiency. Connection attempts between trees utilize incremental steering, and final path reconstruction merges the best-cost branches. This combination targets enhanced efficiency, robustness, smoothness, reduced path length, and higher success rates.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling free points with a biased probability toward start/goal to balance exploration and exploitation. Each iteration, it extends the smaller tree toward a sampled point with steering constrained to a step size and includes comprehensive collision and boundary checking. After extension, it attempts to incrementally connect the opposing tree using the same steering method. Local rewiring within a shrinking radius dynamically optimizes the trees\u2019 costs. Periodic pruning removes dead-end nodes to keep the tree size manageable. Upon connection, the final path is retrieved by concatenating the paths from both trees, producing an efficient, smooth, and collision-free trajectory.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 25.0,\n                 radius_min: float = 4.5, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            rand_val = random.random()\n            if rand_val < self.goal_sample_rate:\n                # With 70% chance goal, else start\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children and node.valid:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        node.valid = False\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first to keep trees balanced\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Periodic pruning to improve efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.86231,
          "time_improvement": 28.0,
          "length_improvement": 10.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0052844762802124025,
                    "num_nodes_avg": 81.4,
                    "path_length_avg": 175.03859137343892,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 43.966134002765706,
                    "length_improvement": 12.5173944144161,
                    "objective_score": 10.693319083712934
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018130898475646973,
                    "num_nodes_avg": 175.7,
                    "path_length_avg": 288.73219942497633,
                    "success_improvement": 0.0,
                    "time_improvement": -23.061948076957304,
                    "length_improvement": 4.188887985747617,
                    "objective_score": -6.0808068259376675
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01048731803894043,
                    "num_nodes_avg": 135.7,
                    "path_length_avg": 139.80011568287077,
                    "success_improvement": 0.0,
                    "time_improvement": 63.81180857041547,
                    "length_improvement": 14.15430727005782,
                    "objective_score": 21.974404025136206
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive informed sampling biased towards both start and goal, dynamic radius rewiring with pruning of dead-ends to maintain tree efficiency, and iterative shortcut smoothing after successful path connection. It alternately extends the smaller tree to balance exploration, rigorously applies collision checks for nodes and edges, and performs path smoothing to ensure shorter and smoother trajectories. These strategies collectively improve planning speed, path optimality, robustness, success rate, and reduce computational overhead and search time.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree by sampling points within the map bounds with goal and start bias. It uses a dynamic radius for neighbor selection to locally optimize path costs via rewiring. After successfully connecting the two trees, it extracts the path and applies iterative shortcut smoothing. Periodic pruning removes dead-end nodes to reduce complexity and enhance efficiency. Comprehensive collision and edge feasibility checks are enforced to ensure valid and safe path construction.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size               # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start      # Tuple[float, ...]\n        goal_position = map.goal        # Tuple[float, ...]\n        obstacles = map.obstacles       # List of obstacles rectangles/cuboids\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate extending smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -7.55322,
          "time_improvement": 12.0,
          "length_improvement": 19.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.006933975219726563,
                    "num_nodes_avg": 72.8,
                    "path_length_avg": 163.3649260494454,
                    "success_improvement": 0.0,
                    "time_improvement": 26.475696419497474,
                    "length_improvement": 18.35178014195116,
                    "objective_score": 11.613064954239475
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020410585403442382,
                    "num_nodes_avg": 254.5,
                    "path_length_avg": 244.16867087718578,
                    "success_improvement": 0.0,
                    "time_improvement": -38.53513131257554,
                    "length_improvement": 18.976574409173768,
                    "objective_score": -7.765224511937907
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014882683753967285,
                    "num_nodes_avg": 157.4,
                    "path_length_avg": 128.50251110260547,
                    "success_improvement": 0.0,
                    "time_improvement": 48.644886454788,
                    "length_improvement": 21.091717061491025,
                    "objective_score": 18.811809348734606
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a bidirectional RRT* algorithm with balanced tree growth, adaptive neighbor radius for rewiring, and shortcut path smoothing to improve path quality, efficiency, and success rate. The planner alternates extending the smaller tree towards sampled points biased towards start and goal, attempts connection with the opposite tree after each extension, prunes dead-end nodes periodically to control complexity, and provides collision-free, smooth, and near-optimal paths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with bias towards these roots to guide growth. It extends the smaller tree towards samples within step size limits, rewires locally using adaptively shrinking neighbor radius to lower path cost, and attempts to connect the opposite tree at each extension. Invalid or dead nodes are pruned intermittently. Upon connection, the path is extracted and refined through iterative shortcut smoothing, providing a collision-free, shorter, and smoother path.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                  # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.95653,
          "time_improvement": 10.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0070808172225952145,
                    "num_nodes_avg": 92.9,
                    "path_length_avg": 161.14819930966323,
                    "success_improvement": 0.0,
                    "time_improvement": 24.918659416168012,
                    "length_improvement": 19.45967886043232,
                    "objective_score": 11.367533596936868
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.0237623929977417,
                    "num_nodes_avg": 227.0,
                    "path_length_avg": 238.90444583071044,
                    "success_improvement": 0.0,
                    "time_improvement": -61.28524337611435,
                    "length_improvement": 20.723422376253854,
                    "objective_score": -14.240888537583533
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.00985403060913086,
                    "num_nodes_avg": 123.5,
                    "path_length_avg": 130.73786629590094,
                    "success_improvement": 0.0,
                    "time_improvement": 65.99706953559297,
                    "length_improvement": 19.71907431274517,
                    "objective_score": 23.74293572322693
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius rewiring, balanced tree growth, dead-end pruning, and iterative shortcut smoothing to efficiently search in complex environments. It integrates fast connection attempts like RRT-Connect, while maintaining asymptotic optimality and robustness through rewiring and pruning.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to balance expansion. Samples are adaptively biased towards start and goal for directed exploration. Each extension uses a dynamic radius depending on tree size to perform rewiring optimizing path cost. Dead-end pruning is periodically applied to remove unnecessary nodes and reduce computational burden. Upon connecting the two trees without collision, the resultant path is shortcut-smoothed iteratively to improve path quality and smoothness. Collision and edge validity checks are enforced rigorously, ensuring robustness and feasibility.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Choose between goal and start with bias p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.83895,
          "time_improvement": 9.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009789466857910156,
                    "num_nodes_avg": 98.0,
                    "path_length_avg": 163.5535741174694,
                    "success_improvement": 0.0,
                    "time_improvement": -3.8024668886310224,
                    "length_improvement": 18.257495650743063,
                    "objective_score": 2.5107590635593064
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01988651752471924,
                    "num_nodes_avg": 202.9,
                    "path_length_avg": 241.16005059975564,
                    "success_improvement": 0.0,
                    "time_improvement": -34.97806467482155,
                    "length_improvement": 19.974936403379097,
                    "objective_score": -6.498432121770645
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009808039665222168,
                    "num_nodes_avg": 127.6,
                    "path_length_avg": 124.92422072194663,
                    "success_improvement": 0.0,
                    "time_improvement": 66.15576874505864,
                    "length_improvement": 23.28900291505477,
                    "objective_score": 24.504531206528544
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.68311,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.007598710060119629,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 161.4550453822259,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 19.42719038120736,
                    "length_improvement": 19.306320142615537,
                    "objective_score": 4.689421142885316
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.013997030258178712,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 259.63765747646863,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 4.9963346727016456,
                    "length_improvement": 13.8434413164237,
                    "objective_score": -0.7324113349047652
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.012314391136169434,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 131.58176022985964,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.507196585457756,
                    "length_improvement": 19.200872600268642,
                    "objective_score": 16.092333495691054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined bidirectional RRT planner integrating adaptive step sizing near obstacles and frontier-biased sampling for enhanced exploration efficiency. It alternately grows two trees from start and goal, performs strict collision and edge checks, and applies path shortcut smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner samples points biased towards frontiers near obstacles with adaptive step sizes that shrink near obstacles to improve precision. Two trees grow toward each other's new nodes while avoiding collisions. Once connected, the concatenated path is shortcut-smoothed iteratively to reduce unnecessary waypoints and produce a shorter, smoother path before returning the final plan.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: list = []\n        nodes: list = []\n        edges: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for i in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased near frontiers\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            cost_a = nearest_a.cost + math.dist(nearest_a.position, new_pos_a)\n            new_node_a = Node(new_pos_a, parent=nearest_a, cost=cost_a)\n            nearest_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_a, new_node_a))\n\n            # Try connecting tree_b to new_node_a\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos_a))\n            connected = False\n            current_node_b = nearest_b\n\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = current_node_b.cost + math.dist(current_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=current_node_b, cost=cost_b)\n                current_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((current_node_b, new_node_b))\n                current_node_b = new_node_b\n\n                if math.dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist <= query_radius:\n                return self.base_step_size * 0.5\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": -6.65571,
          "time_improvement": 8.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005708551406860352,
                    "num_nodes_avg": 99.5,
                    "path_length_avg": 159.4405888448925,
                    "success_improvement": 0.0,
                    "time_improvement": 39.46945967605338,
                    "length_improvement": 20.313126158032215,
                    "objective_score": 15.903463134422458
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02300090789794922,
                    "num_nodes_avg": 396.3,
                    "path_length_avg": 242.17424129074578,
                    "success_improvement": 0.0,
                    "time_improvement": -56.11672732392269,
                    "length_improvement": 19.638393620510445,
                    "objective_score": -12.907339473074716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01748318672180176,
                    "num_nodes_avg": 311.6,
                    "path_length_avg": 121.5714299751307,
                    "success_improvement": 0.0,
                    "time_improvement": 39.67142928835457,
                    "length_improvement": 25.34781840911247,
                    "objective_score": 16.970992468328866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the adaptive heuristic-informed sampling and dynamic radius shrinking from the improved bidirectional RRT* variant with the structured balanced tree growth, mutual rewiring, and rewiring radius calculations inspired by both algorithms. It introduces enhanced sampling bias that evolves over iterations to focus exploration in promising regions, balances tree growth by always expanding the smaller tree first, applies mutual rewiring with dynamic neighborhoods, and performs path shortcutting to improve path smoothness and reduce length. The planner rigorously validates collision-free nodes and edges and confines sampling within map bounds to ensure robustness, efficiency, and better convergence towards shorter, smoother paths.",
          "planning_mechanism": "The planner alternates growth between start and goal trees, samples points using adaptive heuristic bias that transitions from high goal bias to localized exploration near connection regions, extends nearest nodes using a fixed step size, dynamically computes a shrinking rewiring radius based on node count and iteration to balance global exploration and local refinement, rewires neighbors in both trees mutually to improve path cost, and, upon successful connection, extracts and shortcut smooths the final path. This approach blends adaptive sampling, balanced tree growth, and iterative local optimization within a bidirectional RRT* framework to enhance path quality and planning efficiency.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Initial probability to sample goal or biased points\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int, itr: int) -> float:\n            # Dynamic radius with iteration decay for finer rewiring over time\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5*itr/self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            # Adaptive heuristic sampling:\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early iterations: higher goal bias; later: more spread\n                if itr < self.max_iter / 3:\n                    # High goal bias\n                    if subr < 0.7 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.9 and is_free_node(start_position):\n                        return start_position\n                else:\n                    # After some iterations, bias sampling around promising middle area\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[d] + mid_from_goal[d]) / 2 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                        for _ in range(5):\n                            cand = confined_rand()\n                            if is_free_node(cand):\n                                return cand\n                    # Fallback to goal or start positions biased sampling\n                    if subr < 0.5 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.8 and is_free_node(start_position):\n                        return start_position\n\n            # Uniform random sampling inside bounds and free space\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            # If no free sampled point, fallback to start\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                # Use strict less to promote cost improvement\n                if tentative_cost + 1e-8 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to connect through new_node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Always grow smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Shortcut path for smoothness and length improvement\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.3318,
          "time_improvement": 7.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007486176490783691,
                    "num_nodes_avg": 72.6,
                    "path_length_avg": 164.793398605954,
                    "success_improvement": 0.0,
                    "time_improvement": 20.62043841753064,
                    "length_improvement": 17.637843287967563,
                    "objective_score": 9.713700182852705
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.022054314613342285,
                    "num_nodes_avg": 282.5,
                    "path_length_avg": 234.72263809786804,
                    "success_improvement": 0.0,
                    "time_improvement": -49.69180504018914,
                    "length_improvement": 22.11108765886303,
                    "objective_score": -10.485323980284134
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014582228660583497,
                    "num_nodes_avg": 181.8,
                    "path_length_avg": 123.25719770644477,
                    "success_improvement": 0.0,
                    "time_improvement": 49.6816554738064,
                    "length_improvement": 24.312655469728927,
                    "objective_score": 19.767027736087705
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with adaptive rewiring and dynamic radius adjustment, while incorporating heuristic informed sampling towards the goal and enhanced collision checks. It dynamically balances exploration and exploitation by alternating tree expansions, improves path quality via local rewiring around new nodes, and enforces strict collision-free checks for nodes and edges. The method prunes suboptimal nodes iteratively to enhance planning efficiency, leading to smoother and shorter paths with higher success rates and reduced search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling free points biased towards the goal. Each extension uses a steering function with a fixed step size, adding nodes only after thorough collision checks. Rewiring is performed locally with a dynamically shrinking radius to optimize path costs incrementally. The trees attempt to connect after each extension, and upon success, the optimal path is constructed by backtracking. This blend of bidirectional search, incremental optimization, adaptive sampling, and pruning yields efficient, robust, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Heuristic guided sampling with goal bias and start bias for efficient tree growth\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search with linear scan (can be improved with spatial indexing if needed)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes+1) / (n_nodes+1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Rewire radius scales inversely with node count\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            # Add edge record\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Rewire neighbors around new_node for local path cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # epsilon to avoid floating error loops\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge feasibility check before adding terminal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees with start and goal roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Merge paths, avoid duplicated connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Optional pruning of nodes with no children and higher cost to improve efficiency\n            if itr % 250 == 0 and len(nodes) > 100:\n                pruned = []\n                for node in nodes[:]:\n                    if not node.children and node is not start_root and node is not goal_root:\n                        try:\n                            node.parent.children.remove(node)\n                            nodes.remove(node)\n                            # Remove edges related to node\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            pruned.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.15402,
          "time_improvement": 15.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004810810089111328,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 182.51310029888023,
                    "success_improvement": 0.0,
                    "time_improvement": 48.98864644717982,
                    "length_improvement": 8.781706694699151,
                    "objective_score": 16.452935273093775
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02035815715789795,
                    "num_nodes_avg": 178.3,
                    "path_length_avg": 287.3732004707603,
                    "success_improvement": 0.0,
                    "time_improvement": -38.17927900665584,
                    "length_improvement": 4.639849815737334,
                    "objective_score": -10.525813738849285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01868715286254883,
                    "num_nodes_avg": 139.1,
                    "path_length_avg": 147.54383101693634,
                    "success_improvement": 0.0,
                    "time_improvement": 35.516948894576494,
                    "length_improvement": 9.399199565681393,
                    "objective_score": 12.534924581509227
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a balanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighborhood radius for rewiring, periodic pruning of dead-end nodes, and shortcut path smoothing to enhance path quality and search efficiency. It alternates tree expansions from start and goal, ensuring collision-free nodes and edges, dynamically optimizes connections, and smooths the final path for improved smoothness and shorter lengths.",
          "planning_mechanism": "The planner grows two trees from start and goal positions, extending the smaller tree each iteration for balanced exploration. Samples are adaptively biased towards the goal for directed search. New nodes are added only if collision-free, and neighborhood rewiring optimizes path costs dynamically based on tree size. Periodic pruning removes dead-end nodes to reduce computational load. Upon connecting the trees, iterative shortcut smoothing improves path smoothness and quality.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) -1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.02303,
          "time_improvement": 7.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007739663124084473,
                    "num_nodes_avg": 82.0,
                    "path_length_avg": 168.76230537487686,
                    "success_improvement": 0.0,
                    "time_improvement": 17.932596654354978,
                    "length_improvement": 15.654221831994624,
                    "objective_score": 8.510623362705418
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021677231788635253,
                    "num_nodes_avg": 201.1,
                    "path_length_avg": 241.8012510559584,
                    "success_improvement": 0.0,
                    "time_improvement": -47.132387090927615,
                    "length_improvement": 19.76216439923414,
                    "objective_score": -10.187283247431456
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014474320411682128,
                    "num_nodes_avg": 134.9,
                    "path_length_avg": 124.33994290272581,
                    "success_improvement": 0.0,
                    "time_improvement": 50.054010384144235,
                    "length_improvement": 23.647784693544356,
                    "objective_score": 19.74576005395214
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm integrating balanced tree growth, adaptive sampling with goal bias, and dynamic rewiring radius for incremental path optimization. It ensures collision-free nodes and edges, maintains rewiring for local path cost improvements, and leverages post-search path shortcutting to enhance smoothness and path length, applicable to both 2D and 3D environments.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points with goal bias and adaptive local sampling. It extends the smaller tree first, steering towards samples with fixed step size, adding collision-checked nodes and edges. After each addition, neighbors within a dynamically shrinking radius are rewired for better cost paths. When the trees connect, the optimal path is merged and shortcutting is applied to smooth and reduce path length.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_const: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def is_in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(iteration):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Bias sampling towards goal (70%) or start (10%), else local around connection\n                sub_r = random.random()\n                if sub_r < 0.7 and not in_obstacle(goal_pos):\n                    return goal_pos\n                elif sub_r < 0.8 and not in_obstacle(start_pos):\n                    return start_pos\n                else:\n                    # Local biased sampling around midpoints of existing trees for refinement\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[d] + mid_goal[d]) * 0.5 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - iteration / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                            if not in_obstacle(candidate):\n                                return candidate\n            # Uniform random sampling fallback\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def radius(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_const\n            base = self.radius_const * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = radius(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative = node.cost + math.dist(node.position, new_pos)\n                if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = tentative\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for local improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last.position, target_node.position)\n                if (not is_in_bounds(new_pos) or in_obstacle(new_pos)\n                    or edge_in_obstacle(last.position, new_pos)):\n                    return None\n\n                r = radius(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = last.cost + math.dist(last.position, new_pos)\n                best_parent = last\n                for node in neighbors:\n                    tentative = node.cost + math.dist(node.position, new_pos)\n                    if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                        min_cost = tentative\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_pos, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_pos, target_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No further shortcut, step forward\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for itr in range(self.max_iter):\n            rand_pt = sample_free(itr)\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged = path_start + path_goal[::-1][1:]\n                final_path = shortcut_path(merged)\n                break\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
          "objective": -5.99315,
          "time_improvement": 5.0,
          "length_improvement": 23.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.01188223361968994,
                    "num_nodes_avg": 79.8,
                    "path_length_avg": 158.83592449947326,
                    "success_improvement": 0.0,
                    "time_improvement": -25.993088262433655,
                    "length_improvement": 20.615331586143324,
                    "objective_score": -3.6748601615014307
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01518077850341797,
                    "num_nodes_avg": 232.1,
                    "path_length_avg": 233.555736130099,
                    "success_improvement": 0.0,
                    "time_improvement": -3.038256954816952,
                    "length_improvement": 22.49830520981935,
                    "objective_score": 3.588183955518785
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.016344833374023437,
                    "num_nodes_avg": 246.1,
                    "path_length_avg": 122.24962607271053,
                    "success_improvement": 0.0,
                    "time_improvement": 43.59950210076947,
                    "length_improvement": 24.93136514997817,
                    "objective_score": 18.066123660226474
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines the strengths of both previous algorithms into a bidirectional RRT* variant with adaptive and heuristic-informed sampling, dynamic and decaying rewiring radius, and balanced tree growth. It incorporates mutual rewiring and connection attempts between trees, periodic pruning of dead-end nodes for efficiency, and advanced path shortcutting smoothing. Collision checks rigorously ensure safety, while adaptive sampling focuses exploration near promising regions as iterations progress. This results in improved efficiency, robustness, success rate, and smoother, shorter paths in both 2D and 3D environments.",
          "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balance. It samples points adaptively and heuristically to balance exploration and exploitation. Each extension uses a dynamic, decaying radius to find near nodes for rewiring and cost optimization. After each expansion, the planner attempts to connect the other tree. Dead-end nodes are pruned periodically to keep the search tree efficient. Upon successful connection, a shortcut smoothing post-process refines the path. Collision checks are enforced for all nodes and edges.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Heuristic adaptive sampling shifting from aggressive goal/start bias to exploration near connection midpoints\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free sample\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                # Use the shorter path between raw, shortcuted and smoothed to improve quality\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.86,
          "time_improvement": 5.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009752225875854493,
                    "num_nodes_avg": 84.4,
                    "path_length_avg": 160.30622257797762,
                    "success_improvement": 0.0,
                    "time_improvement": -3.407582686779978,
                    "length_improvement": 19.880490738272123,
                    "objective_score": 2.9538233416204314
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018081092834472658,
                    "num_nodes_avg": 184.4,
                    "path_length_avg": 235.45185784316172,
                    "success_improvement": 0.0,
                    "time_improvement": -22.723896477563834,
                    "length_improvement": 21.869107876772635,
                    "objective_score": -2.4433473679146225
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017218947410583496,
                    "num_nodes_avg": 175.8,
                    "path_length_avg": 122.99644452541483,
                    "success_improvement": 0.0,
                    "time_improvement": 40.583229878560964,
                    "length_improvement": 24.472773630917217,
                    "objective_score": 17.069523689751733
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.6829227155522615,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011509346961975097,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -22.03919010817601,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -4.1314597250548815
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016402530670166015,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -11.330797002361011,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -0.5611573357999351
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010229659080505372,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 64.70090258632817,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 21.741385207511602
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards the goal and start to balance exploration and exploitation. It uses a dynamically shrinking radius for rewiring to optimize path costs continually. The algorithm grows two trees from start and goal, alternately extending the smaller tree for balanced growth. After each extension, the planner attempts to connect the two trees to form a complete path. Dead-end nodes are periodically pruned to enhance efficiency. Additionally, a path smoothing and shortcut procedure is applied post path extraction to reduce path length and improve smoothness. Collision checks ensure safety. This results in improved planning speed, higher success rates, and shorter, smoother paths.",
          "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal positions. It samples points within the map bounds with bias towards the goal and start, steering and extending the smaller tree first. A dynamic radius is used to find neighbors to rewire and reduce path cost locally. After extension, attempts are made to connect the opposing tree to complete a path. Periodic pruning removes dead nodes. Upon successful connection, the path is extracted and post-processed via shortcut smoothing to minimize length and enhance smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                # Post-process with smoothing\n                smoothed_path = path_smoothing(raw_path)\n                # Use the shorter path among raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.61374,
          "time_improvement": 7.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008043766021728516,
                    "num_nodes_avg": 85.5,
                    "path_length_avg": 163.6645421149303,
                    "success_improvement": 0.0,
                    "time_improvement": 14.708046081621204,
                    "length_improvement": 18.202034912180657,
                    "objective_score": 8.052820806922492
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018214941024780273,
                    "num_nodes_avg": 211.3,
                    "path_length_avg": 250.73203836217277,
                    "success_improvement": 0.0,
                    "time_improvement": -23.632379808820406,
                    "length_improvement": 16.798627029050724,
                    "objective_score": -3.7299885368359766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020520853996276855,
                    "num_nodes_avg": 169.4,
                    "path_length_avg": 132.2218958906299,
                    "success_improvement": 0.0,
                    "time_improvement": 29.189465794931664,
                    "length_improvement": 18.80779074213471,
                    "objective_score": 12.518397886906442
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of enhanced bidirectional RRT* with adaptive goal biasing and incremental rewiring along with a dynamic radius and balanced tree growth. It integrates dynamic radius rewiring for local cost improvements, adaptive sampling bias toward both start and goal, and smart tree balancing to improve convergence speed, robustness, and path quality. The algorithm also incorporates rewiring from both trees when extending and connecting nodes, enhancing overall path smoothness and shortness while preserving collision checks and pruning possible redundant edges.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with adaptive biasing favoring goal and start to promote exploration. It extends the smaller tree first toward sampled points, rewiring neighbors within a dynamically shrinking radius to optimize costs. When a new node is created in one tree, it attempts to connect and rewire the opposite tree toward it. Path extraction occurs at the first successful connection by merging both trees' paths. Rigorous obstacle and edge collision checks ensure safe expansions, while adaptive radius and rewiring improve convergence to optimal, smooth paths effectively across 2D or 3D environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive goal biasing: bias toward goal 70% and start 10% when goal_sample_rate applies\n            if random.random() < self.goal_sample_rate:\n                p = goal_position if random.random() < 0.7 else start_position\n                # Verify p does not lie inside obstacle (rare but safe)\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Uniform random sample in bounds and free space\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Dynamic radius shrinking with node count, minimum radius enforced\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if within step_size to target_node\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final edge feasibility check\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Main loop, balanced bidirectional growth alternating tree extension attempts\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            # On successful extension on one tree, attempt connection & rewiring on the other\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found feasible connection: reconstruct path\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                # Merge paths without duplicating connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.55242,
          "time_improvement": 10.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0072095394134521484,
                    "num_nodes_avg": 92.4,
                    "path_length_avg": 171.03662888960565,
                    "success_improvement": 0.0,
                    "time_improvement": 23.55375557122958,
                    "length_improvement": 14.517536798986361,
                    "objective_score": 9.969634031166146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014955592155456544,
                    "num_nodes_avg": 238.0,
                    "path_length_avg": 282.8514380030673,
                    "success_improvement": 0.0,
                    "time_improvement": -1.5098235626334042,
                    "length_improvement": 6.140323580550488,
                    "objective_score": 0.7751176473200765
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026245260238647462,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 137.75874664227172,
                    "success_improvement": 0.0,
                    "time_improvement": 9.436473833552576,
                    "length_improvement": 15.407830835125619,
                    "objective_score": 5.9125083170908965
               }
          ],
          "success_rate": 1.0
     }
]