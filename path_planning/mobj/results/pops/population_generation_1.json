[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.708512676293243,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0016797542572021484,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 82.1887506035762,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 27.56608404471968
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008045697212219238,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 45.39050704503417,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 0.27572040411595267
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0035561323165893555,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 87.72898880878513,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 22.283733580044093
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
          "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -9.55661,
          "time_improvement": 23.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053680181503295895,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 168.24816019864105,
                    "success_improvement": 0.0,
                    "time_improvement": 43.08029901986809,
                    "length_improvement": 15.911186649372569,
                    "objective_score": 16.106327035834944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01864187717437744,
                    "num_nodes_avg": 256.6,
                    "path_length_avg": 287.4569206517525,
                    "success_improvement": 0.0,
                    "time_improvement": -26.530173006684965,
                    "length_improvement": 4.612068627304342,
                    "objective_score": -7.036638176544621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013377833366394042,
                    "num_nodes_avg": 183.6,
                    "path_length_avg": 134.76801275171147,
                    "success_improvement": 0.0,
                    "time_improvement": 53.83761673112537,
                    "length_improvement": 17.24432160877036,
                    "objective_score": 19.600149341091683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.68311,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.007598710060119629,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 161.4550453822259,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 19.42719038120736,
                    "length_improvement": 19.306320142615537,
                    "objective_score": 4.689421142885316
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.013997030258178712,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 259.63765747646863,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 4.9963346727016456,
                    "length_improvement": 13.8434413164237,
                    "objective_score": -0.7324113349047652
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.012314391136169434,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 131.58176022985964,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.507196585457756,
                    "length_improvement": 19.200872600268642,
                    "objective_score": 16.092333495691054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.6829227155522615,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011509346961975097,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -22.03919010817601,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -4.1314597250548815
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016402530670166015,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -11.330797002361011,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -0.5611573357999351
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010229659080505372,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 64.70090258632817,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 21.741385207511602
               }
          ]
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -2.8383427428807892,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007564902305603027,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 19.785670405679053,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 10.167469981989559
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021586298942565918,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -46.51518804828198,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -18.48783628573898
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.009180307388305664,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.32186075440126,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 16.83539453239179
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm enhances the bidirectional RRT by integrating a heuristic-based goal biasing and nearest neighbor optimization to improve efficiency and path quality. It grows two trees from start and goal alternately, extends towards sampled points with goal bias to encourage tree connection, performs rigorous collision and edge checks, and once trees connect, extracts and smooths the path for improved smoothness and shorter path length.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal. At each iteration, it samples points with goal biasing, extends one tree towards the sample, attempts connection to the other tree quickly, and upon successful connection, reconstructs and smooths the path. Rigorous collision checks and edge validity checks ensure robustness. Path smoothing via shortcutting reduces path length and improves smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal to bias growth\n        self.smoothing_iter = smoothing_iter      # Number of path smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def can_connect(node_from, node_to):\n            if self._is_edge_in_obstacle(node_from.position, node_to.position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(node_to.position, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, new_node.position)\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                next_node = Node(new_pos, parent=nearest_node,\n                                cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(new_pos, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            import random\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate tree growth\n        for iter in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Extend start tree towards random point\n            nearest_start = nearest(tree_start, rand_point)\n            new_pos_start = steer(nearest_start.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_start, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d)):\n                new_node_start = Node(new_pos_start, parent=nearest_start,\n                                     cost=nearest_start.cost + math.dist(nearest_start.position, new_pos_start))\n                nearest_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_start, new_node_start))\n\n                # Try connect goal tree to new start node\n                new_node_goal = connect_trees(new_node_start, tree_goal)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap roles: Extend goal tree towards random point\n            rand_point = sample_point()\n            nearest_goal = nearest(tree_goal, rand_point)\n            new_pos_goal = steer(nearest_goal.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_goal, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d)):\n                new_node_goal = Node(new_pos_goal, parent=nearest_goal,\n                                    cost=nearest_goal.cost + math.dist(nearest_goal.position, new_pos_goal))\n                nearest_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_goal, new_node_goal))\n\n                # Try connect start tree to new goal node\n                new_node_start = connect_trees(new_node_goal, tree_start)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.18266,
          "time_improvement": 9.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009535980224609376,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 170.74762170972932,
                    "success_improvement": 0.0,
                    "time_improvement": -1.1146251254553718,
                    "length_improvement": 14.661979809696968,
                    "objective_score": 2.598008424302782
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.015331578254699708,
                    "num_nodes_avg": 255.3,
                    "path_length_avg": 231.82982015577954,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4.06179758007486,
                    "length_improvement": 23.07102252043464,
                    "objective_score": -1.6043347699355293
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.01953170299530029,
                    "num_nodes_avg": 281.5,
                    "path_length_avg": 115.83970390651845,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 32.602691716296164,
                    "length_improvement": 28.867443500228006,
                    "objective_score": 5.554296214934452
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 0.15575745947482242,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00932621955871582,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": 1.1095689897082393,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": 1.5181850655740972
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017459988594055176,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -18.50820369833951,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -5.475109047417674
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026160240173339844,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": 9.729849355042791,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": 3.4896516034191096
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined and generalized optimal RRT-based planner combining bidirectional search and rewiring techniques. It balances efficient exploration with continuous local path cost optimization to enhance path quality, success rate, and computational speed.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points within bounds, and steering towards them with collision checks. It rewires nodes nearby new additions to minimize cost. Trees attempt to connect, forming smoother and shorter paths while quickly exploring the space with balanced bidirectional growth and local optimizations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend start tree\n            new_start = self._extend_tree(tree_start, rand_point, obstacles, is_3d, nodes, edges, near, steer, nearest)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree to new_start\n            new_goal = self._connect_tree(tree_goal, new_start.position, obstacles, is_3d, nodes, edges, near, steer, nearest)\n\n            if new_goal:\n                success_state = True\n                connection_node_start = new_start\n                connection_node_goal = new_goal\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        extracted_path = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            extracted_path = path_start + path_goal[::-1]\n\n            # Optional smoothing\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n        nearest_node = nearest_fn(tree, point)\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for node in near_nodes:\n            cost = node.cost + math.dist(node.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for node in near_nodes:\n            if node == best_parent:\n                continue\n            cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n            if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                if node.parent:\n                    edges.remove((node.parent, node))\n                    node.parent.children.remove(node)\n                node.parent = new_node\n                node.cost = cost_through_new\n                new_node.add_child(node)\n                edges.append((new_node, node))\n\n        return new_node\n\n    def _connect_tree(self, tree, target_position, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n\n        current_node = nearest_fn(tree, target_position)\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            if math.dist(new_node.position, target_position) <= self.step_size:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import math\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 7.29674,
          "time_improvement": -36.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0127516508102417,
                    "num_nodes_avg": 95.7,
                    "path_length_avg": 155.49876463463846,
                    "success_improvement": 0.0,
                    "time_improvement": -35.21194057018043,
                    "length_improvement": 22.283212011486395,
                    "objective_score": -6.10693976875685
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.022982406616210937,
                    "num_nodes_avg": 289.7,
                    "path_length_avg": 218.9591641629555,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -55.99115143061041,
                    "length_improvement": 27.341941612525005,
                    "objective_score": -16.328957106678118
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0340461254119873,
                    "num_nodes_avg": 351.0,
                    "path_length_avg": 115.70390280011952,
                    "success_improvement": 0.0,
                    "time_improvement": -17.481676370436364,
                    "length_improvement": 28.950833560353235,
                    "objective_score": 0.5456638009397379
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive goal biasing, dynamic neighbor radius based on node density, heuristic-driven sampling towards the goal, and efficient rewiring techniques. It balances exploration and exploitation to rapidly discover feasible paths while continuously optimizing path cost, resulting in reduced planning time and shorter, smoother paths. Additionally, it incorporates lazy collision checking and path smoothing to enhance success rate and path quality.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling points with adaptive goal bias. It uses a dynamic neighbor radius influenced by iteration count to refine rewiring as trees expand. Steering uses fixed step size with checks to remain in bounds and avoid obstacles. When new nodes are added, nearby nodes are rewired to minimize cost. The trees attempt to connect through nearest nodes periodically. Upon successful connection, the path is extracted and smoothed by shortcutting collision-free edges, ensuring efficient and smooth navigation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive sampling bias: gradually increase goal bias with iterations\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.2, 0.3)\n            if random.random() < goal_bias:\n                # Bias alternate between start and goal to reduce symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds if slight out-of-bound due to float errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(len(bounds))\n            )\n            return clamped\n\n        def nearest(tree, point):\n            # Use Euclidean distance\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            # Dynamic radius shrinking with iterations to focus rewiring locally as tree grows\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Efficiently find neighbors within dynamic radius\n            # For performance, linear search; could be improved with spatial indexing\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n\n            # Alternate between trees for balanced growth\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(it)\n\n            # --- Extend tree_a towards random sample ---\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path improves cost\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # --- Try to connect tree_b to new_node ---\n            nearest_node_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_node_b\n\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check connector proximity\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    # Trees connected successfully\n                    connection_node_start = new_node if tree_a is tree_start else new_node_b\n                    connection_node_goal = new_node_b if tree_b is tree_goal else new_node\n\n                    success_state = True\n                    break\n\n                curr_node_b = new_node_b\n\n            if success_state:\n                # Extract paths and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing: attempt shortcutting by bypassing intermediate nodes\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.37999,
          "time_improvement": -79.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.8,
                    "time_avg": 0.01865048408508301,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 171.3088822744523,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -97.76013186402028,
                    "length_improvement": 14.381467174002548,
                    "objective_score": -36.451746124405574
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034059691429138186,
                    "num_nodes_avg": 319.6,
                    "path_length_avg": 228.7886221087461,
                    "success_improvement": 0.0,
                    "time_improvement": -131.17729018226305,
                    "length_improvement": 24.080194920749342,
                    "objective_score": -34.53714807052904
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.031148362159729003,
                    "num_nodes_avg": 293.9,
                    "path_length_avg": 121.37515371171125,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -7.4824743913445175,
                    "length_improvement": 25.46834385873305,
                    "objective_score": -2.151073545656743
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved hybrid bidirectional RRT* planner enhances path planning by integrating adaptive sampling, dynamic neighbor radius based on the growing tree size, and more aggressive local rewiring for better path quality and convergence speed. The planning efficiency gains come from adaptive goal biasing, radius scaling to include more neighbors as the tree grows, and collision checks early in the sampling process to avoid futile expansions. The rewiring step is optimized to better minimize path length and enhance smoothness, and the swapping of trees is maintained for balanced exploration from start and goal.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal nodes, each extending towards random samples biased towards the goal and start positions respectively. Each extension involves steering with a fixed step size and connecting the new node to the minimum cost parent within a dynamically computed radius. After insertion, neighbors are rewired if the path via the new node shortens their costs, promoting optimal paths locally. Once the two trees connect within the step size, the algorithm reconstructs the complete path by joining backtracked nodes from both sides. This combination leverages bidirectional search and incremental rewiring to rapidly find short, collision-free, and smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # Constant for radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (2D or 3D)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free(grow_from_start: bool):\n            if random.random() < self.goal_sample_rate:\n                # Bias toward opposite tree root to encourage connection\n                return goal_position if grow_from_start else start_position\n            else:\n                for _ in range(100):  # Limit attempts to 100 for efficiency\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    # Quick boundary check\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback to root positions if sampling fails repeatedly\n                return goal_position if grow_from_start else start_position\n\n        def nearest(tree, point):\n            # Euclidean nearest node in tree\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def compute_radius(n):\n            # Adaptive neighbor radius based on number of nodes (as in RRT*)\n            # radius = \u03b3 * (log(n)/n)^(1/d), \u03b3 estimated by neighbor_radius_const, d dimension\n            d = 3 if is_3d else 2\n            if n <= 1:\n                return self.neighbor_radius_const\n            return min(self.neighbor_radius_const, \n                       self.neighbor_radius_const * ((math.log(n) / n) ** (1 / d)))\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Reject if out of bounds or in obstacle\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = compute_radius(n_nodes)\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path found through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, node.position)\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        # Alternate growth of trees from start and goal\n        for iteration in range(self.max_iter):\n            grow_start = (iteration % 2 == 0)\n            rand_point = sample_free(grow_start)\n\n            # Extend respective tree towards sample\n            tree_a = tree_start if grow_start else tree_goal\n            tree_b = tree_goal if grow_start else tree_start\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                # Swap and continue\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Trees connected successfully\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                extracted_path = path_a + path_b[::-1][1:]\n                break\n\n            # Swap to grow other tree next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 70.96357,
          "time_improvement": -244.0,
          "length_improvement": 11.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027609086036682128,
                    "num_nodes_avg": 204.3,
                    "path_length_avg": 180.49303316131713,
                    "success_improvement": 0.0,
                    "time_improvement": -192.7525350200602,
                    "length_improvement": 9.79131683418436,
                    "objective_score": -55.86749713918118
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05325424671173096,
                    "num_nodes_avg": 509.3,
                    "path_length_avg": 260.2796083827043,
                    "success_improvement": 0.0,
                    "time_improvement": -261.45871935244264,
                    "length_improvement": 13.630420287568977,
                    "objective_score": -75.71153174821899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10933144092559814,
                    "num_nodes_avg": 771.6,
                    "path_length_avg": 147.6395673342232,
                    "success_improvement": 0.0,
                    "time_improvement": -277.26586519041024,
                    "length_improvement": 9.340411699614483,
                    "objective_score": -81.31167721720017
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an improved RRT* variant that balances exploration and exploitation by biasing sampling toward the goal and dynamically adjusting the step size based on obstacle proximity. It incrementally builds a single tree rooted at the start, incorporating collision-checked nodes and edges, and applies a post-processing shortcut smoothing to improve path quality, smoothness, and reduce path length. This approach aims to enhance planning efficiency, robustness, and success rate while producing shorter and smoother paths.",
          "planning_mechanism": "The planner samples mostly randomly but biases sampling near the goal to accelerate convergence. It dynamically adjusts step sizes\u2014smaller near obstacles for precision, larger in free space for speed. It incrementally extends the tree by steering toward sampled points with collision checks on nodes and edges. Upon reaching close to the goal, it reconstructs the path and applies shortcut smoothing to refine it.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.1, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def adaptive_step(pos):\n            query_r = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dz = max(z - pz, 0, pz - (z + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_r:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_pos, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        n = len(path)\n        if n < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 146.53934,
          "time_improvement": -502.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029899191856384278,
                    "num_nodes_avg": 377.1,
                    "path_length_avg": 163.43597517767063,
                    "success_improvement": 0.0,
                    "time_improvement": -217.03563817281366,
                    "length_improvement": 18.316270470552652,
                    "objective_score": -61.44743735773356
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.17256031036376954,
                    "num_nodes_avg": 1409.5,
                    "path_length_avg": 244.54989526735397,
                    "success_improvement": 0.0,
                    "time_improvement": -1071.238589342555,
                    "length_improvement": 18.85007125912084,
                    "objective_score": -317.60156255094233
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09181842803955079,
                    "num_nodes_avg": 1019.0,
                    "path_length_avg": 126.36150399125684,
                    "success_improvement": 0.0,
                    "time_improvement": -216.8343744626728,
                    "length_improvement": 22.406424404297432,
                    "objective_score": -60.56902745794235
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of sampling-based tree expansion with frontier-guided exploration and adaptive step sizing to efficiently explore the configuration space. It applies goal biasing for convergence, dynamically adjusts step sizes near obstacles for precision, and incorporates a frontier sampling strategy to focus sampling near obstacle boundaries. After initial path discovery, iterative shortcut smoothing refines the path to enhance smoothness and reduce length, boosting path quality and success rate.",
          "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling either toward the goal, near frontiers, or randomly in free space, using adaptive step sizes based on proximity to obstacles. It performs rigorous collision checks for nodes and edges before adding them. Upon finding a path to the goal, it executes a shortcut smoothing routine, producing a robust, efficient, and smooth path with improved planning performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            elif r < self.goal_sample_rate + self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                if all(0 <= nbr[i] <= steps[i] for i in range(dims)):\n                    yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        for cz in range(min_cells[2], max_cells[2]+1):\n                            if cz < 0 or cz > steps[2]:\n                                continue\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        occupied.add((cx, cy))\n\n        for ix in range(steps[0]+1):\n            if is_3d:\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontier_pos = tuple((pos_grid[d] + 0.5)*resolution for d in range(3))\n                            frontiers.append(frontier_pos)\n            else:\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontier_pos = ((ix + 0.5)*resolution, (iy + 0.5)*resolution)\n                        frontiers.append(frontier_pos)\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        dim = len(bounds)\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        return tuple(from_pos[d] + unit_vec[d] * step_size for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if self._in_bounds(p_j, bounds) and not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": 154.51652,
          "time_improvement": -529.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030805325508117674,
                    "num_nodes_avg": 345.8,
                    "path_length_avg": 163.60662082009756,
                    "success_improvement": 0.0,
                    "time_improvement": -226.6438129330896,
                    "length_improvement": 18.23098341862772,
                    "objective_score": -64.34694719620133
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.17162775993347168,
                    "num_nodes_avg": 1382.6,
                    "path_length_avg": 242.5890407852697,
                    "success_improvement": 0.0,
                    "time_improvement": -1064.9089817510392,
                    "length_improvement": 19.50074911493595,
                    "objective_score": -315.57254470232454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11421992778778076,
                    "num_nodes_avg": 1022.1,
                    "path_length_avg": 125.31142432665688,
                    "success_improvement": 0.0,
                    "time_improvement": -294.1343817847203,
                    "length_improvement": 23.051236576225087,
                    "objective_score": -83.63006722017107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a sampling-based path planning algorithm that incrementally builds a space-filling tree rooted at the start position by randomly sampling the configuration space and extending the nearest existing node toward the sample. It continues this process until the goal is reached or a maximum number of iterations is exceeded.",
          "planning_mechanism": "The planner randomly samples free configurations, finds the nearest node in the current tree, attempts to extend toward the sample by a fixed step size, and adds the new node if the move is valid. This repeats until the goal is reached or iteration limit is hit.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            length = math.dist(nearest_node.position, sample)\n            if length == 0:\n                continue\n            unit = tuple(d / length for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, length) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=nearest_node.cost + math.dist(nearest_node.position, new_position))\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Check if goal reached\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 189.10686922065494,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.033198428153991696,
                    "num_nodes_avg": 461.3,
                    "path_length_avg": 182.79849371656624,
                    "success_improvement": 0.0,
                    "time_improvement": -252.01904140722368,
                    "length_improvement": 8.639069807597604,
                    "objective_score": -73.87789846064759
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.22934484481811523,
                    "num_nodes_avg": 1743.3,
                    "path_length_avg": 304.8791467783907,
                    "success_improvement": 0.0,
                    "time_improvement": -1456.6588397499486,
                    "length_improvement": -1.1692154216563917,
                    "objective_score": -437.23149500931584
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.08481602668762207,
                    "num_nodes_avg": 962.7,
                    "path_length_avg": 149.90205372686268,
                    "success_improvement": 0.0,
                    "time_improvement": -192.6714531467116,
                    "length_improvement": 7.95110876006046,
                    "objective_score": -56.211214192001385
               }
          ]
     },
     {
          "operator": "e1",
          "algorithm_description": "This algorithm is a hybrid informed sampling planner combining frontier-guided exploration with dynamic step adjustment and path smoothing. It begins with uniform random sampling biased toward unexplored frontier regions near obstacles to efficiently cover free space. The step size dynamically adapts based on local obstacle density to balance exploration and exploitation. After finding an initial path, a shortcut smoothing procedure refines the path to improve smoothness and reduce length, enhancing path quality while maintaining collision safety. This approach aims at faster convergence, higher success rate, better path smoothness, and efficient obstacle-aware exploration.",
          "planning_mechanism": "The planner incrementally builds a tree rooted at start by sampling primarily near frontiers (boundaries between free space and obstacles) to prioritize promising regions. It dynamically adjusts step size: smaller step near obstacles for precision, larger in free space to speed exploration. Upon reaching the goal, it applies iterative shortcut smoothing on the found path to reduce unnecessary detours. Collision checks for nodes and edges ensure path validity and robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n\n            if random.random() < self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            if math.dist(new_position, goal) <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal, obstacles, is_3d) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_position, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        # Sample grid for frontier detection\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        # Convert obstacles to quick check set approximated by grid cells\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i] + 1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        # Frontier detection on grid\n        for ix in range(steps[0]+1):\n            for iy in range(steps[1]+1):\n                pos_grid = (ix, iy) if not is_3d else None\n                if is_3d:\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        # Check neighbors occupied?\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(len(bounds))))\n                else:\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        # Generator for cartesian product of input arrays (list of lists)\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        dim = len(bounds)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        # Decrease step size near obstacles to improve precision, else use base_step_size\n        query_radius = base_step_size * 2\n        nearby_obstacle = False\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx**2 + dy**2 + dz**2)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx**2 + dy**2)**0.5\n            if dist <= query_radius:\n                nearby_obstacle = True\n                break\n        return base_step_size * 0.5 if nearby_obstacle else base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": 232.0497,
          "time_improvement": -785.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.131243896484375,
                    "num_nodes_avg": 1106.5,
                    "path_length_avg": 172.2950583974712,
                    "success_improvement": 0.0,
                    "time_improvement": -1291.6427132235647,
                    "length_improvement": 13.88858582634635,
                    "objective_score": -384.7150968018001
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.14024708271026612,
                    "num_nodes_avg": 1298.2,
                    "path_length_avg": 237.7602131001206,
                    "success_improvement": 0.0,
                    "time_improvement": -851.9152751099193,
                    "length_improvement": 21.103117507379686,
                    "objective_score": -251.35395903149987
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0906510591506958,
                    "num_nodes_avg": 1041.2,
                    "path_length_avg": 132.21978033208794,
                    "success_improvement": 0.0,
                    "time_improvement": -212.80617882085417,
                    "length_improvement": 18.80908982252286,
                    "objective_score": -60.080035681751674
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is an optimal variant of RRT that improves path quality over time by rewiring the tree to minimize path cost. It incrementally builds a space-filling tree from start toward the goal while performing local optimizations by choosing better parents and rewiring nearby nodes.",
          "planning_mechanism": "The planner samples a point, extends the nearest node toward it, finds nearby nodes within a radius, selects the node offering the lowest-cost path as the parent, and rewires suboptimal neighbors to the new node if a shorter path through it is possible and valid.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 3.0, goal_sample_rate: float = 0.05, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(len(bounds)))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(len(bounds)))\n\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Nearby nodes for choosing best parent\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= self.neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check goal connection\n            if math.dist(new_position, goal_position) <= self.step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 349.3863270151231,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0490433931350708,
                    "num_nodes_avg": 379.9,
                    "path_length_avg": 157.7438779343973,
                    "success_improvement": 0.0,
                    "time_improvement": -420.030892989415,
                    "length_improvement": 21.16112596316623,
                    "objective_score": -121.77704270419125
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.41573562622070315,
                    "num_nodes_avg": 1647.6,
                    "path_length_avg": 225.42614332098805,
                    "success_improvement": 0.0,
                    "time_improvement": -2721.770587730782,
                    "length_improvement": 25.195979140247676,
                    "objective_score": -811.4919804911851
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.14521327018737792,
                    "num_nodes_avg": 897.6,
                    "path_length_avg": 118.59892784173539,
                    "success_improvement": 0.0,
                    "time_improvement": -401.0819353570156,
                    "length_improvement": 27.173113785558407,
                    "objective_score": -114.889957849993
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is an enhanced RRT* variant with tuned parameters for improved efficiency, path quality, and success rate. It incrementally expands a tree from start toward goal, leveraging goal biasing, rewiring to reduce path cost, and neighborhood radius adapted to environment size. It includes collision checks for nodes and edges and concludes upon reaching the goal region. Additionally, it incorporates smarter sampling and rewiring strategies to promote smoother and shorter paths while reducing unnecessary branching.",
          "planning_mechanism": "The planner samples random points with bias toward the goal, extends from the nearest node within a defined step size, determines the best parent among neighbors by minimal path cost while ensuring no collisions, then inserts the new node and rewires neighbors if a better path is found through the new node, iterating until a valid goal is connected or max iterations are reached.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.10, neighbor_radius: float = None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius  # Will be set dynamically based on map size\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Dynamically set neighbor radius if not provided, scaled by dimension and step_size\n        dim = len(bounds)\n        if self.neighbor_radius is None:\n            # Use a radius proportional to step_size and dimension (heuristic)\n            self.neighbor_radius = self.step_size * 5.0 * (dim ** 0.5)\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n\n            unit_vec = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest_node.position[d] + unit_vec[d] * min(self.step_size, dist_to_sample) for d in range(dim))\n\n            # Check within bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Gather neighbors for rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                temp_cost = near_node.cost + edge_cost\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check for goal connection\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n                    break\n\n        # If goal not reached: try to find best node near goal for path extraction\n        if not success_state:\n            candidates = [(n, math.dist(n.position, goal_position) + n.cost) for n in nodes]\n            candidates = [c for c in candidates if not self._is_edge_in_obstacle(c[0].position, goal_position, obstacles, is_3d)]\n            if candidates:\n                best_node, _ = min(candidates, key=lambda x: x[1])\n                # Add virtual goal connection if possible (without collision)\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = best_node.cost + math.dist(best_node.position, goal_position)\n                    if not self._is_edge_in_obstacle(best_node.position, goal_position, obstacles, is_3d):\n                        goal_node.update_parent(best_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((best_node, goal_node))\n                        success_state = True\n                        # Extract path\n                        path = []\n                        curr = goal_node\n                        while curr:\n                            path.append(curr.position)\n                            curr = curr.parent\n                        extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 880.29439,
          "time_improvement": -2929.0,
          "length_improvement": 25.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.24811675548553466,
                    "num_nodes_avg": 351.4,
                    "path_length_avg": 160.10209001065772,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -2530.9023432661115,
                    "length_improvement": 19.982514233399094,
                    "objective_score": -760.2742001331536
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.8466428041458129,
                    "num_nodes_avg": 1276.3,
                    "path_length_avg": 222.28644943966083,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -5646.51680629433,
                    "length_improvement": 26.237835790643434,
                    "objective_score": -1698.7074747301704
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.2055886745452881,
                    "num_nodes_avg": 639.2,
                    "path_length_avg": 114.6173289964833,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -609.4170580671276,
                    "length_improvement": 29.61805533209308,
                    "objective_score": -181.9015063537197
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional, asymptotically optimal planner that enhances RRT*-Connect by incorporating informed heuristic sampling, adaptive step size, node rejection, and pruning. It accelerates convergence and improves success rate in narrow, obstacle-rich environments.",
          "planning_mechanism": "The planner grows two trees from start and goal using informed sampling. During expansion, it adaptively adjusts the step size near obstacles, rejects inefficient new nodes, and prunes branches that cannot contribute to an improved solution. The planner rewires nearby nodes only if doing so reduces path cost, and updates the current best path whenever a successful connection is found.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0, rewire_radius=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map):\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_a, tree_b = [Node(start)], [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n        success, c_best, best_path = False, float(\"inf\"), []\n        c_min = math.dist(start, goal)\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = self._informed_sample(start, goal, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if cost + math.dist(new_pos, goal) >= c_best:\n                continue  # pruning\n\n            new_node = Node(new_pos, nearest, cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.children.remove(near)\n                        edges.remove((near.parent, near))\n                    near.parent = new_node\n                    near.cost = new_cost\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n            # Try to connect to the other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float(\"inf\"):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n        a1 = np.array(goal) - np.array(start)\n        a1 = a1 / np.linalg.norm(a1)\n        M = np.outer(a1, np.eye(dim)[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        L = np.diag([r1] + [r2] * (dim - 1))\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            x_ball *= random.random() ** (1 / dim)\n            x_rand = C @ L @ x_ball + x_center\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    ",
          "objective": 2725.302640311251,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.0823269844055177,
                    "num_nodes_avg": 1818.3,
                    "path_length_avg": 154.56558140968315,
                    "success_improvement": 0.0,
                    "time_improvement": -11376.438154611575,
                    "length_improvement": 22.74960801803148,
                    "objective_score": -3408.3815247798657
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 1.6773219585418702,
                    "num_nodes_avg": 3093.7,
                    "path_length_avg": 229.59608695928765,
                    "success_improvement": 0.0,
                    "time_improvement": -11284.68168291116,
                    "length_improvement": 23.81225076558798,
                    "objective_score": -3380.64205472023
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.3741002082824707,
                    "num_nodes_avg": 2839.3,
                    "path_length_avg": 117.39619397761064,
                    "success_improvement": 0.0,
                    "time_improvement": -4641.55558133355,
                    "length_improvement": 27.91166483203798,
                    "objective_score": -1386.8843414336575
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This algorithm is a tuned bidirectional RRT*-Connect variant integrating informed sampling, adaptive step size, node rejection, and pruning to enhance efficiency, robustness, and path quality. The planner uses dynamic rewiring and step adjustment, focusing sampling in an ellipsoidal informed set that shrinks as better solutions are found, thus reducing unnecessary exploration and accelerating convergence to high-quality paths.",
          "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points informed by the current best solution, adaptively adjusts stepping near obstacles to improve feasibility, rejects nodes unlikely to improve the solution, rewires neighbors for optimal paths, prunes suboptimal branches, and connects trees to update the best path continuously.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * max_step / dist for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n            diff = np.array(goal) - np.array(start)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff == 0:\n                a1 = np.eye(dim)[0]\n            else:\n                a1 = diff / norm_diff\n            # Rotation matrix C (Householder or SVD)\n            eye = np.eye(dim)\n            if dim == 2:\n                rot_angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(rot_angle), math.sin(rot_angle)\n                C = np.array([[c, -s], [s, c]])\n            else:\n                M = np.outer(a1, eye[0])\n                U, _, Vt = np.linalg.svd(M)\n                C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                scale = random.random() ** (1 / dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + np.array(x_center)\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            \n            # Node rejection pruning\n            est_lower_bound = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if est_lower_bound >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes to new_node for optimality\n            rewire(tree_a, new_node)\n\n            # Try to connect trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                # Valid connection - update best path\n                c_best = connect_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else other_nearest.path_from_root()\n                path_goal = other_nearest.path_from_root() if tree_b is tree_goal else new_node.path_from_root()\n                best_path = path_start + path_goal[::-1]\n                success = True\n\n                # Prune branches that cannot improve solution cost\n                nodes_before_prune = len(nodes)\n                to_prune = []\n                for n in nodes:\n                    if n.cost + math.dist(n.position, goal) >= c_best and n != tree_start[0] and n != tree_goal[0]:\n                        to_prune.append(n)\n                for n in to_prune:\n                    n.valid = False\n                    # Remove edges and children relation\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    if n in tree_start:\n                        tree_start.remove(n)\n                    if n in tree_goal:\n                        tree_goal.remove(n)\n                    if n in nodes:\n                        nodes.remove(n)\n                # No explicit rewire after pruning for efficiency\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3306.556,
          "time_improvement": -11033.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 1.295757794380188,
                    "num_nodes_avg": 1259.2,
                    "path_length_avg": 152.98371614554847,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -13639.548588200494,
                    "length_improvement": 23.54020907295307,
                    "objective_score": -4092.1565346455573
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 2.1762988805770873,
                    "num_nodes_avg": 2610.7,
                    "path_length_avg": 227.01850240669296,
                    "success_improvement": 0.0,
                    "time_improvement": -14671.445563012072,
                    "length_improvement": 24.667580523705332,
                    "objective_score": -4396.500152798881
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 1.4169222593307496,
                    "num_nodes_avg": 2154.6,
                    "path_length_avg": 115.74836709490107,
                    "success_improvement": 0.0,
                    "time_improvement": -4789.320012143081,
                    "length_improvement": 28.923529804783183,
                    "objective_score": -1431.0112976819676
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm is an enhanced RRT* variant combining adaptive informed sampling and dynamic path smoothing through shortcutting for improved convergence speed, path quality, and smoothness. It incrementally builds a tree rooted at the start, performs rewiring to optimize cost locally, and applies informed sampling within an ellipsoidal domain after an initial solution is found to focus search efficiently. Path shortcutting post-processing reduces unnecessary detours to improve smoothness.",
          "planning_mechanism": "The planner starts from the start position, incrementally samples nodes in the state space, initially uniformly and later within an informed ellipsoid based on the best path cost discovered. It extends nearest tree nodes toward samples, adds collision-free nodes, and rewires locally for better paths. After reaching the goal within iteration limits, it extracts the best path and improves it by shortcutting over the path segments, all while maintaining collision and boundary checks.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        goal_node = None\n\n        def sample_unit_ball(dim):\n            while True:\n                vec = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(vec)\n                if norm > 1e-6:\n                    return vec / norm * (random.random() ** (1.0 / dim))\n\n        def informed_sample():\n            if best_cost == float(\"inf\"):\n                # Uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            dim = len(start)\n            c_best = best_cost\n            L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n            L = np.diag(L_diag)\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            a1 = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n            for _ in range(100):  # Limit internal attempts to avoid infinite loops\n                x_ball = sample_unit_ball(dim)\n                x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback uniform sample if no valid sample found\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            x_rand = informed_sample()\n\n            # Find nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            # Collision & bounds check\n            if any(x_new_pos[d] < 0 or x_new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and choose best parent from near nodes (RRT* rewiring)\n            x_new = Node(x_new_pos)\n            near_radius = min(50.0, self.step_size * math.sqrt(math.log(len(tree) + 1) / (len(tree) + 1)))  # Adaptive radius\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= near_radius]\n\n            # Choose best parent\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes if better path found through x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    # Remove old edge\n                    if n.parent:\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                        n.parent.remove_child(n)\n                    # Add new edge\n                    x_new.add_child(n)\n                    n.cost = alt_cost\n                    n.parent = x_new\n                    edges.append((x_new, n))\n\n            # Check goal proximity and connect\n            if math.dist(x_new.position, goal) <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                    temp_goal = Node(goal, parent=x_new, cost=x_new.cost + math.dist(x_new.position, goal))\n                    x_new.add_child(temp_goal)\n                    nodes.append(temp_goal)\n                    edges.append((x_new, temp_goal))\n                    if temp_goal.cost < best_cost:\n                        best_cost = temp_goal.cost\n                        goal_node = temp_goal\n                        success_state = True\n\n        # If solution found, extract and shortcut path\n        if success_state and goal_node:\n            path = goal_node.path_from_root()\n\n            def shortcut_path(path):\n                if len(path) <= 2:\n                    return path\n                shortened_path = [path[0]]\n                idx = 0\n                while idx < len(path) -1:\n                    next_idx = len(path) -1\n                    # Search for farthest reachable node without obstacles in between\n                    for j in range(len(path)-1, idx, -1):\n                        if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                            next_idx = j\n                            break\n                    shortened_path.append(path[next_idx])\n                    idx = next_idx\n                return shortened_path\n\n            extracted_path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 3757.44651,
          "time_improvement": -12526.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 1.4761212587356567,
                    "num_nodes_avg": 3219.4,
                    "path_length_avg": 173.84918578844727,
                    "success_improvement": 0.0,
                    "time_improvement": -15552.029912099079,
                    "length_improvement": 13.11184789382695,
                    "objective_score": -4662.986604050958
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 2.0650195598602297,
                    "num_nodes_avg": 4242.8,
                    "path_length_avg": 244.07518062754949,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -13916.146535416123,
                    "length_improvement": 19.007597636919,
                    "objective_score": -4181.042441097453
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 2.378909683227539,
                    "num_nodes_avg": 4666.3,
                    "path_length_avg": 127.5641544999296,
                    "success_improvement": 0.0,
                    "time_improvement": -8108.813606174215,
                    "length_improvement": 21.6679245430868,
                    "objective_score": -2428.310496943647
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner is an enhanced bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighbor radius scaling based on the number of nodes, informed sample biasing towards an ellipse defined by the current best path (Informed RRT* concept), and efficient rewiring for local cost optimization. These improvements aim to minimize path length, improve planning speed, increase success rate, and yield smoother and shorter paths by focusing sampling in promising areas and continuously optimizing the tree structure.",
          "planning_mechanism": "The planner grows two trees from start and goal positions alternatively, incorporating goal biasing and sampling within an informed subset (ellipse) once an initial solution is found to focus the search. New nodes are added by steering towards sampled points and rewired locally to reduce path costs. Trees attempt connection upon each extension. Path smoothing is applied at the end to improve smoothness. Dynamic neighbor radius adapts to node density, enhancing rewiring efficiency and convergence speed.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # Base radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Data holders\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Current best cost and node pair to guide informed sampling\n        best_path_cost = math.inf\n        best_connection = None  # Tuple[Node, Node]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            # If we have found a path, sample inside ellipsoid between start and goal (Informed RRT*)\n            if success_state and best_path_cost < math.inf:\n                return self._informed_sample(start_position, goal_position, best_path_cost, bounds, is_3d)\n            # Otherwise do normal goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling equally to start or goal to reduce symmetry bias\n                return start_position if random.random() < 0.5 else goal_position\n            # Uniform sampling in free space\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos):\n            n = len(tree) + 1\n            # Adaptive radius: \u03b3 * (log(n)/n)^(1/d)\n            radius = min(self.neighbor_radius_const * (math.log(n) / n) ** (1/dim), self.step_size * 15)\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def valid_new_node(pos):\n            # Check node itself and edge from nearest node to new node\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_valid(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_new_node(new_pos): \n                return None\n            if not edge_valid(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos)\n\n            # Choose best parent minimizing total cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate < min_cost:\n                    if edge_valid(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_through_new < neighbor.cost and edge_valid(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            current_node = nearest_node\n\n            while True:\n                new_pos = steer(current_node.position, node.position)\n                if not valid_new_node(new_pos):\n                    return None\n                if not edge_valid(current_node.position, new_pos):\n                    return None\n\n                new_cost = current_node.cost + dist(current_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = current_node\n                new_node.cost = new_cost\n                current_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        # Main loop: alternate tree growth\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found; check if better than previous best\n                total_cost = new_node_start.cost + new_node_goal.cost + dist(new_node_start.position, new_node_goal.position)\n                if total_cost < best_path_cost:\n                    success_state = True\n                    best_path_cost = total_cost\n                    best_connection = (new_node_start, new_node_goal)\n\n                # Swap trees to continue improving\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        # Extract the best path found\n        if success_state and best_connection:\n            path_start = best_connection[0].path_from_root()\n            path_goal = best_connection[1].path_from_root()\n            # Merge paths; avoid duplication\n            extracted_path = path_start + path_goal[::-1][1:]\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, cost_best, bounds, is_3d):\n        # Sample within prolate hyperspheroid (ellipse) defined by start, goal, and cost_best (Informed RRT*)\n        # Reference: Gammell et al. 2014\n        import random\n        import math\n\n        dim = len(start)\n        c_min = math.dist(start, goal)\n        if cost_best == math.inf:\n            # No solution found yet; uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Center and unit vector from start to goal\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        unit_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n        # Transformation matrix: rotation aligning x-axis to unit_vec\n        # For 2D and 3D: compute rotation matrix to align first axis with unit_vec\n        def compute_rotation():\n            import numpy as np\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            u = np.array(unit_vec)\n            if np.allclose(u, e1):\n                return np.eye(dim)\n            v = np.cross(e1, u) if dim == 3 else np.array([-u[1], u[0]])\n            s = np.linalg.norm(v)\n            c = np.dot(e1, u)\n            if s == 0:  # vectors aligned/congruent\n                return np.eye(dim)\n            vx = np.array([[0, -v[2], v[1]] if dim ==3 else [0, -v[1]],\n                           [v[2], 0, -v[0]] if dim ==3 else [v[1], 0],\n                           [-v[1], v[0], 0] if dim ==3 else [0, 0]], dtype=float)[:dim,:dim]\n            R = np.eye(dim) + vx + vx @ vx * ((1 - c) / (s ** 2))\n            return R\n\n        # For 2D only implementation without numpy to reduce dependency:\n        if dim == 2:\n            import math as m\n            angle = m.atan2(unit_vec[1], unit_vec[0])\n            cos_a = m.cos(angle)\n            sin_a = m.sin(angle)\n\n            # Radii of ellipsoid axes\n            r1 = cost_best / 2.0  # sum of distances / 2\n            r2 = m.sqrt(r1 ** 2 - (c_min / 2) ** 2)\n            while True:\n                # Sample random point in unit circle\n                r = m.sqrt(random.uniform(0, 1))\n                theta = random.uniform(0, 2*m.pi)\n                x_ball = r * m.cos(theta)\n                y_ball = r * m.sin(theta)\n                # Scale to ellipsoid\n                x = x_ball * r1\n                y = y_ball * r2\n                # Rotate point to align with start-goal\n                sample_x = cos_a * x - sin_a * y + center[0]\n                sample_y = sin_a * x + cos_a * y + center[1]\n                # Clamp to bounds always\n                sample_x = max(0.0, min(bounds[0], sample_x))\n                sample_y = max(0.0, min(bounds[1], sample_y))\n                if not self._is_in_obstacle((sample_x, sample_y), [], False):\n                    return (sample_x, sample_y)\n        else:\n            # For 3D, fallback to uniform random sampling in bounds during informed sampling,\n            # (to avoid numpy dependency and complex rotation)\n            return tuple(random.uniform(0, bounds[d]) for d in range(3))\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        # Shortcut smoothing by attempting to connect farther points when no obstacle\n        import math\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i +1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -=1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 6191.27151,
          "time_improvement": -20629.0,
          "length_improvement": 28.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 2.7585493087768556,
                    "num_nodes_avg": 6361.5,
                    "path_length_avg": 150.04089932645945,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -29150.236753556357,
                    "length_improvement": 25.011000634259318,
                    "objective_score": -8745.068825940056
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 3.1104052782058718,
                    "num_nodes_avg": 7207.8,
                    "path_length_avg": 229.79034029393242,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -21011.614151885336,
                    "length_improvement": 23.74779093727005,
                    "objective_score": -6308.734687378147
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 3.4266282081604005,
                    "num_nodes_avg": 7256.0,
                    "path_length_avg": 103.98116482458965,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -11724.136265772226,
                    "length_improvement": 36.1493008669455,
                    "objective_score": -3520.0110195582783
               }
          ],
          "success_rate": 1.0
     }
]