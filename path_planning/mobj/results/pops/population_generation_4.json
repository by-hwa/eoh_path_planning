[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.708512676293243,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0016797542572021484,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 82.1887506035762,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 27.56608404471968
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008045697212219238,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 45.39050704503417,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 0.27572040411595267
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0035561323165893555,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 87.72898880878513,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 22.283733580044093
               }
          ]
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a simplified, unified bidirectional RRT* planner that balances exploration efficiency and path quality. It grows two trees from the start and goal positions alternately, samples points with adaptive goal biasing, extends nearest nodes towards samples using a fixed step size, and employs local rewiring around new nodes to improve path cost and smoothness. Rigorous collision and edge feasibility checks ensure safety. Upon connection of the trees, the shortest path is reconstructed by merging paths from both connected nodes. The planner avoids excessive complexity while maintaining robustness, smoothness, and efficient convergence.",
          "planning_mechanism": "The planner alternates growth between start and goal trees, samples points with goal bias to encourage connections, extends the nearest node towards samples with a capped step size, rewires neighbors within a radius inversely related to tree size to reduce path cost, and verifies collision-free conditions for nodes and edges. When the trees connect, the optimal path is extracted by backtracking and merged. This approach balances exploration and exploitation to find shorter, smoother feasible paths efficiently.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Parent node or None\n        self.cost = cost                      # Cost from root\n        self.children = []\n        self.valid = True                     # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=20.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes, extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -15.03871,
          "time_improvement": 44.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0039825916290283205,
                    "num_nodes_avg": 76.2,
                    "path_length_avg": 172.59475061003724,
                    "success_improvement": 0.0,
                    "time_improvement": 57.770648626374324,
                    "length_improvement": 13.738802538996584,
                    "objective_score": 20.078955095711613
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.013543009757995605,
                    "num_nodes_avg": 249.1,
                    "path_length_avg": 290.1072272486077,
                    "success_improvement": 0.0,
                    "time_improvement": 8.077960621600676,
                    "length_improvement": 3.732607234605092,
                    "objective_score": 3.169909633401221
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.009406518936157227,
                    "num_nodes_avg": 162.7,
                    "path_length_avg": 149.7826015352379,
                    "success_improvement": 0.0,
                    "time_improvement": 67.54128112795729,
                    "length_improvement": 8.02445960163917,
                    "objective_score": 21.86727625871502
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner combines bidirectional RRT* with adaptive heuristic sampling, dynamic radius rewiring, and node pruning to balance exploration and exploitation. It alternates tree growth between start and goal, uses informed sampling with goal-start bias, applies incremental rewiring within dynamically adjusted radii, and prunes dead-end nodes periodically to enhance efficiency. Collision checks for nodes and edges guarantee safety, while the planner focuses on improving path quality, success rate, and computational speed by maintaining balanced trees and pruning suboptimal branches.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points biased towards them. Each sampled point is used to extend the smaller tree via steering and collision-checked addition of nodes. A dynamic radius, shrinking with node count, determines local neighborhood for rewiring to optimize path costs. After each extension, attempts are made to connect the opposing tree. Periodic pruning removes unproductive nodes, improving search efficiency and aiding smooth, shorter paths. Upon connection, the best path is reconstructed by backtracking and merging the two trees\u2019 paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -11.35589,
          "time_improvement": 30.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004592251777648926,
                    "num_nodes_avg": 80.4,
                    "path_length_avg": 167.45106691181843,
                    "success_improvement": 0.0,
                    "time_improvement": 51.30612626687802,
                    "length_improvement": 16.309566212866937,
                    "objective_score": 18.65375112263679
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018631529808044434,
                    "num_nodes_avg": 213.8,
                    "path_length_avg": 286.29479981745214,
                    "success_improvement": 0.0,
                    "time_improvement": -26.45994112820878,
                    "length_improvement": 4.997699636422811,
                    "objective_score": -6.938442411178071
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010195708274841309,
                    "num_nodes_avg": 119.7,
                    "path_length_avg": 139.18069216669,
                    "success_improvement": 0.0,
                    "time_improvement": 64.81805534645213,
                    "length_improvement": 14.53467062369323,
                    "objective_score": 22.352350728674285
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
          "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -9.55661,
          "time_improvement": 23.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053680181503295895,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 168.24816019864105,
                    "success_improvement": 0.0,
                    "time_improvement": 43.08029901986809,
                    "length_improvement": 15.911186649372569,
                    "objective_score": 16.106327035834944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01864187717437744,
                    "num_nodes_avg": 256.6,
                    "path_length_avg": 287.4569206517525,
                    "success_improvement": 0.0,
                    "time_improvement": -26.530173006684965,
                    "length_improvement": 4.612068627304342,
                    "objective_score": -7.036638176544621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013377833366394042,
                    "num_nodes_avg": 183.6,
                    "path_length_avg": 134.76801275171147,
                    "success_improvement": 0.0,
                    "time_improvement": 53.83761673112537,
                    "length_improvement": 17.24432160877036,
                    "objective_score": 19.600149341091683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid bidirectional RRT* planner integrates adaptive goal bias sampling from both start and goal, dynamic rewiring with node neighborhood radius based on logarithmic scaling, and incremental path cost optimization to achieve efficient and robust path planning. It balances exploration by alternating growth on the smaller tree, performs strict collision and edge feasibility checks before node/edge addition, and incorporates local rewiring for path quality and smoothness. The algorithm adaptively adjusts sampling and rewiring radii to reduce search space and improve convergence speed. On connection, the optimal path is reconstructed by merging the shortest cost paths from both trees, ensuring shorter, smoother, and collision-free paths.",
          "planning_mechanism": "The planner alternates extension steps between start and goal trees, always growing the smaller tree to balance exploration. Sampling uses a combined goal bias for both start and goal to encourage fast connection. New nodes are created via a steering function capped by a fixed step size, with explicit collision and edge checks before insertion. Rewiring is done dynamically within a neighborhood radius that shrinks logarithmically with tree size, incrementally improving path cost and smoothness. When the two trees connect via feasible edges, the optimal path is extracted by backtracking from connection nodes and merging them, resulting in efficient convergence to high-quality paths.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample either start or goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            r = random.random()\n            # Sample with combined goal bias to start or goal to enhance connectivity\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.5 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            # Shrink radius logarithmically for efficient rewiring as tree grows\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            # Check if node position is valid: inside map bounds & not in obstacle\n            for d, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_target = distance(new_pos, node.position)\n                if dist_to_target <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_target\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -8.93552,
          "time_improvement": 21.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.003909516334533692,
                    "num_nodes_avg": 71.2,
                    "path_length_avg": 171.18510106638226,
                    "success_improvement": 0.0,
                    "time_improvement": 58.545501429622384,
                    "length_improvement": 14.443331832073264,
                    "objective_score": 20.452316795301368
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01824326515197754,
                    "num_nodes_avg": 269.4,
                    "path_length_avg": 270.5479880821555,
                    "success_improvement": 0.0,
                    "time_improvement": -23.824627439303637,
                    "length_improvement": 10.22302450854493,
                    "objective_score": -5.102783330082104
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020744752883911134,
                    "num_nodes_avg": 249.0,
                    "path_length_avg": 138.9767873393387,
                    "success_improvement": 0.0,
                    "time_improvement": 28.41686637756919,
                    "length_improvement": 14.659880471120387,
                    "objective_score": 11.457036007494834
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.68311,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.007598710060119629,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 161.4550453822259,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 19.42719038120736,
                    "length_improvement": 19.306320142615537,
                    "objective_score": 4.689421142885316
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.013997030258178712,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 259.63765747646863,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 4.9963346727016456,
                    "length_improvement": 13.8434413164237,
                    "objective_score": -0.7324113349047652
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.012314391136169434,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 131.58176022985964,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.507196585457756,
                    "length_improvement": 19.200872600268642,
                    "objective_score": 16.092333495691054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined bidirectional RRT planner integrating adaptive step sizing near obstacles and frontier-biased sampling for enhanced exploration efficiency. It alternately grows two trees from start and goal, performs strict collision and edge checks, and applies path shortcut smoothing for improved path quality and smoothness.",
          "planning_mechanism": "The planner samples points biased towards frontiers near obstacles with adaptive step sizes that shrink near obstacles to improve precision. Two trees grow toward each other's new nodes while avoiding collisions. Once connected, the concatenated path is shortcut-smoothed iteratively to reduce unnecessary waypoints and produce a shorter, smoother path before returning the final plan.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: list = []\n        nodes: list = []\n        edges: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for i in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased near frontiers\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            cost_a = nearest_a.cost + math.dist(nearest_a.position, new_pos_a)\n            new_node_a = Node(new_pos_a, parent=nearest_a, cost=cost_a)\n            nearest_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_a, new_node_a))\n\n            # Try connecting tree_b to new_node_a\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos_a))\n            connected = False\n            current_node_b = nearest_b\n\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = current_node_b.cost + math.dist(current_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=current_node_b, cost=cost_b)\n                current_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((current_node_b, new_node_b))\n                current_node_b = new_node_b\n\n                if math.dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist <= query_radius:\n                return self.base_step_size * 0.5\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": -6.65571,
          "time_improvement": 8.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.005708551406860352,
                    "num_nodes_avg": 99.5,
                    "path_length_avg": 159.4405888448925,
                    "success_improvement": 0.0,
                    "time_improvement": 39.46945967605338,
                    "length_improvement": 20.313126158032215,
                    "objective_score": 15.903463134422458
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02300090789794922,
                    "num_nodes_avg": 396.3,
                    "path_length_avg": 242.17424129074578,
                    "success_improvement": 0.0,
                    "time_improvement": -56.11672732392269,
                    "length_improvement": 19.638393620510445,
                    "objective_score": -12.907339473074716
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01748318672180176,
                    "num_nodes_avg": 311.6,
                    "path_length_avg": 121.5714299751307,
                    "success_improvement": 0.0,
                    "time_improvement": 39.67142928835457,
                    "length_improvement": 25.34781840911247,
                    "objective_score": 16.970992468328866
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with adaptive rewiring and dynamic radius adjustment, while incorporating heuristic informed sampling towards the goal and enhanced collision checks. It dynamically balances exploration and exploitation by alternating tree expansions, improves path quality via local rewiring around new nodes, and enforces strict collision-free checks for nodes and edges. The method prunes suboptimal nodes iteratively to enhance planning efficiency, leading to smoother and shorter paths with higher success rates and reduced search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling free points biased towards the goal. Each extension uses a steering function with a fixed step size, adding nodes only after thorough collision checks. Rewiring is performed locally with a dynamically shrinking radius to optimize path costs incrementally. The trees attempt to connect after each extension, and upon success, the optimal path is constructed by backtracking. This blend of bidirectional search, incremental optimization, adaptive sampling, and pruning yields efficient, robust, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Heuristic guided sampling with goal bias and start bias for efficient tree growth\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search with linear scan (can be improved with spatial indexing if needed)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes+1) / (n_nodes+1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Rewire radius scales inversely with node count\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            # Add edge record\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Rewire neighbors around new_node for local path cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # epsilon to avoid floating error loops\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge feasibility check before adding terminal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees with start and goal roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Merge paths, avoid duplicated connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Optional pruning of nodes with no children and higher cost to improve efficiency\n            if itr % 250 == 0 and len(nodes) > 100:\n                pruned = []\n                for node in nodes[:]:\n                    if not node.children and node is not start_root and node is not goal_root:\n                        try:\n                            node.parent.children.remove(node)\n                            nodes.remove(node)\n                            # Remove edges related to node\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            pruned.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.15402,
          "time_improvement": 15.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004810810089111328,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 182.51310029888023,
                    "success_improvement": 0.0,
                    "time_improvement": 48.98864644717982,
                    "length_improvement": 8.781706694699151,
                    "objective_score": 16.452935273093775
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02035815715789795,
                    "num_nodes_avg": 178.3,
                    "path_length_avg": 287.3732004707603,
                    "success_improvement": 0.0,
                    "time_improvement": -38.17927900665584,
                    "length_improvement": 4.639849815737334,
                    "objective_score": -10.525813738849285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01868715286254883,
                    "num_nodes_avg": 139.1,
                    "path_length_avg": 147.54383101693634,
                    "success_improvement": 0.0,
                    "time_improvement": 35.516948894576494,
                    "length_improvement": 9.399199565681393,
                    "objective_score": 12.534924581509227
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.6829227155522615,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011509346961975097,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -22.03919010817601,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -4.1314597250548815
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016402530670166015,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -11.330797002361011,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -0.5611573357999351
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010229659080505372,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 64.70090258632817,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 21.741385207511602
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards the goal and start to balance exploration and exploitation. It uses a dynamically shrinking radius for rewiring to optimize path costs continually. The algorithm grows two trees from start and goal, alternately extending the smaller tree for balanced growth. After each extension, the planner attempts to connect the two trees to form a complete path. Dead-end nodes are periodically pruned to enhance efficiency. Additionally, a path smoothing and shortcut procedure is applied post path extraction to reduce path length and improve smoothness. Collision checks ensure safety. This results in improved planning speed, higher success rates, and shorter, smoother paths.",
          "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal positions. It samples points within the map bounds with bias towards the goal and start, steering and extending the smaller tree first. A dynamic radius is used to find neighbors to rewire and reduce path cost locally. After extension, attempts are made to connect the opposing tree to complete a path. Periodic pruning removes dead nodes. Upon successful connection, the path is extracted and post-processed via shortcut smoothing to minimize length and enhance smoothness.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                # Post-process with smoothing\n                smoothed_path = path_smoothing(raw_path)\n                # Use the shorter path among raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.61374,
          "time_improvement": 7.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008043766021728516,
                    "num_nodes_avg": 85.5,
                    "path_length_avg": 163.6645421149303,
                    "success_improvement": 0.0,
                    "time_improvement": 14.708046081621204,
                    "length_improvement": 18.202034912180657,
                    "objective_score": 8.052820806922492
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.018214941024780273,
                    "num_nodes_avg": 211.3,
                    "path_length_avg": 250.73203836217277,
                    "success_improvement": 0.0,
                    "time_improvement": -23.632379808820406,
                    "length_improvement": 16.798627029050724,
                    "objective_score": -3.7299885368359766
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.020520853996276855,
                    "num_nodes_avg": 169.4,
                    "path_length_avg": 132.2218958906299,
                    "success_improvement": 0.0,
                    "time_improvement": 29.189465794931664,
                    "length_improvement": 18.80779074213471,
                    "objective_score": 12.518397886906442
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of enhanced bidirectional RRT* with adaptive goal biasing and incremental rewiring along with a dynamic radius and balanced tree growth. It integrates dynamic radius rewiring for local cost improvements, adaptive sampling bias toward both start and goal, and smart tree balancing to improve convergence speed, robustness, and path quality. The algorithm also incorporates rewiring from both trees when extending and connecting nodes, enhancing overall path smoothness and shortness while preserving collision checks and pruning possible redundant edges.",
          "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with adaptive biasing favoring goal and start to promote exploration. It extends the smaller tree first toward sampled points, rewiring neighbors within a dynamically shrinking radius to optimize costs. When a new node is created in one tree, it attempts to connect and rewire the opposite tree toward it. Path extraction occurs at the first successful connection by merging both trees' paths. Rigorous obstacle and edge collision checks ensure safe expansions, while adaptive radius and rewiring improve convergence to optimal, smooth paths effectively across 2D or 3D environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive goal biasing: bias toward goal 70% and start 10% when goal_sample_rate applies\n            if random.random() < self.goal_sample_rate:\n                p = goal_position if random.random() < 0.7 else start_position\n                # Verify p does not lie inside obstacle (rare but safe)\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Uniform random sample in bounds and free space\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Dynamic radius shrinking with node count, minimum radius enforced\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if within step_size to target_node\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final edge feasibility check\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Main loop, balanced bidirectional growth alternating tree extension attempts\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            # On successful extension on one tree, attempt connection & rewiring on the other\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found feasible connection: reconstruct path\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                # Merge paths without duplicating connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -5.55242,
          "time_improvement": 10.0,
          "length_improvement": 12.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0072095394134521484,
                    "num_nodes_avg": 92.4,
                    "path_length_avg": 171.03662888960565,
                    "success_improvement": 0.0,
                    "time_improvement": 23.55375557122958,
                    "length_improvement": 14.517536798986361,
                    "objective_score": 9.969634031166146
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.014955592155456544,
                    "num_nodes_avg": 238.0,
                    "path_length_avg": 282.8514380030673,
                    "success_improvement": 0.0,
                    "time_improvement": -1.5098235626334042,
                    "length_improvement": 6.140323580550488,
                    "objective_score": 0.7751176473200765
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026245260238647462,
                    "num_nodes_avg": 258.6,
                    "path_length_avg": 137.75874664227172,
                    "success_improvement": 0.0,
                    "time_improvement": 9.436473833552576,
                    "length_improvement": 15.407830835125619,
                    "objective_score": 5.9125083170908965
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* variant with enhanced adaptive sampling and rewiring strategies focusing on minimizing path length and improving convergence speed. It employs dynamic radius calculations, balanced tree growth, and mutual rewiring between trees. Additionally, this version incorporates heuristic-informed sampling bias that adapts over iterations to concentrate exploration around promising areas, employs a decaying radius for finer local optimizations, and implements a path shortcutting smoothing post-processing step. The planner rigorously checks for collisions at nodes and edges while maintaining efficient rewiring to produce shorter, smoother, and more robust paths efficiently in both 2D and 3D environments.",
          "planning_mechanism": "The planner alternately grows and rewires two trees rooted at start and goal positions, sampling points using an adaptive heuristic bias that shifts towards promising regions as iterations increase. It always extends the smaller tree first to maintain balance and dynamically adjusts the rewiring radius decreasing over time for refined local improvements. Mutual tree connection attempts and rewiring enhance path quality and smoothness. Upon finding a connection, a shortcutting process smooths the path by removing unnecessary nodes, thereby minimizing path length and improving traversal efficiency.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node({self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_by_nodes(n_nodes, itr):\n            # Dynamic radius shrinking with node count & iteration progress; radius shrinks faster as iteration count increases\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            # Decay radius as iter increases (slow exponential decay, min bound enforced)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            return (self._is_in_obstacle(pos, obstacles, is_3d) == False)\n\n        def is_free_edge(p1, p2):\n            return (self._is_edge_in_obstacle(p1, p2, obstacles, is_3d) == False)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic informed sampling:\n            # - Early: higher goal bias (goal: 70%, start: 10%)\n            # - Later: increase uniform exploration and biased sampling around best known connection nodes\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    # Sample near best connection region for better local refinement (after some progress)\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        # Pick random midpoint from recent connection attempts or random nodes\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i]+mid_from_goal[i])/2 for i in range(dim))\n                        # Sample in small ball around mid\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):  # try up to 5 samples in this biased region\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sample in free space\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            # fallback to start if stuck\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing nodes where direct connection is collision-free\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                # Search for farthest reachable node from current shortened[-1]\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n\n            rand_point = adaptive_sample(itr)\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Post-process: shortcutting for smoother path\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.53314,
          "time_improvement": 0.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.010382628440856934,
                    "num_nodes_avg": 93.1,
                    "path_length_avg": 159.97272222093744,
                    "success_improvement": 0.0,
                    "time_improvement": -10.092046951276549,
                    "length_improvement": 20.047171011283186,
                    "objective_score": 0.9818201168736733
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020576214790344237,
                    "num_nodes_avg": 272.6,
                    "path_length_avg": 237.41024721166414,
                    "success_improvement": 0.0,
                    "time_improvement": -39.659326842009,
                    "length_improvement": 21.219248029042483,
                    "objective_score": -7.653948446794204
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014211153984069825,
                    "num_nodes_avg": 201.5,
                    "path_length_avg": 122.2769154763927,
                    "success_improvement": 0.0,
                    "time_improvement": 50.96210881549838,
                    "length_improvement": 24.914607812175976,
                    "objective_score": 20.27155420708471
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates a bidirectional RRT* algorithm with adaptive, informed sampling and dynamic radius rewiring, combined with efficient tree balancing, dead-end pruning, and iterative shortcut smoothing. It balances exploration and exploitation to improve planning speed, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
          "planning_mechanism": "The planner grows two trees rooted at start and goal positions, always extending the smaller tree. Sampling is adaptively biased towards the start and goal to guide growth. Each extension steers towards samples within a fixed step size and performs rewiring with a neighbor radius that shrinks as the tree grows, optimizing path costs. Between iterations, dead-end pruning removes unnecessary nodes to reduce complexity. Upon connection of trees, the resultant path is shortcut-smoothed iteratively, ensuring collision-free and shorter paths. Collision and edge feasibility checks are rigorously enforced throughout.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random, math\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -4.43558,
          "time_improvement": 2.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.008450722694396973,
                    "num_nodes_avg": 97.5,
                    "path_length_avg": 167.3582062549438,
                    "success_improvement": 0.0,
                    "time_improvement": 10.392887028230934,
                    "length_improvement": 16.355977076642965,
                    "objective_score": 6.389061523797873
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020722436904907226,
                    "num_nodes_avg": 196.3,
                    "path_length_avg": 240.72557835123666,
                    "success_improvement": 0.0,
                    "time_improvement": -40.651797143148414,
                    "length_improvement": 20.119108994288037,
                    "objective_score": -8.171717344086916
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.018723511695861818,
                    "num_nodes_avg": 159.8,
                    "path_length_avg": 126.43746692465507,
                    "success_improvement": 0.0,
                    "time_improvement": 35.391486844584186,
                    "length_improvement": 22.35977858710682,
                    "objective_score": 15.08940177079662
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements an optimized bidirectional RRT* variant with adaptive sampling biased toward the goal and border safety checks. It employs a KD-tree to accelerate nearest and neighbor searches, reducing computational time. It integrates early stopping when trees connect, uses a geometric rewiring strategy to improve path quality locally, and performs efficient collision checks on sampled points and edges. Post-processing smoothing refines the final path.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal with adaptive goal bias sampling to speed convergence. Each sampled point is steered toward within a step size limit and validated for collision. Using KD-trees for spatial queries, the planner quickly finds nearest and nearby nodes enabling efficient rewiring to reduce path costs. The trees alternate extensions to balance exploration and exploitation, attempting connection at each iteration for early success. Finally, the path is smoothed by shortcutting while ensuring collision-free transitions.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        from bisect import bisect_left, bisect_right\n        from collections import deque\n\n        bounds = map.size                # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal         # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles        # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def build(self):\n                # KD-Tree is approximated by sorted lists per dimension for fast range queries\n                self.sorted_by_dim = [sorted(self.points, key=lambda p: p[d]) for d in range(dim)]\n\n            def insert(self, node: Node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                # Brute-force near neighbors due to moderate problem size and dimensionality\n                neighbors = []\n                r_sq = radius * radius\n                for node in self.nodes:\n                    # Compare squared dist for efficiency\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # With goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Sample extended bounds - slight buffer to avoid border failures\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        # Swap flag to alternate tree growth\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree to extend\n            if tree_flag:\n                new_node = self._extend_bidirectional(tree_start, kd_start, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_goal, kd_goal, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_bidirectional(tree_goal, kd_goal, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_start, kd_start, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    # Note the roles reversed, swap accordingly\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _extend_bidirectional(self, tree: List[Node], kd_tree, point, obstacles, is_3d, nodes, edges, neighbor_radius,\n                              steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n            return None\n\n        if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            if near_node.cost + edge_cost < min_cost:\n                if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = near_node.cost + edge_cost\n                    best_parent = near_node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Try rewiring neighbors for cost improvement\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            edge_cost = math.dist(new_node.position, near_node.position)\n            cost_through_new = new_node.cost + edge_cost\n            if cost_through_new < near_node.cost:\n                if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n        return new_node\n\n    def _connect_bidirectional(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                               neighbor_radius, steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        curr_node = nearest_node\n        while True:\n            new_pos = steer_fn(curr_node.position, target_pos)\n            if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n                return None\n\n            if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                if near_node.cost + edge_cost < min_cost:\n                    if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = near_node.cost + edge_cost\n                        best_parent = near_node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors similarly\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            curr_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _out_of_bounds(self, pos, origin, obstacles, is_3d):\n        # Safety check to not generate nodes past map bounds (origin = start pos's bounds reference)\n        # No explicit bounds checks in original, so add a generic clipping following common sense\n        for d, val in enumerate(pos):\n            if val < 0:\n                return True\n        return False",
          "objective": -3.96181,
          "time_improvement": -2.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009483003616333007,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 160.3701129930091,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5528884439489358,
                    "length_improvement": 19.848558922921917,
                    "objective_score": 3.8038452513997028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023026371002197267,
                    "num_nodes_avg": 276.7,
                    "path_length_avg": 231.60591841983734,
                    "success_improvement": 0.0,
                    "time_improvement": -56.289556001831855,
                    "length_improvement": 23.145320691353117,
                    "objective_score": -12.25780266227893
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014002847671508788,
                    "num_nodes_avg": 202.7,
                    "path_length_avg": 123.48043402619813,
                    "success_improvement": 0.0,
                    "time_improvement": 51.68090352420842,
                    "length_improvement": 24.17557492141821,
                    "objective_score": 20.339386041546167
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -2.8383427428807892,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007564902305603027,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 19.785670405679053,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 10.167469981989559
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021586298942565918,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -46.51518804828198,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -18.48783628573898
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.009180307388305664,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.32186075440126,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 16.83539453239179
               }
          ]
     },
     {
          "operator": "m2",
          "algorithm_description": "This planner enhances bidirectional RRT* with carefully tuned parameters, adaptive rewiring radius, goal-start informed sampling, and periodic pruning of dead-end nodes. It balances exploration and exploitation by growing the smaller tree first, incrementally rewiring neighbors within a shrinking radius, and enforcing strict collision checks on nodes and edges. These augmentations aim to improve planning efficiency, path quality, robustness, and success rate, while reducing search time and producing smoother, shorter paths.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, sampling points with bias towards these goals. It extends the smaller tree toward sampled points using a step-size-limited steering function and collision checks, rewiring neighbors locally for cost improvement. After each extension, it attempts to connect the opposing tree with incremental edge expansions. Periodically, dead-end nodes are pruned to enhance efficiency. Upon successful connection, the final path is reconstructed by merging the two tree paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0, radius_min: float=4.0,\n                 prune_interval: int=200, prune_threshold: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check map bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                # Check map bounds\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first to maintain balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.75):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.68287,
          "time_improvement": 14.0,
          "length_improvement": 9.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.0057315826416015625,
                    "num_nodes_avg": 66.3,
                    "path_length_avg": 171.46445400062805,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 39.225248319466886,
                    "length_improvement": 14.303713920537051,
                    "objective_score": 9.628317279947478
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01809353828430176,
                    "num_nodes_avg": 203.1,
                    "path_length_avg": 295.5878361067072,
                    "success_improvement": 0.0,
                    "time_improvement": -22.808368921261003,
                    "length_improvement": 1.9139557982379714,
                    "objective_score": -6.459719516730707
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.02160623073577881,
                    "num_nodes_avg": 144.6,
                    "path_length_avg": 144.55616086985188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 25.4441973596203,
                    "length_improvement": 11.233809016268987,
                    "objective_score": 4.880021011139888
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm enhances the bidirectional RRT by integrating a heuristic-based goal biasing and nearest neighbor optimization to improve efficiency and path quality. It grows two trees from start and goal alternately, extends towards sampled points with goal bias to encourage tree connection, performs rigorous collision and edge checks, and once trees connect, extracts and smooths the path for improved smoothness and shorter path length.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal. At each iteration, it samples points with goal biasing, extends one tree towards the sample, attempts connection to the other tree quickly, and upon successful connection, reconstructs and smooths the path. Rigorous collision checks and edge validity checks ensure robustness. Path smoothing via shortcutting reduces path length and improves smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal to bias growth\n        self.smoothing_iter = smoothing_iter      # Number of path smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def can_connect(node_from, node_to):\n            if self._is_edge_in_obstacle(node_from.position, node_to.position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(node_to.position, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, new_node.position)\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                next_node = Node(new_pos, parent=nearest_node,\n                                cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(new_pos, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            import random\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate tree growth\n        for iter in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Extend start tree towards random point\n            nearest_start = nearest(tree_start, rand_point)\n            new_pos_start = steer(nearest_start.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_start, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d)):\n                new_node_start = Node(new_pos_start, parent=nearest_start,\n                                     cost=nearest_start.cost + math.dist(nearest_start.position, new_pos_start))\n                nearest_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_start, new_node_start))\n\n                # Try connect goal tree to new start node\n                new_node_goal = connect_trees(new_node_start, tree_goal)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap roles: Extend goal tree towards random point\n            rand_point = sample_point()\n            nearest_goal = nearest(tree_goal, rand_point)\n            new_pos_goal = steer(nearest_goal.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_goal, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d)):\n                new_node_goal = Node(new_pos_goal, parent=nearest_goal,\n                                    cost=nearest_goal.cost + math.dist(nearest_goal.position, new_pos_goal))\n                nearest_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_goal, new_node_goal))\n\n                # Try connect start tree to new goal node\n                new_node_start = connect_trees(new_node_goal, tree_start)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.18266,
          "time_improvement": 9.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009535980224609376,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 170.74762170972932,
                    "success_improvement": 0.0,
                    "time_improvement": -1.1146251254553718,
                    "length_improvement": 14.661979809696968,
                    "objective_score": 2.598008424302782
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.015331578254699708,
                    "num_nodes_avg": 255.3,
                    "path_length_avg": 231.82982015577954,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4.06179758007486,
                    "length_improvement": 23.07102252043464,
                    "objective_score": -1.6043347699355293
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.01953170299530029,
                    "num_nodes_avg": 281.5,
                    "path_length_avg": 115.83970390651845,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 32.602691716296164,
                    "length_improvement": 28.867443500228006,
                    "objective_score": 5.554296214934452
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This planner implements a simplified bidirectional RRT* that incrementally grows trees from start and goal positions, using adaptive goal biasing and rewiring in a reduced and generalized manner. It balances exploration efficiency and path quality by always extending the smaller tree first, verifying collision-free nodes and edges strictly, and smoothing the final path with shortcut attempts. The adaptive neighborhood radius for rewiring adjusts with the size of the trees to optimize connections. This approach aims to improve planning success, path smoothness, and computational efficiency while maintaining robustness in arbitrary 2D or 3D environments.",
          "planning_mechanism": "The planner initializes two trees at start and goal. At each iteration, it samples points biased towards the goal, extends the smaller tree towards the sample while avoiding obstacles, and rewires locally to reduce path cost. Then it attempts connecting the other tree to the newly added node for path completion. On success, the path is extracted and smoothed using random shortcutting to reduce unnecessary waypoints and improve smoothness and length. Collision checks for nodes and edges are enforced throughout, and node expansions respect map bounds.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start: float = 0.1, goal_sample_rate_end: float = 0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(iteration: int) -> Tuple[float, ...]:\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter\n                         + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # Bias towards goal mostly, sometimes towards start to aid connection\n                return goal_position if random.random() < 0.85 else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-6 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, target_node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_trials=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=150)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.98626,
          "time_improvement": -7.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0128068208694458,
                    "num_nodes_avg": 87.7,
                    "path_length_avg": 163.7379014655171,
                    "success_improvement": 0.0,
                    "time_improvement": -35.79693547612365,
                    "length_improvement": 18.165370613850538,
                    "objective_score": -7.1060065200669875
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.021283459663391114,
                    "num_nodes_avg": 248.8,
                    "path_length_avg": 242.37439342685926,
                    "success_improvement": 0.0,
                    "time_improvement": -44.45969191831741,
                    "length_improvement": 19.57197637029986,
                    "objective_score": -9.42351230143525
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.011657309532165528,
                    "num_nodes_avg": 151.5,
                    "path_length_avg": 125.7536583199623,
                    "success_improvement": 0.0,
                    "time_improvement": 59.77456320695808,
                    "length_improvement": 22.779678263711585,
                    "objective_score": 22.48830461482974
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling that biases samples towards start and goal positions to balance exploration and exploitation effectively. It grows two trees from start and goal, always extending the smaller tree to maintain balanced growth. Using a dynamically shrinking neighbor radius based on tree size, it rewires nodes locally to reduce path cost continually. After each extension, attempts are made to connect the opposing tree, forming a feasible complete path. Dead-end nodes are periodically pruned to maintain computational efficiency. A post-processing shortcut smoothing iteratively reduces unnecessary turns and shortens path length while ensuring collision-free shortcuts. These components work in synergy to improve planning speed, success rate, path optimality, and path smoothness.",
          "planning_mechanism": "The planner alternates growth between two trees rooted at the start and goal. Sampling is biased towards these roots, with uniform random samples otherwise. For each sample, the smaller tree extends towards it, steering a limited distance per iteration. The rewiring phase locally optimizes branches using neighbors within a radius that shrinks adaptively as the tree grows. Upon successful extension, the opposite tree attempts to connect directly to the new node. Dead ends with no children are pruned periodically to reduce complexity. When a connection is established, the path is extracted and processed with shortcut smoothing to improve quality, ensuring a shorter, collision-free path.",
          "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Adaptive informed sampling biased towards start and goal\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                # shortcut the path segment between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                extracted_path = smoothed if path_length(smoothed) + 1e-12 < path_length(raw_path) else raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.98003,
          "time_improvement": -5.0,
          "length_improvement": 18.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011020708084106445,
                    "num_nodes_avg": 86.9,
                    "path_length_avg": 171.24582246635723,
                    "success_improvement": 0.0,
                    "time_improvement": -16.857915001301944,
                    "length_improvement": 14.412983859989318,
                    "objective_score": -2.1747777283927188
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02063744068145752,
                    "num_nodes_avg": 198.1,
                    "path_length_avg": 244.0987074270916,
                    "success_improvement": 0.0,
                    "time_improvement": -40.074892427093964,
                    "length_improvement": 18.999790648883877,
                    "objective_score": -8.222509598351413
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.017098093032836915,
                    "num_nodes_avg": 167.5,
                    "path_length_avg": 129.97659425030432,
                    "success_improvement": 0.0,
                    "time_improvement": 41.000257505715716,
                    "length_improvement": 20.186541208541094,
                    "objective_score": 16.337385493422936
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner that efficiently explores the space by growing two trees from start and goal positions, incorporating rewiring to optimize path costs continuously. It balances rapid exploration with local path improvements, ensuring high success rates and high-quality, smooth paths.",
          "planning_mechanism": "The planner samples free points within map bounds, extends the nearest nodes in each tree towards these points while ensuring collision avoidance, attempts to connect the two trees, and rewires neighbors to minimize cost. Once connected, the path is extracted and smoothed for optimal navigation performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.31503,
          "time_improvement": -2.0,
          "length_improvement": 27.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009461736679077149,
                    "num_nodes_avg": 68.6,
                    "path_length_avg": 157.90810556621656,
                    "success_improvement": 0.0,
                    "time_improvement": -0.3273847896268319,
                    "length_improvement": 21.079046571256317,
                    "objective_score": 4.1175938773632135
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.017914962768554688,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 217.9828629857762,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -21.596302631429896,
                    "length_improvement": 27.665911372851916,
                    "objective_score": -5.945708514858585
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.024679231643676757,
                    "num_nodes_avg": 299.9,
                    "path_length_avg": 111.38058968744186,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 14.84030943466389,
                    "length_improvement": 31.605608252301014,
                    "objective_score": 5.77321448085937
               }
          ],
          "success_rate": 1.0
     }
]