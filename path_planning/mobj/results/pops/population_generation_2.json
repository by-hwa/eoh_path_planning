[
     {
          "operator": "initial",
          "algorithm_description": "This algorithm grows two trees simultaneously, one from the start position and one from the goal position, and attempts to connect them to find a feasible path. This bidirectional approach accelerates convergence and increases the success rate compared to a single tree RRT.",
          "planning_mechanism": "The planning mechanism involves randomly sampling points within the map bounds, extending each tree towards the sampled points, and attempting to connect the two trees whenever new nodes are added. Collision checks are performed for nodes and edges to ensure safety, and once the two trees connect, the final path is reconstructed by backtracking through the parent nodes of each tree.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_tree(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_trees(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a  # Swap trees\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, point)\n        new_pos = self._steer(nearest_node.position, point)\n        if not self._is_in_obstacle(new_pos, obstacles, is_3d) and            not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n        return None\n\n    def _connect_trees(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        nearest_node = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest_node.position, new_node.position)\n            if not self._is_in_obstacle(new_pos, obstacles, is_3d) and                not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                next_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(next_node)\n                tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(next_node.position, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n            else:\n                return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -16.708512676293243,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0016797542572021484,
                    "num_nodes_avg": 59.1,
                    "path_length_avg": 170.9770888905735,
                    "success_improvement": 0.0,
                    "time_improvement": 82.1887506035762,
                    "length_improvement": 14.547294318234119,
                    "objective_score": 27.56608404471968
               },
               {
                    "map_id": 1,
                    "success_rate": 0.7,
                    "time_avg": 0.008045697212219238,
                    "num_nodes_avg": 195.7,
                    "path_length_avg": 276.36470377614694,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": 45.39050704503417,
                    "length_improvement": 8.292841453028517,
                    "objective_score": 0.27572040411595267
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.0035561323165893555,
                    "num_nodes_avg": 134.2,
                    "path_length_avg": 154.99263582978188,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 87.72898880878513,
                    "length_improvement": 4.825184687042764,
                    "objective_score": 22.283733580044093
               }
          ]
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
          "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -9.55661,
          "time_improvement": 23.0,
          "length_improvement": 13.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0053680181503295895,
                    "num_nodes_avg": 68.2,
                    "path_length_avg": 168.24816019864105,
                    "success_improvement": 0.0,
                    "time_improvement": 43.08029901986809,
                    "length_improvement": 15.911186649372569,
                    "objective_score": 16.106327035834944
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.01864187717437744,
                    "num_nodes_avg": 256.6,
                    "path_length_avg": 287.4569206517525,
                    "success_improvement": 0.0,
                    "time_improvement": -26.530173006684965,
                    "length_improvement": 4.612068627304342,
                    "objective_score": -7.036638176544621
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.013377833366394042,
                    "num_nodes_avg": 183.6,
                    "path_length_avg": 134.76801275171147,
                    "success_improvement": 0.0,
                    "time_improvement": 53.83761673112537,
                    "length_improvement": 17.24432160877036,
                    "objective_score": 19.600149341091683
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
          "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.68311,
          "time_improvement": 27.0,
          "length_improvement": 17.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.007598710060119629,
                    "num_nodes_avg": 103.3,
                    "path_length_avg": 161.4550453822259,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 19.42719038120736,
                    "length_improvement": 19.306320142615537,
                    "objective_score": 4.689421142885316
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.013997030258178712,
                    "num_nodes_avg": 235.8,
                    "path_length_avg": 259.63765747646863,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 4.9963346727016456,
                    "length_improvement": 13.8434413164237,
                    "objective_score": -0.7324113349047652
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.012314391136169434,
                    "num_nodes_avg": 223.6,
                    "path_length_avg": 131.58176022985964,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 57.507196585457756,
                    "length_improvement": 19.200872600268642,
                    "objective_score": 16.092333495691054
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m1",
          "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with adaptive rewiring and dynamic radius adjustment, while incorporating heuristic informed sampling towards the goal and enhanced collision checks. It dynamically balances exploration and exploitation by alternating tree expansions, improves path quality via local rewiring around new nodes, and enforces strict collision-free checks for nodes and edges. The method prunes suboptimal nodes iteratively to enhance planning efficiency, leading to smoother and shorter paths with higher success rates and reduced search time.",
          "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling free points biased towards the goal. Each extension uses a steering function with a fixed step size, adding nodes only after thorough collision checks. Rewiring is performed locally with a dynamically shrinking radius to optimize path costs incrementally. The trees attempt to connect after each extension, and upon success, the optimal path is constructed by backtracking. This blend of bidirectional search, incremental optimization, adaptive sampling, and pruning yields efficient, robust, and high-quality path planning.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Heuristic guided sampling with goal bias and start bias for efficient tree growth\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search with linear scan (can be improved with spatial indexing if needed)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes+1) / (n_nodes+1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Rewire radius scales inversely with node count\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            # Add edge record\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Rewire neighbors around new_node for local path cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # epsilon to avoid floating error loops\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge feasibility check before adding terminal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees with start and goal roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Merge paths, avoid duplicated connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Optional pruning of nodes with no children and higher cost to improve efficiency\n            if itr % 250 == 0 and len(nodes) > 100:\n                pruned = []\n                for node in nodes[:]:\n                    if not node.children and node is not start_root and node is not goal_root:\n                        try:\n                            node.parent.children.remove(node)\n                            nodes.remove(node)\n                            # Remove edges related to node\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            pruned.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -6.15402,
          "time_improvement": 15.0,
          "length_improvement": 8.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.004810810089111328,
                    "num_nodes_avg": 94.0,
                    "path_length_avg": 182.51310029888023,
                    "success_improvement": 0.0,
                    "time_improvement": 48.98864644717982,
                    "length_improvement": 8.781706694699151,
                    "objective_score": 16.452935273093775
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.02035815715789795,
                    "num_nodes_avg": 178.3,
                    "path_length_avg": 287.3732004707603,
                    "success_improvement": 0.0,
                    "time_improvement": -38.17927900665584,
                    "length_improvement": 4.639849815737334,
                    "objective_score": -10.525813738849285
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.01868715286254883,
                    "num_nodes_avg": 139.1,
                    "path_length_avg": 147.54383101693634,
                    "success_improvement": 0.0,
                    "time_improvement": 35.516948894576494,
                    "length_improvement": 9.399199565681393,
                    "objective_score": 12.534924581509227
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a bidirectional extension of RRT* that grows two trees from start and goal while optimizing paths via rewiring. It combines RRT*\u2018s asymptotic optimality with RRT-Connect\u2019s fast convergence through connection attempts between the trees.",
          "planning_mechanism": "The planner alternates growing two trees with sampling, extension, and rewiring. After each extension, it attempts to connect both trees. When connection is successful, a rewired optimal path is extracted across both trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.radius = radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = self._near(tree_a, new_pos, self.radius)\n                min_cost = nearest.cost + self._distance(nearest.position, new_pos)\n                min_parent = nearest\n\n                for near in near_nodes:\n                    cost = near.cost + self._distance(near.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n\n                for near in near_nodes:\n                    if near == min_parent:\n                        continue\n                    new_cost = new_node.cost + self._distance(new_node.position, near.position)\n                    if new_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n                connect_node = self._nearest(tree_b, new_node.position)\n                if self._distance(new_node.position, connect_node.position) < self.step_size and not self._is_edge_in_obstacle(new_node.position, connect_node.position, obstacles, is_3d):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            point = tuple(random.uniform(0, bounds[i]) for i in range(3 if is_3d else 2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if self._distance(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -5.6829227155522615,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011509346961975097,
                    "num_nodes_avg": 133.0,
                    "path_length_avg": 175.27050435154484,
                    "success_improvement": 0.0,
                    "time_improvement": -22.03919010817601,
                    "length_improvement": 12.401486536989607,
                    "objective_score": -4.1314597250548815
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.016402530670166015,
                    "num_nodes_avg": 264.6,
                    "path_length_avg": 258.5920512869376,
                    "success_improvement": 0.0,
                    "time_improvement": -11.330797002361011,
                    "length_improvement": 14.190408824541839,
                    "objective_score": -0.5611573357999351
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.010229659080505372,
                    "num_nodes_avg": 179.6,
                    "path_length_avg": 143.86931760330097,
                    "success_improvement": 0.0,
                    "time_improvement": 64.70090258632817,
                    "length_improvement": 11.655572158065754,
                    "objective_score": 21.741385207511602
               }
          ]
     },
     {
          "operator": "time_expert",
          "algorithm_description": "This improved planner implements an optimized bidirectional RRT* variant with adaptive sampling biased toward the goal and border safety checks. It employs a KD-tree to accelerate nearest and neighbor searches, reducing computational time. It integrates early stopping when trees connect, uses a geometric rewiring strategy to improve path quality locally, and performs efficient collision checks on sampled points and edges. Post-processing smoothing refines the final path.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal with adaptive goal bias sampling to speed convergence. Each sampled point is steered toward within a step size limit and validated for collision. Using KD-trees for spatial queries, the planner quickly finds nearest and nearby nodes enabling efficient rewiring to reduce path costs. The trees alternate extensions to balance exploration and exploitation, attempting connection at each iteration for early success. Finally, the path is smoothed by shortcutting while ensuring collision-free transitions.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        from bisect import bisect_left, bisect_right\n        from collections import deque\n\n        bounds = map.size                # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal         # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles        # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def build(self):\n                # KD-Tree is approximated by sorted lists per dimension for fast range queries\n                self.sorted_by_dim = [sorted(self.points, key=lambda p: p[d]) for d in range(dim)]\n\n            def insert(self, node: Node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                # Brute-force near neighbors due to moderate problem size and dimensionality\n                neighbors = []\n                r_sq = radius * radius\n                for node in self.nodes:\n                    # Compare squared dist for efficiency\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # With goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Sample extended bounds - slight buffer to avoid border failures\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        # Swap flag to alternate tree growth\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree to extend\n            if tree_flag:\n                new_node = self._extend_bidirectional(tree_start, kd_start, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_goal, kd_goal, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_bidirectional(tree_goal, kd_goal, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_start, kd_start, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    # Note the roles reversed, swap accordingly\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _extend_bidirectional(self, tree: List[Node], kd_tree, point, obstacles, is_3d, nodes, edges, neighbor_radius,\n                              steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n            return None\n\n        if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            if near_node.cost + edge_cost < min_cost:\n                if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = near_node.cost + edge_cost\n                    best_parent = near_node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Try rewiring neighbors for cost improvement\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            edge_cost = math.dist(new_node.position, near_node.position)\n            cost_through_new = new_node.cost + edge_cost\n            if cost_through_new < near_node.cost:\n                if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n        return new_node\n\n    def _connect_bidirectional(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                               neighbor_radius, steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        curr_node = nearest_node\n        while True:\n            new_pos = steer_fn(curr_node.position, target_pos)\n            if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n                return None\n\n            if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                if near_node.cost + edge_cost < min_cost:\n                    if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = near_node.cost + edge_cost\n                        best_parent = near_node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors similarly\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            curr_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _out_of_bounds(self, pos, origin, obstacles, is_3d):\n        # Safety check to not generate nodes past map bounds (origin = start pos's bounds reference)\n        # No explicit bounds checks in original, so add a generic clipping following common sense\n        for d, val in enumerate(pos):\n            if val < 0:\n                return True\n        return False",
          "objective": -3.96181,
          "time_improvement": -2.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009483003616333007,
                    "num_nodes_avg": 72.0,
                    "path_length_avg": 160.3701129930091,
                    "success_improvement": 0.0,
                    "time_improvement": -0.5528884439489358,
                    "length_improvement": 19.848558922921917,
                    "objective_score": 3.8038452513997028
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.023026371002197267,
                    "num_nodes_avg": 276.7,
                    "path_length_avg": 231.60591841983734,
                    "success_improvement": 0.0,
                    "time_improvement": -56.289556001831855,
                    "length_improvement": 23.145320691353117,
                    "objective_score": -12.25780266227893
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.014002847671508788,
                    "num_nodes_avg": 202.7,
                    "path_length_avg": 123.48043402619813,
                    "success_improvement": 0.0,
                    "time_improvement": 51.68090352420842,
                    "length_improvement": 24.17557492141821,
                    "objective_score": 20.339386041546167
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm enhances the standard BI-RRT by incorporating an optimization step that rewires nearby nodes to minimize cost, resulting in asymptotically optimal paths. It grows two trees\u2014one from the start and one from the goal\u2014and attempts to connect them while optimizing the path cost dynamically.",
          "planning_mechanism": "The planning mechanism includes sampling a random point, extending each tree toward it, rewiring neighbors within a radius to optimize the cost, and attempting to connect the two trees. When a connection is established, the combined path is extracted from both trees. Node validity and edge collision checks are strictly enforced throughout the process.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n            rand_point = self._sample_free(bounds, obstacles, is_3d)\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b:\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or            self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or                self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos, radius=20.0)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n\n            nearest = connect_node\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": -2.8383427428807892,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.007564902305603027,
                    "num_nodes_avg": 63.6,
                    "path_length_avg": 157.74844317172378,
                    "success_improvement": 0.0,
                    "time_improvement": 19.785670405679053,
                    "length_improvement": 21.158844301429212,
                    "objective_score": 10.167469981989559
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.021586298942565918,
                    "num_nodes_avg": 236.6,
                    "path_length_avg": 218.9843001436935,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -46.51518804828198,
                    "length_improvement": 27.333600643728058,
                    "objective_score": -18.48783628573898
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.009180307388305664,
                    "num_nodes_avg": 131.2,
                    "path_length_avg": 111.23634768618506,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 68.32186075440126,
                    "length_improvement": 31.694181530357035,
                    "objective_score": 16.83539453239179
               }
          ]
     },
     {
          "operator": "m1",
          "algorithm_description": "This algorithm enhances the bidirectional RRT by integrating a heuristic-based goal biasing and nearest neighbor optimization to improve efficiency and path quality. It grows two trees from start and goal alternately, extends towards sampled points with goal bias to encourage tree connection, performs rigorous collision and edge checks, and once trees connect, extracts and smooths the path for improved smoothness and shorter path length.",
          "planning_mechanism": "The planner alternates growing two trees from start and goal. At each iteration, it samples points with goal biasing, extends one tree towards the sample, attempts connection to the other tree quickly, and upon successful connection, reconstructs and smooths the path. Rigorous collision checks and edge validity checks ensure robustness. Path smoothing via shortcutting reduces path length and improves smoothness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal to bias growth\n        self.smoothing_iter = smoothing_iter      # Number of path smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def can_connect(node_from, node_to):\n            if self._is_edge_in_obstacle(node_from.position, node_to.position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(node_to.position, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, new_node.position)\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                next_node = Node(new_pos, parent=nearest_node,\n                                cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(new_pos, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            import random\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate tree growth\n        for iter in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Extend start tree towards random point\n            nearest_start = nearest(tree_start, rand_point)\n            new_pos_start = steer(nearest_start.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_start, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d)):\n                new_node_start = Node(new_pos_start, parent=nearest_start,\n                                     cost=nearest_start.cost + math.dist(nearest_start.position, new_pos_start))\n                nearest_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_start, new_node_start))\n\n                # Try connect goal tree to new start node\n                new_node_goal = connect_trees(new_node_start, tree_goal)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap roles: Extend goal tree towards random point\n            rand_point = sample_point()\n            nearest_goal = nearest(tree_goal, rand_point)\n            new_pos_goal = steer(nearest_goal.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_goal, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d)):\n                new_node_goal = Node(new_pos_goal, parent=nearest_goal,\n                                    cost=nearest_goal.cost + math.dist(nearest_goal.position, new_pos_goal))\n                nearest_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_goal, new_node_goal))\n\n                # Try connect start tree to new goal node\n                new_node_start = connect_trees(new_node_goal, tree_start)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -2.18266,
          "time_improvement": 9.0,
          "length_improvement": 22.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009535980224609376,
                    "num_nodes_avg": 86.7,
                    "path_length_avg": 170.74762170972932,
                    "success_improvement": 0.0,
                    "time_improvement": -1.1146251254553718,
                    "length_improvement": 14.661979809696968,
                    "objective_score": 2.598008424302782
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.015331578254699708,
                    "num_nodes_avg": 255.3,
                    "path_length_avg": 231.82982015577954,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -4.06179758007486,
                    "length_improvement": 23.07102252043464,
                    "objective_score": -1.6043347699355293
               },
               {
                    "map_id": 2,
                    "success_rate": 0.8,
                    "time_avg": 0.01953170299530029,
                    "num_nodes_avg": 281.5,
                    "path_length_avg": 115.83970390651845,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": 32.602691716296164,
                    "length_improvement": 28.867443500228006,
                    "objective_score": 5.554296214934452
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm implements a bidirectional RRT* planner that efficiently explores the space by growing two trees from start and goal positions, incorporating rewiring to optimize path costs continuously. It balances rapid exploration with local path improvements, ensuring high success rates and high-quality, smooth paths.",
          "planning_mechanism": "The planner samples free points within map bounds, extends the nearest nodes in each tree towards these points while ensuring collision avoidance, attempts to connect the two trees, and rewires neighbors to minimize cost. Once connected, the path is extracted and smoothed for optimal navigation performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": -1.31503,
          "time_improvement": -2.0,
          "length_improvement": 27.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.009461736679077149,
                    "num_nodes_avg": 68.6,
                    "path_length_avg": 157.90810556621656,
                    "success_improvement": 0.0,
                    "time_improvement": -0.3273847896268319,
                    "length_improvement": 21.079046571256317,
                    "objective_score": 4.1175938773632135
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.017914962768554688,
                    "num_nodes_avg": 235.1,
                    "path_length_avg": 217.9828629857762,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -21.596302631429896,
                    "length_improvement": 27.665911372851916,
                    "objective_score": -5.945708514858585
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.024679231643676757,
                    "num_nodes_avg": 299.9,
                    "path_length_avg": 111.38058968744186,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": 14.84030943466389,
                    "length_improvement": 31.605608252301014,
                    "objective_score": 5.77321448085937
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "initial",
          "algorithm_description": "This algorithm is a dual-tree variant of Rapidly-exploring Random Tree (RRT) that grows two trees from the start and goal positions, attempting to connect them as they expand. It is efficient for single-query problems due to its bidirectional search and reduced redundant exploration.",
          "planning_mechanism": "The planner alternates between growing the start and goal trees by extending towards randomly sampled points. Each extension step involves checking for collision-free motion and attempting to connect the two trees. The algorithm terminates when a valid path is formed connecting the trees.",
          "code": "\nclass Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        for iter in range(self.max_iter):\n            rand = self._sample_free(bounds, obstacles, is_3d)\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest = self._nearest(tree_a, rand)\n                new_pos = self._steer(nearest.position, rand, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    continue\n                new_node = Node(new_pos, parent=nearest, cost=nearest.cost + self._distance(nearest.position, new_pos))\n                nearest.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n\n                connect_node = self._nearest(tree_b, new_pos)\n                if self._connect_trees(new_node, connect_node, obstacles, is_3d, tree_b, nodes, edges):\n                    success_state = True\n                    extracted_path = self._extract_path(new_node, connect_node)\n                    return PlannerResult(True, extracted_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(False, [], start_tree + goal_tree, edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        while True:\n            if is_3d:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(3))\n            else:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(2))\n            if not self._is_in_obstacle(point, obstacles, is_3d):\n                return point\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: self._distance(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = self._distance(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n    def _connect_trees(self, node_a, node_b, obstacles, is_3d, tree, nodes, edges):\n        from_pos = node_a.position\n        to_pos = node_b.position\n        if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n            return False\n        curr = node_b\n        path = []\n        while True:\n            new_pos = self._steer(curr.position, from_pos, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                return False\n            new_node = Node(new_pos, parent=curr, cost=curr.cost + self._distance(curr.position, new_pos))\n            curr.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((curr, new_node))\n            if self._distance(new_pos, from_pos) < self.step_size:\n                new_node_final = Node(from_pos, parent=new_node, cost=new_node.cost + self._distance(new_pos, from_pos))\n                new_node.add_child(new_node_final)\n                tree.append(new_node_final)\n                nodes.append(new_node_final)\n                edges.append((new_node, new_node_final))\n                return True\n            curr = new_node\n\n    def _extract_path(self, node_a, node_b):\n        path_a = []\n        while node_a:\n            path_a.append(node_a.position)\n            node_a = node_a.parent\n        path_b = []\n        while node_b:\n            path_b.append(node_b.position)\n            node_b = node_b.parent\n        return list(reversed(path_a)) + path_b\n\n    def _distance(self, a, b):\n        return math.dist(a, b)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = self._distance(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n    ",
          "objective": 0.15575745947482242,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.00932621955871582,
                    "num_nodes_avg": 101.7,
                    "path_length_avg": 188.22576488201025,
                    "success_improvement": 0.0,
                    "time_improvement": 1.1095689897082393,
                    "length_improvement": 5.9265718433081265,
                    "objective_score": 1.5181850655740972
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.017459988594055176,
                    "num_nodes_avg": 254.8,
                    "path_length_avg": 300.19012599646163,
                    "success_improvement": 0.0,
                    "time_improvement": -18.50820369833951,
                    "length_improvement": 0.3867603104208941,
                    "objective_score": -5.475109047417674
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.026160240173339844,
                    "num_nodes_avg": 310.9,
                    "path_length_avg": 158.2035597275041,
                    "success_improvement": 0.0,
                    "time_improvement": 9.729849355042791,
                    "length_improvement": 2.8534839845313615,
                    "objective_score": 3.4896516034191096
               }
          ]
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strength of bidirectional RRT* incremental rewiring and goal biasing with the simplicity and incremental growth strategy of standard RRT. It employs bidirectional search to explore from both start and goal nodes, adapts goal sampling bias dynamically, uses an adaptive neighborhood radius for local rewiring to optimize path quality, and balances tree growth by always extending the smaller tree first. It incorporates efficient collision and edge checking and prunes suboptimal paths when possible. Additionally, it applies a smoothing pass for the final path to further improve path smoothness and length, leveraging steering with fixed step size for incremental growth. This synergy results in faster convergence, higher success rates, and smoother, shorter paths while reducing search time and maintaining robustness.",
          "planning_mechanism": "The planner initializes two trees rooted at start and goal. It then iteratively samples points with adaptive goal bias and attempts to extend the smaller tree toward these points. Each new node locally rewires neighbors within an adaptive radius to improve path costs. After extending one tree, it attempts to connect the other tree toward the newly added node to check for a path connection. Once connected, it reconstructs the path by merging branches from both trees. Finally, the path is smoothed by shortcutting to reduce unnecessary waypoints. Collision and edge feasibility checks are rigorously applied before node/edge acceptance, ensuring safe, robust paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal sampling with increasing bias toward goal as iterations increase\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start)\n                         * iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if improvement found\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Check final connection edge\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=100):\n            # Shortcut smoothing: try random pairs and attempt shortcut if collision-free\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Shortcut is feasible, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main iterative planning loop\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Alternate growth by always extending smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge while avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                # Smooth merged path to improve smoothness and shorten path length\n                smoothed_path = smooth_path(merged_path, max_trials=150)\n                extracted_path = smoothed_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 0.87725,
          "time_improvement": -16.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011067795753479003,
                    "num_nodes_avg": 78.3,
                    "path_length_avg": 164.46229291518293,
                    "success_improvement": 0.0,
                    "time_improvement": -17.35720840633128,
                    "length_improvement": 17.803326729793657,
                    "objective_score": -1.6464971759406528
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.020533823966979982,
                    "num_nodes_avg": 277.5,
                    "path_length_avg": 240.4994491111335,
                    "success_improvement": 0.0,
                    "time_improvement": -39.37160269470332,
                    "length_improvement": 20.194146326446944,
                    "objective_score": -7.772651543121607
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02687411308288574,
                    "num_nodes_avg": 252.0,
                    "path_length_avg": 125.33436833056348,
                    "success_improvement": 0.0,
                    "time_improvement": 7.266515124964315,
                    "length_improvement": 23.037147575656384,
                    "objective_score": 6.787384052620571
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm combines bidirectional Rapidly-exploring Random Tree (RRT) planning with adaptive sampling near frontiers and dynamic step sizing close to obstacles, integrating path shortcut smoothing for enhanced path quality and smoothness. It grows two trees from the start and goal positions simultaneously, biasing sampling towards frontier regions and adapting step size based on local obstacle proximity to improve exploration efficiency and precision, ultimately connecting the two trees to find a collision-free path. After path connection, iterative shortcut smoothing refines the path to reduce unnecessary detours and improve smoothness while maintaining collision safety.",
          "planning_mechanism": "The planner initializes two trees at start and goal, alternately growing them by extending towards randomly sampled points biased towards frontiers near obstacles. Step size dynamically adjusts smaller near obstacles and larger in free space for effective exploration. Each extension validates node and edge collision-free conditions. Upon connection of trees, the combined path is shortcut-smoothed to enhance path length and smoothness, and then returned as the final path.",
          "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n        \n        for _ in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if _ % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased towards frontiers\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_pos = self._steer(nearest_node.position, rand_point, step_size)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect tree_b to new_node\n            nearest_node_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            connecting = True\n            last_added = None\n            while connecting:\n                step_size_b = self._adaptive_step_size(nearest_node_b.position, obstacles, is_3d, self.base_step_size)\n                next_pos = self._steer(nearest_node_b.position, new_pos, step_size_b)\n                if not self._in_bounds(next_pos, bounds):\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node_b.position, next_pos, obstacles, is_3d):\n                    break\n                new_cost_b = nearest_node_b.cost + math.dist(nearest_node_b.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_node_b, cost=new_cost_b)\n                nearest_node_b.add_child(next_node)\n                tree_b.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node_b, next_node))\n                nearest_node_b = next_node\n                last_added = next_node\n\n                if math.dist(next_pos, new_pos) <= step_size_b:\n                    # Connected\n                    path_a = new_node.path_from_root()\n                    path_b = last_added.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # Swap if trees were swapped\n                        path_a, path_b = path_b, path_a\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n                    connecting = False\n                    break\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": 3.37712,
          "time_improvement": -26.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.011121630668640137,
                    "num_nodes_avg": 148.0,
                    "path_length_avg": 158.18834787192,
                    "success_improvement": 0.0,
                    "time_improvement": -17.92804613218255,
                    "length_improvement": 20.93898416041376,
                    "objective_score": -1.1906170075720128
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.031751585006713864,
                    "num_nodes_avg": 468.0,
                    "path_length_avg": 239.0017021215254,
                    "success_improvement": 0.0,
                    "time_improvement": -115.51121201774241,
                    "length_improvement": 20.691149448634693,
                    "objective_score": -30.515133715595784
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.012543845176696777,
                    "num_nodes_avg": 258.0,
                    "path_length_avg": 125.72257630639828,
                    "success_improvement": 0.0,
                    "time_improvement": 56.7154282122604,
                    "length_improvement": 22.79876449245189,
                    "objective_score": 21.574381362168495
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is a streamlined and generalized optimal RRT-based planner combining bidirectional search and rewiring techniques. It balances efficient exploration with continuous local path cost optimization to enhance path quality, success rate, and computational speed.",
          "planning_mechanism": "The planner grows two trees from start and goal, sampling points within bounds, and steering towards them with collision checks. It rewires nodes nearby new additions to minimize cost. Trees attempt to connect, forming smoother and shorter paths while quickly exploring the space with balanced bidirectional growth and local optimizations.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend start tree\n            new_start = self._extend_tree(tree_start, rand_point, obstacles, is_3d, nodes, edges, near, steer, nearest)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree to new_start\n            new_goal = self._connect_tree(tree_goal, new_start.position, obstacles, is_3d, nodes, edges, near, steer, nearest)\n\n            if new_goal:\n                success_state = True\n                connection_node_start = new_start\n                connection_node_goal = new_goal\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        extracted_path = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            extracted_path = path_start + path_goal[::-1]\n\n            # Optional smoothing\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n        nearest_node = nearest_fn(tree, point)\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for node in near_nodes:\n            cost = node.cost + math.dist(node.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for node in near_nodes:\n            if node == best_parent:\n                continue\n            cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n            if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                if node.parent:\n                    edges.remove((node.parent, node))\n                    node.parent.children.remove(node)\n                node.parent = new_node\n                node.cost = cost_through_new\n                new_node.add_child(node)\n                edges.append((new_node, node))\n\n        return new_node\n\n    def _connect_tree(self, tree, target_position, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n\n        current_node = nearest_fn(tree, target_position)\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            if math.dist(new_node.position, target_position) <= self.step_size:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import math\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 7.29674,
          "time_improvement": -36.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.0127516508102417,
                    "num_nodes_avg": 95.7,
                    "path_length_avg": 155.49876463463846,
                    "success_improvement": 0.0,
                    "time_improvement": -35.21194057018043,
                    "length_improvement": 22.283212011486395,
                    "objective_score": -6.10693976875685
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.022982406616210937,
                    "num_nodes_avg": 289.7,
                    "path_length_avg": 218.9591641629555,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -55.99115143061041,
                    "length_improvement": 27.341941612525005,
                    "objective_score": -16.328957106678118
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.0340461254119873,
                    "num_nodes_avg": 351.0,
                    "path_length_avg": 115.70390280011952,
                    "success_improvement": 0.0,
                    "time_improvement": -17.481676370436364,
                    "length_improvement": 28.950833560353235,
                    "objective_score": 0.5456638009397379
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved planner is a bidirectional RRT* variant enhanced with adaptive goal biasing, dynamic neighbor radius, heuristic-driven sampling favoring the goal, and lazy collision checking to reduce computation. It incorporates efficient rewiring for path cost optimization and path smoothing via shortcutting to ensure shorter and smoother paths. Additionally, the algorithm uses spatial pruning to reduce unnecessary node expansions, and alternates tree growth direction for balanced exploration, resulting in faster planning times, higher success rate, and better path quality.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by alternately sampling points biased adaptively towards the goal and start to prevent symmetry issues. Each extension steers a fixed step size towards the sampled point and inserts nodes only if collision-free. A dynamic neighbor radius shrinks as the tree grows, focusing rewiring locally for improved path costs. Upon addition of a new node, nearby nodes are rewired if cost improvements are possible. Trees attempt connection by extending one towards the newest node in the other tree. Once connected, the path is extracted by backtracking parent pointers, merged, and smoothed by shortcutting collision-free edges, resulting in efficient, short, and smooth paths with reduced planning time.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=7.0, max_neighbor_radius: float=25.0,\n                 smoothing_trials: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing: increase bias with iteration, capped at 0.3\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias towards start or goal to mitigate symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fail-safe: fallback to start or goal randomly\n                        return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds if slight out-of-bound due to numerical errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(len(bounds))\n            )\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Dynamic shrinking radius to focus rewiring and reduce neighbors long-run\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Linear search for neighbors within radius (can be replaced by spatial indexing)\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            # Return the node closest to point by Euclidean distance\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n            # Alternate tree expansion to balance growth: even=tree_start grows, odd=tree_goal grows\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(it)\n\n            # --- Extend tree_a towards random sample ---\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Validate node and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors of new_node if improvement found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # --- Attempt to connect tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check connection proximity\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract paths and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing by random shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 17.93773,
          "time_improvement": -49.0,
          "length_improvement": 26.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.012215113639831543,
                    "num_nodes_avg": 73.6,
                    "path_length_avg": 157.86942337224633,
                    "success_improvement": 0.0,
                    "time_improvement": -29.522776627506893,
                    "length_improvement": 21.098379560008855,
                    "objective_score": -4.637157076250296
               },
               {
                    "map_id": 1,
                    "success_rate": 0.8,
                    "time_avg": 0.026813340187072755,
                    "num_nodes_avg": 273.8,
                    "path_length_avg": 229.28425192705168,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -81.99329075188567,
                    "length_improvement": 23.915728179132536,
                    "objective_score": -29.81484158973919
               },
               {
                    "map_id": 2,
                    "success_rate": 0.7,
                    "time_avg": 0.0395944356918335,
                    "num_nodes_avg": 306.7,
                    "path_length_avg": 108.8905895531143,
                    "success_improvement": -30.000000000000004,
                    "time_improvement": -36.6270206588691,
                    "length_improvement": 33.1346183349099,
                    "objective_score": -19.36118253067875
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive goal biasing, dynamic neighbor radius based on node density, heuristic-driven sampling towards the goal, and efficient rewiring techniques. It balances exploration and exploitation to rapidly discover feasible paths while continuously optimizing path cost, resulting in reduced planning time and shorter, smoother paths. Additionally, it incorporates lazy collision checking and path smoothing to enhance success rate and path quality.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling points with adaptive goal bias. It uses a dynamic neighbor radius influenced by iteration count to refine rewiring as trees expand. Steering uses fixed step size with checks to remain in bounds and avoid obstacles. When new nodes are added, nearby nodes are rewired to minimize cost. The trees attempt to connect through nearest nodes periodically. Upon successful connection, the path is extracted and smoothed by shortcutting collision-free edges, ensuring efficient and smooth navigation.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive sampling bias: gradually increase goal bias with iterations\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.2, 0.3)\n            if random.random() < goal_bias:\n                # Bias alternate between start and goal to reduce symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds if slight out-of-bound due to float errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(len(bounds))\n            )\n            return clamped\n\n        def nearest(tree, point):\n            # Use Euclidean distance\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            # Dynamic radius shrinking with iterations to focus rewiring locally as tree grows\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Efficiently find neighbors within dynamic radius\n            # For performance, linear search; could be improved with spatial indexing\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n\n            # Alternate between trees for balanced growth\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(it)\n\n            # --- Extend tree_a towards random sample ---\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path improves cost\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # --- Try to connect tree_b to new_node ---\n            nearest_node_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_node_b\n\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check connector proximity\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    # Trees connected successfully\n                    connection_node_start = new_node if tree_a is tree_start else new_node_b\n                    connection_node_goal = new_node_b if tree_b is tree_goal else new_node\n\n                    success_state = True\n                    break\n\n                curr_node_b = new_node_b\n\n            if success_state:\n                # Extract paths and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing: attempt shortcutting by bypassing intermediate nodes\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 24.37999,
          "time_improvement": -79.0,
          "length_improvement": 21.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.8,
                    "time_avg": 0.01865048408508301,
                    "num_nodes_avg": 98.5,
                    "path_length_avg": 171.3088822744523,
                    "success_improvement": -19.999999999999996,
                    "time_improvement": -97.76013186402028,
                    "length_improvement": 14.381467174002548,
                    "objective_score": -36.451746124405574
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.034059691429138186,
                    "num_nodes_avg": 319.6,
                    "path_length_avg": 228.7886221087461,
                    "success_improvement": 0.0,
                    "time_improvement": -131.17729018226305,
                    "length_improvement": 24.080194920749342,
                    "objective_score": -34.53714807052904
               },
               {
                    "map_id": 2,
                    "success_rate": 0.9,
                    "time_avg": 0.031148362159729003,
                    "num_nodes_avg": 293.9,
                    "path_length_avg": 121.37515371171125,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -7.4824743913445175,
                    "length_improvement": 25.46834385873305,
                    "objective_score": -2.151073545656743
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "cross_over",
          "algorithm_description": "This planner implements an optimized bidirectional RRT* variant augmented with an efficient KD-tree nearest neighbor structure, adaptive heuristic goal biasing, and informed sampling within an ellipsoidal subset to drastically reduce sampling space and improve convergence. It uses cost-aware rewiring to minimize path length locally, aggressive early termination upon tree connection, and iterative shortcut-based smoothing to refine path quality while maintaining collision-free guarantees. The planner balances exploration and exploitation via alternating tree growth and employs strict collision and edge checks to ensure robustness and reliability.",
          "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, employing heuristic and informed sampling strategies that bias samples toward the connectable region between trees. Using a KD-tree for fast nearest and near neighbor retrieval, it performs cost-based rewiring to improve path quality locally. Trees alternate growth and attempt connections to minimize total path cost, with early stopping once path found. Post extraction, iterative smoothing shortcuts the path while verifying obstacle collisions to ensure reduced length and improved smoothness, ultimately achieving efficient and high-quality path planning in complex environments.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius: float=15.0, smoothing_iter: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Early fail if start or goal inside obstacle\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or \\\n           self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    d_sq = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        d_sq += diff*diff\n                        if d_sq > r_sq:\n                            break\n                    if d_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n\n        def informed_sample(c_best, start, goal):\n            # Informed sampling inside an ellipse: sampling inside an ellipse between start and goal constrained by c_best (current best path length)\n            # Only used if a solution exists to improve path quality and speed-up convergence\n\n            if c_best == float('inf'):\n                # No solution found, use basic biased sampling\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            dist_start_goal = math.dist(start, goal)\n            if dist_start_goal == 0:\n                return start\n\n            # Define ellipse axes lengths\n            a = c_best / 2.0  # major axis half-length\n            c = dist_start_goal / 2.0\n            if a <= c:\n                # Degenerate case, sample uniformly\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            b = math.sqrt(a * a - c * c)  # minor axis half-length\n\n            def sample_unit_ball():\n                # Sample uniformly within unit ball in dim-dimensional space\n                import random as rand\n                if dim == 2:\n                    while True:\n                        x = rand.uniform(-1, 1)\n                        y = rand.uniform(-1, 1)\n                        if x*x + y*y <= 1:\n                            return (x,y)\n                else:\n                    while True:\n                        x = rand.uniform(-1,1)\n                        y = rand.uniform(-1,1)\n                        z = rand.uniform(-1,1)\n                        if x*x + y*y + z*z <=1:\n                            return (x,y,z)\n\n            # Rotation from ellipse frame to world frame\n            # Direction vector start->goal\n            dir_vec = tuple((goal[d] - start[d]) / dist_start_goal for d in range(dim))\n            if dim == 2:\n                # 2D rotation matrix from x-axis to dir_vec\n                cos_theta = dir_vec[0]\n                sin_theta = dir_vec[1]\n\n                while True:\n                    x_ball, y_ball = sample_unit_ball()\n                    # Scale to ellipse axes\n                    x_ellip = x_ball * a\n                    y_ellip = y_ball * b\n                    # Rotate to map frame\n                    sample_x = center[0] + cos_theta * x_ellip - sin_theta * y_ellip\n                    sample_y = center[1] + sin_theta * x_ellip + cos_theta * y_ellip\n                    sample = (sample_x, sample_y)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                # 3D rotation to align x-axis with dir_vec\n                # Use Householder transformation or build rotation matrix\n                import numpy as np\n                e1 = np.array([1.0,0.0,0.0])\n                dir_v = np.array(dir_vec)\n                if np.allclose(dir_v, e1):\n                    R = np.eye(3)\n                elif np.allclose(dir_v, -e1):\n                    R = -np.eye(3)\n                else:\n                    v = np.cross(e1, dir_v)\n                    s = np.linalg.norm(v)\n                    c = np.dot(e1, dir_v)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c)/(s*s))\n\n                while True:\n                    x_ball, y_ball, z_ball = sample_unit_ball()\n                    scaled = np.array([a*x_ball, b*y_ball, b*z_ball])\n                    rotated = R.dot(scaled)\n                    sample_np = np.array(center) + rotated\n                    sample = tuple(sample_np.tolist())\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        c_best = float('inf')  # Best path cost found so far\n\n        def choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes:\n                edge_cost = math.dist(node.position, new_pos)\n                cost_through_node = node.cost + edge_cost\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n            if best_parent is None:\n                return None, None\n            return best_parent, min_cost\n\n        def rewire(new_node, near_nodes, obstacles, is_3d, edges):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent connection\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        def extend(tree, kd_tree, sample_point):\n            nearest_node = kd_tree.nearest(sample_point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not in_bounds(new_pos):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n            parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n            if parent_node is None:\n                # Fallback to nearest_node\n                parent_node = nearest_node\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                # Double check edge validity (already checked once)\n                if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n            new_node = Node(new_pos)\n            new_node.parent = parent_node\n            new_node.cost = min_cost\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            kd_tree.insert(new_node)\n\n            rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n            return new_node\n\n\n        def connect(tree, kd_tree, target_node):\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n            curr_node = nearest_node\n\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n                parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n                if parent_node is None:\n                    parent_node = curr_node\n                    min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                    if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                        return None\n\n                new_node = Node(new_pos)\n                new_node.parent = parent_node\n                new_node.cost = min_cost\n                parent_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                kd_tree.insert(new_node)\n\n                rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size * 0.5:\n                    return new_node\n\n                curr_node = new_node\n\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_flag = True  # True=extend start tree, False=extend goal tree\n\n        for iter in range(self.max_iter):\n            sample_pt = informed_sample(c_best, start_position, goal_position)\n\n            if tree_flag:\n                new_node = extend(tree_start, kd_start, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_goal, kd_goal, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = new_node\n                        connection_node_goal = connect_node\n                        # Early exit once a better solution found\n                        break\n            else:\n                new_node = extend(tree_goal, kd_goal, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_start, kd_start, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = connect_node\n                        connection_node_goal = new_node\n                        break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state and connection_node_start is not None and connection_node_goal is not None:\n            extracted_path = extract_path(connection_node_start, connection_node_goal)\n            # Iterative smoothing\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 37.41939,
          "time_improvement": -127.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.02829596996307373,
                    "num_nodes_avg": 116.0,
                    "path_length_avg": 169.7434955762623,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -200.0358985638046,
                    "length_improvement": 15.163832400048669,
                    "objective_score": -61.97800308913164
               },
               {
                    "map_id": 1,
                    "success_rate": 0.9,
                    "time_avg": 0.04106793403625488,
                    "num_nodes_avg": 297.4,
                    "path_length_avg": 238.03299060648334,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -178.74514728466403,
                    "length_improvement": 21.012600702294776,
                    "objective_score": -54.421024044940246
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.02965552806854248,
                    "num_nodes_avg": 247.3,
                    "path_length_avg": 123.43876793354507,
                    "success_improvement": 0.0,
                    "time_improvement": -2.331208294152157,
                    "length_improvement": 24.20116041231484,
                    "objective_score": 4.140869594217321
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This improved hybrid bidirectional RRT* planner enhances path planning by integrating adaptive sampling, dynamic neighbor radius based on the growing tree size, and more aggressive local rewiring for better path quality and convergence speed. The planning efficiency gains come from adaptive goal biasing, radius scaling to include more neighbors as the tree grows, and collision checks early in the sampling process to avoid futile expansions. The rewiring step is optimized to better minimize path length and enhance smoothness, and the swapping of trees is maintained for balanced exploration from start and goal.",
          "planning_mechanism": "The planner grows two trees alternately from start and goal nodes, each extending towards random samples biased towards the goal and start positions respectively. Each extension involves steering with a fixed step size and connecting the new node to the minimum cost parent within a dynamically computed radius. After insertion, neighbors are rewired if the path via the new node shortens their costs, promoting optimal paths locally. Once the two trees connect within the step size, the algorithm reconstructs the complete path by joining backtracked nodes from both sides. This combination leverages bidirectional search and incremental rewiring to rapidly find short, collision-free, and smooth paths.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # Constant for radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (2D or 3D)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free(grow_from_start: bool):\n            if random.random() < self.goal_sample_rate:\n                # Bias toward opposite tree root to encourage connection\n                return goal_position if grow_from_start else start_position\n            else:\n                for _ in range(100):  # Limit attempts to 100 for efficiency\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    # Quick boundary check\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback to root positions if sampling fails repeatedly\n                return goal_position if grow_from_start else start_position\n\n        def nearest(tree, point):\n            # Euclidean nearest node in tree\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def compute_radius(n):\n            # Adaptive neighbor radius based on number of nodes (as in RRT*)\n            # radius = \u03b3 * (log(n)/n)^(1/d), \u03b3 estimated by neighbor_radius_const, d dimension\n            d = 3 if is_3d else 2\n            if n <= 1:\n                return self.neighbor_radius_const\n            return min(self.neighbor_radius_const, \n                       self.neighbor_radius_const * ((math.log(n) / n) ** (1 / d)))\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Reject if out of bounds or in obstacle\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = compute_radius(n_nodes)\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path found through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, node.position)\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        # Alternate growth of trees from start and goal\n        for iteration in range(self.max_iter):\n            grow_start = (iteration % 2 == 0)\n            rand_point = sample_free(grow_start)\n\n            # Extend respective tree towards sample\n            tree_a = tree_start if grow_start else tree_goal\n            tree_b = tree_goal if grow_start else tree_start\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                # Swap and continue\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Trees connected successfully\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                extracted_path = path_a + path_b[::-1][1:]\n                break\n\n            # Swap to grow other tree next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 70.96357,
          "time_improvement": -244.0,
          "length_improvement": 11.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.027609086036682128,
                    "num_nodes_avg": 204.3,
                    "path_length_avg": 180.49303316131713,
                    "success_improvement": 0.0,
                    "time_improvement": -192.7525350200602,
                    "length_improvement": 9.79131683418436,
                    "objective_score": -55.86749713918118
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.05325424671173096,
                    "num_nodes_avg": 509.3,
                    "path_length_avg": 260.2796083827043,
                    "success_improvement": 0.0,
                    "time_improvement": -261.45871935244264,
                    "length_improvement": 13.630420287568977,
                    "objective_score": -75.71153174821899
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.10933144092559814,
                    "num_nodes_avg": 771.6,
                    "path_length_avg": 147.6395673342232,
                    "success_improvement": 0.0,
                    "time_improvement": -277.26586519041024,
                    "length_improvement": 9.340411699614483,
                    "objective_score": -81.31167721720017
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "path_expert",
          "algorithm_description": "This enhanced bidirectional RRT planner integrates informed sampling using a dynamically updated ellipsoid heuristic to minimize path length, plus nearest neighbor caching for efficiency. Both trees grow alternately with adaptive goal biasing toward the goal and start respectively. New nodes are connected only after rigorous collision and edge validity checks. After the trees connect, the path is extracted and refined using advanced shortcut and weighted smoothing techniques to improve smoothness and reduce length, thus improving planning efficiency, success rate, and path quality.",
          "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal. Sampling is biased inside an informed ellipsoid once a first solution is found to focus exploration around better paths. Each iteration extends the chosen tree toward a sampled point, validates the new node and edge, then tries to connect to the other tree efficiently. Upon connection, path extraction and smoothing refine the final path. The nearest neighbor search uses caching to speed up queries, and the path smoothing applies iterative shortcutting and weighted averaging for robustness.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, smoothing_iter: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling actual goal point\n        self.smoothing_iter = smoothing_iter      # Number of smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n        edges_set = set()\n\n        # Cache for faster nearest neighbor search (list is small at start, so brute-force ok)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._in_bounds(pos, bounds)\n\n        def collision_free_edge(p1, p2):\n            return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        # Informed sampling: sample inside ellipsoid defined by current best solution cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet, sample uniformly with goal biasing\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return uniform_sample()\n            else:\n                # Sample inside ellipsoid to focus search near current best path\n                return sample_in_ellipsoid(start, goal, c_best)\n        \n        def uniform_sample():\n            while True:\n                if is_3d:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]),\n                          random.uniform(0, bounds[2]))\n                else:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def sample_in_ellipsoid(start, goal, c_max):\n            # Following the Informed RRT* ellipse sampling method for heuristic bias\n            import numpy as np\n            a = c_max / 2.0       # Long axis radius\n            c_min = math.dist(start, goal)\n            if c_min == 0.0:\n                return goal  # Avoid degenerate case\n            b = math.sqrt(max(a*a - (c_min/2.0)**2, 0))  # Short axis radius\n\n            # Sample unit ball point in 2D or 3D inside unit n-ball\n            def sample_unit_ball(dim):\n                vec = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(vec)\n                r = random.random() ** (1/dim)\n                return r * vec / norm if norm > 0 else vec\n\n            dim = len(start)\n            x_ball = sample_unit_ball(dim)\n            # Scale to ellipse radii\n            L = np.diag([a] + [b]*(dim-1))\n            # Direction rotation matrix from unit vector e1 to vector from start to goal\n            start_np = np.array(start)\n            goal_np = np.array(goal)\n            diff = (goal_np - start_np)\n            e1 = diff / np.linalg.norm(diff)\n            # Create rotation matrix that aligns x-axis with e1\n            def rotation_to_align(e1):\n                d = len(e1)\n                import scipy.linalg\n                I = np.eye(d)\n                v = np.zeros(d)\n                v[0] = 1.0\n                if np.allclose(e1, v):\n                    return I\n                if np.allclose(e1, -v):\n                    # 180 deg rotation in any plane orthogonal to v\n                    R = -I\n                    R[0,0] = 1.0\n                    return R\n                a = v\n                b = e1\n                v_cross = np.cross(a, b) if d == 3 else None\n                if d == 3:\n                    s = np.linalg.norm(v_cross)\n                    c = np.dot(a, b)\n                    vx = np.array([[0, -v_cross[2], v_cross[1]],\n                                   [v_cross[2], 0, -v_cross[0]],\n                                   [-v_cross[1], v_cross[0], 0]])\n                    R = np.eye(3) + vx + vx.dot(vx) * ((1 - c) / (s**2))\n                    return R\n                else:\n                    # For 2D, rotation matrix:\n                    angle = math.atan2(e1[1], e1[0])\n                    R = np.array([[math.cos(angle), -math.sin(angle)],\n                                  [math.sin(angle), math.cos(angle)]])\n                    return R\n            R = rotation_to_align(e1)\n            sample = start_np + R.dot(L.dot(x_ball))\n            sample_tup = tuple(float(x) for x in sample)\n            # Clip sample inside bounds and valid position\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)) or self._is_in_obstacle(sample_tup, obstacles, is_3d):\n                # Fallback to uniform sample if not valid\n                return uniform_sample()\n            return sample_tup\n\n        def path_cost(node):\n            return node.cost\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def add_edge(n1, n2):\n            if (n1, n2) not in edges_set and (n2, n1) not in edges_set:\n                edges.append((n1, n2))\n                edges_set.add((n1, n2))\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            cur_pos = nearest_node.position\n            total_cost = nearest_node.cost\n            parent_node = nearest_node\n\n            while True:\n                next_pos = steer(cur_pos, new_node.position)\n                if not collision_free_edge(cur_pos, next_pos):\n                    return None\n                if not collision_free_node(next_pos):\n                    return None\n                next_cost = total_cost + math.dist(cur_pos, next_pos)\n                next_node = Node(next_pos, parent=parent_node, cost=next_cost)\n                parent_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                add_edge(parent_node, next_node)\n\n                if math.dist(next_pos, new_node.position) <= self.step_size:\n                    # Try final connection edge\n                    if collision_free_edge(next_pos, new_node.position) and collision_free_node(new_node.position):\n                        return next_node\n                    return None\n                parent_node = next_node\n                cur_pos = next_pos\n                total_cost = next_cost\n\n        def shortcut_path(path):\n            # Shortcut path using random pairs  - faster and better for length minimization\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if collision_free_edge(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def smooth_path_weighted(path):\n            # Smooth path by iterative weighted averaging to reduce sharp changes\n            if len(path) < 3:\n                return path\n            path_np = [list(p) for p in path]\n            alpha = 0.4\n            beta = 0.2\n            for _ in range(self.smoothing_iter):\n                new_path = [path_np[0]]\n                for i in range(1, len(path_np)-1):\n                    prev_p = path_np[i-1]\n                    curr_p = path_np[i]\n                    next_p = path_np[i+1]\n                    new_coords = [curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(len(curr_p))]\n                    # Only update if collision free with neighbors\n                    p_prev = tuple(new_coords)\n                    if collision_free_edge(path_np[i-1], p_prev) and collision_free_edge(p_prev, path_np[i+1]) and not self._is_in_obstacle(p_prev, obstacles, is_3d):\n                        new_path.append(new_coords)\n                    else:\n                        new_path.append(curr_p)\n                new_path.append(path_np[-1])\n                path_np = new_path\n            path_smoothed = [tuple(p) for p in path_np]\n            return path_smoothed\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        best_path = None\n\n        # Alternate tree growth with heuristic informed sampling after first solution\n        for itr in range(self.max_iter):\n            if len(tree_start) == 0 or len(tree_goal) == 0:\n                break\n\n            # Alternate expanding tree_start and tree_goal each iteration\n            extend_start_tree = (itr % 2 == 0)\n\n            # Sample point - informed sampling after first found solution\n            if extend_start_tree:\n                rand_point = informed_sample(c_best, c_min, start_position, goal_position)\n                nearest_node = nearest(tree_start, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_start.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_goal)\n                if connect_node:\n                    # path found\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    # Early break to find best feasible quickly\n                    extracted_path = best_path\n                    break\n\n            else:\n                rand_point = informed_sample(c_best, c_min, goal_position, start_position)\n                nearest_node = nearest(tree_goal, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_goal.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_start)\n                if connect_node:\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    extracted_path = best_path\n                    break\n\n        if success_state and best_path:\n            # Improve path by shortcut + smoothing\n            extracted_path = shortcut_path(best_path)\n            extracted_path = smooth_path_weighted(extracted_path)\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path if extracted_path else [],\n                             nodes=nodes,\n                             edges=edges)\n\n    def _path_length(self, path):\n        import math\n        length = 0.0\n        for i in range(len(path) - 1):\n            length += math.dist(path[i], path[i+1])\n        return length\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(pos)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
          "objective": 109.06939,
          "time_improvement": -371.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 0.9,
                    "time_avg": 0.09053049087524415,
                    "num_nodes_avg": 72.6,
                    "path_length_avg": 162.22412286628153,
                    "success_improvement": -9.999999999999998,
                    "time_improvement": -859.9387196347446,
                    "length_improvement": 18.92194260807031,
                    "objective_score": -259.1972273688093
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.04918806552886963,
                    "num_nodes_avg": 247.5,
                    "path_length_avg": 243.15743782945282,
                    "success_improvement": 0.0,
                    "time_improvement": -233.85985665576513,
                    "length_improvement": 19.312135745948165,
                    "objective_score": -66.29552984753991
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.03469226360321045,
                    "num_nodes_avg": 321.8,
                    "path_length_avg": 128.66844422598928,
                    "success_improvement": 0.0,
                    "time_improvement": -19.71128097164393,
                    "length_improvement": 20.989824127753838,
                    "objective_score": -1.7154194659424107
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "m3",
          "algorithm_description": "This algorithm is an improved RRT* variant that balances exploration and exploitation by biasing sampling toward the goal and dynamically adjusting the step size based on obstacle proximity. It incrementally builds a single tree rooted at the start, incorporating collision-checked nodes and edges, and applies a post-processing shortcut smoothing to improve path quality, smoothness, and reduce path length. This approach aims to enhance planning efficiency, robustness, and success rate while producing shorter and smoother paths.",
          "planning_mechanism": "The planner samples mostly randomly but biases sampling near the goal to accelerate convergence. It dynamically adjusts step sizes\u2014smaller near obstacles for precision, larger in free space for speed. It incrementally extends the tree by steering toward sampled points with collision checks on nodes and edges. Upon reaching close to the goal, it reconstructs the path and applies shortcut smoothing to refine it.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.1, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def adaptive_step(pos):\n            query_r = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dz = max(z - pz, 0, pz - (z + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_r:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_pos, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        n = len(path)\n        if n < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
          "objective": 146.53934,
          "time_improvement": -502.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.029899191856384278,
                    "num_nodes_avg": 377.1,
                    "path_length_avg": 163.43597517767063,
                    "success_improvement": 0.0,
                    "time_improvement": -217.03563817281366,
                    "length_improvement": 18.316270470552652,
                    "objective_score": -61.44743735773356
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.17256031036376954,
                    "num_nodes_avg": 1409.5,
                    "path_length_avg": 244.54989526735397,
                    "success_improvement": 0.0,
                    "time_improvement": -1071.238589342555,
                    "length_improvement": 18.85007125912084,
                    "objective_score": -317.60156255094233
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.09181842803955079,
                    "num_nodes_avg": 1019.0,
                    "path_length_avg": 126.36150399125684,
                    "success_improvement": 0.0,
                    "time_improvement": -216.8343744626728,
                    "length_improvement": 22.406424404297432,
                    "objective_score": -60.56902745794235
               }
          ],
          "success_rate": 1.0
     },
     {
          "operator": "e2",
          "algorithm_description": "This hybrid planner combines the strengths of sampling-based tree expansion with frontier-guided exploration and adaptive step sizing to efficiently explore the configuration space. It applies goal biasing for convergence, dynamically adjusts step sizes near obstacles for precision, and incorporates a frontier sampling strategy to focus sampling near obstacle boundaries. After initial path discovery, iterative shortcut smoothing refines the path to enhance smoothness and reduce length, boosting path quality and success rate.",
          "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling either toward the goal, near frontiers, or randomly in free space, using adaptive step sizes based on proximity to obstacles. It performs rigorous collision checks for nodes and edges before adding them. Upon finding a path to the goal, it executes a shortcut smoothing routine, producing a robust, efficient, and smooth path with improved planning performance.",
          "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            elif r < self.goal_sample_rate + self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                if all(0 <= nbr[i] <= steps[i] for i in range(dims)):\n                    yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        for cz in range(min_cells[2], max_cells[2]+1):\n                            if cz < 0 or cz > steps[2]:\n                                continue\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        occupied.add((cx, cy))\n\n        for ix in range(steps[0]+1):\n            if is_3d:\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontier_pos = tuple((pos_grid[d] + 0.5)*resolution for d in range(3))\n                            frontiers.append(frontier_pos)\n            else:\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontier_pos = ((ix + 0.5)*resolution, (iy + 0.5)*resolution)\n                        frontiers.append(frontier_pos)\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        dim = len(bounds)\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        return tuple(from_pos[d] + unit_vec[d] * step_size for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if self._in_bounds(p_j, bounds) and not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
          "objective": 154.51652,
          "time_improvement": -529.0,
          "length_improvement": 20.0,
          "other_inf": [
               {
                    "map_id": 0,
                    "success_rate": 1.0,
                    "time_avg": 0.030805325508117674,
                    "num_nodes_avg": 345.8,
                    "path_length_avg": 163.60662082009756,
                    "success_improvement": 0.0,
                    "time_improvement": -226.6438129330896,
                    "length_improvement": 18.23098341862772,
                    "objective_score": -64.34694719620133
               },
               {
                    "map_id": 1,
                    "success_rate": 1.0,
                    "time_avg": 0.17162775993347168,
                    "num_nodes_avg": 1382.6,
                    "path_length_avg": 242.5890407852697,
                    "success_improvement": 0.0,
                    "time_improvement": -1064.9089817510392,
                    "length_improvement": 19.50074911493595,
                    "objective_score": -315.57254470232454
               },
               {
                    "map_id": 2,
                    "success_rate": 1.0,
                    "time_avg": 0.11421992778778076,
                    "num_nodes_avg": 1022.1,
                    "path_length_avg": 125.31142432665688,
                    "success_improvement": 0.0,
                    "time_improvement": -294.1343817847203,
                    "length_improvement": 23.051236576225087,
                    "objective_score": -83.63006722017107
               }
          ],
          "success_rate": 1.0
     }
]