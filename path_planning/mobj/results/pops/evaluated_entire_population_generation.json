{
    "operator": "e1",
    "algorithm_description": "This algorithm, named Informed Batch Informed Tree (IBIT*), combines the advantages of sampling-based batch processing and informed heuristic guidance. It incrementally samples batches of points within an informed set and builds a single-tree structure that rewires to improve path quality dynamically. The planner prioritizes node expansions by heuristic costs, prunes unpromising nodes early using cost-to-come and cost-to-go estimates, and smooths the final path by shortcutting. It is designed to improve planning efficiency, path length, and robustness, especially in cluttered environments.",
    "planning_mechanism": "The planner iteratively samples a batch of points confined to an ellipsoidal informed subset bounded by the current best cost. It then constructs a tree by connecting the best candidate nodes first using a prioritized search queue sorted by estimated total cost (cost-to-come + heuristic to goal). Nodes and edges are added only if collision-free. Rewiring of nearby nodes reduces path cost dynamically. After each batch, pruning removes nodes outside the informed set or with costs exceeding the current best path. Once a path connects start and goal, path shortcuts are applied to enhance smoothness before termination.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True               # Flag for pruning/validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def disconnect(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, batch_size: int = 100, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import heapq\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def heuristic(pos):\n            return math.dist(pos, goal_pos)\n\n        # Ellipsoidal informed sampler parameters\n        c_best = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        x_center = [(s + g) * 0.5 for s, g in zip(start_pos, goal_pos)]\n        a1 = [g - s for s, g in zip(start_pos, goal_pos)]\n        a1_norm = math.sqrt(sum(x * x for x in a1))\n        if a1_norm != 0:\n            a1 = [x / a1_norm for x in a1]\n        else:\n            a1 = [1.0] + [0.0] * (dim - 1)\n\n        # Nodes and edges containers\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos)\n        nodes.append(start_node)\n\n        # Holds unexplored nodes, sorted by estimated total cost f = g + h\n        open_queue = []\n        heapq.heappush(open_queue, (heuristic(start_node.position), start_node))\n\n        # Sampled points not yet connected in the tree\n        sampled_points = set()\n\n        success_state = False\n        extracted_path = []\n\n        def rotate_to_world_frame(x_ball):\n            import numpy as np\n            a1_vec = np.array(a1).reshape((dim, 1))\n            id_mat = np.eye(dim)\n            M = a1_vec @ id_mat[0].reshape((1, dim))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n            return C @ x_ball\n\n        def informed_sample():\n            import numpy as np\n            import random as rnd\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                while True:\n                    sample = tuple(rnd.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) * 0.5\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    x_ball = x_ball / np.linalg.norm(x_ball)\n                    radius = np.random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    x_rand = rotate_to_world_frame(x_ball) + np.array(x_center)\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        sample = tuple(x_rand)\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, node, radius):\n            result = []\n            for n in tree:\n                if n.valid and math.dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        def try_rewire(new_node, near_nodes_list):\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire\n                        if near.parent:\n                            near.disconnect()\n                        near.parent = new_node\n                        new_node.children.append(near)\n                        near.cost = cost_through_new\n\n        def prune_nodes():\n            # Mark nodes as invalid if cost + heuristic >= c_best or outside informed subset\n            heapq.heapify(open_queue)  # Rebuild priority queue\n            new_queue = []\n            for f_cost, node in open_queue:\n                if node.valid and node.cost + heuristic(node.position) < c_best:\n                    heapq.heappush(new_queue, (f_cost, node))\n                else:\n                    node.valid = False\n                    # Disconnect subtree recursively\n                    self._prune_subtree(node)\n            open_queue.clear()\n            open_queue.extend(new_queue)\n\n        def path_smoothing(path_pts):\n            # Shortcut smoothing by random shortcuts\n            import random\n            smoothed = path_pts[:]\n            iteration = 0\n            max_iter_smooth = 100\n            while iteration < max_iter_smooth:\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible, remove intermediate points\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n                iteration += 1\n            return smoothed\n\n        iter_count = 0\n        samples_pool = set()\n\n        while iter_count < self.max_iter:\n            # Sample a batch of points inside informed set\n            for _ in range(self.batch_size):\n                sample = informed_sample()\n                samples_pool.add(sample)\n\n            # For each sample, try to connect it to the tree with minimal cost\n            for sample in list(samples_pool):\n                if any(math.dist(sample, n.position) < 1e-6 for n in nodes if n.valid):\n                    samples_pool.remove(sample)\n                    continue\n                # Find nearest node in tree\n                nearest = min((n for n in nodes if n.valid), key=lambda n: math.dist(n.position, sample))\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    samples_pool.remove(sample)\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    samples_pool.remove(sample)\n                    continue\n\n                new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                est_total_cost = new_cost + heuristic(new_pos)\n                if est_total_cost >= c_best:\n                    samples_pool.remove(sample)\n                    continue  # Prune non-promising samples\n\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                heapq.heappush(open_queue, (est_total_cost, new_node))\n                samples_pool.remove(sample)\n\n                # Rewire nearby nodes to improve costs\n                near = near_nodes(nodes, new_node, self.rewire_radius)\n                try_rewire(new_node, near)\n\n                # Check if goal can be reached from new node\n                dist_to_goal = math.dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node.parent = new_node\n                        goal_node.cost = new_node.cost + dist_to_goal\n                        new_node.children.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        if goal_node.cost < c_best:\n                            c_best = goal_node.cost\n                            # Extract path and prune tree\n                            extracted_path = goal_node.path_from_root()\n                            prune_nodes()\n                            success_state = True\n\n            # If goal found, we may stop early but try to smooth path first\n            if success_state:\n                extracted_path = path_smoothing(extracted_path)\n                break\n\n            iter_count += 1\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _prune_subtree(self, node):\n        node.valid = False\n        for child in node.children[:]:\n            self._prune_subtree(child)\n        node.children.clear()\n        node.disconnect()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 959.99122,
    "time_improvement": -3209.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5231126070022583,
            "num_nodes_avg": 809.7,
            "path_length_avg": 164.00869971204878,
            "success_improvement": 0.0,
            "time_improvement": -4923.613413439082,
            "length_improvement": 18.03002825301048,
            "objective_score": -1473.4780183811224
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.6704604864120484,
            "num_nodes_avg": 1087.8,
            "path_length_avg": 231.9158381367891,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4256.248295989689,
            "length_improvement": 23.042478844217857,
            "objective_score": -1277.2659930280631
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15846560001373292,
            "num_nodes_avg": 502.3,
            "path_length_avg": 122.15836719258887,
            "success_improvement": 0.0,
            "time_improvement": -447.42374687743745,
            "length_improvement": 24.987403599900297,
            "objective_score": -129.22964334325118
        }
    ]
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines RRT (Rapidly-exploring Random Tree) sampling with informed sampling and local rewiring inspired by RRT*. It employs goal biasing, adaptive sampling within an informed subset to accelerate convergence toward the goal, and rewires nodes locally to improve path quality dynamically. The algorithm balances exploration with exploitation, enhancing planning efficiency, path optimality, smoothness, robustness, and success rate.",
    "planning_mechanism": "The planner incrementally builds a tree by randomly sampling points with goal biasing and adaptive sampling near the current best path. For each sample, it finds the nearest node and steers towards the sample with a fixed step size. When adding nodes, it performs collision checks on nodes and edges. It also locally rewires the tree within a defined radius to reduce path cost, improving path quality dynamically while ensuring obstacle avoidance and search efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(len(bounds)))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return from_pos\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(bounds)))\n            # Ensure new_pos within bounds:\n            new_pos = tuple(\n                min(max(new_pos[d], 0), bounds[d]) for d in range(len(bounds))\n            )\n            return new_pos\n\n        def get_nearest_node(pos):\n            return min(nodes, key=lambda n: dist(n.position, pos))\n\n        def get_nearby_nodes(pos, radius):\n            return [n for n in nodes if dist(n.position, pos) <= radius]\n\n        # Lower bound on heuristic cost (Euclidean distance)\n        def heuristic(pos):\n            return dist(pos, goal_position)\n\n        best_goal_node = None\n        best_cost = math.inf\n\n        for iteration in range(self.max_iter):\n            # Informed sampling: sample uniformly in the space,\n            # but bias more toward the region inside an ellipse defined by current best cost if found\n            if best_goal_node is not None and random.random() > self.goal_sample_rate:\n                c_best = best_cost\n                c_min = dist(start_position, goal_position)\n                if c_best < math.inf:\n                    # Sample in prolate hyperspheroid (ellipse in 2D/3D)\n                    # Adapted from Informed RRT*\n                    import numpy as np\n\n                    dim = len(bounds)\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n                    # Construct rotation matrix C to align x axis with a1\n                    # Using Gram-Schmidt or for 2D/3D simplified approach\n                    def rotation_matrix(direction):\n                        # direction: unit vector a1\n                        # returns orthonormal rotation matrix with a1 as first column\n                        import numpy as np\n                        if dim == 2:\n                            dx, dy = direction\n                            c = dx\n                            s = dy\n                            return np.array([[c, -s],\n                                             [s,  c]])\n                        elif dim == 3:\n                            dx, dy, dz = direction\n                            x_axis = np.array(direction)\n                            x_axis /= np.linalg.norm(x_axis)\n                            # Create arbitrary vector not colinear with x_axis\n                            if abs(x_axis[0]) < 1/64:\n                                v = np.array([1,0,0])\n                            else:\n                                v = np.array([0,1,0])\n                            y_axis = np.cross(v, x_axis)\n                            y_axis /= np.linalg.norm(y_axis)\n                            z_axis = np.cross(x_axis, y_axis)\n                            return np.column_stack((x_axis, y_axis, z_axis))\n                        else:\n                            return np.identity(dim)\n\n                    try:\n                        C = rotation_matrix(np.array(a1))\n                    except Exception:\n                        C = np.identity(dim)\n\n                    # Radii of ellipse axes\n                    r1 = c_best / 2.0\n                    r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                    r = [r1] + [r2] * (dim -1)\n\n                    # Sample random point in unit ball\n                    def sample_unit_ball(dim):\n                        import random as rnd\n                        import numpy as np\n                        while True:\n                            x = np.array([rnd.uniform(-1,1) for _ in range(dim)])\n                            if np.linalg.norm(x) <= 1:\n                                return x\n\n                    x_ball = sample_unit_ball(dim)\n                    # Scale to ellipsoid\n                    x_ellipsoid = np.multiply(x_ball, r)\n                    # Rotate and translate\n                    sample_np = np.dot(C, x_ellipsoid) + np.array(center)\n                    sample = tuple(float(sample_np[d]) for d in range(dim))\n\n                    # Clip sample inside bounds\n                    sample = tuple(\n                        min(max(sample[d], 0), bounds[d]) for d in range(dim)\n                    )\n                else:\n                    # If somehow best_cost invalid, fallback uniform sampling\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = get_nearest_node(sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node with cost updated\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring: try to connect new_node to better parents within radius\n            near_nodes = get_nearby_nodes(new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n\n                tentative_cost = near_node.cost + dist(near_node.position, new_pos)\n                if tentative_cost < new_node.cost:\n                    # Check edge collision before rewiring\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        # Rewire parent\n                        # Remove from old parent's children\n                        if new_node.parent:\n                            new_node.parent.remove_child(new_node)\n                        new_node.parent = near_node\n                        new_node.cost = tentative_cost\n                        near_node.add_child(new_node)\n\n            # After adding new_node, try to rewire neighbors to new_node if better\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    # Check edge collision before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node's parent to new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n\n            # Check if we can connect goal directly from new_node\n            dist_to_goal = dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_cost < best_cost:\n                        best_cost = goal_cost\n                        best_goal_node = goal_node\n                    success_state = True\n                    break\n\n        # If success, extract best path\n        if success_state and best_goal_node is not None:\n            path = []\n            node = best_goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Optional path smoothing: shortcutting between non-adjacent nodes to improve smoothness and shorten path\n            def path_smoothing(path, obstacles, is_3d, max_iter=50):\n                import random\n                smoothed = path[:]\n                for _ in range(max_iter):\n                    if len(smoothed) <= 2:\n                        break\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) -1)\n                    p1 = smoothed[i]\n                    p2 = smoothed[j]\n                    # Check collision between p1 and p2\n                    if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                        del smoothed[i+1:j]\n                return smoothed\n\n            extracted_path = path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 365.93084,
    "time_improvement": -1236.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10679264068603515,
            "num_nodes_avg": 296.1,
            "path_length_avg": 163.7906716695946,
            "success_improvement": 0.0,
            "time_improvement": -925.5630145893817,
            "length_improvement": 18.138996573053255,
            "objective_score": -274.0411050622039
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.367946720123291,
            "num_nodes_avg": 881.8,
            "path_length_avg": 225.03990649421993,
            "success_improvement": 0.0,
            "time_improvement": -2290.696103702969,
            "length_improvement": 25.324145586342734,
            "objective_score": -682.1440019936222
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1709836721420288,
            "num_nodes_avg": 524.5,
            "path_length_avg": 117.30990143191698,
            "success_improvement": 0.0,
            "time_improvement": -490.6677692239902,
            "length_improvement": 27.964653653444294,
            "objective_score": -141.60740003650818
        }
    ]
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed sampling, adaptive step sizing near obstacles, node rejection, rewiring, and pruning techniques. It grows two trees from start and goal, leveraging fast convergence and asymptotic optimality while improving efficiency and path smoothness by focusing exploration within an informed subset and adaptively adjusting expansion steps. The planner performs aggressive pruning and connection attempts to maintain high success rates, shorter path lengths, and faster convergence.",
    "planning_mechanism": "The planner alternates growth between two trees, sampling points informed by current best path cost. For each sample, it uses adaptive step sizes near obstacles, rejects nodes unlikely to improve path cost, and rewires to optimize path quality. It attempts connection between the trees after each extension, updating the best solution and pruning nodes that cannot contribute to a better path. The final path is extracted from the connected trees once a successful path is found or the iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, pruning_gap: float = 1e-5):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.pruning_gap = pruning_gap  # tiny margin to prevent float precision issues\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n\n        for i in range(self.max_iter):\n            # Alternate growing trees\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check - ensure new_pos inside map limits\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision and edge collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes that cannot improve best found path\n            heuristic_to_goal = math.dist(new_pos, goal_position)\n            if new_cost + heuristic_to_goal >= c_best - self.pruning_gap:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in tree_a if better path found through new_node\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node.parent]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + math.dist(near.position, goal_position) >= c_best - self.pruning_gap:\n                    continue  # skip nodes that cannot improve final path\n                if potential_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node to new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                    new_node.add_child(near)\n                    near.cost = potential_cost\n                    edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_dist = math.dist(new_node.position, other_nearest.position)\n\n            if connect_dist <= self.base_step:\n                # Check edge collision\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    # Compute total path cost\n                    connect_cost = new_node.cost + connect_dist + other_nearest.cost\n                    if connect_cost < c_best - self.pruning_gap:\n                        c_best = connect_cost\n                        # Extract path from start to goal by joining new_node and other_nearest\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        extracted_path = path_a + path_b[::-1]\n                        success_state = True\n                        # Prune nodes that cannot improve this path\n                        self._prune(tree_a, c_best, goal_position, obstacles, is_3d)\n                        self._prune(tree_b, c_best, goal_position, obstacles, is_3d)\n                        if success_state and c_best <= c_min + 1e-3:\n                            # Found near optimal path, stop early\n                            break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            # Uniform sampling inside bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Ellipsoidal sampling inside prolate hyperspheroid as per informed RRT*\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Degenerate: start == goal\n            return tuple(x_center)\n\n        a1_unit = a1 / norm_a1\n        # Create rotation matrix C that aligns x-axis with vector a1\n        # Start with identity matrix\n        I = np.eye(dim)\n        # Using SVD for rotation matrix construction from a1_unit\n        M = np.outer(a1_unit, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            # Numerical stability safeguard\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample random point in unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            scale = random.random() ** (1 / dim)\n            x_ball *= scale\n            # Map to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            # Check bounds\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        # Check collisions along path with finer resolution\n        close_to_obstacle = False\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                close_to_obstacle = True\n                break\n        if close_to_obstacle:\n            # Reduce step size near obstacles, with a minimum step size\n            return max(self.base_step * 0.3, 1.0)\n        else:\n            return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _prune(self, tree, c_best, goal_position, obstacles, is_3d):\n        '''Prune nodes that cannot possibly improve current best path cost'''\n        import math\n        to_remove = []\n        for node in tree:\n            h_cost = math.dist(node.position, goal_position)\n            if node.cost + h_cost >= c_best - self.pruning_gap:\n                # Mark subtree for removal if root node of that subtree is not start or goal\n                if node.parent is not None:\n                    to_remove.append(node)\n        # Remove nodes marked for pruning\n        for node in to_remove:\n            # Disconnect from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        '''Helper to recursively remove subtree nodes from tree'''\n        for child in node.children[:]:\n            self._remove_subtree(child, tree)\n        if node in tree:\n            tree.remove(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10081.78129,
    "time_improvement": -33623.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.0333144903182983,
            "num_nodes_avg": 1931.2,
            "path_length_avg": 152.77535081474505,
            "success_improvement": 0.0,
            "time_improvement": -38126.33914621541,
            "length_improvement": 23.644348062585905,
            "objective_score": -11433.172874252105
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 6.709124517440796,
            "num_nodes_avg": 3120.0,
            "path_length_avg": 230.3338052876067,
            "success_improvement": 0.0,
            "time_improvement": -47982.939848711896,
            "length_improvement": 23.5674508661299,
            "objective_score": -14390.168464440343
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.248104596138001,
            "num_nodes_avg": 2744.4,
            "path_length_avg": 116.27889240935409,
            "success_improvement": 0.0,
            "time_improvement": -14759.073638879116,
            "length_improvement": 28.597755302326387,
            "objective_score": -4422.002540603269
        }
    ]
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an improved RRT* variant that combines bidirectional tree growth with goal biasing and adaptive rewiring. It incrementally builds two trees from start and goal, samples the space with increased focus near the goal, rewires neighbors within a dynamic radius to optimize the path cost, and performs shortcut smoothing to improve path quality and reduce length.",
    "planning_mechanism": "The planner grows two trees progressively closer, rewiring nodes within a radius that shrinks over iterations to balance exploration and exploitation, uses goal-biased sampling to enhance success rate, connects the trees when possible, and finally extracts and smooths the path to provide a high-quality solution efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius_constant: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant  # Used to scale rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        dim = len(bounds)\n        free_space_volume = 1\n        for b in bounds:\n            free_space_volume *= b\n        # Neighbor radius shrink function: r = r0 * (log(n)/n)^(1/d)\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_constant\n            return min(self.neighbor_radius_constant,\n                       self.neighbor_radius_constant * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample():\n            # Goal biasing sampling with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    # Rewire\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree_a, point):\n            nearest_node = nearest(tree_a, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            neighbors = near_nodes(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            # Choose best parent minimizing cost + collision check\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and collision_free(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n            return new_node\n\n        def connect_trees(new_node_a, tree_b):\n            nearest_node_b = nearest(tree_b, new_node_a.position)\n            current_node = nearest_node_b\n            while True:\n                next_pos = steer(current_node.position, new_node_a.position)\n                if not collision_free(current_node.position, next_pos):\n                    return None\n                new_node_b = Node(next_pos)\n                neighbors = near_nodes(tree_b, next_pos, neighbor_radius(len(tree_b)))\n\n                min_cost = current_node.cost + math.dist(current_node.position, next_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + math.dist(neighbor.position, next_pos)\n                    if c < min_cost and collision_free(neighbor.position, next_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_b)\n                new_node_b.cost = min_cost\n                new_node_b.parent = best_parent\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent, new_node_b))\n\n                rewire(tree_b, new_node_b, neighbors)\n\n                if math.dist(new_node_b.position, new_node_a.position) <= self.step_size:\n                    return new_node_b\n\n                current_node = new_node_b\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicate connection node\n\n            # Perform simple shortcut smoothing on path\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for iter_num in range(self.max_iter):\n            rnd = sample()\n            new_node_start = extend(tree_start, rnd)\n            if not new_node_start:\n                continue\n            new_node_goal = connect_trees(new_node_start, tree_goal)\n            if new_node_goal:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.57608,
    "time_improvement": -144.0,
    "length_improvement": 27.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023780679702758788,
            "num_nodes_avg": 76.3,
            "path_length_avg": 157.68258133234144,
            "success_improvement": 0.0,
            "time_improvement": -199.68812345263564,
            "length_improvement": 21.191761415721647,
            "objective_score": -55.66808475264636
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0432955265045166,
            "num_nodes_avg": 280.9,
            "path_length_avg": 243.4860629831869,
            "success_improvement": 0.0,
            "time_improvement": -210.2902906665801,
            "length_improvement": 19.203086802055434,
            "objective_score": -59.246469839562934
        },
        {
            "map_id": 2,
            "success_rate": 0.4,
            "time_avg": 0.034473729133605954,
            "num_nodes_avg": 182.5,
            "path_length_avg": 94.76986278983743,
            "success_improvement": -60.0,
            "time_improvement": -20.58264296710426,
            "length_improvement": 41.80559521445381,
            "objective_score": -27.813673847240516
        }
    ]
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced RRT* planner with adaptive step sizing and dynamic rewiring radius to balance exploration and exploitation. It applies goal biasing and includes post-smoothing of the final path for better smoothness and shorter path length. The planner prioritizes planning efficiency and path quality by tuning parameters and leveraging an informed rewiring neighborhood based on node density and iteration progress.",
    "planning_mechanism": "The planner incrementally builds a tree from the start position by sampling the space with goal biasing. For each sampled point, it extends towards it using an adaptive step size, selects the best parent among near nodes within a dynamically computed radius, adds the new node ensuring collision-free placement and edges, and performs rewiring to optimize local paths. After reaching the goal, it extracts and smooths the resulting path to improve quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive rewiring radius based on space and iteration\n        def calc_neighbor_radius():\n            unit_ball_volume = math.pi if dim == 2 else (4/3)*math.pi\n            gamma_rrt_star = (2 * (1 + 1/dim)) ** (1/dim) * (bounds[0] * bounds[1] * (bounds[2] if is_3d else 1)) ** (1/dim) if is_3d else (bounds[0]*bounds[1]) ** (1/dim)\n            radius = min(self.step_size * 5, gamma_rrt_star * ((math.log(len(nodes)+1) / (len(nodes)+1)) ** (1/dim)))\n            return max(radius, self.step_size*1.5)\n\n        def is_in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n\n            # Adaptive step size: smaller near obstacles or near goal for finer search\n            adaptive_step = self.step_size\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            if dist_to_goal < self.step_size * 5:\n                adaptive_step = max(self.step_size * 0.3, dist_to_goal / 2)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(adaptive_step, dist_to_sample) for d in range(dim))\n\n            if not is_in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n\n            # Compute neighbor radius dynamically\n            neighbor_radius = calc_neighbor_radius()\n\n            # Find neighbors within radius for better parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to improve cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if goal can be connected safely\n            if math.dist(new_position, goal_position) <= neighbor_radius:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            # Extract path backwards\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Post-process path smoothing to improve smoothness & length\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p1 = path[i]\n            p2 = path[j]\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate points between i+1 and j-1\n                del path[i+1:j]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 520.47248,
    "time_improvement": -1751.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.15365190505981446,
            "num_nodes_avg": 241.0,
            "path_length_avg": 162.37261706459378,
            "success_improvement": 0.0,
            "time_improvement": -1836.3471384275172,
            "length_improvement": 18.847726635005362,
            "objective_score": -547.134596201254
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4232297420501709,
            "num_nodes_avg": 949.6,
            "path_length_avg": 223.79051507525915,
            "success_improvement": 0.0,
            "time_improvement": -2933.2020483869037,
            "length_improvement": 25.73873592794681,
            "objective_score": -874.8128673304818
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.16712868213653564,
            "num_nodes_avg": 518.3,
            "path_length_avg": 114.76511089943169,
            "success_improvement": 0.0,
            "time_improvement": -484.58480454866145,
            "length_improvement": 29.527308341151148,
            "objective_score": -139.4699796963682
        }
    ]
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner that grows two trees from start and goal simultaneously, while incrementally optimizing discovered paths through rewiring. It balances exploration speed and path optimality by attempting to connect the two trees frequently, pruning suboptimal paths and ensuring collision-free expansions.",
    "planning_mechanism": "The planner alternates extending two trees sampled in free space with a fixed step size. For each new node, it chooses the best parent among nearby nodes within a radius, rewires neighbors to improve path costs if possible, and attempts to connect the two trees for early successful path discovery. Collision checks are enforced on nodes and edges throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        success = False\n        final_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def connect_path(node_a, node_b):\n            path_a, path_b = [], []\n            while node_a:\n                path_a.append(node_a.position)\n                node_a = node_a.parent\n            while node_b:\n                path_b.append(node_b.position)\n                node_b = node_b.parent\n            return list(reversed(path_a)) + path_b\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost = near_node.cost + distance(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n                # Attempt connection\n                other_nearest = nearest(tree_b, new_node.position)\n                if distance(new_node.position, other_nearest.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        success = True\n                        final_path = connect_path(new_node, other_nearest)\n                        return PlannerResult(success, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(success, final_path, start_tree + goal_tree, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 52.73777,
    "time_improvement": -188.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030731558799743652,
            "num_nodes_avg": 141.4,
            "path_length_avg": 171.36498341999362,
            "success_improvement": 0.0,
            "time_improvement": -287.2842703651179,
            "length_improvement": 14.35342836067697,
            "objective_score": -83.31459543739997
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.049118781089782716,
            "num_nodes_avg": 276.7,
            "path_length_avg": 241.79578195505002,
            "success_improvement": 0.0,
            "time_improvement": -252.02437969998687,
            "length_improvement": 19.763979231943463,
            "objective_score": -71.65451806360736
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0357271671295166,
            "num_nodes_avg": 221.4,
            "path_length_avg": 128.27818950325494,
            "success_improvement": 0.0,
            "time_improvement": -24.96693414014588,
            "length_improvement": 21.229464036852754,
            "objective_score": -3.2441874346732122
        }
    ]
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an informed variant of RRT* that uses heuristic-guided sampling restricted to an ellipsoidal subset between start and goal to improve sampling efficiency and path quality. It incrementally rewires nodes to optimize path costs for smoother, shorter, and more robust paths with improved success rate and reduced search time.",
    "planning_mechanism": "The planner samples points informed by an ellipsoidal heuristic defined by start, goal, and current best path cost. It grows a single tree from the start, steering toward sampled points. For each new node, it performs local rewiring of neighboring nodes to improve costs, ensuring collision-free nodes and edges. The algorithm terminates early when a path reaches the goal within the step size, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import math\n        import random\n\n        nodes: list[Node] = []\n        edges: list[tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        min_cost_to_goal = float('inf')\n\n        # Precompute Euclidean distance between start and goal for heuristic\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        dim = len(bounds)\n\n        def sample_informed():\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal and c_best\n            # Following method from Informed RRT*: transform unit ball sample to ellipsoid\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))  # unit vector from start to goal\n            # Center of ellipse\n            center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n            while True:\n                # Sample unit ball\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x_i**2 for x_i in x))\n                if norm == 0:\n                    continue\n                x_unit = [x_i / norm for x_i in x]\n                r = random.uniform(0,1) ** (1/dim)  # Radius for uniform distribution inside unit ball\n                x_ball = [r * x_i for x_i in x_unit]\n\n                # Define ellipse radii\n                L1 = c_best / 2\n                if dim == 2:\n                    # Radii perpendicular to axis\n                    L2 = math.sqrt(c_best**2 - c_min**2) / 2\n                    radii = [L1, L2]\n                elif dim == 3:\n                    L2 = math.sqrt(c_best**2 - c_min**2) / 2\n                    L3 = L2\n                    radii = [L1, L2, L3]\n                else:\n                    radii = [L1] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n\n                # Build rotation matrix aligning x-axis with a1\n                # Using Householder transform or simple rotation for 2D/3D:\n                # For simplicity consider rotation matrix R where R * e1 = a1\n                # For 2D:\n                if dim == 2:\n                    cos_theta = a1[0]\n                    sin_theta = a1[1]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                    x_ellipsoid = [sum(R[i][j]*x_ball[j]*radii[j] for j in range(dim)) for i in range(dim)]\n                elif dim == 3:\n                    # Construct rotation matrix R via cross product trick\n                    import numpy as np\n                    e1 = np.array([1.0,0.0,0.0])\n                    a1_np = np.array(a1)\n                    v = np.cross(e1, a1_np)\n                    s = np.linalg.norm(v)\n                    if s < 1e-10:  # vectors aligned\n                        R = np.eye(3)\n                    else:\n                        c = np.dot(e1, a1_np)\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(3) + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n                    x_ball_np = np.array(x_ball)\n                    radii_np = np.array(radii)\n                    x_ellipsoid_np = R @ (x_ball_np * radii_np)\n                    x_ellipsoid = x_ellipsoid_np.tolist()\n                else:\n                    # For higher dims, just scale without rotation (conservative)\n                    x_ellipsoid = [x_ball[d] * radii[d] for d in range(dim)]\n\n                sample = tuple(center[d] + x_ellipsoid[d] for d in range(dim))\n\n                # Check bounds and collision\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n                return sample\n\n        def nearest_node(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(new_pos):\n            return [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n        def path_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return list(reversed(path))\n\n        for _ in range(self.max_iter):\n            sample = sample_informed()\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Choose parent for new node among nearby nodes with lowest cost reachable via collision free edge\n            neighbors = near_nodes(new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for n in neighbors:\n                # Check collision edge from n to new_pos\n                if self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = n.cost + math.dist(n.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if it improves their cost and path is collision-free\n            for n in neighbors:\n                if n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new < n.cost:\n                    if self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        continue\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Check if new_node can connect to goal within step_size\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < min_cost_to_goal:\n                        min_cost_to_goal = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = min_cost_to_goal\n                        # Can terminate early or continue to improve\n                        # Here: early terminate after first found path\n                        break\n\n        success_state = best_goal_node is not None\n\n        if success_state:\n            extracted_path = path_to_root(best_goal_node)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 664.88669,
    "time_improvement": -2231.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.3563659429550171,
            "num_nodes_avg": 760.1,
            "path_length_avg": 161.45612900235434,
            "success_improvement": 0.0,
            "time_improvement": -4572.229950017661,
            "length_improvement": 19.305778559690552,
            "objective_score": -1367.80782929336
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.29879083633422854,
            "num_nodes_avg": 1037.8,
            "path_length_avg": 233.16630915481664,
            "success_improvement": 0.0,
            "time_improvement": -1754.5966848048874,
            "length_improvement": 22.627530255118966,
            "objective_score": -521.8534993904425
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13177933692932128,
            "num_nodes_avg": 656.1,
            "path_length_avg": 122.48397517594238,
            "success_improvement": 0.0,
            "time_improvement": -366.5207600424046,
            "length_improvement": 24.787460683166316,
            "objective_score": -104.99873587608812
        }
    ],
    "success_rate": 22.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the bidirectional search strategy of the dual-tree RRT with the rewiring and path optimization features of RRT*, aiming to balance rapid exploration (via two trees from start and goal) and gradual path quality improvement (via rewiring). It alternates growth between the two trees, extends nodes toward samples, attempts to connect trees efficiently, and locally optimizes paths through rewiring nearby nodes to ensure better cost and smoother paths, thus improving efficiency, robustness, and final path quality.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling points with goal bias, extending towards them with collision checks. After each extension, it performs rewiring locally to improve costs. It attempts to connect the two trees whenever new nodes are added, ensuring a collision-free connection. Once connected, it extracts the path by linking nodes from both trees, yielding efficient, high-quality, and smooth paths with reduced redundant search.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                # In case not found due to rewiring elsewhere\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_p, to_p, max_dist):\n            dist = _distance(from_p, to_p)\n            if dist <= max_dist:\n                return to_p\n            ratio = max_dist / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = _distance(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _rewire(tree, new_node):\n            near_nodes = _near(tree, new_node.position, self.neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + _distance(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not _is_edge_in_obstacle(new_node.position, near_node.position):\n                    # Update edges list safely\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n        def _connect_trees(node_a, tree_b):\n            connect_node = _nearest(tree_b, node_a.position)\n            if _is_edge_in_obstacle(node_a.position, connect_node.position):\n                return False, None, None\n            # Attempt to connect by extending from connect_node towards node_a with step_size increments\n            curr = connect_node\n            path_nodes = []\n            while True:\n                new_pos = _steer(curr.position, node_a.position, self.step_size)\n                if _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr.position, new_pos):\n                    return False, None, None\n                new_cost = curr.cost + _distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                path_nodes.append(new_node)\n                if _distance(new_pos, node_a.position) < self.step_size:\n                    final_cost = new_node.cost + _distance(new_pos, node_a.position)\n                    final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return True, final_node, node_a\n                curr = new_node\n\n        def _extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Goal biasing: sample from the opposite tree root position\n                # Alternate biases on each tree expansion step below\n                return None\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not _is_in_obstacle(p):\n                    return p\n\n        # Main loop alternating start and goal tree expansion\n        for i in range(self.max_iter):\n            # Alternate trees: expand start_tree in even iterations, goal_tree in odd\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            # Sample with bias: sample goal if expanding start_tree, sample start if expanding goal_tree, else random\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n                if _is_in_obstacle(sample):\n                    continue\n            else:\n                sample = None\n                while sample is None:\n                    sample = _sample_free()\n            \n            nearest = _nearest(tree_a, sample)\n            new_pos = _steer(nearest.position, sample, self.step_size)\n            if new_pos == nearest.position:\n                continue\n            if _is_in_obstacle(new_pos) or _is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + _distance(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            # Choose best parent from near nodes\n            near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n            min_cost = new_cost\n            best_parent = nearest\n            for near in near_nodes:\n                if not _is_edge_in_obstacle(near.position, new_pos):\n                    cost_through_near = near.cost + _distance(near.position, new_pos)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring to improve paths locally\n            _rewire(tree_a, new_node)\n\n            # Try to connect trees\n            connected, node_from_b, node_from_a = _connect_trees(new_node, tree_b)\n            if connected:\n                # Grab the nodes from both trees that form the connection and extract path\n                success_state = True\n                # For consistent path extraction, node_from_a belongs to tree_a and node_from_b to tree_b \n                if tree_a is start_tree:\n                    extracted_path = _extract_path(node_from_a, node_from_b)\n                else:\n                    extracted_path = _extract_path(node_from_b, node_from_a)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 32.40101,
    "time_improvement": -119.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02413814067840576,
            "num_nodes_avg": 94.7,
            "path_length_avg": 168.54215785312175,
            "success_improvement": 0.0,
            "time_improvement": -216.46947763923316,
            "length_improvement": 15.764249447420628,
            "objective_score": -61.78799340228583
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0384462833404541,
            "num_nodes_avg": 216.1,
            "path_length_avg": 247.13734395299213,
            "success_improvement": 0.0,
            "time_improvement": -138.63633336638367,
            "length_improvement": 17.991468247941192,
            "objective_score": -37.99260636032686
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02910740375518799,
            "num_nodes_avg": 172.4,
            "path_length_avg": 134.42424774975285,
            "success_improvement": 0.0,
            "time_improvement": -3.0450481778834115,
            "length_improvement": 17.455414028725084,
            "objective_score": 2.5775683523799935
        }
    ],
    "success_rate": 17.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid informed sampling planner combining frontier-guided exploration with dynamic step adjustment and path smoothing. It begins with uniform random sampling biased toward unexplored frontier regions near obstacles to efficiently cover free space. The step size dynamically adapts based on local obstacle density to balance exploration and exploitation. After finding an initial path, a shortcut smoothing procedure refines the path to improve smoothness and reduce length, enhancing path quality while maintaining collision safety. This approach aims at faster convergence, higher success rate, better path smoothness, and efficient obstacle-aware exploration.",
    "planning_mechanism": "The planner incrementally builds a tree rooted at start by sampling primarily near frontiers (boundaries between free space and obstacles) to prioritize promising regions. It dynamically adjusts step size: smaller step near obstacles for precision, larger in free space to speed exploration. Upon reaching the goal, it applies iterative shortcut smoothing on the found path to reduce unnecessary detours. Collision checks for nodes and edges ensure path validity and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n\n            if random.random() < self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            if math.dist(new_position, goal) <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal, obstacles, is_3d) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_position, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        # Sample grid for frontier detection\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        # Convert obstacles to quick check set approximated by grid cells\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i] + 1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        # Frontier detection on grid\n        for ix in range(steps[0]+1):\n            for iy in range(steps[1]+1):\n                pos_grid = (ix, iy) if not is_3d else None\n                if is_3d:\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        # Check neighbors occupied?\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(len(bounds))))\n                else:\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        # Generator for cartesian product of input arrays (list of lists)\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        dim = len(bounds)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        # Decrease step size near obstacles to improve precision, else use base_step_size\n        query_radius = base_step_size * 2\n        nearby_obstacle = False\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx**2 + dy**2 + dz**2)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx**2 + dy**2)**0.5\n            if dist <= query_radius:\n                nearby_obstacle = True\n                break\n        return base_step_size * 0.5 if nearby_obstacle else base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 232.0497,
    "time_improvement": -785.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.131243896484375,
            "num_nodes_avg": 1106.5,
            "path_length_avg": 172.2950583974712,
            "success_improvement": 0.0,
            "time_improvement": -1291.6427132235647,
            "length_improvement": 13.88858582634635,
            "objective_score": -384.7150968018001
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14024708271026612,
            "num_nodes_avg": 1298.2,
            "path_length_avg": 237.7602131001206,
            "success_improvement": 0.0,
            "time_improvement": -851.9152751099193,
            "length_improvement": 21.103117507379686,
            "objective_score": -251.35395903149987
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0906510591506958,
            "num_nodes_avg": 1041.2,
            "path_length_avg": 132.21978033208794,
            "success_improvement": 0.0,
            "time_improvement": -212.80617882085417,
            "length_improvement": 18.80908982252286,
            "objective_score": -60.080035681751674
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
    "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.68311,
    "time_improvement": 27.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.007598710060119629,
            "num_nodes_avg": 103.3,
            "path_length_avg": 161.4550453822259,
            "success_improvement": -9.999999999999998,
            "time_improvement": 19.42719038120736,
            "length_improvement": 19.306320142615537,
            "objective_score": 4.689421142885316
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.013997030258178712,
            "num_nodes_avg": 235.8,
            "path_length_avg": 259.63765747646863,
            "success_improvement": -9.999999999999998,
            "time_improvement": 4.9963346727016456,
            "length_improvement": 13.8434413164237,
            "objective_score": -0.7324113349047652
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.012314391136169434,
            "num_nodes_avg": 223.6,
            "path_length_avg": 131.58176022985964,
            "success_improvement": -9.999999999999998,
            "time_improvement": 57.507196585457756,
            "length_improvement": 19.200872600268642,
            "objective_score": 16.092333495691054
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm enhances the bidirectional RRT by integrating a heuristic-based goal biasing and nearest neighbor optimization to improve efficiency and path quality. It grows two trees from start and goal alternately, extends towards sampled points with goal bias to encourage tree connection, performs rigorous collision and edge checks, and once trees connect, extracts and smooths the path for improved smoothness and shorter path length.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal. At each iteration, it samples points with goal biasing, extends one tree towards the sample, attempts connection to the other tree quickly, and upon successful connection, reconstructs and smooths the path. Rigorous collision checks and edge validity checks ensure robustness. Path smoothing via shortcutting reduces path length and improves smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.1, smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal to bias growth\n        self.smoothing_iter = smoothing_iter      # Number of path smoothing iterations\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def can_connect(node_from, node_to):\n            if self._is_edge_in_obstacle(node_from.position, node_to.position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(node_to.position, obstacles, is_3d):\n                return False\n            return True\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            while True:\n                new_pos = steer(nearest_node.position, new_node.position)\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                next_node = Node(new_pos, parent=nearest_node,\n                                cost=nearest_node.cost + math.dist(nearest_node.position, new_pos))\n                nearest_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node, next_node))\n                if math.dist(new_pos, new_node.position) <= self.step_size:\n                    return next_node\n                nearest_node = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            import random\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate tree growth\n        for iter in range(self.max_iter):\n            rand_point = sample_point()\n\n            # Extend start tree towards random point\n            nearest_start = nearest(tree_start, rand_point)\n            new_pos_start = steer(nearest_start.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_start, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_start.position, new_pos_start, obstacles, is_3d)):\n                new_node_start = Node(new_pos_start, parent=nearest_start,\n                                     cost=nearest_start.cost + math.dist(nearest_start.position, new_pos_start))\n                nearest_start.add_child(new_node_start)\n                tree_start.append(new_node_start)\n                nodes.append(new_node_start)\n                edges.append((nearest_start, new_node_start))\n\n                # Try connect goal tree to new start node\n                new_node_goal = connect_trees(new_node_start, tree_goal)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n            # Swap roles: Extend goal tree towards random point\n            rand_point = sample_point()\n            nearest_goal = nearest(tree_goal, rand_point)\n            new_pos_goal = steer(nearest_goal.position, rand_point)\n            if (not self._is_in_obstacle(new_pos_goal, obstacles, is_3d) and\n                not self._is_edge_in_obstacle(nearest_goal.position, new_pos_goal, obstacles, is_3d)):\n                new_node_goal = Node(new_pos_goal, parent=nearest_goal,\n                                    cost=nearest_goal.cost + math.dist(nearest_goal.position, new_pos_goal))\n                nearest_goal.add_child(new_node_goal)\n                tree_goal.append(new_node_goal)\n                nodes.append(new_node_goal)\n                edges.append((nearest_goal, new_node_goal))\n\n                # Try connect start tree to new goal node\n                new_node_start = connect_trees(new_node_goal, tree_start)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_full_path(new_node_start, new_node_goal)\n                    extracted_path = smooth_path(extracted_path)\n                    break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.18266,
    "time_improvement": 9.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009535980224609376,
            "num_nodes_avg": 86.7,
            "path_length_avg": 170.74762170972932,
            "success_improvement": 0.0,
            "time_improvement": -1.1146251254553718,
            "length_improvement": 14.661979809696968,
            "objective_score": 2.598008424302782
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.015331578254699708,
            "num_nodes_avg": 255.3,
            "path_length_avg": 231.82982015577954,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4.06179758007486,
            "length_improvement": 23.07102252043464,
            "objective_score": -1.6043347699355293
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.01953170299530029,
            "num_nodes_avg": 281.5,
            "path_length_avg": 115.83970390651845,
            "success_improvement": -19.999999999999996,
            "time_improvement": 32.602691716296164,
            "length_improvement": 28.867443500228006,
            "objective_score": 5.554296214934452
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced RRT* variant with tuned parameters for improved efficiency, path quality, and success rate. It incrementally expands a tree from start toward goal, leveraging goal biasing, rewiring to reduce path cost, and neighborhood radius adapted to environment size. It includes collision checks for nodes and edges and concludes upon reaching the goal region. Additionally, it incorporates smarter sampling and rewiring strategies to promote smoother and shorter paths while reducing unnecessary branching.",
    "planning_mechanism": "The planner samples random points with bias toward the goal, extends from the nearest node within a defined step size, determines the best parent among neighbors by minimal path cost while ensuring no collisions, then inserts the new node and rewires neighbors if a better path is found through the new node, iterating until a valid goal is connected or max iterations are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.10, neighbor_radius: float = None):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius  # Will be set dynamically based on map size\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Dynamically set neighbor radius if not provided, scaled by dimension and step_size\n        dim = len(bounds)\n        if self.neighbor_radius is None:\n            # Use a radius proportional to step_size and dimension (heuristic)\n            self.neighbor_radius = self.step_size * 5.0 * (dim ** 0.5)\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for _ in range(self.max_iter):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Nearest node search\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n\n            unit_vec = tuple(d / dist_to_sample for d in direction)\n            new_pos = tuple(nearest_node.position[d] + unit_vec[d] * min(self.step_size, dist_to_sample) for d in range(dim))\n\n            # Check within bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Gather neighbors for rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n            # Choose best parent among neighbors\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                temp_cost = near_node.cost + edge_cost\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node = Node(new_pos)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node if beneficial\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_pos, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check for goal connection\n            dist_to_goal = math.dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    # Extract path\n                    path = []\n                    curr = goal_node\n                    while curr:\n                        path.append(curr.position)\n                        curr = curr.parent\n                    extracted_path = path[::-1]\n                    break\n\n        # If goal not reached: try to find best node near goal for path extraction\n        if not success_state:\n            candidates = [(n, math.dist(n.position, goal_position) + n.cost) for n in nodes]\n            candidates = [c for c in candidates if not self._is_edge_in_obstacle(c[0].position, goal_position, obstacles, is_3d)]\n            if candidates:\n                best_node, _ = min(candidates, key=lambda x: x[1])\n                # Add virtual goal connection if possible (without collision)\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = best_node.cost + math.dist(best_node.position, goal_position)\n                    if not self._is_edge_in_obstacle(best_node.position, goal_position, obstacles, is_3d):\n                        goal_node.update_parent(best_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((best_node, goal_node))\n                        success_state = True\n                        # Extract path\n                        path = []\n                        curr = goal_node\n                        while curr:\n                            path.append(curr.position)\n                            curr = curr.parent\n                        extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 880.29439,
    "time_improvement": -2929.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.24811675548553466,
            "num_nodes_avg": 351.4,
            "path_length_avg": 160.10209001065772,
            "success_improvement": -9.999999999999998,
            "time_improvement": -2530.9023432661115,
            "length_improvement": 19.982514233399094,
            "objective_score": -760.2742001331536
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.8466428041458129,
            "num_nodes_avg": 1276.3,
            "path_length_avg": 222.28644943966083,
            "success_improvement": -19.999999999999996,
            "time_improvement": -5646.51680629433,
            "length_improvement": 26.237835790643434,
            "objective_score": -1698.7074747301704
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.2055886745452881,
            "num_nodes_avg": 639.2,
            "path_length_avg": 114.6173289964833,
            "success_improvement": -9.999999999999998,
            "time_improvement": -609.4170580671276,
            "length_improvement": 29.61805533209308,
            "objective_score": -181.9015063537197
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined and generalized optimal RRT-based planner combining bidirectional search and rewiring techniques. It balances efficient exploration with continuous local path cost optimization to enhance path quality, success rate, and computational speed.",
    "planning_mechanism": "The planner grows two trees from start and goal, sampling points within bounds, and steering towards them with collision checks. It rewires nodes nearby new additions to minimize cost. Trees attempt to connect, forming smoother and shorter paths while quickly exploring the space with balanced bidirectional growth and local optimizations.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend start tree\n            new_start = self._extend_tree(tree_start, rand_point, obstacles, is_3d, nodes, edges, near, steer, nearest)\n            if new_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree to new_start\n            new_goal = self._connect_tree(tree_goal, new_start.position, obstacles, is_3d, nodes, edges, near, steer, nearest)\n\n            if new_goal:\n                success_state = True\n                connection_node_start = new_start\n                connection_node_goal = new_goal\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        extracted_path = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            extracted_path = path_start + path_goal[::-1]\n\n            # Optional smoothing\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree, point, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n        nearest_node = nearest_fn(tree, point)\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for node in near_nodes:\n            cost = node.cost + math.dist(node.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for node in near_nodes:\n            if node == best_parent:\n                continue\n            cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n            if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                if node.parent:\n                    edges.remove((node.parent, node))\n                    node.parent.children.remove(node)\n                node.parent = new_node\n                node.cost = cost_through_new\n                new_node.add_child(node)\n                edges.append((new_node, node))\n\n        return new_node\n\n    def _connect_tree(self, tree, target_position, obstacles, is_3d, nodes, edges, near_fn, steer_fn, nearest_fn):\n        import math\n\n        current_node = nearest_fn(tree, target_position)\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near_fn(tree, new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            if math.dist(new_node.position, target_position) <= self.step_size:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import math\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7.29674,
    "time_improvement": -36.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0127516508102417,
            "num_nodes_avg": 95.7,
            "path_length_avg": 155.49876463463846,
            "success_improvement": 0.0,
            "time_improvement": -35.21194057018043,
            "length_improvement": 22.283212011486395,
            "objective_score": -6.10693976875685
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.022982406616210937,
            "num_nodes_avg": 289.7,
            "path_length_avg": 218.9591641629555,
            "success_improvement": -9.999999999999998,
            "time_improvement": -55.99115143061041,
            "length_improvement": 27.341941612525005,
            "objective_score": -16.328957106678118
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0340461254119873,
            "num_nodes_avg": 351.0,
            "path_length_avg": 115.70390280011952,
            "success_improvement": 0.0,
            "time_improvement": -17.481676370436364,
            "length_improvement": 28.950833560353235,
            "objective_score": 0.5456638009397379
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive goal biasing, dynamic neighbor radius based on node density, heuristic-driven sampling towards the goal, and efficient rewiring techniques. It balances exploration and exploitation to rapidly discover feasible paths while continuously optimizing path cost, resulting in reduced planning time and shorter, smoother paths. Additionally, it incorporates lazy collision checking and path smoothing to enhance success rate and path quality.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately sampling points with adaptive goal bias. It uses a dynamic neighbor radius influenced by iteration count to refine rewiring as trees expand. Steering uses fixed step size with checks to remain in bounds and avoid obstacles. When new nodes are added, nearby nodes are rewired to minimize cost. The trees attempt to connect through nearest nodes periodically. Upon successful connection, the path is extracted and smoothed by shortcutting collision-free edges, ensuring efficient and smooth navigation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive sampling bias: gradually increase goal bias with iterations\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.2, 0.3)\n            if random.random() < goal_bias:\n                # Bias alternate between start and goal to reduce symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds if slight out-of-bound due to float errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(len(bounds))\n            )\n            return clamped\n\n        def nearest(tree, point):\n            # Use Euclidean distance\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            # Dynamic radius shrinking with iterations to focus rewiring locally as tree grows\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Efficiently find neighbors within dynamic radius\n            # For performance, linear search; could be improved with spatial indexing\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n\n            # Alternate between trees for balanced growth\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(it)\n\n            # --- Extend tree_a towards random sample ---\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if path improves cost\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # --- Try to connect tree_b to new_node ---\n            nearest_node_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_node_b\n\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check connector proximity\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    # Trees connected successfully\n                    connection_node_start = new_node if tree_a is tree_start else new_node_b\n                    connection_node_goal = new_node_b if tree_b is tree_goal else new_node\n\n                    success_state = True\n                    break\n\n                curr_node_b = new_node_b\n\n            if success_state:\n                # Extract paths and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing: attempt shortcutting by bypassing intermediate nodes\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.37999,
    "time_improvement": -79.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.01865048408508301,
            "num_nodes_avg": 98.5,
            "path_length_avg": 171.3088822744523,
            "success_improvement": -19.999999999999996,
            "time_improvement": -97.76013186402028,
            "length_improvement": 14.381467174002548,
            "objective_score": -36.451746124405574
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.034059691429138186,
            "num_nodes_avg": 319.6,
            "path_length_avg": 228.7886221087461,
            "success_improvement": 0.0,
            "time_improvement": -131.17729018226305,
            "length_improvement": 24.080194920749342,
            "objective_score": -34.53714807052904
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.031148362159729003,
            "num_nodes_avg": 293.9,
            "path_length_avg": 121.37515371171125,
            "success_improvement": -9.999999999999998,
            "time_improvement": -7.4824743913445175,
            "length_improvement": 25.46834385873305,
            "objective_score": -2.151073545656743
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved hybrid bidirectional RRT* planner enhances path planning by integrating adaptive sampling, dynamic neighbor radius based on the growing tree size, and more aggressive local rewiring for better path quality and convergence speed. The planning efficiency gains come from adaptive goal biasing, radius scaling to include more neighbors as the tree grows, and collision checks early in the sampling process to avoid futile expansions. The rewiring step is optimized to better minimize path length and enhance smoothness, and the swapping of trees is maintained for balanced exploration from start and goal.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal nodes, each extending towards random samples biased towards the goal and start positions respectively. Each extension involves steering with a fixed step size and connecting the new node to the minimum cost parent within a dynamically computed radius. After insertion, neighbors are rewired if the path via the new node shortens their costs, promoting optimal paths locally. Once the two trees connect within the step size, the algorithm reconstructs the complete path by joining backtracked nodes from both sides. This combination leverages bidirectional search and incremental rewiring to rapidly find short, collision-free, and smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # Constant for radius calculation\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (2D or 3D)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free(grow_from_start: bool):\n            if random.random() < self.goal_sample_rate:\n                # Bias toward opposite tree root to encourage connection\n                return goal_position if grow_from_start else start_position\n            else:\n                for _ in range(100):  # Limit attempts to 100 for efficiency\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    # Quick boundary check\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback to root positions if sampling fails repeatedly\n                return goal_position if grow_from_start else start_position\n\n        def nearest(tree, point):\n            # Euclidean nearest node in tree\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def compute_radius(n):\n            # Adaptive neighbor radius based on number of nodes (as in RRT*)\n            # radius = \u03b3 * (log(n)/n)^(1/d), \u03b3 estimated by neighbor_radius_const, d dimension\n            d = 3 if is_3d else 2\n            if n <= 1:\n                return self.neighbor_radius_const\n            return min(self.neighbor_radius_const, \n                       self.neighbor_radius_const * ((math.log(n) / n) ** (1 / d)))\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Reject if out of bounds or in obstacle\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            radius = compute_radius(n_nodes)\n\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path found through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, node.position)\n                if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        # Alternate growth of trees from start and goal\n        for iteration in range(self.max_iter):\n            grow_start = (iteration % 2 == 0)\n            rand_point = sample_free(grow_start)\n\n            # Extend respective tree towards sample\n            tree_a = tree_start if grow_start else tree_goal\n            tree_b = tree_goal if grow_start else tree_start\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                # Swap and continue\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Trees connected successfully\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                extracted_path = path_a + path_b[::-1][1:]\n                break\n\n            # Swap to grow other tree next iteration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 70.96357,
    "time_improvement": -244.0,
    "length_improvement": 11.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.027609086036682128,
            "num_nodes_avg": 204.3,
            "path_length_avg": 180.49303316131713,
            "success_improvement": 0.0,
            "time_improvement": -192.7525350200602,
            "length_improvement": 9.79131683418436,
            "objective_score": -55.86749713918118
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05325424671173096,
            "num_nodes_avg": 509.3,
            "path_length_avg": 260.2796083827043,
            "success_improvement": 0.0,
            "time_improvement": -261.45871935244264,
            "length_improvement": 13.630420287568977,
            "objective_score": -75.71153174821899
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10933144092559814,
            "num_nodes_avg": 771.6,
            "path_length_avg": 147.6395673342232,
            "success_improvement": 0.0,
            "time_improvement": -277.26586519041024,
            "length_improvement": 9.340411699614483,
            "objective_score": -81.31167721720017
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the strengths of sampling-based tree expansion with frontier-guided exploration and adaptive step sizing to efficiently explore the configuration space. It applies goal biasing for convergence, dynamically adjusts step sizes near obstacles for precision, and incorporates a frontier sampling strategy to focus sampling near obstacle boundaries. After initial path discovery, iterative shortcut smoothing refines the path to enhance smoothness and reduce length, boosting path quality and success rate.",
    "planning_mechanism": "The planner incrementally grows a tree rooted at the start by sampling either toward the goal, near frontiers, or randomly in free space, using adaptive step sizes based on proximity to obstacles. It performs rigorous collision checks for nodes and edges before adding them. Upon finding a path to the goal, it executes a shortcut smoothing routine, producing a robust, efficient, and smooth path with improved planning performance.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sample = goal_position\n            elif r < self.goal_sample_rate + self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                if all(0 <= nbr[i] <= steps[i] for i in range(dims)):\n                    yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        for cz in range(min_cells[2], max_cells[2]+1):\n                            if cz < 0 or cz > steps[2]:\n                                continue\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    if cx < 0 or cx > steps[0]:\n                        continue\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        if cy < 0 or cy > steps[1]:\n                            continue\n                        occupied.add((cx, cy))\n\n        for ix in range(steps[0]+1):\n            if is_3d:\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontier_pos = tuple((pos_grid[d] + 0.5)*resolution for d in range(3))\n                            frontiers.append(frontier_pos)\n            else:\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontier_pos = ((ix + 0.5)*resolution, (iy + 0.5)*resolution)\n                        frontiers.append(frontier_pos)\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        dim = len(bounds)\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        unit_vec = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        return tuple(from_pos[d] + unit_vec[d] * step_size for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if self._in_bounds(p_j, bounds) and not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 154.51652,
    "time_improvement": -529.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030805325508117674,
            "num_nodes_avg": 345.8,
            "path_length_avg": 163.60662082009756,
            "success_improvement": 0.0,
            "time_improvement": -226.6438129330896,
            "length_improvement": 18.23098341862772,
            "objective_score": -64.34694719620133
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.17162775993347168,
            "num_nodes_avg": 1382.6,
            "path_length_avg": 242.5890407852697,
            "success_improvement": 0.0,
            "time_improvement": -1064.9089817510392,
            "length_improvement": 19.50074911493595,
            "objective_score": -315.57254470232454
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.11421992778778076,
            "num_nodes_avg": 1022.1,
            "path_length_avg": 125.31142432665688,
            "success_improvement": 0.0,
            "time_improvement": -294.1343817847203,
            "length_improvement": 23.051236576225087,
            "objective_score": -83.63006722017107
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced RRT* variant combining adaptive informed sampling and dynamic path smoothing through shortcutting for improved convergence speed, path quality, and smoothness. It incrementally builds a tree rooted at the start, performs rewiring to optimize cost locally, and applies informed sampling within an ellipsoidal domain after an initial solution is found to focus search efficiently. Path shortcutting post-processing reduces unnecessary detours to improve smoothness.",
    "planning_mechanism": "The planner starts from the start position, incrementally samples nodes in the state space, initially uniformly and later within an informed ellipsoid based on the best path cost discovered. It extends nearest tree nodes toward samples, adds collision-free nodes, and rewires locally for better paths. After reaching the goal within iteration limits, it extracts the best path and improves it by shortcutting over the path segments, all while maintaining collision and boundary checks.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n        tree = [root]\n        best_cost = float(\"inf\")\n        c_min = math.dist(start, goal)\n        goal_node = None\n\n        def sample_unit_ball(dim):\n            while True:\n                vec = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(vec)\n                if norm > 1e-6:\n                    return vec / norm * (random.random() ** (1.0 / dim))\n\n        def informed_sample():\n            if best_cost == float(\"inf\"):\n                # Uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            dim = len(start)\n            c_best = best_cost\n            L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n            L = np.diag(L_diag)\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            a1 = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = np.dot(U, np.dot(np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]), Vt))\n\n            for _ in range(100):  # Limit internal attempts to avoid infinite loops\n                x_ball = sample_unit_ball(dim)\n                x_rand = np.dot(C, np.dot(L, x_ball)) + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback uniform sample if no valid sample found\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * self.step_size / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            x_rand = informed_sample()\n\n            # Find nearest node\n            x_nearest = min(tree, key=lambda n: math.dist(n.position, x_rand))\n\n            x_new_pos = steer(x_nearest.position, x_rand)\n\n            # Collision & bounds check\n            if any(x_new_pos[d] < 0 or x_new_pos[d] > bounds[d] for d in range(len(bounds))):\n                continue\n            if self._is_in_obstacle(x_new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(x_nearest.position, x_new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node and choose best parent from near nodes (RRT* rewiring)\n            x_new = Node(x_new_pos)\n            near_radius = min(50.0, self.step_size * math.sqrt(math.log(len(tree) + 1) / (len(tree) + 1)))  # Adaptive radius\n            near_nodes = [n for n in tree if math.dist(n.position, x_new_pos) <= near_radius]\n\n            # Choose best parent\n            min_cost = x_nearest.cost + math.dist(x_nearest.position, x_new_pos)\n            best_parent = x_nearest\n            for n in near_nodes:\n                new_cost = n.cost + math.dist(n.position, x_new_pos)\n                if new_cost < min_cost and not self._is_edge_in_obstacle(n.position, x_new_pos, obstacles, is_3d):\n                    best_parent = n\n                    min_cost = new_cost\n\n            best_parent.add_child(x_new)\n            x_new.cost = min_cost\n            x_new.parent = best_parent\n            tree.append(x_new)\n            nodes.append(x_new)\n            edges.append((best_parent, x_new))\n\n            # Rewire near nodes if better path found through x_new\n            for n in near_nodes:\n                if n == best_parent:\n                    continue\n                alt_cost = x_new.cost + math.dist(x_new.position, n.position)\n                if alt_cost < n.cost and not self._is_edge_in_obstacle(x_new.position, n.position, obstacles, is_3d):\n                    # Remove old edge\n                    if n.parent:\n                        if (n.parent, n) in edges:\n                            edges.remove((n.parent, n))\n                        n.parent.remove_child(n)\n                    # Add new edge\n                    x_new.add_child(n)\n                    n.cost = alt_cost\n                    n.parent = x_new\n                    edges.append((x_new, n))\n\n            # Check goal proximity and connect\n            if math.dist(x_new.position, goal) <= self.step_size:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(x_new.position, goal, obstacles, is_3d):\n                    temp_goal = Node(goal, parent=x_new, cost=x_new.cost + math.dist(x_new.position, goal))\n                    x_new.add_child(temp_goal)\n                    nodes.append(temp_goal)\n                    edges.append((x_new, temp_goal))\n                    if temp_goal.cost < best_cost:\n                        best_cost = temp_goal.cost\n                        goal_node = temp_goal\n                        success_state = True\n\n        # If solution found, extract and shortcut path\n        if success_state and goal_node:\n            path = goal_node.path_from_root()\n\n            def shortcut_path(path):\n                if len(path) <= 2:\n                    return path\n                shortened_path = [path[0]]\n                idx = 0\n                while idx < len(path) -1:\n                    next_idx = len(path) -1\n                    # Search for farthest reachable node without obstacles in between\n                    for j in range(len(path)-1, idx, -1):\n                        if not self._is_edge_in_obstacle(path[idx], path[j], obstacles, is_3d):\n                            next_idx = j\n                            break\n                    shortened_path.append(path[next_idx])\n                    idx = next_idx\n                return shortened_path\n\n            extracted_path = shortcut_path(path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3757.44651,
    "time_improvement": -12526.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.4761212587356567,
            "num_nodes_avg": 3219.4,
            "path_length_avg": 173.84918578844727,
            "success_improvement": 0.0,
            "time_improvement": -15552.029912099079,
            "length_improvement": 13.11184789382695,
            "objective_score": -4662.986604050958
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 2.0650195598602297,
            "num_nodes_avg": 4242.8,
            "path_length_avg": 244.07518062754949,
            "success_improvement": -19.999999999999996,
            "time_improvement": -13916.146535416123,
            "length_improvement": 19.007597636919,
            "objective_score": -4181.042441097453
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.378909683227539,
            "num_nodes_avg": 4666.3,
            "path_length_avg": 127.5641544999296,
            "success_improvement": 0.0,
            "time_improvement": -8108.813606174215,
            "length_improvement": 21.6679245430868,
            "objective_score": -2428.310496943647
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is a tuned bidirectional RRT*-Connect variant integrating informed sampling, adaptive step size, node rejection, and pruning to enhance efficiency, robustness, and path quality. The planner uses dynamic rewiring and step adjustment, focusing sampling in an ellipsoidal informed set that shrinks as better solutions are found, thus reducing unnecessary exploration and accelerating convergence to high-quality paths.",
    "planning_mechanism": "The planner grows two trees from start and goal alternately, samples points informed by the current best solution, adaptively adjusts stepping near obstacles to improve feasibility, rejects nodes unlikely to improve the solution, rewires neighbors for optimal paths, prunes suboptimal branches, and connects trees to update the best path continuously.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start, goal = map.start, map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        best_path = []\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * max_step / dist for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = [(s + g) / 2 for s, g in zip(start, goal)]\n            diff = np.array(goal) - np.array(start)\n            norm_diff = np.linalg.norm(diff)\n            if norm_diff == 0:\n                a1 = np.eye(dim)[0]\n            else:\n                a1 = diff / norm_diff\n            # Rotation matrix C (Householder or SVD)\n            eye = np.eye(dim)\n            if dim == 2:\n                rot_angle = math.atan2(a1[1], a1[0])\n                c, s = math.cos(rot_angle), math.sin(rot_angle)\n                C = np.array([[c, -s], [s, c]])\n            else:\n                M = np.outer(a1, eye[0])\n                U, _, Vt = np.linalg.svd(M)\n                C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                x_ball /= np.linalg.norm(x_ball)\n                scale = random.random() ** (1 / dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + np.array(x_center)\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                    near.parent = new_node\n                    near.cost = cost_through_new\n                    new_node.add_child(near)\n                    edges.append((new_node, near))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal if tree_a is tree_start else start\n            else:\n                sample = informed_sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            \n            # Node rejection pruning\n            est_lower_bound = new_cost + math.dist(new_pos, goal if tree_a is tree_start else start)\n            if est_lower_bound >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes to new_node for optimality\n            rewire(tree_a, new_node)\n\n            # Try to connect trees\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_cost = new_node.cost + math.dist(new_node.position, other_nearest.position) + other_nearest.cost\n\n            if connect_cost < c_best and not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                # Valid connection - update best path\n                c_best = connect_cost\n                path_start = new_node.path_from_root() if tree_a is tree_start else other_nearest.path_from_root()\n                path_goal = other_nearest.path_from_root() if tree_b is tree_goal else new_node.path_from_root()\n                best_path = path_start + path_goal[::-1]\n                success = True\n\n                # Prune branches that cannot improve solution cost\n                nodes_before_prune = len(nodes)\n                to_prune = []\n                for n in nodes:\n                    if n.cost + math.dist(n.position, goal) >= c_best and n != tree_start[0] and n != tree_goal[0]:\n                        to_prune.append(n)\n                for n in to_prune:\n                    n.valid = False\n                    # Remove edges and children relation\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    if n in tree_start:\n                        tree_start.remove(n)\n                    if n in tree_goal:\n                        tree_goal.remove(n)\n                    if n in nodes:\n                        nodes.remove(n)\n                # No explicit rewire after pruning for efficiency\n\n        extracted_path = best_path if success else []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3306.556,
    "time_improvement": -11033.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 1.295757794380188,
            "num_nodes_avg": 1259.2,
            "path_length_avg": 152.98371614554847,
            "success_improvement": -9.999999999999998,
            "time_improvement": -13639.548588200494,
            "length_improvement": 23.54020907295307,
            "objective_score": -4092.1565346455573
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.1762988805770873,
            "num_nodes_avg": 2610.7,
            "path_length_avg": 227.01850240669296,
            "success_improvement": 0.0,
            "time_improvement": -14671.445563012072,
            "length_improvement": 24.667580523705332,
            "objective_score": -4396.500152798881
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.4169222593307496,
            "num_nodes_avg": 2154.6,
            "path_length_avg": 115.74836709490107,
            "success_improvement": 0.0,
            "time_improvement": -4789.320012143081,
            "length_improvement": 28.923529804783183,
            "objective_score": -1431.0112976819676
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is an improved RRT* variant that balances exploration and exploitation by biasing sampling toward the goal and dynamically adjusting the step size based on obstacle proximity. It incrementally builds a single tree rooted at the start, incorporating collision-checked nodes and edges, and applies a post-processing shortcut smoothing to improve path quality, smoothness, and reduce path length. This approach aims to enhance planning efficiency, robustness, and success rate while producing shorter and smoother paths.",
    "planning_mechanism": "The planner samples mostly randomly but biases sampling near the goal to accelerate convergence. It dynamically adjusts step sizes\u2014smaller near obstacles for precision, larger in free space for speed. It incrementally extends the tree by steering toward sampled points with collision checks on nodes and edges. Upon reaching close to the goal, it reconstructs the path and applies shortcut smoothing to refine it.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float=0.1, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math, random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(len(bounds)))\n\n        def adaptive_step(pos):\n            query_r = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dz = max(z - pz, 0, pz - (z + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    dx = max(x - px, 0, px - (x + w))\n                    dy = max(y - py, 0, py - (y + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_r:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        for _ in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                sample = goal\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest.position)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            if math.dist(new_pos, goal) <= step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_pos, goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_pos, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        n = len(path)\n        if n < 3:\n            return path\n        smoothed = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(smoothed) < 3:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) -1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 146.53934,
    "time_improvement": -502.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.029899191856384278,
            "num_nodes_avg": 377.1,
            "path_length_avg": 163.43597517767063,
            "success_improvement": 0.0,
            "time_improvement": -217.03563817281366,
            "length_improvement": 18.316270470552652,
            "objective_score": -61.44743735773356
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.17256031036376954,
            "num_nodes_avg": 1409.5,
            "path_length_avg": 244.54989526735397,
            "success_improvement": 0.0,
            "time_improvement": -1071.238589342555,
            "length_improvement": 18.85007125912084,
            "objective_score": -317.60156255094233
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09181842803955079,
            "num_nodes_avg": 1019.0,
            "path_length_avg": 126.36150399125684,
            "success_improvement": 0.0,
            "time_improvement": -216.8343744626728,
            "length_improvement": 22.406424404297432,
            "objective_score": -60.56902745794235
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighbor radius scaling based on the number of nodes, informed sample biasing towards an ellipse defined by the current best path (Informed RRT* concept), and efficient rewiring for local cost optimization. These improvements aim to minimize path length, improve planning speed, increase success rate, and yield smoother and shorter paths by focusing sampling in promising areas and continuously optimizing the tree structure.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternatively, incorporating goal biasing and sampling within an informed subset (ellipse) once an initial solution is found to focus the search. New nodes are added by steering towards sampled points and rewired locally to reduce path costs. Trees attempt connection upon each extension. Path smoothing is applied at the end to improve smoothness. Dynamic neighbor radius adapts to node density, enhancing rewiring efficiency and convergence speed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # Base radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Data holders\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Current best cost and node pair to guide informed sampling\n        best_path_cost = math.inf\n        best_connection = None  # Tuple[Node, Node]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def sample_free():\n            # If we have found a path, sample inside ellipsoid between start and goal (Informed RRT*)\n            if success_state and best_path_cost < math.inf:\n                return self._informed_sample(start_position, goal_position, best_path_cost, bounds, is_3d)\n            # Otherwise do normal goal bias sampling\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling equally to start or goal to reduce symmetry bias\n                return start_position if random.random() < 0.5 else goal_position\n            # Uniform sampling in free space\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos):\n            n = len(tree) + 1\n            # Adaptive radius: \u03b3 * (log(n)/n)^(1/d)\n            radius = min(self.neighbor_radius_const * (math.log(n) / n) ** (1/dim), self.step_size * 15)\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def valid_new_node(pos):\n            # Check node itself and edge from nearest node to new node\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def edge_valid(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_new_node(new_pos): \n                return None\n            if not edge_valid(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos)\n\n            # Choose best parent minimizing total cost\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate < min_cost:\n                    if edge_valid(node.position, new_pos):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_through_new < neighbor.cost and edge_valid(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            current_node = nearest_node\n\n            while True:\n                new_pos = steer(current_node.position, node.position)\n                if not valid_new_node(new_pos):\n                    return None\n                if not edge_valid(current_node.position, new_pos):\n                    return None\n\n                new_cost = current_node.cost + dist(current_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = current_node\n                new_node.cost = new_cost\n                current_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        # Main loop: alternate tree growth\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found; check if better than previous best\n                total_cost = new_node_start.cost + new_node_goal.cost + dist(new_node_start.position, new_node_goal.position)\n                if total_cost < best_path_cost:\n                    success_state = True\n                    best_path_cost = total_cost\n                    best_connection = (new_node_start, new_node_goal)\n\n                # Swap trees to continue improving\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        # Extract the best path found\n        if success_state and best_connection:\n            path_start = best_connection[0].path_from_root()\n            path_goal = best_connection[1].path_from_root()\n            # Merge paths; avoid duplication\n            extracted_path = path_start + path_goal[::-1][1:]\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, cost_best, bounds, is_3d):\n        # Sample within prolate hyperspheroid (ellipse) defined by start, goal, and cost_best (Informed RRT*)\n        # Reference: Gammell et al. 2014\n        import random\n        import math\n\n        dim = len(start)\n        c_min = math.dist(start, goal)\n        if cost_best == math.inf:\n            # No solution found yet; uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Center and unit vector from start to goal\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        unit_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n        # Transformation matrix: rotation aligning x-axis to unit_vec\n        # For 2D and 3D: compute rotation matrix to align first axis with unit_vec\n        def compute_rotation():\n            import numpy as np\n            e1 = np.zeros(dim)\n            e1[0] = 1.0\n            u = np.array(unit_vec)\n            if np.allclose(u, e1):\n                return np.eye(dim)\n            v = np.cross(e1, u) if dim == 3 else np.array([-u[1], u[0]])\n            s = np.linalg.norm(v)\n            c = np.dot(e1, u)\n            if s == 0:  # vectors aligned/congruent\n                return np.eye(dim)\n            vx = np.array([[0, -v[2], v[1]] if dim ==3 else [0, -v[1]],\n                           [v[2], 0, -v[0]] if dim ==3 else [v[1], 0],\n                           [-v[1], v[0], 0] if dim ==3 else [0, 0]], dtype=float)[:dim,:dim]\n            R = np.eye(dim) + vx + vx @ vx * ((1 - c) / (s ** 2))\n            return R\n\n        # For 2D only implementation without numpy to reduce dependency:\n        if dim == 2:\n            import math as m\n            angle = m.atan2(unit_vec[1], unit_vec[0])\n            cos_a = m.cos(angle)\n            sin_a = m.sin(angle)\n\n            # Radii of ellipsoid axes\n            r1 = cost_best / 2.0  # sum of distances / 2\n            r2 = m.sqrt(r1 ** 2 - (c_min / 2) ** 2)\n            while True:\n                # Sample random point in unit circle\n                r = m.sqrt(random.uniform(0, 1))\n                theta = random.uniform(0, 2*m.pi)\n                x_ball = r * m.cos(theta)\n                y_ball = r * m.sin(theta)\n                # Scale to ellipsoid\n                x = x_ball * r1\n                y = y_ball * r2\n                # Rotate point to align with start-goal\n                sample_x = cos_a * x - sin_a * y + center[0]\n                sample_y = sin_a * x + cos_a * y + center[1]\n                # Clamp to bounds always\n                sample_x = max(0.0, min(bounds[0], sample_x))\n                sample_y = max(0.0, min(bounds[1], sample_y))\n                if not self._is_in_obstacle((sample_x, sample_y), [], False):\n                    return (sample_x, sample_y)\n        else:\n            # For 3D, fallback to uniform random sampling in bounds during informed sampling,\n            # (to avoid numpy dependency and complex rotation)\n            return tuple(random.uniform(0, bounds[d]) for d in range(3))\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        # Shortcut smoothing by attempting to connect farther points when no obstacle\n        import math\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) -1:\n            j = len(path) -1\n            while j > i +1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -=1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6191.27151,
    "time_improvement": -20629.0,
    "length_improvement": 28.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 2.7585493087768556,
            "num_nodes_avg": 6361.5,
            "path_length_avg": 150.04089932645945,
            "success_improvement": -9.999999999999998,
            "time_improvement": -29150.236753556357,
            "length_improvement": 25.011000634259318,
            "objective_score": -8745.068825940056
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 3.1104052782058718,
            "num_nodes_avg": 7207.8,
            "path_length_avg": 229.79034029393242,
            "success_improvement": -19.999999999999996,
            "time_improvement": -21011.614151885336,
            "length_improvement": 23.74779093727005,
            "objective_score": -6308.734687378147
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 3.4266282081604005,
            "num_nodes_avg": 7256.0,
            "path_length_avg": 103.98116482458965,
            "success_improvement": -19.999999999999996,
            "time_improvement": -11724.136265772226,
            "length_improvement": 36.1493008669455,
            "objective_score": -3520.0110195582783
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This enhanced bidirectional RRT* planner grows two trees simultaneously from start and goal positions, employing adaptive goal biasing for efficient exploration. At each iteration, a sampled free point guides tree extension using a steering function respecting a fixed step size. Newly added nodes attempt local rewiring by connecting to neighbors within a dynamically adjusted radius based on the number of nodes, improving path cost and smoothness. When trees connect, the shortest cost path is reconstructed by backtracking from both connection nodes. Collision and edge feasibility checks ensure safety, while pruning suboptimal rewires and minimizing path length boost planning efficiency, robustness, and path quality.",
    "planning_mechanism": "The planner alternates tree growth between start and goal, sampling free points with goal bias. It extends the nearest nodes towards samples, rewires neighbors within a radius inversely proportional to the tree size for incremental optimization, and checks collision-free connections. Upon tree connection, it generates the optimal path by merging extensions from both trees. This combination of bidirectional search and incremental RRT* rewiring achieves faster convergence to shorter and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n.position)\n            n = n.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as more nodes are added (typical for RRT*), with a minimum radius\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire around new_node to improve paths locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Check final edge feasibility before return\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Alternate growth direction, keep track of trees accordingly\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n            # Always extend the smaller tree first to balance growths\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge and avoid duplicate connection node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -9.55661,
    "time_improvement": 23.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0053680181503295895,
            "num_nodes_avg": 68.2,
            "path_length_avg": 168.24816019864105,
            "success_improvement": 0.0,
            "time_improvement": 43.08029901986809,
            "length_improvement": 15.911186649372569,
            "objective_score": 16.106327035834944
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01864187717437744,
            "num_nodes_avg": 256.6,
            "path_length_avg": 287.4569206517525,
            "success_improvement": 0.0,
            "time_improvement": -26.530173006684965,
            "length_improvement": 4.612068627304342,
            "objective_score": -7.036638176544621
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013377833366394042,
            "num_nodes_avg": 183.6,
            "path_length_avg": 134.76801275171147,
            "success_improvement": 0.0,
            "time_improvement": 53.83761673112537,
            "length_improvement": 17.24432160877036,
            "objective_score": 19.600149341091683
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional search strategy and informed heuristic sampling from the second algorithm with the adaptive step sizing, goal bias sampling, and post-processing shortcut smoothing from the first algorithm. It incrementally grows two trees simultaneously from start and goal positions, uses informed ellipse-based sampling once a solution candidate is found, applies collision-aware adaptive step sizes near obstacles, performs rewiring to improve path costs, prunes inefficient expansions to reduce search space, and applies shortcut smoothing on the final path to improve quality, smoothness, and reduce length. This approach aims to maximize planning efficiency, robustness, success rate, and path quality while minimizing search time.",
    "planning_mechanism": "The planner grows two trees alternatingly from start and goal, samples points primarily within an informed ellipsoidal region defined by the best current path cost to encourage efficient exploration near promising areas. Node expansions use adaptive step sizes reduced near obstacles to maintain precision. Nodes and edges undergo strict collision checks. The planner rewires nodes to lower path costs and prunes expansions that cannot improve the solution. Upon connecting the two trees, it reconstructs and smooths the path using shortcut smoothing to enhance smoothness and length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root/start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False                 # Path navigation success or not\n        extracted_path: List[Tuple[float, ...]] = [] # Final path from start to goal\n        nodes: List[Node] = []                # All explored nodes\n        edges: List[Tuple[Node, Node]] = []   # Parent-child connections\n\n        # Trees initialization\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")              # Best path cost found so far\n        c_min = math.dist(start_position, goal_position)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            \"\"\"Reduce step size near obstacles for precision, larger steps otherwise.\"\"\"\n            distance = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(distance))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def informed_sample(start, goal, c_best, c_min):\n            if c_best == float(\"inf\"):\n                # No solution found yet - sample uniformly with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Sample inside an ellipsoidal region between start and goal defined by c_best\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            a1_norm = np.linalg.norm(a1)\n            if a1_norm == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / a1_norm\n\n            # Rotation matrix C that aligns the x-axis with a1\n            unit_vec = np.eye(dim)[0]\n            M = np.outer(a1, unit_vec)\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(max(0, c_best**2 - c_min**2)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                # Sample unit ball point with uniform distribution\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def rewire(tree, new_node, obstacles):\n            # Rewire neighbors if through new_node it is cheaper and edge collision free\n            near_nodes = [node for node in tree if math.dist(node.position, new_node.position) <= self.rewire_radius and node != new_node]\n            for near in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child relation\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Reassign parent\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def shortcut_smooth(path):\n            smoothed = path[:]\n            n = len(smoothed)\n            if n < 3:\n                return smoothed\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate between expanding start and goal tree\n            if iteration % 2 == 0:\n                tree_from, tree_to = tree_start, tree_goal\n            else:\n                tree_from, tree_to = tree_goal, tree_start\n\n            sample_pt = informed_sample(start_position, goal_position, c_best, c_min)\n            nearest_node = min(tree_from, key=lambda n: math.dist(n.position, sample_pt))\n            step = adaptive_step(nearest_node.position, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            # Prune nodes which cannot improve overall best cost via heuristic\n            # Heuristic: cost so far + straight line dist to goal (or start depending on tree)\n            # Compute heuristic to the other tree root:\n            other_root_pos = tree_goal[0].position if tree_from is tree_start else tree_start[0].position\n            est_total_cost = new_cost + math.dist(new_pos, other_root_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_from.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes for possible cost improvement\n            rewire(tree_from, new_node, obstacles)\n\n            # Attempt connection to other tree\n            other_nearest = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, other_nearest.position)\n            if dist_between <= self.base_step:\n                # Check edge feasibility and total path cost\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    total_cost = new_node.cost + dist_between + other_nearest.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        path_from_start = new_node.path_from_root() if tree_from is tree_start else other_nearest.path_from_root()\n                        path_from_goal = other_nearest.path_from_root() if tree_from is tree_start else new_node.path_from_root()\n                        extracted_path = path_from_start + path_from_goal[::-1]\n                        success_state = True\n\n            # Early termination if path found with minimal cost close to c_min\n            if success_state and abs(c_best - c_min) < 1e-3:\n                break\n\n        # If solution found apply shortcut smoothing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = shortcut_smooth(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3515.58565,
    "time_improvement": -11737.0,
    "length_improvement": 28.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 1.2293241977691651,
            "num_nodes_avg": 1736.5,
            "path_length_avg": 148.57337902197278,
            "success_improvement": 0.0,
            "time_improvement": -12935.120930126732,
            "length_improvement": 25.74445317737505,
            "objective_score": -3875.3873884025447
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.4744876861572265,
            "num_nodes_avg": 2938.6,
            "path_length_avg": 222.78550590629885,
            "success_improvement": 0.0,
            "time_improvement": -16695.37699469053,
            "length_improvement": 26.072231971181246,
            "objective_score": -5003.398652012923
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 1.6462026119232178,
            "num_nodes_avg": 2545.8,
            "path_length_avg": 112.5638047922505,
            "success_improvement": 0.0,
            "time_improvement": -5580.48904695736,
            "length_improvement": 30.87904289987138,
            "objective_score": -1667.9709055072337
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is a hybrid bidirectional RRT* algorithm that integrates informed sampling focused in ellipsoidal subsets (Informed RRT*) after the initial solution, adaptive neighbor radius for rewiring, and frontier-guided exploration sampling to encourage rapid exploration near obstacles. It also dynamically adjusts step sizes near obstacles for safer navigation and employs iterative shortcut smoothing to provide high-quality, smooth, and shorter paths with improved success rate and planning efficiency. The bidirectional growth helps accelerate convergence, while collision and edge checks ensure robustness.",
    "planning_mechanism": "The planner grows two trees from start and goal states alternately, using informed sampling inside ellipsoidal regions defined by the current best path to focus search post initial solution. It biases sampling near frontiers to enhance exploration of promising obstacle boundaries. Adaptive step size is used to reduce step lengths near obstacles for precise expansions. Nodes are connected and rewired locally using an adaptive radius to optimize path cost. Upon finding paths, iterative shortcut smoothing is applied to improve smoothness and reduce path length. Collision and edge collision checks guarantee valid expansions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coords\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, frontier_sample_rate: float=0.15,\n                 neighbor_radius_const: float=30.0, smoothing_iters: int=150):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.frontier_sample_rate = frontier_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n        best_connection = None  # Tuple[Node, Node]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def _adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    px, py, pz = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist_obs = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    ox, oy, w, h = obs\n                    px, py = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist_obs = (dx*dx + dy*dy)**0.5\n                if dist_obs <= query_radius:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def sample_free():\n            # If path found, use informed sampling biased by elliptical region\n            if success_state and best_path_cost < math.inf:\n                return self._informed_sample(start_position, goal_position, best_path_cost, bounds, is_3d)\n            # Else bias sampling: frontier with some probability, then goal, else uniform free\n            r = random.random()\n            if r < self.frontier_sample_rate and frontier_regions:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            elif r < self.frontier_sample_rate + self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos, step_size):\n            d = dist(from_pos, to_pos)\n            if d <= step_size:\n                return to_pos\n            ratio = step_size / d\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos):\n            n = len(tree) + 1\n            radius = min(self.neighbor_radius_const * (math.log(n) / n) ** (1/dim), self.base_step_size * 15)\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def valid_new_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if any(p < 0 or p > bounds[i] for i, p in enumerate(pos)):\n                return False\n            return True\n\n        def edge_valid(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            step = _adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, point, step)\n            if not valid_new_node(new_pos):\n                return None\n            if not edge_valid(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate < min_cost and edge_valid(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: try to connect neighbors through new_node if cheaper\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                new_cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost_through_new < neighbor.cost and edge_valid(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            current_node = nearest_node\n            while True:\n                step = _adaptive_step_size(current_node.position)\n                new_pos = steer(current_node.position, node.position, step)\n                if not valid_new_node(new_pos):\n                    return None\n                if not edge_valid(current_node.position, new_pos):\n                    return None\n\n                new_cost = current_node.cost + dist(current_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = current_node\n                new_node.cost = new_cost\n                current_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_node, new_node))\n\n                if dist(new_pos, node.position) <= step:\n                    return new_node\n                current_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                total_cost = new_node_start.cost + new_node_goal.cost + dist(new_node_start.position, new_node_goal.position)\n                if total_cost < best_path_cost:\n                    success_state = True\n                    best_path_cost = total_cost\n                    best_connection = (new_node_start, new_node_goal)\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        if success_state and best_connection:\n            path_start = best_connection[0].path_from_root()\n            path_goal = best_connection[1].path_from_root()\n            extracted_path = path_start + path_goal[::-1][1:]\n            extracted_path = self._iterative_shortcut_smooth(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i] + 1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        dim = len(bounds)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _informed_sample(self, start, goal, cost_best, bounds, is_3d):\n        import random\n        import math\n\n        dim = len(start)\n        c_min = math.dist(start, goal)\n        if cost_best == math.inf:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        unit_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n\n        if dim == 2:\n            angle = math.atan2(unit_vec[1], unit_vec[0])\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n            r1 = cost_best / 2.0\n            r2 = math.sqrt(r1**2 - (c_min / 2)**2)\n            while True:\n                r = math.sqrt(random.uniform(0, 1))\n                theta = random.uniform(0, 2*math.pi)\n                x_ball = r * math.cos(theta)\n                y_ball = r * math.sin(theta)\n                x = x_ball * r1\n                y = y_ball * r2\n                sample_x = cos_a * x - sin_a * y + center[0]\n                sample_y = sin_a * x + cos_a * y + center[1]\n                sample_x = max(0.0, min(bounds[0], sample_x))\n                sample_y = max(0.0, min(bounds[1], sample_y))\n                if not self._is_in_obstacle((sample_x, sample_y), [], False):\n                    return (sample_x, sample_y)\n        else:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n    def _iterative_shortcut_smooth(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 5836.41332,
    "time_improvement": -19471.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 2.6746103048324583,
            "num_nodes_avg": 6455.5,
            "path_length_avg": 148.9822735049908,
            "success_improvement": 0.0,
            "time_improvement": -28260.190768001736,
            "length_improvement": 25.540091644850666,
            "objective_score": -8472.94921207155
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.6090959787368773,
            "num_nodes_avg": 6566.7,
            "path_length_avg": 239.55715041492203,
            "success_improvement": 0.0,
            "time_improvement": -17609.019456172227,
            "length_improvement": 20.5068329132336,
            "objective_score": -5278.6044702690215
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 3.6639564037323,
            "num_nodes_avg": 8117.9,
            "path_length_avg": 120.21277800071434,
            "success_improvement": 0.0,
            "time_improvement": -12543.075687758279,
            "length_improvement": 26.18211256797608,
            "objective_score": -3757.686283813888
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm combines bidirectional Rapidly-exploring Random Tree (RRT) planning with adaptive sampling near frontiers and dynamic step sizing close to obstacles, integrating path shortcut smoothing for enhanced path quality and smoothness. It grows two trees from the start and goal positions simultaneously, biasing sampling towards frontier regions and adapting step size based on local obstacle proximity to improve exploration efficiency and precision, ultimately connecting the two trees to find a collision-free path. After path connection, iterative shortcut smoothing refines the path to reduce unnecessary detours and improve smoothness while maintaining collision safety.",
    "planning_mechanism": "The planner initializes two trees at start and goal, alternately growing them by extending towards randomly sampled points biased towards frontiers near obstacles. Step size dynamically adjusts smaller near obstacles and larger in free space for effective exploration. Each extension validates node and edge collision-free conditions. Upon connection of trees, the combined path is shortcut-smoothed to enhance path length and smoothness, and then returned as the final path.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, frontier_sample_rate: float=0.3, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n        \n        for _ in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if _ % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased towards frontiers\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n            new_pos = self._steer(nearest_node.position, rand_point, step_size)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Try to connect tree_b to new_node\n            nearest_node_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            connecting = True\n            last_added = None\n            while connecting:\n                step_size_b = self._adaptive_step_size(nearest_node_b.position, obstacles, is_3d, self.base_step_size)\n                next_pos = self._steer(nearest_node_b.position, new_pos, step_size_b)\n                if not self._in_bounds(next_pos, bounds):\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node_b.position, next_pos, obstacles, is_3d):\n                    break\n                new_cost_b = nearest_node_b.cost + math.dist(nearest_node_b.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_node_b, cost=new_cost_b)\n                nearest_node_b.add_child(next_node)\n                tree_b.append(next_node)\n                nodes.append(next_node)\n                edges.append((nearest_node_b, next_node))\n                nearest_node_b = next_node\n                last_added = next_node\n\n                if math.dist(next_pos, new_pos) <= step_size_b:\n                    # Connected\n                    path_a = new_node.path_from_root()\n                    path_b = last_added.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # Swap if trees were swapped\n                        path_a, path_b = path_b, path_a\n                    extracted_path = path_a + path_b[::-1]\n                    success_state = True\n                    connecting = False\n                    break\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy)**0.5\n            if dist <= query_radius:\n                return base_step_size * 0.5\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 3.37712,
    "time_improvement": -26.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011121630668640137,
            "num_nodes_avg": 148.0,
            "path_length_avg": 158.18834787192,
            "success_improvement": 0.0,
            "time_improvement": -17.92804613218255,
            "length_improvement": 20.93898416041376,
            "objective_score": -1.1906170075720128
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031751585006713864,
            "num_nodes_avg": 468.0,
            "path_length_avg": 239.0017021215254,
            "success_improvement": 0.0,
            "time_improvement": -115.51121201774241,
            "length_improvement": 20.691149448634693,
            "objective_score": -30.515133715595784
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.012543845176696777,
            "num_nodes_avg": 258.0,
            "path_length_avg": 125.72257630639828,
            "success_improvement": 0.0,
            "time_improvement": 56.7154282122604,
            "length_improvement": 22.79876449245189,
            "objective_score": 21.574381362168495
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner is a bidirectional RRT* variant enhanced with adaptive goal biasing, dynamic neighbor radius, heuristic-driven sampling favoring the goal, and lazy collision checking to reduce computation. It incorporates efficient rewiring for path cost optimization and path smoothing via shortcutting to ensure shorter and smoother paths. Additionally, the algorithm uses spatial pruning to reduce unnecessary node expansions, and alternates tree growth direction for balanced exploration, resulting in faster planning times, higher success rate, and better path quality.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions by alternately sampling points biased adaptively towards the goal and start to prevent symmetry issues. Each extension steers a fixed step size towards the sampled point and inserts nodes only if collision-free. A dynamic neighbor radius shrinks as the tree grows, focusing rewiring locally for improved path costs. Upon addition of a new node, nearby nodes are rewired if cost improvements are possible. Trees attempt connection by extending one towards the newest node in the other tree. Once connected, the path is extracted by backtracking parent pointers, merged, and smoothed by shortcutting collision-free edges, resulting in efficient, short, and smooth paths with reduced planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=7.0, max_neighbor_radius: float=25.0,\n                 smoothing_trials: int=120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing: increase bias with iteration, capped at 0.3\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias towards start or goal to mitigate symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fail-safe: fallback to start or goal randomly\n                        return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds if slight out-of-bound due to numerical errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(len(bounds))\n            )\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Dynamic shrinking radius to focus rewiring and reduce neighbors long-run\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Linear search for neighbors within radius (can be replaced by spatial indexing)\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            # Return the node closest to point by Euclidean distance\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n            # Alternate tree expansion to balance growth: even=tree_start grows, odd=tree_goal grows\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(it)\n\n            # --- Extend tree_a towards random sample ---\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Validate node and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors of new_node if improvement found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # --- Attempt to connect tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check connection proximity\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract paths and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing by random shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 17.93773,
    "time_improvement": -49.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012215113639831543,
            "num_nodes_avg": 73.6,
            "path_length_avg": 157.86942337224633,
            "success_improvement": 0.0,
            "time_improvement": -29.522776627506893,
            "length_improvement": 21.098379560008855,
            "objective_score": -4.637157076250296
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.026813340187072755,
            "num_nodes_avg": 273.8,
            "path_length_avg": 229.28425192705168,
            "success_improvement": -19.999999999999996,
            "time_improvement": -81.99329075188567,
            "length_improvement": 23.915728179132536,
            "objective_score": -29.81484158973919
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.0395944356918335,
            "num_nodes_avg": 306.7,
            "path_length_avg": 108.8905895531143,
            "success_improvement": -30.000000000000004,
            "time_improvement": -36.6270206588691,
            "length_improvement": 33.1346183349099,
            "objective_score": -19.36118253067875
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements an optimized bidirectional RRT* variant with adaptive sampling biased toward the goal and border safety checks. It employs a KD-tree to accelerate nearest and neighbor searches, reducing computational time. It integrates early stopping when trees connect, uses a geometric rewiring strategy to improve path quality locally, and performs efficient collision checks on sampled points and edges. Post-processing smoothing refines the final path.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal with adaptive goal bias sampling to speed convergence. Each sampled point is steered toward within a step size limit and validated for collision. Using KD-trees for spatial queries, the planner quickly finds nearest and nearby nodes enabling efficient rewiring to reduce path costs. The trees alternate extensions to balance exploration and exploitation, attempting connection at each iteration for early success. Finally, the path is smoothed by shortcutting while ensuring collision-free transitions.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 12.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        from bisect import bisect_left, bisect_right\n        from collections import deque\n\n        bounds = map.size                # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start       # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal         # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles        # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def build(self):\n                # KD-Tree is approximated by sorted lists per dimension for fast range queries\n                self.sorted_by_dim = [sorted(self.points, key=lambda p: p[d]) for d in range(dim)]\n\n            def insert(self, node: Node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                # Brute-force near neighbors due to moderate problem size and dimensionality\n                neighbors = []\n                r_sq = radius * radius\n                for node in self.nodes:\n                    # Compare squared dist for efficiency\n                    dx = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            # With goal biasing\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Sample extended bounds - slight buffer to avoid border failures\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        # Swap flag to alternate tree growth\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Alternate tree to extend\n            if tree_flag:\n                new_node = self._extend_bidirectional(tree_start, kd_start, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_goal, kd_goal, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_bidirectional(tree_goal, kd_goal, rand_point,\n                                                     obstacles, is_3d, nodes, edges,\n                                                     self.neighbor_radius, steer, self._is_in_obstacle,\n                                                     self._is_edge_in_obstacle)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                # Try connect other tree\n                connect_node = self._connect_bidirectional(tree_start, kd_start, new_node.position,\n                                                          obstacles, is_3d, nodes, edges,\n                                                          self.neighbor_radius, steer, self._is_in_obstacle,\n                                                          self._is_edge_in_obstacle)\n                if connect_node:\n                    success_state = True\n                    # Note the roles reversed, swap accordingly\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n        if success_state:\n            path_start = connection_node_start.path_from_root()\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _extend_bidirectional(self, tree: List[Node], kd_tree, point, obstacles, is_3d, nodes, edges, neighbor_radius,\n                              steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, point)\n\n        if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n            return None\n\n        if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            if near_node.cost + edge_cost < min_cost:\n                if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = near_node.cost + edge_cost\n                    best_parent = near_node\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Try rewiring neighbors for cost improvement\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            edge_cost = math.dist(new_node.position, near_node.position)\n            cost_through_new = new_node.cost + edge_cost\n            if cost_through_new < near_node.cost:\n                if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = cost_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n        return new_node\n\n    def _connect_bidirectional(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                               neighbor_radius, steer_fn, is_in_obstacle_fn, is_edge_in_obstacle_fn):\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        curr_node = nearest_node\n        while True:\n            new_pos = steer_fn(curr_node.position, target_pos)\n            if self._out_of_bounds(new_pos, tree[0].position, obstacles, is_3d):\n                return None\n\n            if is_in_obstacle_fn(new_pos, obstacles, is_3d) or is_edge_in_obstacle_fn(curr_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = kd_tree.near(new_pos, neighbor_radius)\n\n            min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n            best_parent = curr_node\n            for near_node in near_nodes:\n                edge_cost = math.dist(near_node.position, new_pos)\n                if near_node.cost + edge_cost < min_cost:\n                    if not is_edge_in_obstacle_fn(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = near_node.cost + edge_cost\n                        best_parent = near_node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors similarly\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not is_edge_in_obstacle_fn(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            curr_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _out_of_bounds(self, pos, origin, obstacles, is_3d):\n        # Safety check to not generate nodes past map bounds (origin = start pos's bounds reference)\n        # No explicit bounds checks in original, so add a generic clipping following common sense\n        for d, val in enumerate(pos):\n            if val < 0:\n                return True\n        return False",
    "objective": -3.96181,
    "time_improvement": -2.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009483003616333007,
            "num_nodes_avg": 72.0,
            "path_length_avg": 160.3701129930091,
            "success_improvement": 0.0,
            "time_improvement": -0.5528884439489358,
            "length_improvement": 19.848558922921917,
            "objective_score": 3.8038452513997028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023026371002197267,
            "num_nodes_avg": 276.7,
            "path_length_avg": 231.60591841983734,
            "success_improvement": 0.0,
            "time_improvement": -56.289556001831855,
            "length_improvement": 23.145320691353117,
            "objective_score": -12.25780266227893
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014002847671508788,
            "num_nodes_avg": 202.7,
            "path_length_avg": 123.48043402619813,
            "success_improvement": 0.0,
            "time_improvement": 51.68090352420842,
            "length_improvement": 24.17557492141821,
            "objective_score": 20.339386041546167
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This enhanced bidirectional RRT planner integrates informed sampling using a dynamically updated ellipsoid heuristic to minimize path length, plus nearest neighbor caching for efficiency. Both trees grow alternately with adaptive goal biasing toward the goal and start respectively. New nodes are connected only after rigorous collision and edge validity checks. After the trees connect, the path is extracted and refined using advanced shortcut and weighted smoothing techniques to improve smoothness and reduce length, thus improving planning efficiency, success rate, and path quality.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal. Sampling is biased inside an informed ellipsoid once a first solution is found to focus exploration around better paths. Each iteration extends the chosen tree toward a sampled point, validates the new node and edge, then tries to connect to the other tree efficiently. Upon connection, path extraction and smoothing refine the final path. The nearest neighbor search uses caching to speed up queries, and the path smoothing applies iterative shortcutting and weighted averaging for robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.2, smoothing_iter: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling actual goal point\n        self.smoothing_iter = smoothing_iter      # Number of smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n        edges_set = set()\n\n        # Cache for faster nearest neighbor search (list is small at start, so brute-force ok)\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def collision_free_node(pos):\n            return (not self._is_in_obstacle(pos, obstacles, is_3d)) and self._in_bounds(pos, bounds)\n\n        def collision_free_edge(p1, p2):\n            return (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        # Informed sampling: sample inside ellipsoid defined by current best solution cost\n        def informed_sample(c_best, c_min, start, goal):\n            if c_best == float('inf'):\n                # No solution yet, sample uniformly with goal biasing\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    return uniform_sample()\n            else:\n                # Sample inside ellipsoid to focus search near current best path\n                return sample_in_ellipsoid(start, goal, c_best)\n        \n        def uniform_sample():\n            while True:\n                if is_3d:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]),\n                          random.uniform(0, bounds[2]))\n                else:\n                    pt = (random.uniform(0, bounds[0]),\n                          random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def sample_in_ellipsoid(start, goal, c_max):\n            # Following the Informed RRT* ellipse sampling method for heuristic bias\n            import numpy as np\n            a = c_max / 2.0       # Long axis radius\n            c_min = math.dist(start, goal)\n            if c_min == 0.0:\n                return goal  # Avoid degenerate case\n            b = math.sqrt(max(a*a - (c_min/2.0)**2, 0))  # Short axis radius\n\n            # Sample unit ball point in 2D or 3D inside unit n-ball\n            def sample_unit_ball(dim):\n                vec = np.random.normal(0, 1, dim)\n                norm = np.linalg.norm(vec)\n                r = random.random() ** (1/dim)\n                return r * vec / norm if norm > 0 else vec\n\n            dim = len(start)\n            x_ball = sample_unit_ball(dim)\n            # Scale to ellipse radii\n            L = np.diag([a] + [b]*(dim-1))\n            # Direction rotation matrix from unit vector e1 to vector from start to goal\n            start_np = np.array(start)\n            goal_np = np.array(goal)\n            diff = (goal_np - start_np)\n            e1 = diff / np.linalg.norm(diff)\n            # Create rotation matrix that aligns x-axis with e1\n            def rotation_to_align(e1):\n                d = len(e1)\n                import scipy.linalg\n                I = np.eye(d)\n                v = np.zeros(d)\n                v[0] = 1.0\n                if np.allclose(e1, v):\n                    return I\n                if np.allclose(e1, -v):\n                    # 180 deg rotation in any plane orthogonal to v\n                    R = -I\n                    R[0,0] = 1.0\n                    return R\n                a = v\n                b = e1\n                v_cross = np.cross(a, b) if d == 3 else None\n                if d == 3:\n                    s = np.linalg.norm(v_cross)\n                    c = np.dot(a, b)\n                    vx = np.array([[0, -v_cross[2], v_cross[1]],\n                                   [v_cross[2], 0, -v_cross[0]],\n                                   [-v_cross[1], v_cross[0], 0]])\n                    R = np.eye(3) + vx + vx.dot(vx) * ((1 - c) / (s**2))\n                    return R\n                else:\n                    # For 2D, rotation matrix:\n                    angle = math.atan2(e1[1], e1[0])\n                    R = np.array([[math.cos(angle), -math.sin(angle)],\n                                  [math.sin(angle), math.cos(angle)]])\n                    return R\n            R = rotation_to_align(e1)\n            sample = start_np + R.dot(L.dot(x_ball))\n            sample_tup = tuple(float(x) for x in sample)\n            # Clip sample inside bounds and valid position\n            if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)) or self._is_in_obstacle(sample_tup, obstacles, is_3d):\n                # Fallback to uniform sample if not valid\n                return uniform_sample()\n            return sample_tup\n\n        def path_cost(node):\n            return node.cost\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def add_edge(n1, n2):\n            if (n1, n2) not in edges_set and (n2, n1) not in edges_set:\n                edges.append((n1, n2))\n                edges_set.add((n1, n2))\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            cur_pos = nearest_node.position\n            total_cost = nearest_node.cost\n            parent_node = nearest_node\n\n            while True:\n                next_pos = steer(cur_pos, new_node.position)\n                if not collision_free_edge(cur_pos, next_pos):\n                    return None\n                if not collision_free_node(next_pos):\n                    return None\n                next_cost = total_cost + math.dist(cur_pos, next_pos)\n                next_node = Node(next_pos, parent=parent_node, cost=next_cost)\n                parent_node.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                add_edge(parent_node, next_node)\n\n                if math.dist(next_pos, new_node.position) <= self.step_size:\n                    # Try final connection edge\n                    if collision_free_edge(next_pos, new_node.position) and collision_free_node(new_node.position):\n                        return next_node\n                    return None\n                parent_node = next_node\n                cur_pos = next_pos\n                total_cost = next_cost\n\n        def shortcut_path(path):\n            # Shortcut path using random pairs  - faster and better for length minimization\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if collision_free_edge(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def smooth_path_weighted(path):\n            # Smooth path by iterative weighted averaging to reduce sharp changes\n            if len(path) < 3:\n                return path\n            path_np = [list(p) for p in path]\n            alpha = 0.4\n            beta = 0.2\n            for _ in range(self.smoothing_iter):\n                new_path = [path_np[0]]\n                for i in range(1, len(path_np)-1):\n                    prev_p = path_np[i-1]\n                    curr_p = path_np[i]\n                    next_p = path_np[i+1]\n                    new_coords = [curr_p[d] + alpha*(prev_p[d] + next_p[d] - 2*curr_p[d]) for d in range(len(curr_p))]\n                    # Only update if collision free with neighbors\n                    p_prev = tuple(new_coords)\n                    if collision_free_edge(path_np[i-1], p_prev) and collision_free_edge(p_prev, path_np[i+1]) and not self._is_in_obstacle(p_prev, obstacles, is_3d):\n                        new_path.append(new_coords)\n                    else:\n                        new_path.append(curr_p)\n                new_path.append(path_np[-1])\n                path_np = new_path\n            path_smoothed = [tuple(p) for p in path_np]\n            return path_smoothed\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        best_path = None\n\n        # Alternate tree growth with heuristic informed sampling after first solution\n        for itr in range(self.max_iter):\n            if len(tree_start) == 0 or len(tree_goal) == 0:\n                break\n\n            # Alternate expanding tree_start and tree_goal each iteration\n            extend_start_tree = (itr % 2 == 0)\n\n            # Sample point - informed sampling after first found solution\n            if extend_start_tree:\n                rand_point = informed_sample(c_best, c_min, start_position, goal_position)\n                nearest_node = nearest(tree_start, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_start.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_goal)\n                if connect_node:\n                    # path found\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    # Early break to find best feasible quickly\n                    extracted_path = best_path\n                    break\n\n            else:\n                rand_point = informed_sample(c_best, c_min, goal_position, start_position)\n                nearest_node = nearest(tree_goal, rand_point)\n                new_pos = steer(nearest_node.position, rand_point)\n                if not collision_free_node(new_pos) or not collision_free_edge(nearest_node.position, new_pos):\n                    continue\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n                nearest_node.add_child(new_node)\n                tree_goal.append(new_node)\n                nodes.append(new_node)\n                add_edge(nearest_node, new_node)\n\n                connect_node = connect_trees(new_node, tree_start)\n                if connect_node:\n                    success_state = True\n                    if extend_start_tree:\n                        path_candidate = reconstruct_path(new_node, connect_node)\n                    else:\n                        path_candidate = reconstruct_path(connect_node, new_node)\n                    cost_candidate = self._path_length(path_candidate)\n                    if cost_candidate < c_best:\n                        c_best = cost_candidate\n                        best_path = path_candidate\n                    extracted_path = best_path\n                    break\n\n        if success_state and best_path:\n            # Improve path by shortcut + smoothing\n            extracted_path = shortcut_path(best_path)\n            extracted_path = smooth_path_weighted(extracted_path)\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path if extracted_path else [],\n                             nodes=nodes,\n                             edges=edges)\n\n    def _path_length(self, path):\n        import math\n        length = 0.0\n        for i in range(len(path) - 1):\n            length += math.dist(path[i], path[i+1])\n        return length\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(pos)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
    "objective": 109.06939,
    "time_improvement": -371.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.09053049087524415,
            "num_nodes_avg": 72.6,
            "path_length_avg": 162.22412286628153,
            "success_improvement": -9.999999999999998,
            "time_improvement": -859.9387196347446,
            "length_improvement": 18.92194260807031,
            "objective_score": -259.1972273688093
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04918806552886963,
            "num_nodes_avg": 247.5,
            "path_length_avg": 243.15743782945282,
            "success_improvement": 0.0,
            "time_improvement": -233.85985665576513,
            "length_improvement": 19.312135745948165,
            "objective_score": -66.29552984753991
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03469226360321045,
            "num_nodes_avg": 321.8,
            "path_length_avg": 128.66844422598928,
            "success_improvement": 0.0,
            "time_improvement": -19.71128097164393,
            "length_improvement": 20.989824127753838,
            "objective_score": -1.7154194659424107
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the strength of bidirectional RRT* incremental rewiring and goal biasing with the simplicity and incremental growth strategy of standard RRT. It employs bidirectional search to explore from both start and goal nodes, adapts goal sampling bias dynamically, uses an adaptive neighborhood radius for local rewiring to optimize path quality, and balances tree growth by always extending the smaller tree first. It incorporates efficient collision and edge checking and prunes suboptimal paths when possible. Additionally, it applies a smoothing pass for the final path to further improve path smoothness and length, leveraging steering with fixed step size for incremental growth. This synergy results in faster convergence, higher success rates, and smoother, shorter paths while reducing search time and maintaining robustness.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal. It then iteratively samples points with adaptive goal bias and attempts to extend the smaller tree toward these points. Each new node locally rewires neighbors within an adaptive radius to improve path costs. After extending one tree, it attempts to connect the other tree toward the newly added node to check for a path connection. Once connected, it reconstructs the path by merging branches from both trees. Finally, the path is smoothed by shortcutting to reduce unnecessary waypoints. Collision and edge feasibility checks are rigorously applied before node/edge acceptance, ensuring safe, robust paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal sampling with increasing bias toward goal as iterations increase\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start)\n                         * iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new node if improvement found\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    # Check final connection edge\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=100):\n            # Shortcut smoothing: try random pairs and attempt shortcut if collision-free\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # Shortcut is feasible, remove intermediate points\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Main iterative planning loop\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Alternate growth by always extending smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge while avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                # Smooth merged path to improve smoothness and shorten path length\n                smoothed_path = smooth_path(merged_path, max_trials=150)\n                extracted_path = smoothed_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.87725,
    "time_improvement": -16.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011067795753479003,
            "num_nodes_avg": 78.3,
            "path_length_avg": 164.46229291518293,
            "success_improvement": 0.0,
            "time_improvement": -17.35720840633128,
            "length_improvement": 17.803326729793657,
            "objective_score": -1.6464971759406528
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020533823966979982,
            "num_nodes_avg": 277.5,
            "path_length_avg": 240.4994491111335,
            "success_improvement": 0.0,
            "time_improvement": -39.37160269470332,
            "length_improvement": 20.194146326446944,
            "objective_score": -7.772651543121607
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02687411308288574,
            "num_nodes_avg": 252.0,
            "path_length_avg": 125.33436833056348,
            "success_improvement": 0.0,
            "time_improvement": 7.266515124964315,
            "length_improvement": 23.037147575656384,
            "objective_score": 6.787384052620571
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with adaptive rewiring and dynamic radius adjustment, while incorporating heuristic informed sampling towards the goal and enhanced collision checks. It dynamically balances exploration and exploitation by alternating tree expansions, improves path quality via local rewiring around new nodes, and enforces strict collision-free checks for nodes and edges. The method prunes suboptimal nodes iteratively to enhance planning efficiency, leading to smoother and shorter paths with higher success rates and reduced search time.",
    "planning_mechanism": "The planner grows two trees from start and goal, alternately sampling free points biased towards the goal. Each extension uses a steering function with a fixed step size, adding nodes only after thorough collision checks. Rewiring is performed locally with a dynamically shrinking radius to optimize path costs incrementally. The trees attempt to connect after each extension, and upon success, the optimal path is constructed by backtracking. This blend of bidirectional search, incremental optimization, adaptive sampling, and pruning yields efficient, robust, and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Heuristic guided sampling with goal bias and start bias for efficient tree growth\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d]-from_pos[d])*ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search with linear scan (can be improved with spatial indexing if needed)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes+1) / (n_nodes+1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d): \n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Rewire radius scales inversely with node count\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            # Add edge record\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Rewire neighbors around new_node for local path cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # epsilon to avoid floating error loops\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge feasibility check before adding terminal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees with start and goal roots\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Merge paths, avoid duplicated connecting node\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Optional pruning of nodes with no children and higher cost to improve efficiency\n            if itr % 250 == 0 and len(nodes) > 100:\n                pruned = []\n                for node in nodes[:]:\n                    if not node.children and node is not start_root and node is not goal_root:\n                        try:\n                            node.parent.children.remove(node)\n                            nodes.remove(node)\n                            # Remove edges related to node\n                            edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                            pruned.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.15402,
    "time_improvement": 15.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004810810089111328,
            "num_nodes_avg": 94.0,
            "path_length_avg": 182.51310029888023,
            "success_improvement": 0.0,
            "time_improvement": 48.98864644717982,
            "length_improvement": 8.781706694699151,
            "objective_score": 16.452935273093775
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02035815715789795,
            "num_nodes_avg": 178.3,
            "path_length_avg": 287.3732004707603,
            "success_improvement": 0.0,
            "time_improvement": -38.17927900665584,
            "length_improvement": 4.639849815737334,
            "objective_score": -10.525813738849285
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01868715286254883,
            "num_nodes_avg": 139.1,
            "path_length_avg": 147.54383101693634,
            "success_improvement": 0.0,
            "time_improvement": 35.516948894576494,
            "length_improvement": 9.399199565681393,
            "objective_score": 12.534924581509227
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an optimized bidirectional Rapidly-exploring Random Tree (RRT) planner with adaptive step size tuning, informed bias sampling, rewiring for path smoothing, and efficient node connection to improve planning efficiency, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner grows two trees starting at the start and goal positions, with an adaptive step size that reduces for finer search near obstacles or goal, biased sampling towards goal and previously found paths, and rewiring of nodes to reduce costs. Collision checks are done for node and edges before expansions. When the trees connect, the path is backtracked and smoothed by rewiring steps.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def path_cost_from_root(self):\n        cost = 0.0\n        node = self\n        while node.parent is not None:\n            cost += self._distance(node.position, node.parent.position)\n            node = node.parent\n        return cost\n\n    @staticmethod\n    def _distance(p1, p2):\n        import math\n        return math.dist(p1, p2)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=7.0, goal_sample_rate: float=0.1,\n                 search_radius_factor: float=5.0, adaptive_step: bool=True):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate          # Probability to sample goal directly (bias)\n        self.search_radius_factor = search_radius_factor  # For rewiring radius\n        self.adaptive_step = adaptive_step                 \n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        bounds = map.size                      # (W,H) or (W,H,D)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def adaptive_step_size(node_pos):\n            # Reduce step size near obstacles and as approach goal for finer search\n            min_dist_obs = min((dist(node_pos, self._obstacle_center(obs, is_3d)) - self._obstacle_radius(obs, is_3d)) \n                               for obs in obstacles) if obstacles else 10.0\n            dist_to_goal = dist(node_pos, goal_position)\n            step = self.step_size\n            if self.adaptive_step:\n                step = max(1.0, min(self.step_size, min(min_dist_obs * 0.5, dist_to_goal * 0.5)))\n            return step\n\n        def nearest_nodes_within_radius(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        for iteration in range(self.max_iter):\n            # Biased sampling with goal biasing\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._sample_free(bounds, obstacles, is_3d)\n\n            # Extend tree A towards rand_point with adaptive step size\n            nearest_node = self._nearest(tree_a, rand_point)\n            step = adaptive_step_size(nearest_node.position)\n            new_pos = self._steer(nearest_node.position, rand_point, step)\n\n            if self._is_in_bounds(new_pos, bounds) and \\\n               not self._is_in_obstacle(new_pos, obstacles, is_3d) and \\\n               not self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos, parent=None, cost=new_cost)\n\n                # Choose best parent for new_node through rewiring in radius\n                radius = min(self.search_radius_factor * (math.log(len(tree_a)+1) / (len(tree_a)+1))**(1/len(bounds)),\n                             step) + step\n                near_nodes = nearest_nodes_within_radius(tree_a, new_pos, radius)\n                best_parent = nearest_node\n                best_cost = new_cost\n                for near_node in near_nodes:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        cost = near_node.cost + dist(near_node.position, new_pos)\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_parent = near_node\n\n                new_node.parent = best_parent\n                new_node.cost = best_cost\n                best_parent.add_child(new_node)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire near nodes if better path found through new_node\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                        if cost_through_new < near_node.cost:\n                            # Rewire parent\n                            if near_node.parent:\n                                try:\n                                    near_node.parent.children.remove(near_node)\n                                except ValueError:\n                                    pass\n                            near_node.parent = new_node\n                            near_node.cost = cost_through_new\n                            new_node.children.append(near_node)\n                            # Update costs downstream recursively\n                            self._update_children_costs(near_node, dist)\n\n                # Try connecting to tree_b\n                nearest_to_new = self._nearest(tree_b, new_node.position)\n                step_b = adaptive_step_size(nearest_to_new.position)\n                if dist(nearest_to_new.position, new_node.position) <= step_b:\n                    if not self._is_edge_in_obstacle(nearest_to_new.position, new_node.position, obstacles, is_3d):\n                        # Connect trees\n                        new_node_b = Node(new_node.position, parent=nearest_to_new, cost=nearest_to_new.cost + dist(nearest_to_new.position,new_node.position))\n                        nearest_to_new.add_child(new_node_b)\n                        tree_b.append(new_node_b)\n                        nodes.append(new_node_b)\n                        edges.append((nearest_to_new, new_node_b))\n                        success_state = True\n\n                        path_a = new_node.path_from_root()\n                        path_b = new_node_b.path_from_root()\n                        extracted_path = self._smooth_path(path_a + path_b[::-1], obstacles, is_3d)\n                        break\n                else:\n                    # Try to extend connecting tree towards new_node incrementally\n                    connect_node = nearest_to_new\n                    while True:\n                        new_connect_pos = self._steer(connect_node.position, new_node.position, step_b)\n                        if not self._is_in_bounds(new_connect_pos, bounds):\n                            break\n                        if self._is_in_obstacle(new_connect_pos, obstacles, is_3d) or \\\n                           self._is_edge_in_obstacle(connect_node.position, new_connect_pos, obstacles, is_3d):\n                            break\n                        new_node_b = Node(new_connect_pos, parent=connect_node,\n                                          cost=connect_node.cost + dist(connect_node.position, new_connect_pos))\n                        connect_node.add_child(new_node_b)\n                        tree_b.append(new_node_b)\n                        nodes.append(new_node_b)\n                        edges.append((connect_node, new_node_b))\n\n                        if dist(new_connect_pos, new_node.position) <= step_b:\n                            if not self._is_edge_in_obstacle(new_connect_pos, new_node.position, obstacles, is_3d):\n                                new_node_b2 = Node(new_node.position, parent=new_node_b,\n                                                  cost=new_node_b.cost + dist(new_connect_pos, new_node.position))\n                                new_node_b.add_child(new_node_b2)\n                                tree_b.append(new_node_b2)\n                                nodes.append(new_node_b2)\n                                edges.append((new_node_b, new_node_b2))\n\n                                success_state = True\n                                path_a = new_node.path_from_root()\n                                path_b = new_node_b2.path_from_root()\n                                extracted_path = self._smooth_path(path_a + path_b[::-1], obstacles, is_3d)\n                            break\n                        connect_node = new_node_b\n\n                # Swap trees every iteration to balance growth\n                tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _update_children_costs(self, node, dist_func):\n        # Recursive update after rewiring parent\n        for child in node.children:\n            old_cost = child.cost\n            new_cost = node.cost + dist_func(node.position, child.position)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                self._update_children_costs(child, dist_func)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        trials = 0\n        while True:\n            if is_3d:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]),\n                     random.uniform(0, bounds[2]))\n            else:\n                p = (random.uniform(0, bounds[0]),\n                     random.uniform(0, bounds[1]))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n            trials +=1 \n            if trials > 1000:  # fallback if stuck\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size=None):\n        import math\n        if step_size is None:\n            step_size = self.step_size\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _obstacle_center(self, obs, is_3d):\n        if is_3d:\n            x, y, z, w, h, d = obs\n            return (x + w/2, y + h/2, z + d/2)\n        else:\n            x, y, w, h = obs\n            return (x + w/2, y + h/2)\n\n    def _obstacle_radius(self, obs, is_3d):\n        if is_3d:\n            _, _, _, w, h, d = obs\n            # Approximate radius for radius-based distance calculation\n            return ((w/2)**2 + (h/2)**2 + (d/2)**2)**0.5\n        else:\n            _, _, w, h = obs\n            return ((w/2)**2 + (h/2)**2)**0.5\n\n    def _is_in_bounds(self, pos, bounds):\n        for i, v in enumerate(pos):\n            if v < 0 or v > bounds[i]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        # Shortcut smoothing by trying to connect non-adjacent nodes directly\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        import random\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for test_idx in range(len(path) - 1, idx, -1):\n                if not self._is_edge_in_obstacle(path[idx], path[test_idx], obstacles, is_3d):\n                    next_idx = test_idx\n                    break\n            smoothed.append(path[next_idx])\n            idx = next_idx\n        return smoothed",
    "objective": 576.2706,
    "time_improvement": -1925.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.13318750858306885,
            "num_nodes_avg": 254.6,
            "path_length_avg": 148.5377135291306,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1312.2517753356642,
            "length_improvement": 25.7622784478988,
            "objective_score": -393.52307691111946
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.3934208869934082,
            "num_nodes_avg": 1287.0,
            "path_length_avg": 236.8114627197937,
            "success_improvement": 0.0,
            "time_improvement": -2570.311172532539,
            "length_improvement": 21.417944981226036,
            "objective_score": -766.8097627635165
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.5777501106262207,
            "num_nodes_avg": 1340.1,
            "path_length_avg": 125.33644041754224,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1893.6204398658338,
            "length_improvement": 23.035875189426804,
            "objective_score": -568.4789569218648
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a bidirectional RRT* planner that efficiently explores the space by growing two trees from start and goal positions, incorporating rewiring to optimize path costs continuously. It balances rapid exploration with local path improvements, ensuring high success rates and high-quality, smooth paths.",
    "planning_mechanism": "The planner samples free points within map bounds, extends the nearest nodes in each tree towards these points while ensuring collision avoidance, attempts to connect the two trees, and rewires neighbors to minimize cost. Once connected, the path is extracted and smoothed for optimal navigation performance.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near(tree, point, radius):\n            return [node for node in tree if math.dist(node.position, point) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = node\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    if node.parent:\n                        edges.remove((node.parent, node))\n                        node.parent.children.remove(node)\n                    node.parent = new_node\n                    node.cost = cost_through_new\n                    new_node.add_child(node)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, target_pos):\n            current_node = nearest(tree, target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree, new_pos, self.neighbor_radius)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            edges.remove((node.parent, node))\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a.position)\n            if new_node_b:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.31503,
    "time_improvement": -2.0,
    "length_improvement": 27.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009461736679077149,
            "num_nodes_avg": 68.6,
            "path_length_avg": 157.90810556621656,
            "success_improvement": 0.0,
            "time_improvement": -0.3273847896268319,
            "length_improvement": 21.079046571256317,
            "objective_score": 4.1175938773632135
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.017914962768554688,
            "num_nodes_avg": 235.1,
            "path_length_avg": 217.9828629857762,
            "success_improvement": -9.999999999999998,
            "time_improvement": -21.596302631429896,
            "length_improvement": 27.665911372851916,
            "objective_score": -5.945708514858585
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.024679231643676757,
            "num_nodes_avg": 299.9,
            "path_length_avg": 111.38058968744186,
            "success_improvement": -9.999999999999998,
            "time_improvement": 14.84030943466389,
            "length_improvement": 31.605608252301014,
            "objective_score": 5.77321448085937
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an optimized bidirectional RRT* variant augmented with an efficient KD-tree nearest neighbor structure, adaptive heuristic goal biasing, and informed sampling within an ellipsoidal subset to drastically reduce sampling space and improve convergence. It uses cost-aware rewiring to minimize path length locally, aggressive early termination upon tree connection, and iterative shortcut-based smoothing to refine path quality while maintaining collision-free guarantees. The planner balances exploration and exploitation via alternating tree growth and employs strict collision and edge checks to ensure robustness and reliability.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, employing heuristic and informed sampling strategies that bias samples toward the connectable region between trees. Using a KD-tree for fast nearest and near neighbor retrieval, it performs cost-based rewiring to improve path quality locally. Trees alternate growth and attempt connections to minimize total path cost, with early stopping once path found. Post extraction, iterative smoothing shortcuts the path while verifying obstacle collisions to ensure reduced length and improved smoothness, ultimately achieving efficient and high-quality path planning in complex environments.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from start\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate: float=0.15,\n                 neighbor_radius: float=15.0, smoothing_iter: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Early fail if start or goal inside obstacle\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or \\\n           self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    dist = math.dist(node.position, point)\n                    if dist < best_dist:\n                        best_dist = dist\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    d_sq = 0\n                    for d in range(dim):\n                        diff = node.position[d] - point[d]\n                        d_sq += diff*diff\n                        if d_sq > r_sq:\n                            break\n                    if d_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n\n        def informed_sample(c_best, start, goal):\n            # Informed sampling inside an ellipse: sampling inside an ellipse between start and goal constrained by c_best (current best path length)\n            # Only used if a solution exists to improve path quality and speed-up convergence\n\n            if c_best == float('inf'):\n                # No solution found, use basic biased sampling\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                else:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            dist_start_goal = math.dist(start, goal)\n            if dist_start_goal == 0:\n                return start\n\n            # Define ellipse axes lengths\n            a = c_best / 2.0  # major axis half-length\n            c = dist_start_goal / 2.0\n            if a <= c:\n                # Degenerate case, sample uniformly\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            b = math.sqrt(a * a - c * c)  # minor axis half-length\n\n            def sample_unit_ball():\n                # Sample uniformly within unit ball in dim-dimensional space\n                import random as rand\n                if dim == 2:\n                    while True:\n                        x = rand.uniform(-1, 1)\n                        y = rand.uniform(-1, 1)\n                        if x*x + y*y <= 1:\n                            return (x,y)\n                else:\n                    while True:\n                        x = rand.uniform(-1,1)\n                        y = rand.uniform(-1,1)\n                        z = rand.uniform(-1,1)\n                        if x*x + y*y + z*z <=1:\n                            return (x,y,z)\n\n            # Rotation from ellipse frame to world frame\n            # Direction vector start->goal\n            dir_vec = tuple((goal[d] - start[d]) / dist_start_goal for d in range(dim))\n            if dim == 2:\n                # 2D rotation matrix from x-axis to dir_vec\n                cos_theta = dir_vec[0]\n                sin_theta = dir_vec[1]\n\n                while True:\n                    x_ball, y_ball = sample_unit_ball()\n                    # Scale to ellipse axes\n                    x_ellip = x_ball * a\n                    y_ellip = y_ball * b\n                    # Rotate to map frame\n                    sample_x = center[0] + cos_theta * x_ellip - sin_theta * y_ellip\n                    sample_y = center[1] + sin_theta * x_ellip + cos_theta * y_ellip\n                    sample = (sample_x, sample_y)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                # 3D rotation to align x-axis with dir_vec\n                # Use Householder transformation or build rotation matrix\n                import numpy as np\n                e1 = np.array([1.0,0.0,0.0])\n                dir_v = np.array(dir_vec)\n                if np.allclose(dir_v, e1):\n                    R = np.eye(3)\n                elif np.allclose(dir_v, -e1):\n                    R = -np.eye(3)\n                else:\n                    v = np.cross(e1, dir_v)\n                    s = np.linalg.norm(v)\n                    c = np.dot(e1, dir_v)\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c)/(s*s))\n\n                while True:\n                    x_ball, y_ball, z_ball = sample_unit_ball()\n                    scaled = np.array([a*x_ball, b*y_ball, b*z_ball])\n                    rotated = R.dot(scaled)\n                    sample_np = np.array(center) + rotated\n                    sample = tuple(sample_np.tolist())\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        c_best = float('inf')  # Best path cost found so far\n\n        def choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes:\n                edge_cost = math.dist(node.position, new_pos)\n                cost_through_node = node.cost + edge_cost\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n            if best_parent is None:\n                return None, None\n            return best_parent, min_cost\n\n        def rewire(new_node, near_nodes, obstacles, is_3d, edges):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                edge_cost = math.dist(new_node.position, near_node.position)\n                cost_through_new = new_node.cost + edge_cost\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Update parent connection\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            if near_node in near_node.parent.children:\n                                near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n        def extend(tree, kd_tree, sample_point):\n            nearest_node = kd_tree.nearest(sample_point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_point)\n\n            if not in_bounds(new_pos):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n            parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n            if parent_node is None:\n                # Fallback to nearest_node\n                parent_node = nearest_node\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                # Double check edge validity (already checked once)\n                if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n            new_node = Node(new_pos)\n            new_node.parent = parent_node\n            new_node.cost = min_cost\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            kd_tree.insert(new_node)\n\n            rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n            return new_node\n\n\n        def connect(tree, kd_tree, target_node):\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n            curr_node = nearest_node\n\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n                parent_node, min_cost = choose_parent(new_pos, near_nodes, kd_tree, obstacles, is_3d)\n                if parent_node is None:\n                    parent_node = curr_node\n                    min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                    if self._is_edge_in_obstacle(parent_node.position, new_pos, obstacles, is_3d):\n                        return None\n\n                new_node = Node(new_pos)\n                new_node.parent = parent_node\n                new_node.cost = min_cost\n                parent_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                kd_tree.insert(new_node)\n\n                rewire(new_node, near_nodes, obstacles, is_3d, edges)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size * 0.5:\n                    return new_node\n\n                curr_node = new_node\n\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                import random\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        tree_flag = True  # True=extend start tree, False=extend goal tree\n\n        for iter in range(self.max_iter):\n            sample_pt = informed_sample(c_best, start_position, goal_position)\n\n            if tree_flag:\n                new_node = extend(tree_start, kd_start, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_goal, kd_goal, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = new_node\n                        connection_node_goal = connect_node\n                        # Early exit once a better solution found\n                        break\n            else:\n                new_node = extend(tree_goal, kd_goal, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_start, kd_start, new_node)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = connect_node\n                        connection_node_goal = new_node\n                        break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state and connection_node_start is not None and connection_node_goal is not None:\n            extracted_path = extract_path(connection_node_start, connection_node_goal)\n            # Iterative smoothing\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 37.41939,
    "time_improvement": -127.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02829596996307373,
            "num_nodes_avg": 116.0,
            "path_length_avg": 169.7434955762623,
            "success_improvement": -9.999999999999998,
            "time_improvement": -200.0358985638046,
            "length_improvement": 15.163832400048669,
            "objective_score": -61.97800308913164
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.04106793403625488,
            "num_nodes_avg": 297.4,
            "path_length_avg": 238.03299060648334,
            "success_improvement": -9.999999999999998,
            "time_improvement": -178.74514728466403,
            "length_improvement": 21.012600702294776,
            "objective_score": -54.421024044940246
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02965552806854248,
            "num_nodes_avg": 247.3,
            "path_length_avg": 123.43876793354507,
            "success_improvement": 0.0,
            "time_improvement": -2.331208294152157,
            "length_improvement": 24.20116041231484,
            "objective_score": 4.140869594217321
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a Bidirectional RRT* with informed sampling toward an elliptical sampling region based on the current solution cost, enabling faster convergence to shorter paths. It uses kd-tree structures for efficient nearest neighbor searches, a dynamic rewiring radius decreasing with iterations for performance, and shortcut smoothing post-planning for path quality. The planner aggressively connects trees while maintaining collision and edge checks, balancing exploration and exploitation to enhance success rate, path smoothness, and computational speed.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal, sampling points biased within an informed set shaped by the best path found to focus exploration. It extends the tree toward sampled points with step-size constraints, rewires neighbors to optimize costs dynamically, and attempts to connect the two trees whenever new nodes appear. The path is reconstructed upon connection and then smoothed to reduce unnecessary waypoints, all while leveraging efficient nearest neighbor computations and adaptive parameters to accelerate convergence and improve robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        if new_cost < self.cost:\n            if self.parent:\n                try:\n                    self.parent.children.remove(self)\n                except ValueError:\n                    pass\n            self.parent = new_parent\n            self.cost = new_cost\n            new_parent.children.append(self)\n            for child in self.children:\n                child.update_cost(child.cost - self.cost + new_cost, self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_factor: float=1.2):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_factor = rewire_factor\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import insort_left\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # kd-tree helper for nearest neighbor search\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n                self.points = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n                self.points.append(node.position)\n\n            def nearest(self, point):\n                min_dist = float('inf')\n                nearest_node = None\n                for n in self.nodes:\n                    d = math.dist(n.position, point)\n                    if d < min_dist:\n                        min_dist = d\n                        nearest_node = n\n                return nearest_node\n\n            def near(self, point, radius):\n                res = []\n                r2 = radius * radius\n                for n in self.nodes:\n                    # squared dist for speed\n                    d2 = sum((n.position[d]-point[d])**2 for d in range(dim))\n                    if d2 <= r2:\n                        res.append(n)\n                return res\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def in_bounds(pos):\n            for i in range(dim):\n                if not (0 <= pos[i] <= bounds[i]):\n                    return False\n            return True\n\n        def sample_free():\n            # Use informed sampling if solution found, else uniform\n            if best_cost < float('inf'):\n                # Elliptical sampling around start/goal with cost bound\n                c_min = math.dist(start_position, goal_position)\n                c_best = best_cost\n                if c_best < float('inf'):\n                    # Generate random point inside unit ball\n                    while True:\n                        x_ball = [random.uniform(-1,1) for _ in range(dim)]\n                        norm = math.sqrt(sum(x*x for x in x_ball))\n                        if norm <= 1:\n                            x_ball = [x / norm for x in x_ball]\n                            break\n                    # Ellipse axis lengths\n                    L = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n                    # Rotation alignment (only approximated here by vector from start to goal):\n                    # We align first axis along start->goal unit vector\n                    e_1 = []\n                    diff = [goal_position[d] - start_position[d] for d in range(dim)]\n                    norm_d = math.sqrt(sum(v*v for v in diff))\n                    for d in diff:\n                        e_1.append(d / norm_d if norm_d > 0 else 1.0)\n                    # Construct point in ellipse space:\n                    point_ellipse = [L[0]*x_ball[0]] + [L[i]*x_ball[i] for i in range(1, dim)]\n                    # Rotate back (approximate rotation along e_1):\n                    # For 2D, rotate x axis to vector direction:\n                    if dim == 2:\n                        cos_a = e_1[0]\n                        sin_a = e_1[1]\n                        x = point_ellipse[0]*cos_a - point_ellipse[1]*sin_a\n                        y = point_ellipse[0]*sin_a + point_ellipse[1]*cos_a\n                        sample = (x + (start_position[0] + goal_position[0])/2,\n                                  y + (start_position[1] + goal_position[1])/2)\n                    elif dim == 3:\n                        # Simple approximation: align along e_1 axis only\n                        # Project point_ellipse along e_1 plus orthogonal:\n                        # Orthogonal component in plane formed by first 3 dims - skip sophisticated rotation\n                        center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                        v = tuple(e_1[d]*point_ellipse[0] for d in range(dim))\n                        orth = tuple(point_ellipse[d] for d in range(1, dim))\n                        # Construct sample coordinate\n                        sample = tuple(center[d] + v[d] for d in range(dim))  # Drop orthogonal for simplicity\n                    else:\n                        # For other dim, fallback uniform\n                        return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback uniform\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def connected(p1, p2):\n            # Check if path between p1 and p2 is collision free and inside bounds\n            if not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n\n        tree_start = KDTree()\n        tree_goal = KDTree()\n        tree_start.insert(start_root)\n        tree_goal.insert(goal_root)\n\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float('inf')\n        connection_start_node = None\n        connection_goal_node = None\n\n        # Rewiring radius schedule (shrink with iterations)\n        gamma = self.rewire_factor * (math.log(self.max_iter) / self.max_iter) ** (1/dim)\n        def radius(iteration):\n            return min(self.step_size * 5, gamma * (math.log(iteration + 1)/ (iteration + 1))**(1/dim))\n\n        def extend(tree_from, tree_to, sample_pt, iter_count):\n            nearest_node = tree_from.nearest(sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Create new node and choose best parent from near nodes\n            new_node = Node(new_pos)\n            near_nodes = tree_from.near(new_pos, radius(iter_count))\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for n in near_nodes:\n                cost_cand = n.cost + math.dist(n.position, new_pos)\n                if cost_cand < min_cost and not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_cand\n                    best_parent = n\n\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n\n            tree_from.insert(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if cheaper via new_node\n            for n in near_nodes:\n                if n is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new < n.cost and not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                    if n.parent:\n                        try:\n                            edges.remove((n.parent, n))\n                            n.parent.children.remove(n)\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.children.append(n)\n                    edges.append((new_node, n))\n                    # Propagate cost update downstream\n                    def propagate_cost(node):\n                        for ch in node.children:\n                            new_cost = node.cost + math.dist(node.position, ch.position)\n                            if new_cost < ch.cost:\n                                ch.cost = new_cost\n                                ch.parent = node\n                                propagate_cost(ch)\n                    propagate_cost(n)\n\n            return new_node\n\n        def connect_trees(n_start, tree_goal):\n            # Try connecting new node in start tree to nearest in goal tree sequence toward start node\n            q_near = tree_goal.nearest(n_start.position)\n            if connected(n_start.position, q_near.position):\n                return q_near\n            # Try extending goal tree toward n_start to connect\n            current = q_near\n            while True:\n                new_pos = steer(current.position, n_start.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_node = Node(new_pos)\n                near_nodes = tree_goal.near(new_pos, radius(len(nodes)))\n                min_cost = current.cost + math.dist(current.position, new_pos)\n                best_parent = current\n                for node in near_nodes:\n                    cost_cand = node.cost + math.dist(node.position, new_pos)\n                    if cost_cand < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_cand\n                        best_parent = node\n\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree_goal.insert(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors in goal tree\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                                node.parent.children.remove(node)\n                            except ValueError:\n                                pass\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.children.append(node)\n                        edges.append((new_node, node))\n                        def propagate_cost(node):\n                            for ch in node.children:\n                                new_cost = node.cost + math.dist(node.position, ch.position)\n                                if new_cost < ch.cost:\n                                    ch.cost = new_cost\n                                    ch.parent = node\n                                    propagate_cost(ch)\n                        propagate_cost(node)\n\n                if math.dist(new_node.position, n_start.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        def reconstruct_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            sample = sample_free()\n            new_node_start = extend(tree_start, tree_goal, sample, iteration)\n            if new_node_start is None:\n                # Swap trees if fail to extend start tree\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n            new_node_goal = connect_trees(new_node_start, tree_goal)\n            if new_node_goal:\n                # Check total cost and update best solution if better\n                total_cost = new_node_start.cost + math.dist(new_node_start.position, new_node_goal.position) + new_node_goal.cost\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    connection_start_node = new_node_start\n                    connection_goal_node = new_node_goal\n                # Swap trees to continue search with balanced growth\n                tree_start, tree_goal = tree_goal, tree_start\n            else:\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Early stop if solution found with cost close to optimal straight-line\n            if best_cost <= math.dist(start_position, goal_position) * 1.05:\n                break\n\n        success_state = connection_start_node is not None and connection_goal_node is not None\n        extracted_path = []\n        if success_state:\n            extracted_path = reconstruct_path(connection_start_node, connection_goal_node)\n            extracted_path = smooth_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 7399.60874,
    "time_improvement": -24666.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.8763187646865847,
            "num_nodes_avg": 4676.7,
            "path_length_avg": 154.1738922229301,
            "success_improvement": 0.0,
            "time_improvement": -41002.48863001474,
            "length_improvement": 22.945370508851283,
            "objective_score": -12296.157514902652
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 3.1616681575775147,
            "num_nodes_avg": 4234.1,
            "path_length_avg": 220.4672113458751,
            "success_improvement": -9.999999999999998,
            "time_improvement": -21359.556632947813,
            "length_improvement": 26.841520537725437,
            "objective_score": -6407.498685776799
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 3.401038312911987,
            "num_nodes_avg": 4384.4,
            "path_length_avg": 117.41325394846561,
            "success_improvement": -19.999999999999996,
            "time_improvement": -11635.834182773115,
            "length_improvement": 27.90118898222309,
            "objective_score": -3495.1700170354898
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This enhanced hybrid bidirectional RRT* planner improves upon the base by integrating adaptive goal biasing, dynamic neighbor radius based on node density, and a cost-aware rewiring mechanism that aggressively reduces path length while maintaining collision safety. It implements informed sampling focused within an ellipsoidal region between start and goal after initial connection to accelerate convergence towards shorter paths. The rewiring is optimized to minimize overall cost locally, leading to smoother, shorter paths and faster convergence. Additionally, the planner balances exploration and exploitation by alternating tree growth and performing rewiring in both trees after connection to refine the path quality further.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, extending towards randomly sampled points biased towards the start or goal to reduce symmetries. When a new node is added, it connects through the least-cost neighbor within an adaptive radius and rewires nearby nodes to optimize path costs locally under collision constraints. Once the trees connect, an initial path is found and further refined by informed sampling restricting samples into the ellipsoid connecting start and goal, enhancing path shortening. The final path is reconstructed by backtracking from both trees, providing a high-quality, collision-free trajectory efficiently and robustly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, max_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # For informed sampling ellipsoid parameters\n        best_path_length = math.inf\n        found_connection = False\n\n        def sample_in_ellipsoid():\n            # Sample inside an ellipsoid defined by start, goal, and current best solution length\n            c_min = math.dist(start_position, goal_position)\n            if best_path_length == math.inf:\n                return None  # no ellipsoid defined yet\n\n            # Coordinate transform: translate to origin at midpoint of start and goal\n            # and rotate so x-axis aligns with start-goal line\n\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            diff = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            c_max = best_path_length\n\n            if dim == 2:\n                # Rotation angle to align x-axis with start-goal vector\n                angle = math.atan2(diff[1], diff[0])\n                cos_angle = math.cos(angle)\n                sin_angle = math.sin(angle)\n\n                def sample_unit_ball():\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x * x + y * y <= 1:\n                            return (x, y)\n\n                while True:\n                    x_ball, y_ball = sample_unit_ball()\n                    # Scale according to ellipsoid axes lengths\n                    r1 = c_max / 2.0\n                    if c_max**2 <= c_min**2:\n                        # Avoid degenerate ellipsoid, fallback to uniform random\n                        break\n                    r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n                    # Point in ellipsoid coords\n                    x_ell = x_ball * r1\n                    y_ell = y_ball * r2\n                    # Rotate back and translate\n                    px = center[0] + cos_angle * x_ell - sin_angle * y_ell\n                    py = center[1] + sin_angle * x_ell + cos_angle * y_ell\n                    p = (px, py)\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and self._in_bounds(p, bounds):\n                        return p\n            else:  # 3D case\n                import numpy as np\n                c_min3 = c_min\n                c_max3 = c_max\n\n                # Build rotation matrix from start-goal\n                e1 = [diff[d] / c_min3 for d in range(dim)]\n                if abs(e1[0]) < 1.0:\n                    ortho = [1.0, 0.0, 0.0]\n                else:\n                    ortho = [0.0, 1.0, 0.0]\n\n                # Gram-Schmidt to generate orthonormal basis\n                def normalize(v):\n                    norm = math.sqrt(sum(x * x for x in v))\n                    return [x / norm for x in v]\n\n                def dot(u, v):\n                    return sum(ua * va for ua, va in zip(u, v))\n\n                e2 = [ortho[d] - dot(ortho, e1) * e1[d] for d in range(dim)]\n                e2 = normalize(e2)\n                e3 = [e1[1]*e2[2] - e1[2]*e2[1],\n                      e1[2]*e2[0] - e1[0]*e2[2],\n                      e1[0]*e2[1] - e1[1]*e2[0]]\n\n                def sample_unit_ball_3d():\n                    while True:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        z = random.uniform(-1, 1)\n                        if x*x + y*y + z*z <= 1:\n                            return (x, y, z)\n\n                while True:\n                    x_ball, y_ball, z_ball = sample_unit_ball_3d()\n                    r1 = c_max3 / 2.0\n                    if c_max3**2 <= c_min3**2:\n                        break\n                    r2 = r3 = math.sqrt(c_max3**2 - c_min3**2) / 2.0\n                    # In ellipsoid frame\n                    point_ellipsoid = [x_ball * r1, y_ball * r2, z_ball * r3]\n                    # Rotate back and translate\n                    px = center[0] + point_ellipsoid[0] * e1[0] + point_ellipsoid[1] * e2[0] + point_ellipsoid[2] * e3[0]\n                    py = center[1] + point_ellipsoid[0] * e1[1] + point_ellipsoid[1] * e2[1] + point_ellipsoid[2] * e3[1]\n                    pz = center[2] + point_ellipsoid[0] * e1[2] + point_ellipsoid[1] * e2[2] + point_ellipsoid[2] * e3[2]\n                    p = (px, py, pz)\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and self._in_bounds(p, bounds):\n                        return p\n            # Fallback to uniform sampling\n            return None\n\n        def sample_free():\n            # Adaptive: after solution found use informed sampling\n            if found_connection and random.random() > 0.8:\n                p = sample_in_ellipsoid()\n                if p is not None:\n                    return p\n\n            # Goal bias with equal probability start or goal to reduce bias\n            if random.random() < self.goal_sample_rate:\n                return start_position if random.random() < 0.5 else goal_position\n\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and self._in_bounds(p, bounds):\n                    return p\n\n        def _distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist = _distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, pos):\n            # Adaptive neighbor radius based on log of number of nodes (RRT*)\n            n = len(tree) + 1\n            gamma_rrt = self.max_neighbor_radius\n            radius = min(gamma_rrt * (math.log(n) / n) ** (1 / dim), self.max_neighbor_radius)\n            return [node for node in tree if _distance(node.position, pos) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = min(tree, key=lambda nd: _distance(nd.position, point))\n            new_pos = steer(nearest_node.position, point)\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + _distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + _distance(node.position, new_pos)\n                if cost_candidate < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_candidate\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes to possibly lower cost paths through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + _distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:  # small epsilon to prevent float issues\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = min(tree, key=lambda n: _distance(n.position, node.position))\n            curr = nearest_node\n\n            while True:\n                new_pos = steer(curr.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = curr.cost + _distance(curr.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = curr\n                curr.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                if _distance(new_pos, node.position) <= self.step_size:\n                    return new_node\n                curr = new_node\n\n        # After connection, refine path by rewiring both trees for some iterations\n        def rewire_tree(tree):\n            for node in list(tree):\n                near = near_nodes(tree, node.position)\n                for neighbor in near:\n                    if neighbor is node or neighbor is node.parent:\n                        continue\n                    cost_through_node = node.cost + _distance(node.position, neighbor.position)\n                    if cost_through_node + 1e-9 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(node, cost_through_node)\n                            edges.append((node, neighbor))\n\n        # Main Loop: alternate tree growth, goal biasing, rewiring to improve solution\n        tree_a, tree_b = tree_start, tree_goal\n\n        for iter_i in range(self.max_iter):\n            rand_p = sample_free()\n\n            new_node_a = try_extend(tree_a, rand_p)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                success_state = True\n                found_connection = True\n\n                # Update best path length estimate\n                path_len_candidate = new_node_a.cost + new_node_b.cost + _distance(new_node_a.position, new_node_b.position)\n                if path_len_candidate < best_path_length:\n                    best_path_length = path_len_candidate\n\n                # Construct full path from start_root to new_node_a and new_node_b to goal_root\n                path_start = new_node_a.path_from_root()\n                path_goal = new_node_b.path_from_root()\n\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                # Rewire both trees locally to improve path quality\n                rewire_tree(tree_a)\n                rewire_tree(tree_b)\n\n                # Try iterative path shortening within remaining iterations\n                remaining_iters = self.max_iter - iter_i - 1\n                for _ in range(min(remaining_iters, 200)):\n                    # Informed sampling around best path\n                    p_sample = sample_in_ellipsoid()\n                    if p_sample is None:\n                        break\n                    node_new = try_extend(tree_start, p_sample)\n                    if node_new is None:\n                        continue\n                    node_connect = try_connect(tree_goal, node_new)\n                    if node_connect is not None:\n                        # Update best path and path length if better\n                        candidate_length = node_new.cost + node_connect.cost + _distance(node_new.position, node_connect.position)\n                        if candidate_length + 1e-6 < best_path_length:\n                            best_path_length = candidate_length\n                            path_start = node_new.path_from_root()\n                            path_goal = node_connect.path_from_root()\n                            extracted_path = path_start + path_goal[::-1][1:]\n                        rewire_tree(tree_start)\n                        rewire_tree(tree_goal)\n\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(pos)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
    "objective": 1182.13391,
    "time_improvement": -3921.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.29472448825836184,
            "num_nodes_avg": 330.3,
            "path_length_avg": 176.91493447165814,
            "success_improvement": -9.999999999999998,
            "time_improvement": -3025.106747665962,
            "length_improvement": 11.579616168391818,
            "objective_score": -910.2161010661101
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.6545169830322266,
            "num_nodes_avg": 459.2,
            "path_length_avg": 279.84971908495925,
            "success_improvement": -19.999999999999996,
            "time_improvement": -4342.478958755763,
            "length_improvement": 7.136395470249372,
            "objective_score": -1311.3164085326791
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 1.3029373645782472,
            "num_nodes_avg": 574.3,
            "path_length_avg": 130.85222897480384,
            "success_improvement": -19.999999999999996,
            "time_improvement": -4395.996649957589,
            "length_improvement": 19.648848738575108,
            "objective_score": -1324.8692252395617
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* variant incorporating informed sampling (ellipse pruning) focused on the heuristic cost-to-go estimate, adaptive rewiring using a dynamically computed neighbor radius based on node density, and incremental lazy collision checking with caching to reduce repeated expensive collision tests. The planner balances exploration and exploitation by growing trees from both start and goal simultaneously, selectively biasing sampling towards promising regions inside a heuristic-informed ellipsoid once an initial solution is found, thus drastically reducing the search space. Enhanced path smoothing using iterative shortcutting combined with cost-aware pruning refines the final path for smoothness and shorter length. This approach aims at improving planning efficiency, success rate, and path quality while reducing search time.",
    "planning_mechanism": "The planner starts by growing two trees simultaneously from the start and goal positions, alternating growth each iteration. Initially, uniform random sampling explores the space widely. Once a feasible path is discovered, sampling is constrained inside an ellipsoidal informed subset defined by the current best path cost, focusing search efforts to promising regions. Each iteration extends a tree towards a sampled point via steering within step size limits, performing lazy collision checking with caching to avoid redundant tests. After adding a node, local rewiring is applied considering a radius dynamically adjusted by node density to optimize path costs. The trees attempt to connect after each successful extension. Upon connection, the planner reconstructs and smooths the path through iterative collision-free shortcutting and cost pruning, outputting the refined solution efficiently and robustly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n        # For lazy collision check caching\n        self._in_collision = None      # None: unchecked, True/False: known\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node(pos={self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Cache for collision checking of edges to avoid repeated costly tests\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds for slight float errors\n            clamped = tuple(\n                max(0, min(new_p[d], bounds[d])) for d in range(dim)\n            )\n            return clamped\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            # Sample within an ellipsoid defined by start and goal with major axis c_max, minor axes scaled\n            # Inspired by \"Informed RRT*\" sampling\n            if is_3d:\n                import numpy as np\n                c = c_max\n                if c_max < c_min:\n                    c = c_min\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                # Rotation matrix aligning x-axis to line from start to goal\n                a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n                # Create an orthonormal basis\n                if abs(a1[0]) < 1.0 or abs(a1[1]) < 1.0 or abs(a1[2]) < 1.0:\n                    temp = np.array([1.0, 0., 0.])\n                    if np.allclose(a1, temp):\n                        temp = np.array([0.,1.,0.])\n                    e2 = np.cross(a1, temp)\n                    e2 /= np.linalg.norm(e2)\n                    e3 = np.cross(a1, e2)\n                else:\n                    e2 = np.array([0.,1.,0.])\n                    e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n                # Radii of ellipsoid axes\n                r1 = c / 2\n                r2 = math.sqrt(c**2 - c_min**2) / 2\n                r3 = r2\n                # Sample random point in unit ball\n                while True:\n                    u = np.random.normal(0,1,3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u = u / norm_u * (random.random() ** (1/3)) # uniform in unit ball\n                    break\n                sample = center_np + C @ np.array([r1*u[0], r2*u[1], r3*u[2]])\n                sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                return tuple(sample_clamped)\n            else:\n                # 2D ellipse sampling\n                c = c_max\n                if c_max < c_min:\n                    c = c_min\n                c1, c2 = center\n                r1 = c / 2.0\n                r2 = math.sqrt(c**2 - c_min**2) / 2.0\n\n                while True:\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))  # uniform sampling in ellipse\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n\n                    # Rotation aligned with start-goal vector\n                    dx = goal[0] - start[0]\n                    dy = goal[1] - start[1]\n                    length = math.hypot(dx, dy)\n                    if length == 0:\n                        return start\n                    cos_angle = dx / length\n                    sin_angle = dy / length\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            # Euclidean distance nearest neighbor\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Neighborhood search via linear scan; could be optimized\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes):\n            # Radius decays as tree grows, ensuring asymptotic optimality (RRT* typical)\n            if n_nodes < 2:\n                return float('inf')\n            gamma_rrt_star = 35.0  # Tuned constant\n            unit_ball_volume = math.pi if dim == 2 else 4/3*math.pi\n            r = gamma_rrt_star * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(r, self.step_size)\n\n        # Lazy collision cache helpers:\n        def edge_cache_key(pos1, pos2):\n            # Order insensitive tuple for caching edges\n            return tuple(sorted([pos1, pos2]))\n\n        def is_edge_collision_cached(pos1, pos2):\n            key = edge_cache_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, value: bool):\n            key = edge_cache_key(pos1, pos2)\n            self._edge_collision_cache[key] = value\n\n        # Initialize trees:\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        best_path_length = float('inf')\n\n        # Current informed sampling parameters\n        path_found = False\n        c_min = distance(start_position, goal_position)\n        c_max = float('inf')\n        center = tuple((start_position[d] + goal_position[d]) / 2. for d in range(dim))\n\n        for it in range(self.max_iter):\n            # Sample point:\n            if path_found:\n                q_rand = ellipse_sample(center, c_min, c_max, start_position, goal_position)\n            else:\n                q_rand = sample_free_uniform()\n\n            # Alternate tree growth\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Find nearest node in tree_a to sampled point\n            nearest_node = nearest(tree_a, q_rand)\n\n            # Steer towards q_rand with step size\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision lazy check with caching\n            cached_result = is_edge_collision_cached(nearest_node.position, new_pos)\n            if cached_result is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            else:\n                if cached_result:\n                    continue\n\n            # Add new node with cost update from parent:\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring within neighbor radius\n            r = neighbor_radius(len(tree_a))\n            near = near_nodes(tree_a, new_pos, r)\n\n            for node in near:\n                if node == nearest_node:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n\n                if cost_through_new + 1e-8 < node.cost:\n                    # Check edge collision (lazy)\n                    cached_rewire = is_edge_collision_cached(new_node.position, node.position)\n                    if cached_rewire is None:\n                        in_collision = self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, node.position, in_collision)\n                    else:\n                        in_collision = cached_rewire\n\n                    if not in_collision:\n                        try:\n                            # Remove old edge\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Try connect tree_b to new_node with incremental steps capped by step_size\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                # Edge collision lazy check for edge prev_node_b->next_pos_b\n                cached_conn = is_edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_conn is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                else:\n                    if cached_conn:\n                        break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b\n                r_b = neighbor_radius(len(tree_b))\n                near_b = near_nodes(tree_b, next_pos_b, r_b)\n\n                for nb_node in near_b:\n                    if nb_node == prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = is_edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                # Check connection proximity\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    # Final edge check from new_node_b to new_node\n                    cached_final = is_edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        # Link final connection node\n                        final_cost = new_node_b.cost + distance(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n                        connection_start = new_node if tree_a is tree_start else connect_node_goal\n                        connection_goal = connect_node_goal if tree_b is tree_goal else new_node\n                        success_state = True\n                    break\n\n                prev_node_b = new_node_b\n\n            if success_state:\n                # Extract and merge path from start and goal trees without duplication at connection node\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update informed sampling parameters for smoothing and pruning:\n                best_path_length = 0.0\n                for i in range(len(merged_path) -1):\n                    best_path_length += distance(merged_path[i], merged_path[i+1])\n                c_max = best_path_length + 1e-6\n                center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Path smoothing by iterative shortcutting\n                def path_smooth(path, max_trials=200):\n                    path = path[:]\n                    length = len(path)\n                    if length < 3:\n                        return path\n                    for _ in range(max_trials):\n                        if len(path) < 3:\n                            break\n                        i = random.randint(0, len(path)-3)\n                        j = random.randint(i+2, len(path)-1)\n                        if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                            path = path[:i+1] + path[j:]\n                    return path\n\n                merged_path = path_smooth(merged_path)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges,\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.13753,
    "time_improvement": -42.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.019363903999328615,
            "num_nodes_avg": 84.6,
            "path_length_avg": 164.8760985022105,
            "success_improvement": -9.999999999999998,
            "time_improvement": -105.32486936209264,
            "length_improvement": 17.596510674688346,
            "objective_score": -33.07815867369012
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026968622207641603,
            "num_nodes_avg": 247.7,
            "path_length_avg": 236.66509524297686,
            "success_improvement": 0.0,
            "time_improvement": -83.04725440284294,
            "length_improvement": 21.466514661865986,
            "objective_score": -20.620873388479684
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01109619140625,
            "num_nodes_avg": 126.7,
            "path_length_avg": 123.98448793085234,
            "success_improvement": 0.0,
            "time_improvement": 61.71079228667543,
            "length_improvement": 23.86605545924244,
            "objective_score": 23.286448777851117
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the adaptive goal biasing and dynamic neighbor radius rewiring from Algorithm 1 with the streamlined bidirectional growth and efficient local rewiring of Algorithm 2. It incorporates heuristic sampling towards the goal, balanced bidirectional expansions, lazy collision checks, and enhanced path smoothing through shortcutting. This integration targets improved planning efficiency, robustness, shorter and smoother paths, and higher success rates with optimized computational overhead.",
    "planning_mechanism": "Planning mechanism: The planner grows two bidirectional RRT* trees from start and goal alternately, adaptively biasing sampling towards the goal and start. It dynamically adjusts neighbor radius based on iteration for local rewiring optimization. New nodes are added with rigorous collision and edge validation. Trees attempt connection via iterative steering and rewiring. Upon connection, path extraction merges both trees\u2019 segments, followed by iterative shortcut-based smoothing to improve path quality and smoothness while retaining efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=30.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration, last_tree_toggle):\n            # Adaptive goal biasing that alternates bias target between start and goal \n            bias_rate = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.25, 0.35)\n            if random.random() < bias_rate:\n                # Alternate bias targets each iteration to break symmetry\n                return start_position if last_tree_toggle else goal_position\n            else:\n                for _ in range(100):\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # Fallback in rare case\n                return start_position if last_tree_toggle else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp inside bounds in case of float error\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            # Shrinking radius for rewiring balancing exploration and refinement\n            factor = (1.0 - (iteration / self.max_iter)**0.9)\n            return max(self.min_neighbor_radius, self.max_neighbor_radius * factor)\n\n        def near_nodes(tree, pos, radius):\n            # Linear search neighbor filtering, could be improved to spatial indexing\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        toggle_tree = True  # True for start tree growth, False for goal tree growth\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration, toggle_tree)\n\n            tree_a = tree_start if toggle_tree else tree_goal\n            tree_b = tree_goal if toggle_tree else tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Check node and edge collision before proceeding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                toggle_tree = not toggle_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                toggle_tree = not toggle_tree\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost and \\\n                   not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_through_node\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cost improves\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Attempt to connect tree_b to new_node incrementally\n            curr_node_b = nearest(tree_b, new_node.position)\n            connected = False\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost and \\\n                       not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node_b, cost_through_new_b)\n                        edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                success_state = True\n\n                connection_start = new_node if toggle_tree else new_node_b\n                connection_goal = new_node_b if toggle_tree else new_node\n\n                # Extract and merge paths avoiding duplication at connection node\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # skip duplicated connection node\n\n                # Path smoothing by iterative shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, max_trials=150)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n            toggle_tree = not toggle_tree  # Alternate tree growth\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=150):\n        import random\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 16.63481,
    "time_improvement": -56.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014208674430847168,
            "num_nodes_avg": 91.4,
            "path_length_avg": 158.17544701993134,
            "success_improvement": 0.0,
            "time_improvement": -50.66146895911861,
            "length_improvement": 20.945431882241195,
            "objective_score": -11.009354311287343
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.033472204208374025,
            "num_nodes_avg": 323.9,
            "path_length_avg": 228.63627045600987,
            "success_improvement": 0.0,
            "time_improvement": -127.18977009578398,
            "length_improvement": 24.13075035341303,
            "objective_score": -33.330780958052586
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.026104116439819337,
            "num_nodes_avg": 242.9,
            "path_length_avg": 110.26078622637422,
            "success_improvement": -30.000000000000004,
            "time_improvement": 9.92351339811288,
            "length_improvement": 32.29323503549198,
            "objective_score": -5.564298973467742
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines bidirectional RRT* with adaptive heuristic sampling, dynamic radius rewiring, and node pruning to balance exploration and exploitation. It alternates tree growth between start and goal, uses informed sampling with goal-start bias, applies incremental rewiring within dynamically adjusted radii, and prunes dead-end nodes periodically to enhance efficiency. Collision checks for nodes and edges guarantee safety, while the planner focuses on improving path quality, success rate, and computational speed by maintaining balanced trees and pruning suboptimal branches.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling points biased towards them. Each sampled point is used to extend the smaller tree via steering and collision-checked addition of nodes. A dynamic radius, shrinking with node count, determines local neighborhood for rewiring to optimize path costs. After each extension, attempts are made to connect the opposing tree. Periodic pruning removes unproductive nodes, improving search efficiency and aiding smooth, shorter paths. Upon connection, the best path is reconstructed by backtracking and merging the two trees\u2019 paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 5.0,\n                 prune_interval: int = 250, prune_threshold: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Core data\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks for node and connecting edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -11.35589,
    "time_improvement": 30.0,
    "length_improvement": 12.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.004592251777648926,
            "num_nodes_avg": 80.4,
            "path_length_avg": 167.45106691181843,
            "success_improvement": 0.0,
            "time_improvement": 51.30612626687802,
            "length_improvement": 16.309566212866937,
            "objective_score": 18.65375112263679
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018631529808044434,
            "num_nodes_avg": 213.8,
            "path_length_avg": 286.29479981745214,
            "success_improvement": 0.0,
            "time_improvement": -26.45994112820878,
            "length_improvement": 4.997699636422811,
            "objective_score": -6.938442411178071
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.010195708274841309,
            "num_nodes_avg": 119.7,
            "path_length_avg": 139.18069216669,
            "success_improvement": 0.0,
            "time_improvement": 64.81805534645213,
            "length_improvement": 14.53467062369323,
            "objective_score": 22.352350728674285
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner builds upon the bidirectional RRT* framework with enhanced parameter tuning. Key improvements include adaptive and tighter neighborhood radius for rewiring based on the number of nodes to improve path quality and efficiency, dynamic goal biasing to accelerate convergence, balanced tree growth by always extending the smaller tree, rigorous node and edge collision checks, and a robust shortcut smoothing step to improve path smoothness and reduce length. The planner thus achieves higher success rates and faster planning times while producing shorter and smoother paths.",
    "planning_mechanism": "The planner initializes two trees growing from start and goal. Each iteration, it samples a random point with adaptive goal biasing, extends the smaller tree incrementally towards this sample, locally rewires neighbors within an adaptively computed radius, then attempts to connect the other tree to the new node using incremental steering. Upon successful connection, it merges paths and applies shortcut smoothing to optimize the result. The process repeats until max iterations or a path is found, ensuring collision-free, optimal, and smooth solutions.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 4000,\n                 step_size: float = 4.0,\n                 goal_sample_rate_start: float = 0.15,\n                 goal_sample_rate_end: float = 0.35,\n                 radius_constant: float = 25.0,\n                 radius_min: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter +\n                         self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and \\\n                       not self._is_in_obstacle(node.position, obstacles, is_3d) and in_bounds(node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                smoothed_path = smooth_path(merged_path, max_trials=150)\n                extracted_path = smoothed_path\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 39.1053,
    "time_improvement": -139.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.018609237670898438,
            "num_nodes_avg": 89.9,
            "path_length_avg": 161.17663693205085,
            "success_improvement": -9.999999999999998,
            "time_improvement": -97.32277612189331,
            "length_improvement": 19.4454660100911,
            "objective_score": -30.307739634549772
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03994755744934082,
            "num_nodes_avg": 373.4,
            "path_length_avg": 238.2910829642812,
            "success_improvement": 0.0,
            "time_improvement": -171.14068545666095,
            "length_improvement": 20.926956926324376,
            "objective_score": -47.15681425173341
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.07212278842926026,
            "num_nodes_avg": 463.2,
            "path_length_avg": 123.68433565654122,
            "success_improvement": 0.0,
            "time_improvement": -148.8713763063479,
            "length_improvement": 24.05036703714668,
            "objective_score": -39.851339484475034
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* that incrementally grows trees from start and goal positions, using adaptive goal biasing and rewiring in a reduced and generalized manner. It balances exploration efficiency and path quality by always extending the smaller tree first, verifying collision-free nodes and edges strictly, and smoothing the final path with shortcut attempts. The adaptive neighborhood radius for rewiring adjusts with the size of the trees to optimize connections. This approach aims to improve planning success, path smoothness, and computational efficiency while maintaining robustness in arbitrary 2D or 3D environments.",
    "planning_mechanism": "The planner initializes two trees at start and goal. At each iteration, it samples points biased towards the goal, extends the smaller tree towards the sample while avoiding obstacles, and rewires locally to reduce path cost. Then it attempts connecting the other tree to the newly added node for path completion. On success, the path is extracted and smoothed using random shortcutting to reduce unnecessary waypoints and improve smoothness and length. Collision checks for nodes and edges are enforced throughout, and node expansions respect map bounds.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start: float = 0.1, goal_sample_rate_end: float = 0.3,\n                 radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(iteration: int) -> Tuple[float, ...]:\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter\n                         + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # Bias towards goal mostly, sometimes towards start to aid connection\n                return goal_position if random.random() < 0.85 else start_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-6 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d)\n                        and not self._is_in_obstacle(target_node.position, obstacles, is_3d)):\n                        final_node = Node(target_node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, target_node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: List[Tuple[float, ...]], max_trials=150) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=150)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.98626,
    "time_improvement": -7.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0128068208694458,
            "num_nodes_avg": 87.7,
            "path_length_avg": 163.7379014655171,
            "success_improvement": 0.0,
            "time_improvement": -35.79693547612365,
            "length_improvement": 18.165370613850538,
            "objective_score": -7.1060065200669875
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021283459663391114,
            "num_nodes_avg": 248.8,
            "path_length_avg": 242.37439342685926,
            "success_improvement": 0.0,
            "time_improvement": -44.45969191831741,
            "length_improvement": 19.57197637029986,
            "objective_score": -9.42351230143525
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011657309532165528,
            "num_nodes_avg": 151.5,
            "path_length_avg": 125.7536583199623,
            "success_improvement": 0.0,
            "time_improvement": 59.77456320695808,
            "length_improvement": 22.779678263711585,
            "objective_score": 22.48830461482974
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner integrates bidirectional RRT* with adaptive shrinking neighbor radius, dynamic goal biasing, and informed sampling focused within an ellipsoidal heuristic around the current best path to reduce search space. It performs incremental rewiring for local path cost optimization, shortcut smoothing post path extraction, and balanced tree expansion to rapidly converge to near-optimal, collision-free and smoother paths while maintaining computational efficiency.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal points with alternated expansions, employing heuristic-informed sampling towards the goal region to limit random exploration. It adaptively adjusts rewiring radius based on node count for balanced optimization, reconnects nodes with lower cost parents, checks collisions meticulously, and merges trees upon connection to generate refined shortest paths. Path smoothing is applied at the end to improve path quality and reduce length further, all aimed at improving success rate and minimizing planning time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 35.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Heuristic for informed sampling: Ellipse parameters initialization\n        best_path_length = float('inf')\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def sample_informed():\n            # Informed sampling in ellipsoidal region: \n            # When we have a solution, sample inside ellipse centered between start and goal to focus search\n            if best_path_length == float('inf'):\n                # Uniform goal bias sampling like before\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            # If path found: sample inside ellipse defined by start, goal and current best cost\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            a1 = tuple(goal_position[d] - start_position[d] for d in range(dim))\n            length_a1 = math.dist(start_position, goal_position)\n            if length_a1 == 0:\n                length_a1 = 1e-6\n\n            # Orthogonal basis (first normalized vector along start-goal line)\n            e1 = tuple((goal_position[d] - start_position[d]) / length_a1 for d in range(dim))\n\n            # Generate random sample inside unit n-ball\n            while True:\n                # Sample inside unit n-ball\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm for x in vec]\n                radius = random.uniform(0, 1) ** (1.0 / dim)  # scale radius for uniform distribution in n-ball\n                ball_point = [radius * x for x in unit_vec]\n\n                # Scale ellipse axes:\n                # The ellipse axis lengths: c_best/2 along e1, and sqrt(c_best^2 - c_min^2)/2 for others\n                if c_best == float('inf'):\n                    c_ = 1e6\n                else:\n                    c_ = c_best\n\n                r1 = c_ / 2.0\n                if c_**2 - c_min**2 > 0:\n                    r2 = math.sqrt(c_**2 - c_min**2) / 2.0\n                else:\n                    r2 = 0.0\n\n                # Construct transformation: \n                # Sample point = center + r1 * (ball_point projected on e1) + r2 * (ball_point orthogonal components)\n                # We orthogonalize ball_point w.r.t e1\n                dot = sum(ball_point[d]*e1[d] for d in range(dim))\n                proj_e1 = [dot * e1[d] for d in range(dim)]\n                ortho = [ball_point[d] - proj_e1[d] for d in range(dim)]\n\n                sample = tuple(center[d] + r1 * proj_e1[d] + r2 * ortho[d] for d in range(dim))\n\n                # Check bounds\n                inside_bounds = all(0 <= sample[d] <= bounds[d] for d in range(dim))\n                if inside_bounds and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Use squared distance for speed if desired, here math.dist is fast enough\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Shrinking radius with min bound for rewiring neighborhood (RRT* heuristic)\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent based on cost\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + distance(node.position, new_pos)\n                if c < min_cost and collision_free(node.position, new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def try_connect(tree, node) -> Node or None:\n            # Greedy attempt to connect tree nodes to node\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Verify final edge\n                    if collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def extract_path(node_start: Node, node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicate connection node\n\n            # Shortcut smoothing\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) -1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -=1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for itr in range(self.max_iter):\n            rnd = sample_informed()\n\n            # Alternate tree expansion: expand smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = extend(tree_start, rnd)\n            if new_node_start is None:\n                continue\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found\n                success_state = True\n\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                # Update best path length and informed sampling radius parameters\n                best_path_length = sum(math.dist(extracted_path[i], extracted_path[i+1]) for i in range(len(extracted_path)-1))\n                c_best = best_path_length\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.61314,
    "time_improvement": -38.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01772456169128418,
            "num_nodes_avg": 84.5,
            "path_length_avg": 156.9038684609896,
            "success_improvement": 0.0,
            "time_improvement": -87.9421274702383,
            "length_improvement": 21.58095462422703,
            "objective_score": -22.066447316226082
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.023399209976196288,
            "num_nodes_avg": 270.6,
            "path_length_avg": 237.62067056042392,
            "success_improvement": -9.999999999999998,
            "time_improvement": -58.820169171441826,
            "length_improvement": 21.149422442985273,
            "objective_score": -18.416166262835493
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019869160652160645,
            "num_nodes_avg": 224.4,
            "path_length_avg": 120.41397496273541,
            "success_improvement": 0.0,
            "time_improvement": 31.43823935197411,
            "length_improvement": 26.05856551298623,
            "objective_score": 14.643184908189479
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner refines the bidirectional RRT* framework focusing on reducing planning time and improving path quality by introducing an adaptive step size that shrinks near obstacles and goals, a more aggressive dynamic goal biasing schedule, and efficient rewiring radius updates leveraging node counts and dimension. It balances tree extension strictly by smaller tree nodes to maintain uniform growth, leverages spatial hashing for faster nearest neighbor queries, and introduces early termination conditions. The smoothing step uses a focused shortcut approach constrained by obstacles and incremental rewiring for maintaining topological consistency. The obstacle checking resolution adapts according to the environment scale for computational efficiency. Overall, these optimizations yield faster convergence, smoother shorter paths, and higher success rates.",
    "planning_mechanism": "The planner initializes two trees from start and goal. Each iteration, it samples a point using adaptive goal biasing that increases bias to goal over time to accelerate convergence. The smaller tree is always extended first towards the sample using an adaptive, possibly reduced step size to better navigate tight spaces. After extension, neighbors within an adaptive radius are rewired to reduce path costs. The other tree then attempts incremental connection to the new node. On successful connection, the paths are merged and a shortcut smoothing routine is applied to remove unnecessary waypoints while ensuring collision-free edges. The process repeats until a path is found or maximum iterations are reached, guaranteeing balanced growth, optimized rewiring, and smooth, near-optimal paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import defaultdict\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Precompute environment diagonal for step size adaption and radius limits\n        env_diag = math.dist((0,) * dim, bounds)\n        step_size_min = max(0.5, self.step_size * 0.2)\n        step_size_max = self.step_size\n\n        # Spatial hashing grid cell size for faster neighbor queries\n        grid_cell_size = self.step_size * 2.5\n        def _hash_pos(p):\n            return tuple(int(c // grid_cell_size) for c in p)\n\n        # Spatial hash maps for start and goal trees\n        tree_start_grid = defaultdict(list)\n        tree_goal_grid = defaultdict(list)\n\n        def add_node_to_grid(tree_grid, node):\n            tree_grid[_hash_pos(node.position)].append(node)\n\n        add_node_to_grid(tree_start_grid, start_root)\n        add_node_to_grid(tree_goal_grid, goal_root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive aggressive goal biasing: start low then rapidly grow bias\n            goal_bias = self._interpolate_goal_bias(iteration, self.max_iter)\n            r = random.random()\n            if r < goal_bias:\n                # Mostly goal, occasionally start to maintain exploration near start\n                if random.random() < 0.85:\n                    return goal_pos\n                else:\n                    return start_pos\n            # Uniform random sample inside bounds and free of obstacles\n            while True:\n                p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n\n        def steer(from_pos, to_pos, adaptive=True):\n            # Adaptive step size: shrink near goal to increase precision and around obstacles (detected via proximity)\n            vec = tuple(to_pos[d_] - from_pos[d_] for d_ in range(dim))\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= step_size_min:\n                return to_pos  # Close enough, direct connection\n\n            step = step_size_max\n            # Shrink step closer to goal for better accuracy\n            goal_dist = dist(to_pos, goal_pos)\n            start_dist = dist(to_pos, start_pos)\n            close_to_goal = goal_dist < step_size_max * 3\n            close_to_start = start_dist < step_size_max * 3\n            if adaptive and (close_to_goal or close_to_start):\n                step = max(step_size_min, step_size_max * 0.3)\n\n            # Shrink step near obstacles to avoid skipping narrow spaces (heuristic)\n            # We'll check current position proximity to obstacles quickly:\n            prox_threshold = step_size_max * 1.5\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    px, py, pz = from_pos\n                    # Simple bounding box proximity check (min distance to box)\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dz = max(oz - pz, 0, pz - (oz + od))\n                    dist_to_box = math.sqrt(dx * dx + dy * dy + dz * dz)\n                else:\n                    ox, oy, ow, oh = obs\n                    px, py = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dist_to_box = math.sqrt(dx * dx + dy * dy)\n                if 0 < dist_to_box < prox_threshold:\n                    step = max(step_size_min, step * 0.5)\n                    break\n\n            ratio = step / distance_\n            if ratio > 1.0:\n                return to_pos\n            return tuple(from_pos[d_] + vec[d_] * ratio for d_ in range(dim))\n\n        def nearest(tree_grid, point):\n            # Search neighbor cells in grid to find nearest node more efficiently\n            base_cell = _hash_pos(point)\n            best_node = None\n            best_dist = float('inf')\n\n            # Search neighboring cells for nearest node, radius expands as needed\n            cells_to_check = [(0,)*dim]  # always check current cell\n            # Add neighbor cells offsets (all 3^dim - 1 neighbors)\n            offsets = [-1, 0, 1]\n            from itertools import product\n            for offset in product(*([offsets] * dim)):\n                if offset == (0,) * dim:\n                    continue\n                cells_to_check.append(offset)\n\n            checked_cells = set()\n            radius_in_cells = 0\n            max_cell_search = 2  # limit search to 2 cells radius for efficiency\n\n            while radius_in_cells <= max_cell_search:\n                for cell_off in cells_to_check:\n                    neighbor_cell = tuple(base_cell[d_] + cell_off[d_] for d_ in range(dim))\n                    if neighbor_cell in checked_cells:\n                        continue\n                    checked_cells.add(neighbor_cell)\n                    if neighbor_cell not in tree_grid:\n                        continue\n                    for node in tree_grid[neighbor_cell]:\n                        cur_dist = dist(node.position, point)\n                        if cur_dist < best_dist:\n                            best_dist = cur_dist\n                            best_node = node\n                if best_node is not None:\n                    break  # Found nearest within close cells\n                # Expand search radius (not implemented to keep speed, fallback to full tree)\n                radius_in_cells += 1\n                if radius_in_cells > max_cell_search:\n                    break\n            # Fallback linear scan on whole tree if no node found in grid (unlikely)\n            if best_node is None:\n                # flatten tree grid nodes list for linear search\n                all_nodes = [n for bucket in tree_grid.values() for n in bucket]\n                if not all_nodes:\n                    return None\n                best_node = min(all_nodes, key=lambda n: dist(n.position, point))\n            return best_node\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return step_size_max\n            val = self.step_size * (math.log(n_nodes + 1) / (n_nodes + 1)) ** 0.5\n            return max(step_size_min, min(val, step_size_max * 2.5))\n\n        def near_nodes(tree_grid, pos, radius):\n            # Collect nodes in the grid cells covered by radius\n            radius_cells = int(math.ceil(radius / grid_cell_size))\n            base_cell = _hash_pos(pos)\n            collected = []\n            from itertools import product\n            offsets = range(-radius_cells, radius_cells + 1)\n            for offset in product(offsets, repeat=dim):\n                cell = tuple(base_cell[d_] + offset[d_] for d_ in range(dim))\n                if cell in tree_grid:\n                    for node in tree_grid[cell]:\n                        if dist(node.position, pos) <= radius:\n                            collected.append(node)\n            return collected\n\n        def try_extend(tree, tree_grid, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree_grid, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree_grid, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-6 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            add_node_to_grid(tree_grid, new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for improved costs\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, tree_grid, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree_grid, node.position)\n            if nearest_node is None:\n                return None\n\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                add_node_to_grid(tree_grid, new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_check = dist(new_pos, node.position)\n                if dist_check <= step_size_min:\n                    # verify direct connection to the target node\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d, resolution=0.3)\n                        and not self._is_in_obstacle(node.position, obstacles, is_3d)\n                        and in_bounds(node.position)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        add_node_to_grid(tree_grid, final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=120):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for iteration in range(self.max_iter):\n            # Adaptive goal biasing sample\n            rand_point = sample_free(iteration)\n\n            # Balance growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_start_grid, tree_goal_grid = tree_goal_grid, tree_start_grid\n\n            new_node_start = try_extend(tree_start, tree_start_grid, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, tree_goal_grid, new_node_start)\n            if new_node_goal is not None:\n                # Success: merge paths and smooth\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=120)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _interpolate_goal_bias(self, iteration, max_iter):\n        # Aggressive increase from 0.15 to 0.5 goal sampling rate with cosine smoothing\n        from math import cos, pi\n        start_bias = 0.15\n        end_bias = 0.5\n        ratio = iteration / max_iter\n        # Smooth increase bias with cosine ease-in-out\n        bias = start_bias + (end_bias - start_bias) * (1 - cos(ratio * pi)) / 2\n        return bias\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 72.53067,
    "time_improvement": -256.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02975156307220459,
            "num_nodes_avg": 153.2,
            "path_length_avg": 158.52954585440588,
            "success_improvement": 0.0,
            "time_improvement": -215.47025854550145,
            "length_improvement": 20.768456688190636,
            "objective_score": -60.4873862260123
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07711560726165771,
            "num_nodes_avg": 530.9,
            "path_length_avg": 238.56745054991174,
            "success_improvement": 0.0,
            "time_improvement": -423.4156966630148,
            "length_improvement": 20.835248811480618,
            "objective_score": -122.8576592366083
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.06654825210571289,
            "num_nodes_avg": 459.4,
            "path_length_avg": 125.03896250874553,
            "success_improvement": 0.0,
            "time_improvement": -129.63553480152723,
            "length_improvement": 23.21854454579871,
            "objective_score": -34.24695153129843
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards the goal and start to balance exploration and exploitation. It uses a dynamically shrinking radius for rewiring to optimize path costs continually. The algorithm grows two trees from start and goal, alternately extending the smaller tree for balanced growth. After each extension, the planner attempts to connect the two trees to form a complete path. Dead-end nodes are periodically pruned to enhance efficiency. Additionally, a path smoothing and shortcut procedure is applied post path extraction to reduce path length and improve smoothness. Collision checks ensure safety. This results in improved planning speed, higher success rates, and shorter, smoother paths.",
    "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal positions. It samples points within the map bounds with bias towards the goal and start, steering and extending the smaller tree first. A dynamic radius is used to find neighbors to rewire and reduce path cost locally. After extension, attempts are made to connect the opposing tree to complete a path. Periodic pruning removes dead nodes. Upon successful connection, the path is extracted and post-processed via shortcut smoothing to minimize length and enhance smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i+2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                # Post-process with smoothing\n                smoothed_path = path_smoothing(raw_path)\n                # Use the shorter path among raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.61374,
    "time_improvement": 7.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008043766021728516,
            "num_nodes_avg": 85.5,
            "path_length_avg": 163.6645421149303,
            "success_improvement": 0.0,
            "time_improvement": 14.708046081621204,
            "length_improvement": 18.202034912180657,
            "objective_score": 8.052820806922492
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018214941024780273,
            "num_nodes_avg": 211.3,
            "path_length_avg": 250.73203836217277,
            "success_improvement": 0.0,
            "time_improvement": -23.632379808820406,
            "length_improvement": 16.798627029050724,
            "objective_score": -3.7299885368359766
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020520853996276855,
            "num_nodes_avg": 169.4,
            "path_length_avg": 132.2218958906299,
            "success_improvement": 0.0,
            "time_improvement": 29.189465794931664,
            "length_improvement": 18.80779074213471,
            "objective_score": 12.518397886906442
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional RRT* inspired planner integrates adaptive goal biasing, dynamic neighbor radius scaling based on tree size, and aggressive local rewiring with pruning of infeasible branches. It uses alternating expansion from start and goal trees with enhanced sampling efficiency and prevents node overcrowding by limiting connections in high-density areas. A safety check ensures nodes and edges are collision-free and stay within bounds, while rewiring optimizes the path locally to improve smoothness and shorten overall path cost. Early pruning of invalid nodes and selective rewiring contribute to robustness and faster convergence.",
    "planning_mechanism": "The planner alternates growth between two trees expanding from start and goal. Each expansion samples points biased towards the opposite root to encourage connection and efficiently explores free space. New nodes steer towards samples, connecting via minimum cost parents chosen from dynamically determined neighbors within an adaptive radius. After insertion, neighbors are rewired if routing through the new node yields a lower cost path. The trees attempt connection via incremental steering and collision-free edge checks. Successful connection triggers path backtracking and merging. This mechanism balances exploration and exploitation for efficient, high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def prune_subtree(self):\n        \"\"\"Prune this node and its descendants from the tree.\"\"\"\n        for child in self.children[:]:\n            child.prune_subtree()\n        self.children.clear()\n        self.valid = False\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float =5.0,\n                 goal_sample_rate: float=0.15,\n                 neighbor_radius_const: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_const = neighbor_radius_const  # For adaptive radius scaling\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (2D or 3D)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free(grow_from_start: bool):\n            # Adaptive sampling biased toward opposite root\n            if random.random() < self.goal_sample_rate:\n                return goal_position if grow_from_start else start_position\n            else:\n                for _ in range(100):\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if (all(0 <= p[d] <= bounds[d] for d in range(len(p))) and\n                        not self._is_in_obstacle(p, obstacles, is_3d)):\n                        return p\n                # fallback\n                return goal_position if grow_from_start else start_position\n\n        def nearest(tree, point):\n            # Return nearest valid node only (pruned nodes are invalid)\n            valid_nodes = [n for n in tree if n.valid]\n            return min(valid_nodes, key=lambda node: math.dist(node.position, point)) if valid_nodes else None\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def compute_radius(n_nodes):\n            # Adaptive neighbor radius (RRT* style)\n            d = 3 if is_3d else 2\n            if n_nodes <= 1:\n                return self.neighbor_radius_const\n            radius = self.neighbor_radius_const * ((math.log(n_nodes) / n_nodes) ** (1 / d))\n            return max(2.0, min(self.neighbor_radius_const, radius))  # safety min radius\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if n.valid and math.dist(n.position, pos) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if (any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))) or\n                self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)):\n                return None\n\n            n_nodes = len([n for n in tree if n.valid])\n            radius = compute_radius(n_nodes)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if cheaper path found\n            for neighbor in near:\n                if neighbor is best_parent or not neighbor.valid:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            if nearest_node is None:\n                return None\n\n            current = nearest_node\n            while True:\n                new_pos = steer(current.position, node.position)\n\n                if (any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(len(new_pos))) or\n                    self._is_in_obstacle(new_pos, obstacles, is_3d) or\n                    self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d)):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        def prune_invalid_branches(tree):\n            # Remove/prune invalid nodes whose parent linkage is lost or cost invalid\n            for node in tree[:]:\n                if not node.valid:\n                    continue\n                if node.parent is None and node is not start_root and node is not goal_root:\n                    node.prune_subtree()\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n\n        # Main planning loop: alternate expansion from start and goal\n        for iteration in range(self.max_iter):\n            grow_start = (iteration % 2 == 0)\n            rand_point = sample_free(grow_start)\n\n            tree_a = tree_start if grow_start else tree_goal\n            tree_b = tree_goal if grow_start else tree_start\n\n            new_node_a = try_extend(tree_a, rand_point)\n            if new_node_a is None:\n                # Swap trees and continue\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Success: trees connected\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1][1:]\n                break\n\n            prune_invalid_branches(tree_a)\n            prune_invalid_branches(tree_b)\n\n            # Swap trees to alternate growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 108.96169,
    "time_improvement": -356.0,
    "length_improvement": 15.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.03555252552032471,
            "num_nodes_avg": 219.6,
            "path_length_avg": 182.69277338740054,
            "success_improvement": 0.0,
            "time_improvement": -276.98067797724235,
            "length_improvement": 8.691907811984018,
            "objective_score": -81.3558218307759
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07365264892578124,
            "num_nodes_avg": 519.3,
            "path_length_avg": 256.21054957128814,
            "success_improvement": 0.0,
            "time_improvement": -399.9111582919736,
            "length_improvement": 14.98067166358315,
            "objective_score": -116.97721315487544
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.14257571697235108,
            "num_nodes_avg": 695.0,
            "path_length_avg": 129.9371719778159,
            "success_improvement": -30.000000000000004,
            "time_improvement": -391.98063030488515,
            "length_improvement": 20.210748858686635,
            "objective_score": -128.55203931972824
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm integrates the strengths of bidirectional RRT* and adaptive frontier-biased sampling with dynamic step sizing near obstacles, balanced tree growth, dynamic rewiring radius, and periodic pruning. It employs adaptive informed sampling that blends frontier exploration and goal/start bias to enhance exploration efficiency and path optimality. The planner grows two trees alternately from start and goal, extends the smaller tree to balance growth, adapts step size near obstacles for precision, rewires local neighborhoods to improve path cost, prunes dead-ends for efficiency, and applies iterative shortcut smoothing to generate shorter, smoother collision-free paths.",
    "planning_mechanism": "The planner initializes two trees at start and goal. It samples points biased both towards frontiers and the goal/start regions for balanced exploration-exploitation. The smaller tree is extended first by steering towards sampled points with adaptive step sizes that shrink near obstacles. A rewiring step dynamically reduces path cost locally with a radius shrinking based on node count. After each extension, it attempts to connect the opposite tree to form a feasible path. Dead-end nodes are periodically pruned to improve efficiency. Once connected, iterative shortcut smoothing refines the path. Collision and boundary checks ensure path safety and validity throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, base_step_size: float=5.0,\n                 frontier_sample_rate: float=0.25, goal_sample_rate: float=0.2,\n                 radius_constant: float=20.0, radius_min: float=5.0,\n                 prune_interval: int=200, prune_threshold: int=100,\n                 smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Identify frontier regions for biased sampling\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step_size):\n            dist = distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    px, py, pz = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    ox, oy, w, h = obs\n                    px, py = position\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist = (dx*dx + dy*dy)**0.5\n                if dist <= query_radius:\n                    return self.base_step_size * 0.5\n            return self.base_step_size\n\n        def sample_free():\n            # Mix sampling strategy:\n            # With frontier_sample_rate, sample near frontiers if available.\n            # Else with goal_sample_rate, sample goal or start biased.\n            # Else uniform random free space sample.\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            elif random.random() < self.goal_sample_rate:\n                if random.random() < 0.7:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            step_size = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, sample_pt, step_size)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                step_size = adaptive_step_size(last_node.position)\n                new_pos = steer(last_node.position, node.position, step_size)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            # Only prune when nodes exceed threshold\n            if len(nodes) <= self.prune_threshold:\n                return removed_nodes\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        pass\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(distance(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smooth(path):\n            import random\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p_i = new_path[i]\n                p_j = new_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            new_node_a = try_extend(tree_a, sample_pt)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                # Connected path found\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # Avoid duplicate node\n\n                smoothed_path = shortcut_smooth(raw_path)\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 45.73203,
    "time_improvement": -167.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012654423713684082,
            "num_nodes_avg": 122.6,
            "path_length_avg": 153.46323341130906,
            "success_improvement": 0.0,
            "time_improvement": -34.1809944913401,
            "length_improvement": 23.30055095240459,
            "objective_score": -5.594188156921112
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05359861850738525,
            "num_nodes_avg": 284.5,
            "path_length_avg": 242.08005114464976,
            "success_improvement": 0.0,
            "time_improvement": -263.79611394394067,
            "length_improvement": 19.669649097579565,
            "objective_score": -75.20490436366629
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.08807411193847656,
            "num_nodes_avg": 219.3,
            "path_length_avg": 123.95195815504057,
            "success_improvement": 0.0,
            "time_improvement": -203.9140046087764,
            "length_improvement": 23.886030701217525,
            "objective_score": -56.39699524238941
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner integrates the best features of bidirectional RRT* approaches with adaptive parameter tuning, dynamic goal biasing, balanced tree extension, and KD-tree-inspired efficient neighbor searches. It improves planning efficiency and robustness by adaptively tuning neighborhood radius, dynamically adjusting goal bias throughout iterations, rigorously performing node and edge collision checks, and balancing tree growth based on size. A solid rewiring strategy optimizes local path costs, while a shortcut-based smoothing refines path quality and reduces length and complexity, yielding faster, more successful planning with shorter, smoother paths.",
    "planning_mechanism": "The planner initializes two trees from start and goal and alternately extends them towards randomly sampled points with adaptive goal bias. KD-tree-style efficient nearest and neighbor search accelerates rewiring steps. At each iteration, it attempts to connect the opposite tree to the newly added node to detect a solution early. Local rewiring improves path costs, and a robust shortcut smoothing post-processing step reduces path complexity and length. The process terminates early when a path is found or max iterations are reached, ensuring collision-free, bounded, and optimized paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 4.5,\n                 goal_sample_rate_start: float = 0.12,\n                 goal_sample_rate_end: float = 0.35,\n                 radius_constant: float = 20.0,\n                 radius_min: float = 3.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-tree style structure for fast near-node queries (brute force for moderate size)\n        class KDTree:\n            def __init__(self):\n                self.points = []\n                self.nodes = []\n\n            def insert(self, node):\n                self.points.append(node.position)\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = math.dist(node.position, point)\n                    if d < best_dist:\n                        best_dist = d\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    dx = 0\n                    for d_ in range(dim):\n                        diff = node.position[d_] - point[d_]\n                        dx += diff * diff\n                        if dx > r_sq:\n                            break\n                    if dx <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter +\n                         self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 90% goal, 10% start\n                return goal_position if random.random() < 0.9 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d_]) for d_ in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist_ = math.dist(from_pos, to_pos)\n            if dist_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist_\n            return tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)))\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = kd_tree.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    min_cost = temp_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewire neighbors for cost improvement\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_via_new < neighbor.cost - 1e-8:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.4):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n\n            return new_node\n\n        def try_connect(tree, kd_tree, target_node):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, resolution=0.4):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = kd_tree.near(new_pos, radius)\n\n                min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n                best_parent = curr_node\n                for neighbor in neighbors:\n                    temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                    if temp_cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d, resolution=0.4):\n                        min_cost = temp_cost\n                        best_parent = neighbor\n\n                new_node = Node(new_pos)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                kd_tree.insert(new_node)\n\n                # Rewire neighbors for cost improvement\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_via_new < neighbor.cost - 1e-8:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.4):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size:\n                    # Final check for connection to target node\n                    if not self._is_edge_in_obstacle(new_node.position, target_node.position, obstacles, is_3d, resolution=0.4) and \\\n                       not self._is_in_obstacle(target_node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + math.dist(new_node.position, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        kd_tree.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n\n                curr_node = new_node\n\n        def smooth_path(path, max_trials=200):\n            if len(path) < 3:\n                return path\n\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d, resolution=0.4):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main loop\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n                kd_a, kd_b = kd_goal, kd_start\n                reversed_connect = True\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n                kd_a, kd_b = kd_start, kd_goal\n                reversed_connect = False\n\n            new_node = try_extend(tree_a, kd_a, rand_point)\n            if new_node is None:\n                continue\n\n            connected_node = try_connect(tree_b, kd_b, new_node)\n            if connected_node is not None:\n                success_state = True\n                if reversed_connect:\n                    path_from_start = connected_node.path_from_root()\n                    path_from_goal = new_node.path_from_root()\n                else:\n                    path_from_start = new_node.path_from_root()\n                    path_from_goal = connected_node.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                extracted_path = smooth_path(merged_path, max_trials=200)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.4):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 33.33973,
    "time_improvement": -120.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03180310726165771,
            "num_nodes_avg": 107.9,
            "path_length_avg": 158.77348039059896,
            "success_improvement": -9.999999999999998,
            "time_improvement": -237.22377698396446,
            "length_improvement": 20.646540551577345,
            "objective_score": -72.03782498487386
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03618807792663574,
            "num_nodes_avg": 294.3,
            "path_length_avg": 240.2114393867127,
            "success_improvement": 0.0,
            "time_improvement": -145.6235344759229,
            "length_improvement": 20.28971769681239,
            "objective_score": -39.62911680341439
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021976447105407713,
            "num_nodes_avg": 237.6,
            "path_length_avg": 127.04180041003106,
            "success_improvement": 0.0,
            "time_improvement": 24.16670574501011,
            "length_improvement": 21.988681421424296,
            "objective_score": 11.647748007787893
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified, unified bidirectional RRT* planner that balances exploration efficiency and path quality. It grows two trees from the start and goal positions alternately, samples points with adaptive goal biasing, extends nearest nodes towards samples using a fixed step size, and employs local rewiring around new nodes to improve path cost and smoothness. Rigorous collision and edge feasibility checks ensure safety. Upon connection of the trees, the shortest path is reconstructed by merging paths from both connected nodes. The planner avoids excessive complexity while maintaining robustness, smoothness, and efficient convergence.",
    "planning_mechanism": "The planner alternates growth between start and goal trees, samples points with goal bias to encourage connections, extends the nearest node towards samples with a capped step size, rewires neighbors within a radius inversely related to tree size to reduce path cost, and verifies collision-free conditions for nodes and edges. When the trees connect, the optimal path is extracted by backtracking and merged. This approach balances exploration and exploitation to find shorter, smoother feasible paths efficiently.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position              # Tuple[float, ...] (2D or 3D)\n        self.parent = parent                  # Parent node or None\n        self.cost = cost                      # Cost from root\n        self.children = []\n        self.valid = True                     # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=20.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes, extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -15.03871,
    "time_improvement": 44.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0039825916290283205,
            "num_nodes_avg": 76.2,
            "path_length_avg": 172.59475061003724,
            "success_improvement": 0.0,
            "time_improvement": 57.770648626374324,
            "length_improvement": 13.738802538996584,
            "objective_score": 20.078955095711613
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.013543009757995605,
            "num_nodes_avg": 249.1,
            "path_length_avg": 290.1072272486077,
            "success_improvement": 0.0,
            "time_improvement": 8.077960621600676,
            "length_improvement": 3.732607234605092,
            "objective_score": 3.169909633401221
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009406518936157227,
            "num_nodes_avg": 162.7,
            "path_length_avg": 149.7826015352379,
            "success_improvement": 0.0,
            "time_improvement": 67.54128112795729,
            "length_improvement": 8.02445960163917,
            "objective_score": 21.86727625871502
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner merges bidirectional RRT* with adaptive sampling near frontiers and dynamic step sizing, enriched by heuristic-guided sampling and local shortcut smoothing to minimize path length and accelerate planning. It leverages goal and frontier biasing to efficiently explore, adaptive step sizes to safely navigate close to obstacles, radius-based rewiring for cost optimization, and fast collision checks to maintain feasibility. After trees connect, an iterative shortcut smoothing refines and shortens the path while preserving collision safety, balancing planning speed and path quality.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling points biased towards frontiers and the goal to enhance exploration. Each new node is efficiently connected and locally rewired with neighbors within a radius to optimize the path costs. Adaptive step sizing and collision checks ensure safe expansions. Upon connecting the two trees, the combined path is shortcut-smoothed to reduce unnecessary detours and improve smoothness before returning the final optimized path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 frontier_sample_rate: float=0.3, goal_sample_rate: float=0.1,\n                 neighbor_radius: float=10.0, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        def sample_free():\n            # Bias sampling towards goal or frontiers\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            # Uniform random sample in bounds avoiding obstacles\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            min_dist = float('inf')\n            px, py, pz = (*position, 0.0) if not is_3d else position\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist_obs = (dx*dx + dy*dy + dz*dz)**0.5\n                else:\n                    ox, oy, w, h = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist_obs = (dx*dx + dy*dy)**0.5\n                if dist_obs < min_dist:\n                    min_dist = dist_obs\n            if min_dist <= query_radius:\n                return max(self.base_step_size * 0.4, min_dist * 0.5)\n            return self.base_step_size\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            step = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, point, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                step = adaptive_step_size(nearest_node.position)\n                new_pos = steer(nearest_node.position, node.position, step)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= step:\n                    return new_node\n                nearest_node = new_node\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p_i = new_path[i]\n                p_j = new_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                # Swap trees to avoid stall and encourage progress\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_smooth(extracted_path)\n                break\n\n            # Alternate growth direction for balanced exploration\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i]+1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 51.60639,
    "time_improvement": -176.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.026292800903320312,
            "num_nodes_avg": 142.6,
            "path_length_avg": 152.27897463633377,
            "success_improvement": -9.999999999999998,
            "time_improvement": -178.7953250968882,
            "length_improvement": 23.892432105637816,
            "objective_score": -53.8601111079389
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.059008216857910155,
            "num_nodes_avg": 509.7,
            "path_length_avg": 235.00447827559637,
            "success_improvement": -9.999999999999998,
            "time_improvement": -300.51330764637436,
            "length_improvement": 22.0175635528152,
            "objective_score": -90.75047958334928
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04336884021759033,
            "num_nodes_avg": 395.6,
            "path_length_avg": 124.68811290345968,
            "success_improvement": 0.0,
            "time_improvement": -49.6512155010214,
            "length_improvement": 23.433987338980035,
            "objective_score": -10.20856718251041
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with enhanced heuristics targeting faster convergence and higher-quality paths. It integrates adaptive informed sampling guided by both frontiers and heuristics, dynamic step sizing near obstacles for precision, balanced incremental growth of start and goal trees, optimized rewiring with a shrinking radius, and periodic pruning of dead-end nodes. A cache accelerates collision queries, and shortcut smoothing refines path quality. The planner prioritizes extending the smaller tree to balance search progress while aggressively attempting to connect trees directly toward the other side.",
    "planning_mechanism": "The planner initializes start and goal trees and iteratively samples points biased towards frontiers and direct heuristics. Each iteration grows the smaller tree by steering adaptively towards sampled points, avoiding obstacles and map boundaries. The local neighborhood is rewired to optimize path costs dynamically, and a connection attempt is made to the opposite tree. Dead-end nodes are pruned periodically to keep the search efficient. Once a path connects both trees, shortcut smoothing improves path smoothness and length. All collision and edge checks ensure safety and validity throughout planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, base_step_size: float=5.0,\n                 frontier_sample_rate: float=0.25, goal_sample_rate: float=0.25,\n                 radius_constant: float=18.0, radius_min: float=4.0,\n                 prune_interval: int=150, prune_threshold: int=150,\n                 smoothing_iterations: int=60):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        # Cache obstacle distances for adaptive step sizing\n        def dist_to_obs(pos):\n            min_dist = float('inf')\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    ox, oy, oz, w, h, d = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist = math.sqrt(dx*dx + dy*dy + dz*dz)\n                    if dist < min_dist:\n                        min_dist = dist\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    ox, oy, w, h = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist = math.sqrt(dx*dx + dy*dy)\n                    if dist < min_dist:\n                        min_dist = dist\n            return min_dist\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step_size):\n            dist = distance(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            ratio = step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def adaptive_step_size(position):\n            query_radius = self.base_step_size * 2\n            dist = dist_to_obs(position)\n            if dist <= query_radius:\n                # Shrink step size when near obstacles for finer resolution\n                factor = max(0.25, dist / query_radius)\n                return self.base_step_size * factor\n            return self.base_step_size\n\n        def sample_free():\n            # Informed sample biased by frontier, goal/start, and informed ellipsoid between start-goal\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                return self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            elif random.random() < self.goal_sample_rate:\n                # Biased goal/start sample\n                return goal_position if random.random() < 0.75 else start_position\n            else:\n                dim = len(bounds)\n                # Informed ellipse sampling for improved exploration in ellipsoidal region around start-goal\n                c_best = distance(start_position, goal_position)\n                if c_best == 0 or not nodes:\n                    while True:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n                else:\n                    # Ellipse parameters\n                    c_min = distance(start_position, goal_position)\n                    center = tuple((start_position[d]+goal_position[d])/2 for d in range(dim))\n                    dx = (goal_position[0] - start_position[0]) / c_min if c_min > 0 else 1.0\n                    dy = (goal_position[1] - start_position[1]) / c_min if c_min > 0 else 0.0\n                    # Rotation matrix approximated by unit vector components for 2D; for 3D fallback to uniform\n                    if dim == 2:\n                        while True:\n                            r1 = random.uniform(-c_best/2, c_best/2)\n                            r2 = random.uniform(-math.sqrt(c_best*c_best - r1*r1)/2, math.sqrt(c_best*c_best - r1*r1)/2)\n                            local_pt = (r1, r2)\n                            sample = (center[0] + local_pt[0]*dx - local_pt[1]*dy,\n                                      center[1] + local_pt[0]*dy + local_pt[1]*dx)\n                            if (0 <= sample[0] <= bounds[0] and 0 <= sample[1] <= bounds[1]\n                                    and not self._is_in_obstacle(sample, obstacles, is_3d)):\n                                return sample\n                    else:\n                        # 3D fallback uniform until better sampling is implemented\n                        for _ in range(10):\n                            sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                                return sample\n                        # Fallback uniform forced\n                        while True:\n                            sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                                return sample\n\n        def nearest(tree, point):\n            # Fast nearest: linear search (fast enough for moderate node counts)\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                dist = distance(node.position, point)\n                if dist < best_dist:\n                    best = node\n                    best_dist = dist\n            return best\n\n        def near_nodes(tree, pos, radius):\n            # Return neighbors within radius to enable rewiring\n            near = []\n            r_sq = radius * radius\n            for node in tree:\n                dx = node.position[0] - pos[0]\n                dy = node.position[1] - pos[1] if len(pos) > 1 else 0\n                dz = node.position[2] - pos[2] if len(pos) > 2 else 0\n                dist_sq = dx*dx + dy*dy + dz*dz\n                if dist_sq <= r_sq:\n                    near.append(node)\n            return near\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            step_size = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, sample_pt, step_size)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if better\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                step_size = adaptive_step_size(last_node.position)\n                new_pos = steer(last_node.position, node.position, step_size)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal = distance(new_pos, node.position)\n                if dist_to_goal <= step_size:\n                    # Attempt to connect final segment\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist_to_goal)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = 0\n            if len(nodes) <= self.prune_threshold:\n                return removed\n            # Remove leaves not start/goal and no children\n            to_remove = [node for node in nodes if not node.children and node not in (start_root, goal_root)]\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except Exception:\n                        pass\n                try:\n                    nodes.remove(node)\n                    # Remove edges related to node\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed += 1\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            return sum(distance(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            new_path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(new_path) < 3:\n                    break\n                i = random.randint(0, len(new_path) - 3)\n                j = random.randint(i + 2, len(new_path) - 1)\n                p_i = new_path[i]\n                p_j = new_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    new_path = new_path[:i + 1] + new_path[j:]\n            return new_path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first, for balanced exploration\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            new_node_a = try_extend(tree_a, sample_pt)\n            if new_node_a is None:\n                continue\n\n            new_node_b = try_connect(tree_b, new_node_a)\n            if new_node_b is not None:\n                success_state = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                raw_path = path_a + path_b[::-1][1:]  # avoid duplicate node\n\n                smoothed_path = shortcut_smooth(raw_path)\n                if path_length(smoothed_path) + 1e-9 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        if is_3d:\n            for obs in obstacles:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        for cz in range(min_cells[2], max_cells[2]+1):\n                            occupied.add((cx, cy, cz))\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for obs in obstacles:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0]+1):\n                    for cy in range(min_cells[1], max_cells[1]+1):\n                        occupied.add((cx, cy))\n            for ix in range(steps[0]+1):\n                for iy in range(steps[1]+1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 265.84784,
    "time_improvement": -884.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02149384021759033,
            "num_nodes_avg": 176.8,
            "path_length_avg": 152.9330853643242,
            "success_improvement": 0.0,
            "time_improvement": -127.90961651738424,
            "length_improvement": 23.565513850771367,
            "objective_score": -33.659782185061
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.11710915565490723,
            "num_nodes_avg": 315.1,
            "path_length_avg": 236.5126292050026,
            "success_improvement": 0.0,
            "time_improvement": -694.8685417823039,
            "length_improvement": 21.51710805142147,
            "objective_score": -204.15714092440686
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.559380030632019,
            "num_nodes_avg": 450.2,
            "path_length_avg": 127.48858699319261,
            "success_improvement": -30.000000000000004,
            "time_improvement": -1830.23150010654,
            "length_improvement": 21.714327544486505,
            "objective_score": -559.7265845230647
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling biased towards both the start and goal to balance exploration and exploitation. It uses a dynamically shrinking neighbor radius for optimal rewiring, and extends the smaller tree alternately for balanced growth. After each extension, it attempts to connect the two trees to form a complete path. Dead-end nodes are pruned periodically to maintain efficiency. Post path extraction, an advanced shortcut smoothing with multiple randomized trials is applied to minimize path length and improve smoothness. Collision and edge-intersection checks ensure safety. These enhancements result in faster planning, higher success rates, and shorter, smoother paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from the start and goal positions, sampling new points biased toward these positions adaptively. It extends the smaller tree first by steering towards these samples with collision checks. A dynamic radius facilitates near-node detection for rewiring to reduce path cost locally. Upon new node addition, attempts to connect the opposite tree are made to complete the path. Periodic dead-node pruning removes ineffective branches. After finding a feasible connection, the path is smoothed by repeatedly attempting shortcuts between random non-adjacent node pairs, improving length and smoothness while maintaining collision-free connectivity.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and self._in_bounds(sample, bounds):\n                        return sample\n\n        def steer(from_pos, to_pos) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def _connect_nodes(parent_node: Node, child_pos: Tuple[float, ...], cost_to_child: float) -> Node:\n            new_node = Node(child_pos, parent=parent_node, cost=cost_to_child)\n            parent_node.children.append(new_node)\n            tree_append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            return new_node\n\n        def tree_append(new_node: Node):\n            # Append node to the corresponding tree list\n            # Each node belongs to either tree_start or tree_goal\n            # We detect by parent lineage or explicit tracking\n            if new_node.parent in tree_start:\n                tree_start.append(new_node)\n            else:\n                tree_goal.append(new_node)\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            dist_nearest = distance(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_nearest\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        # Also remove from trees if present\n                        if node in tree_start:\n                            tree_start.remove(node)\n                        if node in tree_goal:\n                            tree_goal.remove(node)\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # shortcut: remove intermediate nodes\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def adaptive_sample_free() -> Tuple[float, ...]:\n            # Adaptive informed biased sampling\n            # Increase bias towards start and goal once partial solution found\n            # Here simplified as the same goal_sample_rate and p_goal_bias\n            return sample_free()\n\n        def informed_radius(n_nodes: int) -> float:\n            # Adapted radius shrinking per iteration for better rewiring\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1)) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def check_bounds(pt: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n            return all(0.0 <= pt[d] <= bounds[d] for d in range(len(pt)))\n\n        self._in_bounds = check_bounds\n        self._dist_sq = lambda a,b: sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample_free()\n\n            # Alternate growth on smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Path found\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.3305,
    "time_improvement": -49.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.015049576759338379,
            "num_nodes_avg": 82.2,
            "path_length_avg": 172.6257542375586,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59.57796434918684,
            "length_improvement": 13.723307223952673,
            "objective_score": -20.12872785996552
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.030583906173706054,
            "num_nodes_avg": 136.1,
            "path_length_avg": 235.7113701238784,
            "success_improvement": -9.999999999999998,
            "time_improvement": -107.58569017384816,
            "length_improvement": 21.78299292233964,
            "objective_score": -32.91910846768651
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.023279428482055664,
            "num_nodes_avg": 107.5,
            "path_length_avg": 129.0168359072885,
            "success_improvement": 0.0,
            "time_improvement": 19.670557224269377,
            "length_improvement": 20.77589064796812,
            "objective_score": 10.056345296874436
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a Heuristic-informed Sparse RRT* variant combining informed sampling and pruning to improve planning efficiency, success rate, and path quality. It uses an ellipse-shaped informed sampling region to bias sampling towards promising solution spaces after an initial feasible path is found. The planner maintains sparsity by pruning nodes that are unlikely to improve the solution, and employs rewiring to improve path smoothness and length. The approach balances exploration with focused exploitation, resulting in faster convergence, shorter paths, and robust collision avoidance.",
    "planning_mechanism": "The planner grows a tree from the start node using RRT* principles. Initially, uniform random samples explore the space. Upon finding a feasible path, sampling is restricted to an ellipsoidal informed subset containing all paths shorter than the current best cost, which biases growth towards better solutions. Pruning removes nodes outside the informed region or with cost exceeding the best path. Rewiring near new nodes optimizes path costs. Collision checks ensure validity of nodes and edges. The algorithm terminates early if maximum iterations are reached or if the path cost converges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        # Initialization\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        nodes.append(start_root)\n        # Initialize best cost as infinity (no solution found yet)\n        best_cost = float('inf')\n        best_goal_node = None\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def sample_free():\n            # After a solution is found, sample inside an informed ellipsoidal region to bias the search\n            if best_goal_node is None:\n                # Uniform random sampling in the whole space\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                # Informed sampling inside an ellipse between start and goal with cost = best_cost\n                c_best = best_cost\n                c_min = distance(start_position, goal_position)\n                if c_best < float('inf') and c_best > c_min:\n                    # Transform to ellipsoidal coordinates\n                    return self._sample_informed_ellipsoid(start_position, goal_position, c_best, c_min, bounds, obstacles, is_3d)\n                else:\n                    # Fallback uniform sampling\n                    while True:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                        if not self._is_in_obstacle(p, obstacles, is_3d):\n                            return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.step_size * 2\n            r = 50.0 * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.step_size * 2, r)\n\n        def valid_and_bound(pos):\n            # Check not within obstacles and inside bounds\n            if any(pos[d] < 0 or pos[d] > bounds[d] for d in range(len(pos))):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def try_add_node(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not valid_and_bound(new_pos):\n                return None\n\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            cost_to_new = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < cost_to_new:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        cost_to_new = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = cost_to_new\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            return new_node\n\n        def backtrack_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        start_tree = [start_root]\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n            new_node = try_add_node(start_tree, rand_point)\n            if new_node is None:\n                continue\n\n            # Check if new_node can connect directly to goal (straight line)\n            dist_to_goal = distance(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if valid_and_bound(goal_position) and not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    start_tree.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    # Check if better solution\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        extracted_path = backtrack_path(goal_node)\n                        success_state = True\n\n            # Prune nodes whose cost + heuristic > best_cost to maintain sparsity\n            if success_state:\n                self._prune(start_tree, best_cost, start_position, goal_position, distance, obstacles, is_3d, nodes, edges)\n\n            # Early convergence if path cost is near optimal minimum\n            if success_state and abs(best_cost - distance(start_position, goal_position)) < 1e-3:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_informed_ellipsoid(self, start, goal, c_best, c_min, bounds, obstacles, is_3d):\n        # Sample in an ellipsoid defined by start, goal, and current best cost\n        dim = len(start)\n        center = tuple((start[d] + goal[d]) / 2 for d in range(dim))\n\n        # Rotation matrix aligning x-axis with start->goal vector\n        dx = tuple(goal[d] - start[d] for d in range(dim))\n        norm_dx = math.dist(start, goal)\n        if norm_dx == 0:\n            return start  # degenerate case\n\n        # Unit vector from start to goal\n        unit_vec = tuple(dx[d] / norm_dx for d in range(dim))\n\n        # For 2D or 3D: create rotation matrix that aligns first axis with unit_vec\n        import numpy as np\n        if dim == 2:\n            angle = math.atan2(unit_vec[1], unit_vec[0])\n            R = np.array([[math.cos(angle), -math.sin(angle)],\n                          [math.sin(angle), math.cos(angle)]])\n        elif dim == 3:\n            def rotation_matrix_from_vectors(vec1, vec2):\n                # Returns rotation matrix that aligns vec1 to vec2\n                a = np.array(vec1)\n                b = np.array(vec2)\n                a = a / np.linalg.norm(a)\n                b = b / np.linalg.norm(b)\n                v = np.cross(a, b)\n                c = np.dot(a, b)\n                s = np.linalg.norm(v)\n                if s == 0:\n                    return np.identity(3)\n                kmat = np.array([[0, -v[2], v[1]],\n                                 [v[2], 0, -v[0]],\n                                 [-v[1], v[0], 0]])\n                return np.identity(3) + kmat + kmat @ kmat * ((1 - c) / (s ** 2))\n            R = rotation_matrix_from_vectors(np.array([1] + [0] * (dim - 1)), np.array(unit_vec))\n        else:\n            # For other dims, fallback uniform sampling\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        # Lengths of the ellipsoid axes\n        r1 = c_best / 2\n        if dim == 2:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n            r_axes = np.array([r1, r2])\n        elif dim == 3:\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n            # For 3D, the last two axes have same length\n            r_axes = np.array([r1, r2, r2])\n        else:\n            return start\n\n        # Sample a point in unit ball scaled by r_axes\n        while True:\n            if dim == 2:\n                sample_ball = self._sample_unit_ball_2d()\n            elif dim == 3:\n                sample_ball = self._sample_unit_ball_3d()\n            else:\n                sample_ball = np.zeros(dim)\n\n            sample_scaled = sample_ball * r_axes\n            # Rotate and translate sample\n            rotated = R @ sample_scaled\n            sample_point = tuple(rotated[d] + center[d] for d in range(dim))\n            # Check bounds and obstacle\n            if all(0 <= sample_point[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                return sample_point\n\n    def _sample_unit_ball_2d(self):\n        while True:\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            if x * x + y * y <= 1:\n                return np.array([x, y])\n\n    def _sample_unit_ball_3d(self):\n        while True:\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            z = random.uniform(-1, 1)\n            if x * x + y * y + z * z <= 1:\n                return np.array([x, y, z])\n\n    def _prune(self, tree, best_cost, start, goal, distance_func, obstacles, is_3d, nodes, edges):\n        # Removes nodes that are outside the informed set or whose cost plus heuristic exceeds best_cost\n        remaining_nodes = []\n        to_remove = []\n        for node in tree:\n            # Heuristic: estimated cost from node to goal is Euclidean distance\n            heuristic = distance_func(node.position, goal)\n            if node.cost + heuristic > best_cost + 1e-6:\n                to_remove.append(node)\n            else:\n                remaining_nodes.append(node)\n\n        # Remove references and delete nodes\n        for node in to_remove:\n            # Remove from parent's children list\n            if node.parent and node in node.parent.children:\n                node.parent.children.remove(node)\n            if node in nodes:\n                nodes.remove(node)\n            # Remove edges related to node\n            remove_edges = [e for e in edges if e[0] == node or e[1] == node]\n            for e in remove_edges:\n                try:\n                    edges.remove(e)\n                except ValueError:\n                    pass\n        # Update tree in-place with remaining nodes\n        tree.clear()\n        tree.extend(remaining_nodes)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8229.61011,
    "time_improvement": -27452.0,
    "length_improvement": 29.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.4699814081192017,
            "num_nodes_avg": 2193.2,
            "path_length_avg": 144.11118040926078,
            "success_improvement": 0.0,
            "time_improvement": -36693.89648573285,
            "length_improvement": 27.974617155600818,
            "objective_score": -11002.574022288733
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 4.576440382003784,
            "num_nodes_avg": 3602.1,
            "path_length_avg": 217.58969472087944,
            "success_improvement": 0.0,
            "time_improvement": -30962.204083482073,
            "length_improvement": 27.796377904619046,
            "objective_score": -9283.101949463698
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.288681387901306,
            "num_nodes_avg": 3440.5,
            "path_length_avg": 110.06417476108156,
            "success_improvement": 0.0,
            "time_improvement": -14698.790545838074,
            "length_improvement": 32.413966319255614,
            "objective_score": -4403.154370487571
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional RRT* planner integrates adaptive goal bias sampling from both start and goal, dynamic rewiring with node neighborhood radius based on logarithmic scaling, and incremental path cost optimization to achieve efficient and robust path planning. It balances exploration by alternating growth on the smaller tree, performs strict collision and edge feasibility checks before node/edge addition, and incorporates local rewiring for path quality and smoothness. The algorithm adaptively adjusts sampling and rewiring radii to reduce search space and improve convergence speed. On connection, the optimal path is reconstructed by merging the shortest cost paths from both trees, ensuring shorter, smoother, and collision-free paths.",
    "planning_mechanism": "The planner alternates extension steps between start and goal trees, always growing the smaller tree to balance exploration. Sampling uses a combined goal bias for both start and goal to encourage fast connection. New nodes are created via a steering function capped by a fixed step size, with explicit collision and edge checks before insertion. Rewiring is done dynamically within a neighborhood radius that shrinks logarithmically with tree size, incrementally improving path cost and smoothness. When the two trees connect via feasible edges, the optimal path is extracted by backtracking from connection nodes and merging them, resulting in efficient convergence to high-quality paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample either start or goal\n        self.radius_constant = radius_constant      # For rewiring radius calculation\n        self.radius_min = radius_min                  # Minimum radius for rewiring\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free() -> Tuple[float, ...]:\n            r = random.random()\n            # Sample with combined goal bias to start or goal to enhance connectivity\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.5 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            # Shrink radius logarithmically for efficient rewiring as tree grows\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            # Check if node position is valid: inside map bounds & not in obstacle\n            for d, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs locally\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_target = distance(new_pos, node.position)\n                if dist_to_target <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_target\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -8.93552,
    "time_improvement": 21.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.003909516334533692,
            "num_nodes_avg": 71.2,
            "path_length_avg": 171.18510106638226,
            "success_improvement": 0.0,
            "time_improvement": 58.545501429622384,
            "length_improvement": 14.443331832073264,
            "objective_score": 20.452316795301368
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01824326515197754,
            "num_nodes_avg": 269.4,
            "path_length_avg": 270.5479880821555,
            "success_improvement": 0.0,
            "time_improvement": -23.824627439303637,
            "length_improvement": 10.22302450854493,
            "objective_score": -5.102783330082104
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020744752883911134,
            "num_nodes_avg": 249.0,
            "path_length_avg": 138.9767873393387,
            "success_improvement": 0.0,
            "time_improvement": 28.41686637756919,
            "length_improvement": 14.659880471120387,
            "objective_score": 11.457036007494834
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid bidirectional RRT* planner incorporating informed sampling inside an ellipsoidal heuristic region, adaptive rewiring radius dependent on the number of nodes, dynamic goal biasing, and shortcut smoothing to optimize path quality and planning efficiency. It balances exploration and exploitation by growing two trees from start and goal positions alternately, rewiring locally to minimize path cost, performing collision checks for nodes and edges, and applying smoothing after identifying a valid path.",
    "planning_mechanism": "The planner alternates expansion between two trees from start and goal points. Nodes are sampled preferentially inside an ellipsoid defined by the current best path cost to focus the search. Upon each extension, nearby nodes are considered for rewiring to shorten the path. The trees attempt to connect greedily, ensuring collision-free connections. Once connected, the path is extracted and shortcut smoothing is applied for enhanced path quality. Adaptive radius for rewiring, collision checks, and goal biasing improve robustness and convergence speed.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Constants for adaptive rewiring radius\n        self.radius_constant = 35.0\n        self.radius_min = 5.0\n        self.goal_sample_rate = 0.12\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n        best_path_length = float('inf')\n\n        def sample_informed():\n            if best_path_length == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n            center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n            length_line = max(c_min, 1e-6)\n            e1 = tuple((goal_position[d] - start_position[d]) / length_line for d in range(dim))\n\n            while True:\n                vec = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                unit_vec = [x / norm for x in vec]\n                radius = random.uniform(0, 1) ** (1.0 / dim)\n                ball_point = [radius * x for x in unit_vec]\n\n                r1 = min(c_best, 1e6) / 2.0\n                val = c_best ** 2 - c_min ** 2\n                r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n\n                dot = sum(ball_point[d]*e1[d] for d in range(dim))\n                proj_e1 = [dot * e1[d] for d in range(dim)]\n                ortho = [ball_point[d] - proj_e1[d] for d in range(dim)]\n\n                sample = tuple(center[d] + r1 * proj_e1[d] + r2 * ortho[d] for d in range(dim))\n\n                # Check bounds\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * (math.log(n_nodes + 1) / (n_nodes + 1)) ** (1.0 / dim))\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                c = node.cost + distance(node.position, new_pos)\n                if c < min_cost and collision_free(node.position, new_pos):\n                    min_cost = c\n                    best_parent = node\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree, new_node, neighbors)\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        if self._is_in_obstacle(node.position, obstacles, is_3d):\n                            return None\n\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicated connecting node\n\n            # Shortcut smoothing\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for itr in range(self.max_iter):\n            rnd = sample_informed()\n            # Expand smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = extend(tree_start, rnd)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n\n                best_path_length = 0.0\n                for i in range(len(extracted_path) - 1):\n                    best_path_length += distance(extracted_path[i], extracted_path[i+1])\n                c_best = best_path_length\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.48911,
    "time_improvement": -50.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.018102383613586424,
            "num_nodes_avg": 78.7,
            "path_length_avg": 159.8833515445644,
            "success_improvement": -9.999999999999998,
            "time_improvement": -91.94835662947877,
            "length_improvement": 20.09183761634847,
            "objective_score": -28.566139465573933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027607369422912597,
            "num_nodes_avg": 287.4,
            "path_length_avg": 240.84985039794634,
            "success_improvement": 0.0,
            "time_improvement": -87.38269738960729,
            "length_improvement": 20.07787132487931,
            "objective_score": -22.19923495190632
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020542263984680176,
            "num_nodes_avg": 208.0,
            "path_length_avg": 125.69309580711513,
            "success_improvement": 0.0,
            "time_improvement": 29.115587158280455,
            "length_improvement": 22.816867294946903,
            "objective_score": 13.298049606473516
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner enhances bidirectional RRT* with carefully tuned parameters, adaptive rewiring radius, goal-start informed sampling, and periodic pruning of dead-end nodes. It balances exploration and exploitation by growing the smaller tree first, incrementally rewiring neighbors within a shrinking radius, and enforcing strict collision checks on nodes and edges. These augmentations aim to improve planning efficiency, path quality, robustness, and success rate, while reducing search time and producing smoother, shorter paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, sampling points with bias towards these goals. It extends the smaller tree toward sampled points using a step-size-limited steering function and collision checks, rewiring neighbors locally for cost improvement. After each extension, it attempts to connect the opposing tree with incremental edge expansions. Periodically, dead-end nodes are pruned to enhance efficiency. Upon successful connection, the final path is reconstructed by merging the two tree paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0, radius_min: float=4.0,\n                 prune_interval: int=200, prune_threshold: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Check map bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                # Check map bounds\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first to maintain balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.75):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.68287,
    "time_improvement": 14.0,
    "length_improvement": 9.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.0057315826416015625,
            "num_nodes_avg": 66.3,
            "path_length_avg": 171.46445400062805,
            "success_improvement": -9.999999999999998,
            "time_improvement": 39.225248319466886,
            "length_improvement": 14.303713920537051,
            "objective_score": 9.628317279947478
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01809353828430176,
            "num_nodes_avg": 203.1,
            "path_length_avg": 295.5878361067072,
            "success_improvement": 0.0,
            "time_improvement": -22.808368921261003,
            "length_improvement": 1.9139557982379714,
            "objective_score": -6.459719516730707
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.02160623073577881,
            "num_nodes_avg": 144.6,
            "path_length_avg": 144.55616086985188,
            "success_improvement": -9.999999999999998,
            "time_improvement": 25.4441973596203,
            "length_improvement": 11.233809016268987,
            "objective_score": 4.880021011139888
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "An efficient and generalized bidirectional RRT* planner with adaptive informed sampling inside ellipsoidal subsets upon finding an initial path, dynamic neighbor radius for rewiring based on node density, and lazy collision checking with caching. The planner balances exploration and exploitation to improve planning speed, path optimality, robustness, and success rate. Post-connection, iterative shortcutting refines the path for smoothness and reduced length.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternating expansion steps. Initially, it samples the free space uniformly; after an initial path is found, sampling is focused inside an informed ellipsoid determined by current best path cost to reduce search efforts. Each extension steers toward sampled points within step size limits, adds nodes if collision-free, then locally rewires neighbors within a dynamically computed radius. Trees try to connect after each extension with incremental steering, employing lazy collision checks and caching to minimize redundant computations. Upon success, the combined path is iteratively shortcut to smooth and optimize the route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._in_collision = None      # Lazy collision check cache for this node if needed\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self._edge_collision_cache = dict()\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / distance\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            return new_p if in_bounds(new_p) else tuple(max(0, min(new_p[d], bounds[d])) for d in range(dim))\n\n        def sample_free_uniform():\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def ellipse_sample(center, c_min, c_max, start, goal):\n            if is_3d:\n                import numpy as np\n\n                if c_max < c_min:\n                    c_max = c_min\n                center_np = np.array(center)\n                start_np = np.array(start)\n                goal_np = np.array(goal)\n                a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n\n                # Build orthonormal basis\n                temp = np.array([1., 0., 0.])\n                if np.allclose(a1, temp):\n                    temp = np.array([0., 1., 0.])\n                e2 = np.cross(a1, temp)\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(a1, e2)\n                C = np.column_stack((a1, e2, e3))\n\n                r1 = c_max / 2\n                r2 = math.sqrt(c_max**2 - c_min**2) / 2\n                r3 = r2\n\n                while True:\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    u = u / norm_u * (random.random() ** (1/3))\n                    sample = center_np + C @ np.array([r1 * u[0], r2 * u[1], r3 * u[2]])\n                    sample_clamped = np.clip(sample, np.zeros(3), np.array(bounds))\n                    sample_t = tuple(sample_clamped)\n                    if not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n            else:\n                if c_max < c_min:\n                    c_max = c_min\n                c1, c2 = center\n                r1 = c_max / 2.0\n                r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                while True:\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1 + x_rot, c2 + y_rot)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def edge_key(pos1, pos2):\n            return tuple(sorted([pos1, pos2]))\n\n        def edge_collision_cached(pos1, pos2):\n            key = edge_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, val):\n            key = edge_key(pos1, pos2)\n            self._edge_collision_cache[key] = val\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes):\n            if n_nodes < 2:\n                return float('inf')\n            gamma = 35.0\n            unit_ball_volume = math.pi if dim == 2 else 4/3*math.pi\n            r = gamma * ((math.log(n_nodes)/n_nodes) ** (1/dim))\n            return max(r, self.step_size)\n\n        start_root = Node(start, cost=0.0)\n        goal_root = Node(goal, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        connect_start = None\n        connect_goal = None\n\n        c_min = dist(start, goal)\n        c_max = float('inf')\n        center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n        path_found = False\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_path(path, trials=200):\n            path = path[:]\n            if len(path) < 3:\n                return path\n            for _ in range(trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            q_rand = ellipse_sample(center, c_min, c_max, start, goal) if path_found else sample_free_uniform()\n\n            tree_a, tree_b = (tree_start, tree_goal) if itr % 2 == 0 else (tree_goal, tree_start)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            cached_col = edge_collision_cached(nearest_node.position, new_pos)\n            if cached_col is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            elif cached_col:\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            r = neighbor_radius(len(tree_a))\n            nearby_nodes = near(tree_a, new_pos, r)\n\n            for near_node in nearby_nodes:\n                if near_node is nearest_node:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new + 1e-8 < near_node.cost:\n                    cached_rewire = edge_collision_cached(new_node.position, near_node.position)\n                    if cached_rewire is None:\n                        in_col = self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, near_node.position, in_col)\n                    else:\n                        in_col = cached_rewire\n                    if not in_col:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            while True:\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                cached_edge_b = edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_edge_b is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                elif cached_edge_b:\n                    break\n\n                cost_b = prev_node_b.cost + dist(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                r_b = neighbor_radius(len(tree_b))\n                near_b = near(tree_b, next_pos_b, r_b)\n\n                for nb_node in near_b:\n                    if nb_node is prev_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + dist(new_node_b.position, nb_node.position)\n                    if cost_via_new_b + 1e-8 < nb_node.cost:\n                        cached_rewire_b = edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            try:\n                                edges.remove((nb_node.parent, nb_node))\n                            except ValueError:\n                                pass\n                            nb_node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, nb_node))\n\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connect_start, connect_goal = new_node, connect_node_goal\n                        else:\n                            connect_start, connect_goal = connect_node_goal, new_node\n                        success_state = True\n                    break\n                prev_node_b = new_node_b\n\n            if success_state:\n                path_start = connect_start.path_from_root()\n                path_goal = connect_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                c_max = path_length(full_path) + 1e-6\n                center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                full_path = shortcut_path(full_path, trials=200)\n\n                return PlannerResult(\n                    success=True,\n                    path=full_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(success=False, path=[], nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 23.00379,
    "time_improvement": -90.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022764372825622558,
            "num_nodes_avg": 97.2,
            "path_length_avg": 163.74335084733713,
            "success_improvement": 0.0,
            "time_improvement": -141.38169021561887,
            "length_improvement": 18.162647065193603,
            "objective_score": -38.78197765164694
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028568744659423828,
            "num_nodes_avg": 235.9,
            "path_length_avg": 239.01336691543028,
            "success_improvement": 0.0,
            "time_improvement": -93.90795092830683,
            "length_improvement": 20.687278675379513,
            "objective_score": -24.034929543416144
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03930685520172119,
            "num_nodes_avg": 312.6,
            "path_length_avg": 126.24214731601447,
            "success_improvement": 0.0,
            "time_improvement": -35.634677546077484,
            "length_improvement": 22.479716593063337,
            "objective_score": -6.194459945210577
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner implements a bidirectional RRT* approach combining heuristic goal biasing, adaptive step sizing based on distance, and rewiring for path cost optimization. The planner samples points with goal biasing, grows two trees from start and goal alternately, connects trees faster by controlling step size adaptively, and employs local rewiring to minimize path cost and improve path quality. Rigorous collision and edge checks ensure robustness. After successful connection, path shortcut smoothing further reduces path length and improves smoothness while reducing planning time.",
    "planning_mechanism": "The planner alternately extends two trees growing from start and goal positions towards sampled points with goal biasing. It uses adaptive step sizes to speed connections and performs local rewiring to lower path cost. Upon trees connecting, the planner extracts the full path and applies shortcut smoothing to improve smoothness and minimize length, while always ensuring collision-free nodes and edges to maintain robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, smoothing_iter: int = 60, radius_rewire: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_iter = smoothing_iter\n        self.radius_rewire = radius_rewire  # Radius for local rewiring to reduce cost\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]),\n                             random.uniform(0, bounds[2]))\n                    else:\n                        p = (random.uniform(0, bounds[0]),\n                             random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def can_connect(from_node, to_position):\n            if self._is_edge_in_obstacle(from_node.position, to_position, obstacles, is_3d):\n                return False\n            if self._is_in_obstacle(to_position, obstacles, is_3d):\n                return False\n            return True\n\n        def nodes_in_radius(tree, point, radius):\n            return [node for node in tree if dist(node.position, point) <= radius]\n\n        def choose_parent(neighbors, new_pos):\n            best_parent = None\n            min_cost = float('inf')\n            for node in neighbors:\n                if can_connect(node, new_pos):\n                    cost = node.cost + dist(node.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = node\n            return best_parent, min_cost\n\n        def rewire(tree, new_node, neighbors):\n            for node in neighbors:\n                if node == new_node.parent:\n                    continue\n                if can_connect(new_node, node.position):\n                    new_cost = new_node.cost + dist(new_node.position, node.position)\n                    if new_cost < node.cost:\n                        # Rewire node to new_node\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = new_cost\n                        new_node.children.append(node)\n\n        def extend_tree(tree, other_tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            dist_to_target = dist(nearest_node.position, target_point)\n            adaptive_step = min(self.step_size, dist_to_target)\n            new_pos = steer(nearest_node.position, target_point)\n            if not can_connect(nearest_node, new_pos):\n                return None\n\n            # Choose best parent for new node in radius around new_pos (rewiring)\n            neighbor_nodes = nodes_in_radius(tree, new_pos, self.radius_rewire)\n            parent_candidate, min_cost = choose_parent(neighbor_nodes, new_pos)\n            if parent_candidate is None:\n                # no suitable parent found, use nearest node if safe\n                parent_candidate = nearest_node\n                min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n\n            new_node = Node(new_pos, parent=parent_candidate, cost=min_cost)\n            parent_candidate.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_candidate, new_node))\n\n            # Rewire neighbors to new node if possible to reduce cost\n            rewire(tree, new_node, neighbor_nodes)\n\n            # Try connect new_node to other tree\n            connect_node = connect_trees(new_node, other_tree)\n            return connect_node\n\n        def connect_trees(new_node, other_tree):\n            nearest_node = nearest(other_tree, new_node.position)\n            # Try to connect directly if distance small enough\n            dist_to_new = dist(nearest_node.position, new_node.position)\n            if dist_to_new <= self.step_size and can_connect(nearest_node, new_node.position):\n                new_node_other = Node(new_node.position, parent=nearest_node,\n                                      cost=nearest_node.cost + dist(nearest_node.position, new_node.position))\n                nearest_node.add_child(new_node_other)\n                other_tree.append(new_node_other)\n                nodes.append(new_node_other)\n                edges.append((nearest_node, new_node_other))\n                return new_node_other\n\n            # Otherwise incrementally attempt to connect by stepping towards new_node\n            current = nearest_node\n            while True:\n                step_target = steer(current.position, new_node.position)\n                if not can_connect(current, step_target):\n                    return None\n                step_cost = current.cost + dist(current.position, step_target)\n                next_node = Node(step_target, parent=current, cost=step_cost)\n                current.add_child(next_node)\n                other_tree.append(next_node)\n                nodes.append(next_node)\n                edges.append((current, next_node))\n                if dist(step_target, new_node.position) <= self.step_size:\n                    return next_node\n                current = next_node\n\n        def extract_full_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection point\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut the path between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for i in range(self.max_iter):\n            # Grow start tree\n            rand_point = sample_point()\n            connected_node_goal = extend_tree(tree_start, tree_goal, rand_point)\n            if connected_node_goal:\n                success_state = True\n                # Find the newly added node connecting the two trees\n                new_node_start = tree_start[-1]\n                extracted_path = extract_full_path(new_node_start, connected_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n            # Grow goal tree\n            rand_point = sample_point()\n            connected_node_start = extend_tree(tree_goal, tree_start, rand_point)\n            if connected_node_start:\n                success_state = True\n                new_node_goal = tree_goal[-1]\n                extracted_path = extract_full_path(connected_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(success=success_state,\n                             path=extracted_path,\n                             nodes=nodes,\n                             edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.9274,
    "time_improvement": -148.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.029249954223632812,
            "num_nodes_avg": 97.1,
            "path_length_avg": 163.55487187726652,
            "success_improvement": 0.0,
            "time_improvement": -210.15145654630533,
            "length_improvement": 18.256847042869875,
            "objective_score": -59.39406755531762
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.04754550457000732,
            "num_nodes_avg": 263.6,
            "path_length_avg": 229.46080595423595,
            "success_improvement": -19.999999999999996,
            "time_improvement": -222.71111233378588,
            "length_improvement": 23.857141579824223,
            "objective_score": -72.04190538417092
        },
        {
            "map_id": 2,
            "success_rate": 0.7,
            "time_avg": 0.0321993350982666,
            "num_nodes_avg": 191.5,
            "path_length_avg": 114.10543377898837,
            "success_improvement": -30.000000000000004,
            "time_improvement": -11.109026932794292,
            "length_improvement": 29.932389832721682,
            "objective_score": -12.346230113293954
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This enhanced bidirectional RRT planner integrates an early path feasibility check using KD-Trees to speed up nearest neighbor queries, employs a priority sampling strategy near frontiers and unexplored regions to focus exploration, and uses dynamic step sizing with refined obstacle distance computation to better adapt growth steps. It also incorporates partial rewiring for improved path quality and an accelerated shortcut smoothing method reducing smoothing iterations adaptively. These improvements cumulatively reduce planning time while maintaining or enhancing success rate, path smoothness, and robustness.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternately extending towards adaptively sampled points biased near frontiers and low-node-density regions using KD-Trees for fast nearest neighbor searches. Step size dynamically scales according to obstacle proximity, with edge and node collision checks ensuring feasibility. When trees connect, the path is extracted, partially rewired for cost efficiency, and shortcut-smoothed with an adaptive iteration count before returning the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost, new_parent):\n        self.cost = new_cost\n        self.parent = new_parent\nclass Planner:\n    def __init__(self, max_iter: int=4000, step_size: float=5.0, frontier_sample_rate: float=0.35, smoothing_iters: int=60):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                      # Tuple[int, ...]\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n        # KD-Trees for fast nearest node search in each tree (store positions separately)\n        tree_start_positions = [start_root.position]\n        tree_goal_positions = [goal_root.position]\n\n        # For adaptive smoothing iterations based on environment\n        smooth_iters_dynamic = max(20, min(self.smoothing_iters, int(self.max_iter / 100)))\n\n        # Precompute obstacle bounding boxes for efficient collision checking (min/max tuples)\n        obs_boxes = self._precompute_obstacle_bounds(obstacles, is_3d)\n\n        def dist_sq(p1, p2):\n            return sum((p1[d] - p2[d])**2 for d in range(len(p1)))\n\n        for it in range(self.max_iter):\n            # Alternate trees: swap roles each iteration\n            if it & 1 == 0:\n                tree_a, tree_a_pos = tree_start, tree_start_positions\n                tree_b, tree_b_pos = tree_goal, tree_goal_positions\n            else:\n                tree_a, tree_a_pos = tree_goal, tree_goal_positions\n                tree_b, tree_b_pos = tree_start, tree_start_positions\n\n            # Sample a point biased to frontiers with probability frontier_sample_rate\n            if frontier_regions and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            # Nearest node in tree_a using linear scan (since small expected branches)\n            nearest_idx = self._nearest_node_index(tree_a_pos, rand_point)\n            nearest_node = tree_a[nearest_idx]\n\n            # Adaptive step size based on obstacle proximity\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_pos = self._steer(nearest_node.position, rand_point, step_size)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Add new node to tree_a\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            tree_a_pos.append(new_pos)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nearby nodes within radius to new_node for better cost (partial rewiring)\n            neighbor_radius = max(step_size * 2, 10.0)\n            near_idxs = self._near_nodes_indices(tree_a_pos, new_pos, neighbor_radius)\n            for idx in near_idxs:\n                neighbor = tree_a[idx]\n                if neighbor is new_node or neighbor is nearest_node:\n                    continue\n                if neighbor.parent is None:\n                    continue\n                # Check if new_node can provide better path to neighbor\n                dist_to_neighbor = math.dist(new_node.position, neighbor.position)\n                candidate_cost = new_node.cost + dist_to_neighbor\n                if candidate_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        old_parent = neighbor.parent\n                        if neighbor in old_parent.children:\n                            old_parent.children.remove(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.update_cost(candidate_cost, new_node)\n\n            # Try connecting tree_b to new_node\n            nearest_b_idx = self._nearest_node_index(tree_b_pos, new_pos)\n            nearest_node_b = tree_b[nearest_b_idx]\n\n            connecting = True\n            last_added_b = None\n\n            # Limit connection extension attempts to avoid long loops\n            for _ in range(int(self.base_step_size * 3)):\n                step_size_b = self._adaptive_step_size(nearest_node_b.position, obstacles, is_3d, self.base_step_size)\n                next_pos = self._steer(nearest_node_b.position, new_pos, step_size_b)\n                if not self._in_bounds(next_pos, bounds):\n                    break\n                if self._is_in_obstacle(next_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node_b.position, next_pos, obstacles, is_3d):\n                    break\n                new_cost_b = nearest_node_b.cost + math.dist(nearest_node_b.position, next_pos)\n                next_node = Node(next_pos, parent=nearest_node_b, cost=new_cost_b)\n                nearest_node_b.add_child(next_node)\n                tree_b.append(next_node)\n                tree_b_pos.append(next_pos)\n                nodes.append(next_node)\n                edges.append((nearest_node_b, next_node))\n                nearest_node_b = next_node\n                last_added_b = next_node\n\n                if math.dist(next_pos, new_pos) <= step_size_b:\n                    # Trees connected\n                    path_a = new_node.path_from_root()\n                    path_b = last_added_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        # If trees swapped, swap paths to keep start->goal order\n                        path_a, path_b = path_b, path_a\n                    extracted_path = path_a + path_b[::-1]\n\n                    success_state = True\n                    connecting = False\n                    break\n\n            if success_state:\n                break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._adaptive_shortcut_smooth(extracted_path, obstacles, is_3d, bounds, smooth_iters_dynamic)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        # Occupied grid cells set\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_cells = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        for cz in range(min_cells[2], max_cells[2] + 1):\n                            occupied.add((cx, cy, cz))\n            else:\n                ox, oy, w, h = obs\n                min_cells = [int(ox // resolution), int(oy // resolution)]\n                max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        # If any neighbor occupied, pos is frontier\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5)*resolution, (iy + 0.5)*resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        query_radius = base_step_size * 2\n        min_dist = base_step_size * 2\n        px, py = position[0], position[1]\n        pz = position[2] if is_3d else 0.0\n\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = math.sqrt(dx * dx + dy * dy + dz * dz)\n            else:\n                ox, oy, w, h = obs\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = math.sqrt(dx * dx + dy * dy)\n            if dist < min_dist:\n                min_dist = dist\n\n        # Scale step size linearly between 0.5*base_step_size and base_step_size based on proximity\n        if min_dist < query_radius:\n            scaled = max(base_step_size * 0.3, base_step_size * (min_dist / query_radius))\n            return scaled\n        return base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        factor = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * factor for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _precompute_obstacle_bounds(self, obstacles, is_3d):\n        # Return list of (min_corner, max_corner) tuples for all obstacles to accelerate checks if needed\n        obs_bounds = []\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                min_c = (x, y, z)\n                max_c = (x + w, y + h, z + d)\n            else:\n                x, y, w, h = obs\n                min_c = (x, y)\n                max_c = (x + w, y + h)\n            obs_bounds.append((min_c, max_c))\n        return obs_bounds\n\n    def _nearest_node_index(self, nodes_positions, point):\n        # Linear nearest since number of nodes is expected manageable; can plugin KD-tree if needed\n        best_idx = 0\n        best_dist = math.dist(nodes_positions[0], point)\n        for i in range(1, len(nodes_positions)):\n            cur_dist = math.dist(nodes_positions[i], point)\n            if cur_dist < best_dist:\n                best_dist = cur_dist\n                best_idx = i\n        return best_idx\n\n    def _near_nodes_indices(self, nodes_positions, point, radius):\n        radius_sq = radius * radius\n        near_idxs = []\n        for i, pos in enumerate(nodes_positions):\n            dist_sq = sum((pos[d] - point[d]) ** 2 for d in range(len(pos)))\n            if dist_sq <= radius_sq:\n                near_idxs.append(i)\n        return near_idxs\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Optimized by checking bounds quickly before detailed check\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _adaptive_shortcut_smooth(self, path, obstacles, is_3d, bounds, smoothing_iters):\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        length = len(new_path)\n        max_trials = smoothing_iters * 2\n\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 118.318,
    "time_improvement": -410.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014042496681213379,
            "num_nodes_avg": 147.4,
            "path_length_avg": 153.8670724585599,
            "success_improvement": 0.0,
            "time_improvement": -48.899405651242915,
            "length_improvement": 23.09871607808633,
            "objective_score": -10.050078479755609
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.07474789619445801,
            "num_nodes_avg": 547.7,
            "path_length_avg": 235.59275329344896,
            "success_improvement": 0.0,
            "time_improvement": -407.34505698653464,
            "length_improvement": 21.8223539996621,
            "objective_score": -117.83904629602797
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.2532766580581665,
            "num_nodes_avg": 789.5,
            "path_length_avg": 121.10558159031132,
            "success_improvement": 0.0,
            "time_improvement": -773.9721778648745,
            "length_improvement": 25.633877380570418,
            "objective_score": -227.06487788334826
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* with adaptive informed sampling that biases samples towards start and goal positions to balance exploration and exploitation effectively. It grows two trees from start and goal, always extending the smaller tree to maintain balanced growth. Using a dynamically shrinking neighbor radius based on tree size, it rewires nodes locally to reduce path cost continually. After each extension, attempts are made to connect the opposing tree, forming a feasible complete path. Dead-end nodes are periodically pruned to maintain computational efficiency. A post-processing shortcut smoothing iteratively reduces unnecessary turns and shortens path length while ensuring collision-free shortcuts. These components work in synergy to improve planning speed, success rate, path optimality, and path smoothness.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at the start and goal. Sampling is biased towards these roots, with uniform random samples otherwise. For each sample, the smaller tree extends towards it, steering a limited distance per iteration. The rewiring phase locally optimizes branches using neighbors within a radius that shrinks adaptively as the tree grows. Upon successful extension, the opposite tree attempts to connect directly to the new node. Dead ends with no children are pruned periodically to reduce complexity. When a connection is established, the path is extracted and processed with shortcut smoothing to improve quality, ensuring a shorter, collision-free path.",
    "code": "class Node:\n    def __init__(self, position: tuple, parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            # Adaptive informed sampling biased towards start and goal\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to reduce costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                # shortcut the path segment between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Main loop\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                extracted_path = smoothed if path_length(smoothed) + 1e-12 < path_length(raw_path) else raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.98003,
    "time_improvement": -5.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011020708084106445,
            "num_nodes_avg": 86.9,
            "path_length_avg": 171.24582246635723,
            "success_improvement": 0.0,
            "time_improvement": -16.857915001301944,
            "length_improvement": 14.412983859989318,
            "objective_score": -2.1747777283927188
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02063744068145752,
            "num_nodes_avg": 198.1,
            "path_length_avg": 244.0987074270916,
            "success_improvement": 0.0,
            "time_improvement": -40.074892427093964,
            "length_improvement": 18.999790648883877,
            "objective_score": -8.222509598351413
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017098093032836915,
            "num_nodes_avg": 167.5,
            "path_length_avg": 129.97659425030432,
            "success_improvement": 0.0,
            "time_improvement": 41.000257505715716,
            "length_improvement": 20.186541208541094,
            "objective_score": 16.337385493422936
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an informed bidirectional RRT* variant enhanced with a hybrid sampling strategy combining goal-biased informed ellipsoid sampling and frontier-based exploration to efficiently cover free space. It uses a KD-Tree for fast nearest neighbor queries, dynamically adjusts rewiring radius based on the current node count, and incorporates batch partial rewiring to improve path quality iteratively during planning. Additionally, it uses adaptive step-sizing based on local obstacle distance and employs efficient collision checking. Once a solution path is found, an iterative shortcut-based smoothing procedure refines the path adaptively. These combined strategies yield faster convergence, higher success rates, improved path smoothness, and shorter paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal positions, alternating expansions. Sampling alternates between informed ellipsoid sampling biased toward the shortest direct path to the goal and random samples near frontiers identified from explored regions. Newly generated nodes are connected after thorough collision checks. Partial rewiring within a dynamic radius optimizes path costs incrementally. The two trees attempt connection after each extension. Upon successful connection, the path is extracted and adaptively shortcut-smoothed. Use of KD-Trees accelerates nearest neighbor and radius queries, reducing runtime while maintaining solution quality and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.2):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from collections import deque\n\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dims = len(bounds)\n\n        # Core outputs\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        # Initialize trees and their node position lists (for KDTree)\n        tree_start = []\n        tree_goal = []\n        node_positions_start = []\n        node_positions_goal = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start.append(start_root)\n        tree_goal.append(goal_root)\n        node_positions_start.append(start_position)\n        node_positions_goal.append(goal_position)\n        nodes.extend([start_root, goal_root])\n\n        # Precompute obstacle bounds\n        obs_bounds = self._precompute_obstacle_bounds(obstacles, is_3d)\n\n        # KDTree import and init helper, fallback if scipy not available use linear search\n        try:\n            from scipy.spatial import KDTree\n            kd_support = True\n        except ImportError:\n            kd_support = False\n\n        def build_kdtree(pts):\n            if kd_support and pts:\n                return KDTree(pts)\n            return None\n\n        def kd_nearest(kdtree, pts, query_pt):\n            if kd_support and kdtree:\n                dist, idx = kdtree.query(query_pt)\n                return idx\n            else:\n                # Linear fallback\n                best_idx = 0\n                best_dist = math.dist(pts[0], query_pt)\n                for i in range(1, len(pts)):\n                    d = math.dist(pts[i], query_pt)\n                    if d < best_dist:\n                        best_dist = d\n                        best_idx = i\n                return best_idx\n\n        def kd_range_search(kdtree, pts, query_pt, radius):\n            if kd_support and kdtree:\n                idxs = kdtree.query_ball_point(query_pt, r=radius)\n                return idxs\n            else:\n                # Linear fallback\n                radius_sq = radius * radius\n                near_idxs = []\n                for i, pos in enumerate(pts):\n                    dist_sq = sum((pos[d] - query_pt[d]) ** 2 for d in range(dims))\n                    if dist_sq <= radius_sq:\n                        near_idxs.append(i)\n                return near_idxs\n\n        # Frontier identification for exploration bias\n        def identify_frontiers(explored_points, resolution = self.base_step_size*4):\n            # Grid occupied if close to any node (radius resolution/2)\n            # Frontier points: sampled points near edges of explored space or near obstacle boundaries\n            frontiers = []\n\n            # Build approximate occupancy grid from explored_points\n            from collections import defaultdict\n            grid = defaultdict(int)\n            for pt in explored_points:\n                idx = tuple(int(pt[d] // resolution) for d in range(dims))\n                grid[idx] += 1\n\n            # Generate frontier candidates near existing explored frontiers\n            # Frontier defined as free cell adjacent to unexplored (no nodes)\n            offsets = [-1,0,1]\n            neighbor_offsets = list(self._cartesian_product([offsets]*dims))\n            neighbor_offsets.remove((0,)*dims)\n\n            checked = set()\n            for cell in grid:\n                for offset in neighbor_offsets:\n                    neighbor = tuple(cell[d]+offset[d] for d in range(dims))\n                    if neighbor in checked:\n                        continue\n                    if neighbor not in grid:\n                        # frontier cell detected\n                        frontier_pos = tuple((neighbor[d]+0.5)*resolution for d in range(dims))\n                        # Make sure frontier_pos in bounds and free space\n                        if all(0 <= frontier_pos[d] <= bounds[d] for d in range(dims)):\n                            if not self._is_in_obstacle(frontier_pos, obstacles, is_3d):\n                                frontiers.append(frontier_pos)\n                    checked.add(neighbor)\n            return frontiers\n\n        # Informed sampling: sample inside ellipse from start to goal for improved efficiency\n        def informed_sample():\n            c_best = None\n            # If solution found, define ellipse\n            # else sample uniformly in bounds\n\n            if success_state and extracted_path:\n                length_path = self._path_length(extracted_path)\n                c_best = length_path\n            else:\n                c_best = None\n\n            if c_best is None:\n                # No solution yet: uniform sampling + goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                else:\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            else:\n                # Ellipse parameters calculation\n                c_min = math.dist(start_position, goal_position)\n                if c_min < 1e-8:\n                    return goal_position  # same point\n\n                center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dims))\n                a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dims))  # Unit vector along start-goal\n\n                # Construct rotation matrix from a1 to first axis (x)\n                # For 2D only: rotate axis, for 3D or higher approximate by no rotation, sample accordingly\n\n                # Ellipse axes lengths\n                r1 = c_best / 2\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n\n                # Sample uniformly in unit n-ball scaled by ellipse axes\n                def sample_unit_ball(n):\n                    import random\n                    import math\n                    while True:\n                        pt = [random.uniform(-1, 1) for _ in range(n)]\n                        sq_norm = sum(x * x for x in pt)\n                        if 0 < sq_norm <= 1:\n                            scale = (random.random() ** (1.0 / n)) / math.sqrt(sq_norm)\n                            return [x * scale for x in pt]\n\n                sample_local = sample_unit_ball(dims)\n                # Sort radii: r1 along a1 direction, r2 others\n                # Build sample in ellipse frame:\n                if dims == 2:\n                    # 2D rotation and transform back\n                    cos_theta = a1[0]\n                    sin_theta = a1[1]\n                    x_e = sample_local[0] * r1\n                    y_e = sample_local[1] * r2\n                    sample_rot = (\n                        cos_theta * x_e - sin_theta * y_e,\n                        sin_theta * x_e + cos_theta * y_e\n                    )\n                    sample_pt = tuple(center[d] + sample_rot[d] for d in range(2))\n                else:\n                    # For 3D or more, align only first axis a1 by projection, others approximate with orthogonal basis\n                    # Simple approximate: translate start->goal vector along first axis, others random scaled by r2\n\n                    # Unit vector a1\n                    # Generate arbitrary orthonormal basis using a1 and its complements\n                    sample_pt = [0.0] * dims\n                    sample_pt[0] = sample_local[0] * r1\n                    for i in range(1, dims):\n                        sample_pt[i] = sample_local[i] * r2\n                    # Rotate back (approx): sum(sample_pt[d]* basis[d])\n                    # Use Householder reflection or skip rotation (less accurate but acceptable here)\n                    # Approximate final sample as center offset + sample_pt components\n                    sample_pt = tuple(center[d] + sample_pt[d] for d in range(dims))\n\n                # Clamp inside bounds and avoid obstacles\n                clamped_sample = tuple(\n                    max(0.0, min(bounds[d], sample_pt[d])) for d in range(dims)\n                )\n                if not self._is_in_obstacle(clamped_sample, obstacles, is_3d):\n                    return clamped_sample\n                else:\n                    # Fallback uniform\n                    return tuple(random.uniform(0, bounds[d]) for d in range(dims))\n\n        # Alternate between frontier biased sampling and informed sampling\n        def hybrid_sample():\n            # With 30% chance: sample near frontier to improve exploration\n            if frontiers and random.random() < 0.3:\n                f = random.choice(frontiers)\n                radius = self.base_step_size * 3\n                sample_coords = []\n                for d in range(dims):\n                    low = max(0, f[d] - radius)\n                    high = min(bounds[d], f[d] + radius)\n                    sample_coords.append(random.uniform(low, high))\n                candidate = tuple(sample_coords)\n                if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # Else informed sample towards goal\n            return informed_sample()\n\n        # Function: path length calculator\n        def path_length(path):\n            seg_length = 0.0\n            for i in range(1, len(path)):\n                seg_length += math.dist(path[i-1], path[i])\n            return seg_length\n\n        # Maintainer of frontiers and explored points\n        explored_points = [start_position, goal_position]\n        frontiers = identify_frontiers(explored_points)\n\n        # Set initial KD-Trees\n        kdtree_start = build_kdtree(node_positions_start)\n        kdtree_goal = build_kdtree(node_positions_goal)\n\n        def dynamic_radius(n_nodes):\n            if n_nodes == 0:\n                return self.base_step_size * 2\n            val = self.base_step_size * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))) * 10\n            return max(val, self.base_step_size)\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dims))\n\n        def adaptive_step_size(pos):\n            # Reduce step size when close to obstacles\n            query_radius = self.base_step_size * 3\n            min_dist = query_radius\n            px = pos[0]\n            py = pos[1]\n            pz = pos[2] if is_3d else 0.0\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dz = max(oz - pz, 0, pz - (oz + d))\n                    dist_ = math.sqrt(dx*dx + dy*dy + dz*dz)\n                else:\n                    ox, oy, w, h = obs\n                    dx = max(ox - px, 0, px - (ox + w))\n                    dy = max(oy - py, 0, py - (oy + h))\n                    dist_ = math.sqrt(dx*dx + dy*dy)\n                if dist_ < min_dist:\n                    min_dist = dist_\n            if min_dist < query_radius:\n                scale = max(self.base_step_size * 0.3, self.base_step_size * (min_dist / query_radius))\n                return scale\n            return self.base_step_size\n\n        # Partial rewiring around new nodes for cost improvement\n        def partial_rewire(tree, tree_positions, new_node, obstacles, is_3d):\n            radius = dynamic_radius(len(tree))\n            if kd_support:\n                kdtree = KDTree(tree_positions)\n                near_idxs = kdtree.query_ball_point(new_node.position, r=radius)\n            else:\n                near_idxs = []\n                r_sq = radius * radius\n                for i, pos in enumerate(tree_positions):\n                    dist_sq = sum((pos[d] - new_node.position[d])**2 for d in range(dims))\n                    if dist_sq <= r_sq:\n                        near_idxs.append(i)\n            for idx in near_idxs:\n                neighbor = tree[idx]\n                if neighbor is new_node or neighbor.parent is None:\n                    continue\n                dist_new_to_neighbor = math.dist(new_node.position, neighbor.position)\n                candidate_cost = new_node.cost + dist_new_to_neighbor\n                if candidate_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        old_parent = neighbor.parent\n                        if neighbor in old_parent.children:\n                            old_parent.children.remove(neighbor)\n                        new_node.add_child(neighbor)\n                        neighbor.update_parent(new_node, candidate_cost)\n\n        # Try connecting the two trees by extending from one tree towards a node from the other\n        def try_connect_trees(tree_a, positions_a, tree_b, positions_b):\n            if kd_support:\n                kdtree_a = KDTree(positions_a)\n            else:\n                kdtree_a = None\n            if kd_support:\n                kdtree_b = KDTree(positions_b)\n            else:\n                kdtree_b = None\n\n            # For all nodes in tree_a, try connect nearest node in tree_b within step_size*3\n            max_extend = int(self.base_step_size * 3)\n            for node_a in tree_a:\n                idx_b = kd_nearest(kdtree_b, positions_b, node_a.position)\n                node_b = tree_b[idx_b]\n                dist_nodes = math.dist(node_a.position, node_b.position)\n                if dist_nodes <= self.base_step_size * 3:\n                    # Attempt connection by stepping through from node_b towards node_a\n                    last_node = node_b\n                    connected_node = None\n                    connection_steps = max_extend\n                    while connection_steps > 0:\n                        new_pos = steer(last_node.position, node_a.position, adaptive_step_size(last_node.position))\n                        if not self._in_bounds(new_pos, bounds):\n                            break\n                        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                            break\n                        new_cost = last_node.cost + math.dist(last_node.position, new_pos)\n                        new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                        last_node.add_child(new_node)\n                        tree_b.append(new_node)\n                        positions_b.append(new_pos)\n                        nodes.append(new_node)\n                        edges.append((last_node, new_node))\n                        last_node = new_node\n                        connection_steps -= 1\n                        if math.dist(new_pos, node_a.position) <= self.base_step_size:\n                            # Final check for edge feasibility\n                            if not self._is_edge_in_obstacle(new_pos, node_a.position, obstacles, is_3d):\n                                final_cost = new_node.cost + math.dist(new_pos, node_a.position)\n                                final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                                new_node.add_child(final_node)\n                                tree_b.append(final_node)\n                                positions_b.append(node_a.position)\n                                nodes.append(final_node)\n                                edges.append((new_node, final_node))\n                                connected_node = final_node\n                            break\n                    if connected_node:\n                        # Return connecting nodes (node_a from tree_a, connected_node from tree_b)\n                        return node_a, connected_node\n            return None, None\n\n        # After path extracted, shortcut smoothing (adaptive)\n        def shortcut_smooth(path, iterations):\n            if len(path) < 3:\n                return path\n            smooth_path = path[:]\n            for _ in range(iterations):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                p_i = smooth_path[i]\n                p_j = smooth_path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    smooth_path = smooth_path[:i + 1] + smooth_path[j:]\n            return smooth_path\n\n        # =============== MAIN LOOP =================\n        for itr in range(self.max_iter):\n            # Maintain trees' KD-Trees for efficient queries\n            kdtree_start = build_kdtree(node_positions_start)\n            kdtree_goal = build_kdtree(node_positions_goal)\n\n            sample_pt = hybrid_sample()\n\n            # Alternate growth: grow smaller tree each iteration\n            if len(tree_start) > len(tree_goal):\n                tree_curr, positions_curr = tree_goal, node_positions_goal\n                tree_opp, positions_opp = tree_start, node_positions_start\n            else:\n                tree_curr, positions_curr = tree_start, node_positions_start\n                tree_opp, positions_opp = tree_goal, node_positions_goal\n\n            # Find nearest in current tree\n            if not positions_curr:\n                continue\n            idx_near = kd_nearest(kdtree=build_kdtree(positions_curr), pts=positions_curr, query_pt=sample_pt)\n            nearest_node = tree_curr[idx_near]\n\n            # Adaptive step size\n            step_sz = adaptive_step_size(nearest_node.position)\n            new_pos = steer(nearest_node.position, sample_pt, step_sz)\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Add new node to tree_curr\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_curr.append(new_node)\n            positions_curr.append(new_pos)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Partial rewiring locally for path improvement\n            partial_rewire(tree_curr, positions_curr, new_node, obstacles, is_3d)\n\n            # Update explored points and frontiers every 100 iterations to reduce overhead\n            if itr % 100 == 0:\n                explored_points.append(new_pos)\n                frontiers = identify_frontiers(explored_points)\n\n            # Try connect trees at this new node\n            node_a, node_b = try_connect_trees(tree_curr, positions_curr, tree_opp, positions_opp)\n            if node_a is not None and node_b is not None:\n                # Connected successfully\n                success_state = True\n                path_from_start = node_a.path_from_root() if tree_curr is tree_start else node_b.path_from_root()\n                path_from_goal = node_b.path_from_root() if tree_curr is tree_start else node_a.path_from_root()\n                # Merge, avoid duplicate connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Adaptive smoothing iterations based on path length and iteration count\n                length_path = path_length(extracted_path)\n                smooth_iters = max(20, min(100, int(length_path / self.base_step_size)))\n                extracted_path = shortcut_smooth(extracted_path, smooth_iters)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _precompute_obstacle_bounds(self, obstacles, is_3d):\n        obs_bounds = []\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                min_c = (x, y, z)\n                max_c = (x + w, y + h, z + d)\n            else:\n                x, y, w, h = obs\n                min_c = (x, y)\n                max_c = (x + w, y + h)\n            obs_bounds.append((min_c, max_c))\n        return obs_bounds\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _path_length(self, path):\n        import math\n        length = 0.0\n        for i in range(1, len(path)):\n            length += math.dist(path[i-1], path[i])\n        return length\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2013.34591,
    "time_improvement": -6726.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.07166345119476318,
            "num_nodes_avg": 187.6,
            "path_length_avg": 157.59086318662713,
            "success_improvement": 0.0,
            "time_improvement": -659.8823437211641,
            "length_improvement": 21.237601263400997,
            "objective_score": -193.71718286366902
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 2.443140482902527,
            "num_nodes_avg": 670.6,
            "path_length_avg": 236.97219182472773,
            "success_improvement": 0.0,
            "time_improvement": -16482.61048979453,
            "length_improvement": 21.364609626501295,
            "objective_score": -4940.5102250130585
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.9084259986877441,
            "num_nodes_avg": 459.4,
            "path_length_avg": 125.46789099280099,
            "success_improvement": 0.0,
            "time_improvement": -3034.671211272333,
            "length_improvement": 22.95515661750205,
            "objective_score": -905.8103320581995
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the strengths of enhanced bidirectional RRT* with adaptive goal biasing and incremental rewiring along with a dynamic radius and balanced tree growth. It integrates dynamic radius rewiring for local cost improvements, adaptive sampling bias toward both start and goal, and smart tree balancing to improve convergence speed, robustness, and path quality. The algorithm also incorporates rewiring from both trees when extending and connecting nodes, enhancing overall path smoothness and shortness while preserving collision checks and pruning possible redundant edges.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal positions, sampling points with adaptive biasing favoring goal and start to promote exploration. It extends the smaller tree first toward sampled points, rewiring neighbors within a dynamically shrinking radius to optimize costs. When a new node is created in one tree, it attempts to connect and rewire the opposite tree toward it. Path extraction occurs at the first successful connection by merging both trees' paths. Rigorous obstacle and edge collision checks ensure safe expansions, while adaptive radius and rewiring improve convergence to optimal, smooth paths effectively across 2D or 3D environments.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive goal biasing: bias toward goal 70% and start 10% when goal_sample_rate applies\n            if random.random() < self.goal_sample_rate:\n                p = goal_position if random.random() < 0.7 else start_position\n                # Verify p does not lie inside obstacle (rare but safe)\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Uniform random sample in bounds and free space\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Dynamic radius shrinking with node count, minimum radius enforced\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:  # Strict improvement with epsilon\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if within step_size to target_node\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final edge feasibility check\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position, cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Main loop, balanced bidirectional growth alternating tree extension attempts\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            # On successful extension on one tree, attempt connection & rewiring on the other\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found feasible connection: reconstruct path\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                # Merge paths without duplicating connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.55242,
    "time_improvement": 10.0,
    "length_improvement": 12.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0072095394134521484,
            "num_nodes_avg": 92.4,
            "path_length_avg": 171.03662888960565,
            "success_improvement": 0.0,
            "time_improvement": 23.55375557122958,
            "length_improvement": 14.517536798986361,
            "objective_score": 9.969634031166146
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014955592155456544,
            "num_nodes_avg": 238.0,
            "path_length_avg": 282.8514380030673,
            "success_improvement": 0.0,
            "time_improvement": -1.5098235626334042,
            "length_improvement": 6.140323580550488,
            "objective_score": 0.7751176473200765
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.026245260238647462,
            "num_nodes_avg": 258.6,
            "path_length_avg": 137.75874664227172,
            "success_improvement": 0.0,
            "time_improvement": 9.436473833552576,
            "length_improvement": 15.407830835125619,
            "objective_score": 5.9125083170908965
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates a bidirectional RRT* algorithm with adaptive, informed sampling and dynamic radius rewiring, combined with efficient tree balancing, dead-end pruning, and iterative shortcut smoothing. It balances exploration and exploitation to improve planning speed, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, always extending the smaller tree. Sampling is adaptively biased towards the start and goal to guide growth. Each extension steers towards samples within a fixed step size and performs rewiring with a neighbor radius that shrinks as the tree grows, optimizing path costs. Between iterations, dead-end pruning removes unnecessary nodes to reduce complexity. Upon connection of trees, the resultant path is shortcut-smoothed iteratively, ensuring collision-free and shorter paths. Collision and edge feasibility checks are rigorously enforced throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import random, math\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.43558,
    "time_improvement": 2.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008450722694396973,
            "num_nodes_avg": 97.5,
            "path_length_avg": 167.3582062549438,
            "success_improvement": 0.0,
            "time_improvement": 10.392887028230934,
            "length_improvement": 16.355977076642965,
            "objective_score": 6.389061523797873
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020722436904907226,
            "num_nodes_avg": 196.3,
            "path_length_avg": 240.72557835123666,
            "success_improvement": 0.0,
            "time_improvement": -40.651797143148414,
            "length_improvement": 20.119108994288037,
            "objective_score": -8.171717344086916
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.018723511695861818,
            "num_nodes_avg": 159.8,
            "path_length_avg": 126.43746692465507,
            "success_improvement": 0.0,
            "time_improvement": 35.391486844584186,
            "length_improvement": 22.35977858710682,
            "objective_score": 15.08940177079662
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a bidirectional RRT* with adaptive informed sampling biased toward both start and goal. It employs a dynamically shrinking neighbor radius for rewiring, alternates extending the smaller tree to balance growth, prunes dead-end nodes periodically for efficiency, and applies iterative randomized shortcut smoothing to improve path quality and smoothness. The planner emphasizes fast convergence, robustness, and generating shorter, smoother paths by rigorous collision and edge checks at all connections.",
    "planning_mechanism": "The planner grows two trees from start and goal respectively, alternating expansion of the smaller tree each iteration. Samples are drawn with adaptive bias towards start and goal to balance exploration. Each extension steers towards the sample with strict in-bound and collision verification. Nearby nodes within a shrinking radius are rewired for path cost minimization. After each extension a connection attempt to the opposite tree is made. Dead-end pruning cleans ineffective branches to improve runtime. Once connected, multiple randomized shortcut smoothing iterations refine the final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def _in_bounds(pt, bounds):\n            return all(0.0 <= pt[d] <= bounds[d] for d in range(len(pt)))\n\n        def _dist_sq(a, b):\n            return sum((a[d]-b[d])**2 for d in range(len(a)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [node for node in tree if _dist_sq(node.position, pos) <= r_sq]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if (not self._is_in_obstacle(sample, obstacles, is_3d)) and _in_bounds(sample, bounds):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not _in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            dist_nearest = distance(nearest_node.position, new_pos)\n            min_cost = nearest_node.cost + dist_nearest\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            current = nearest_node\n\n            while True:\n                new_pos = steer(current.position, node.position)\n                if not _in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + distance(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                current = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if (not node.children) and (node is not start_root) and (node is not goal_root):\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        if node in tree_start:\n                            tree_start.remove(node)\n                        if node in tree_goal:\n                            tree_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path) - 1):\n                total += distance(path[i], path[i + 1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path[:]\n            path = path[:]\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth of smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                if (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                    prune_dead_nodes()\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = path_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.65633,
    "time_improvement": -51.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.012760138511657715,
            "num_nodes_avg": 81.8,
            "path_length_avg": 166.9989977726145,
            "success_improvement": -19.999999999999996,
            "time_improvement": -35.30193978647939,
            "length_improvement": 16.535506023579977,
            "objective_score": -17.28348073122782
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.028537988662719727,
            "num_nodes_avg": 135.4,
            "path_length_avg": 238.46151411141437,
            "success_improvement": 0.0,
            "time_improvement": -93.69919718813566,
            "length_improvement": 20.870402105763265,
            "objective_score": -23.935678735288043
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03580961227416992,
            "num_nodes_avg": 109.6,
            "path_length_avg": 127.67276769617656,
            "success_improvement": 0.0,
            "time_improvement": -23.566873740751802,
            "length_improvement": 21.60122949762214,
            "objective_score": -2.7498162227011127
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT planner integrating adaptive step sizing near obstacles and frontier-biased sampling for enhanced exploration efficiency. It alternately grows two trees from start and goal, performs strict collision and edge checks, and applies path shortcut smoothing for improved path quality and smoothness.",
    "planning_mechanism": "The planner samples points biased towards frontiers near obstacles with adaptive step sizes that shrink near obstacles to improve precision. Two trees grow toward each other's new nodes while avoiding collisions. Once connected, the concatenated path is shortcut-smoothed iteratively to reduce unnecessary waypoints and produce a shorter, smoother path before returning the final plan.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path: list = []\n        nodes: list = []\n        edges: list = []\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n        nodes.extend(tree_start + tree_goal)\n\n        frontiers = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for i in range(self.max_iter):\n            # Alternate between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point biased near frontiers\n            if frontiers and random.random() < self.frontier_sample_rate:\n                rand_point = self._sample_near_frontier(frontiers, bounds, is_3d)\n            else:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_a = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step_size_a = self._adaptive_step_size(nearest_a.position, obstacles, is_3d)\n            new_pos_a = self._steer(nearest_a.position, rand_point, step_size_a)\n\n            if not self._in_bounds(new_pos_a, bounds):\n                continue\n            if self._is_in_obstacle(new_pos_a, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos_a, obstacles, is_3d):\n                continue\n\n            cost_a = nearest_a.cost + math.dist(nearest_a.position, new_pos_a)\n            new_node_a = Node(new_pos_a, parent=nearest_a, cost=cost_a)\n            nearest_a.add_child(new_node_a)\n            tree_a.append(new_node_a)\n            nodes.append(new_node_a)\n            edges.append((nearest_a, new_node_a))\n\n            # Try connecting tree_b to new_node_a\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos_a))\n            connected = False\n            current_node_b = nearest_b\n\n            while True:\n                step_size_b = self._adaptive_step_size(current_node_b.position, obstacles, is_3d)\n                next_pos_b = self._steer(current_node_b.position, new_pos_a, step_size_b)\n\n                if not self._in_bounds(next_pos_b, bounds):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(current_node_b.position, next_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = current_node_b.cost + math.dist(current_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=current_node_b, cost=cost_b)\n                current_node_b.add_child(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((current_node_b, new_node_b))\n                current_node_b = new_node_b\n\n                if math.dist(next_pos_b, new_pos_a) <= step_size_b:\n                    path_a = new_node_a.path_from_root()\n                    path_b = current_node_b.path_from_root()\n                    if tree_a is tree_goal and tree_b is tree_start:\n                        path_a, path_b = path_b, path_a\n                    path = path_a + path_b[::-1]\n                    success = True\n                    connected = True\n                    break\n            if connected:\n                break\n\n        if success and len(path) > 2:\n            path = self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d):\n        query_radius = self.base_step_size * 2\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx*dx + dy*dy + dz*dz) ** 0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx*dx + dy*dy) ** 0.5\n            if dist <= query_radius:\n                return self.base_step_size * 0.5\n        return self.base_step_size\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        dim = len(bounds)\n        frontier = random.choice(frontiers)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                ranges = [range(min_c[i], max_c[i] + 1) for i in range(3)]\n                for x in ranges[0]:\n                    for y in ranges[1]:\n                        for z in ranges[2]:\n                            occupied.add((x, y, z))\n            else:\n                ox, oy, w, h = obs\n                min_c = [int(ox // resolution), int(oy // resolution)]\n                max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                for x in range(min_c[0], max_c[0] + 1):\n                    for y in range(min_c[1], max_c[1] + 1):\n                        occupied.add((x, y))\n\n        if is_3d:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    for iz in range(steps[2] + 1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dims)))\n        else:\n            for ix in range(steps[0] + 1):\n                for iy in range(steps[1] + 1):\n                    pos_grid = (ix, iy)\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        if not arrays:\n            yield ()\n            return\n        for item in arrays[0]:\n            for rest in self._cartesian_product(arrays[1:]):\n                yield (item,) + rest\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": -6.65571,
    "time_improvement": 8.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005708551406860352,
            "num_nodes_avg": 99.5,
            "path_length_avg": 159.4405888448925,
            "success_improvement": 0.0,
            "time_improvement": 39.46945967605338,
            "length_improvement": 20.313126158032215,
            "objective_score": 15.903463134422458
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02300090789794922,
            "num_nodes_avg": 396.3,
            "path_length_avg": 242.17424129074578,
            "success_improvement": 0.0,
            "time_improvement": -56.11672732392269,
            "length_improvement": 19.638393620510445,
            "objective_score": -12.907339473074716
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01748318672180176,
            "num_nodes_avg": 311.6,
            "path_length_avg": 121.5714299751307,
            "success_improvement": 0.0,
            "time_improvement": 39.67142928835457,
            "length_improvement": 25.34781840911247,
            "objective_score": 16.970992468328866
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner is a bidirectional RRT* variant incorporating adaptive goal biasing, dynamic neighbor radius, heuristic-driven sampling favoring the goal and start alternately, efficient rewiring for cost optimization, balanced tree growth, lazy collision checking, spatial pruning, and robust path smoothing via randomized shortcutting. It aggressively optimizes path cost during growth by rewiring neighbors and maintains computational efficiency by dynamically shrinking neighbor radius and alternating tree expansions, resulting in faster convergence to shorter, smooth, and collision-free paths.",
    "planning_mechanism": "The planner initializes two trees from start and goal, alternately samples points biased adaptively between start and goal to mitigate symmetry issues, and extends the respective tree towards the samples using fixed step size. It performs collision checks on nodes and edges before adding them. Upon adding a node, the planner rewires nearby nodes if improved cost paths are found within a dynamically shrinking radius. The trees attempt to connect at each iteration by extending one tree towards the newest node in the other tree. Once connected, it extracts, merges, and smooths the path via randomized shortcutting, enhancing path length and smoothness while maintaining robustness and reducing planning time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing increases linearly, capped at 0.3\n            goal_bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry problems\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fallback to start or goal to avoid stalling\n                        return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds if slight out-of-bound due to numerical errors\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Shrink radius sub-linearly, allowing fewer neighbors as tree grows\n            return max(self.min_neighbor_radius,\n                       self.max_neighbor_radius * (1 - (iteration / self.max_iter) ** 0.85))\n\n        def near_nodes(tree, pos, radius):\n            # Linear neighbor search; can be improved via spatial indices\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree expansion for balanced exploration\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Skip if node is in obstacle or edge collides\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            # Select parent with minimal cost leading to new_pos\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt to connect tree_b to new_node by stepwise extending towards it\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_node_b, cost_b)\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing with randomized shortcuts\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 9.72661,
    "time_improvement": -27.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.010322642326354981,
            "num_nodes_avg": 71.4,
            "path_length_avg": 156.3920568087793,
            "success_improvement": -9.999999999999998,
            "time_improvement": -9.455985074287279,
            "length_improvement": 21.836753168725675,
            "objective_score": -3.469444888541047
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.032800149917602536,
            "num_nodes_avg": 364.8,
            "path_length_avg": 230.32182654595167,
            "success_improvement": -9.999999999999998,
            "time_improvement": -122.62825813613654,
            "length_improvement": 23.57142581786991,
            "objective_score": -37.074192277266974
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.014490914344787598,
            "num_nodes_avg": 202.2,
            "path_length_avg": 111.02519866841915,
            "success_improvement": -19.999999999999996,
            "time_improvement": 49.996750327229705,
            "length_improvement": 31.823839747096137,
            "objective_score": 11.36379304758814
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive goal and start biasing, dynamically shrinking neighbor radius for efficient rewiring, heuristic alternating tree expansions, and lazy collision checking. It integrates spatial pruning by limiting rewiring to nearby nodes within a radius that decreases as iterations progress, reducing computational overhead. Path smoothing employs randomized shortcutting for robustness and improved smoothness. The planner aggressively optimizes path cost during growth while maintaining fast convergence and avoiding stalling by fallback sampling strategies and strict collision checks.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal positions, alternately sampling new points with an adaptive goal bias that switches sampling between start and goal to mitigate symmetry issues. Nodes are steered towards sampled points within a fixed step size and checked against obstacles for validity. Neighbors within a dynamically shrinking radius are analyzed to select the minimal cost parent and for rewiring to improve path costs. Trees attempt connection each iteration by forward extending from one tree's nearest node toward the other's new node. Upon connection, the combined path is extracted and smoothed via randomized shortcutting to enhance path quality, while all procedures ensure nodes and edges remain collision-free and inside bounds, achieving faster planning times and better path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 base_goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.base_goal_sample_rate = base_goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free(iteration):\n            goal_bias = min(self.base_goal_sample_rate + iteration / self.max_iter * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry\n                return start_position if (iteration % 2 == 0) else goal_position\n            attempts = 0\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n                attempts += 1\n                if attempts > 30:\n                    return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds robustly\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            frac = iteration / self.max_iter\n            shrink = (1 - frac ** 0.85)\n            return max(self.min_neighbor_radius, self.max_neighbor_radius * shrink)\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if self._dist_sq(node.position, pos) <= radius_sq]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: self._dist_sq(node.position, point))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree selection for balanced expansion\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            # Try rewiring to get minimal cost parent\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost paths\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt connection from tree_b to new_node by incremental steering\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if not in_bounds(pos_b_new):\n                    break\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_node_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_node_b, cost_b)\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node is curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n                curr_node_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                # Merge paths: path_start + path_goal reversed (excluding duplicated node)\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing by randomized shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        px, py, pz = (pos + (0,))[:3] if is_3d else (pos[0], pos[1], 0)\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    @staticmethod\n    def _dist_sq(p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))",
    "objective": 79.29633,
    "time_improvement": -261.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.032957601547241214,
            "num_nodes_avg": 135.6,
            "path_length_avg": 172.92176753913392,
            "success_improvement": -9.999999999999998,
            "time_improvement": -249.46544004813447,
            "length_improvement": 13.575362620956227,
            "objective_score": -77.1245594902491
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.08454980850219726,
            "num_nodes_avg": 319.6,
            "path_length_avg": 222.01775383401105,
            "success_improvement": -9.999999999999998,
            "time_improvement": -473.8747121544842,
            "length_improvement": 26.32699808297494,
            "objective_score": -141.89701402975027
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.04620904922485351,
            "num_nodes_avg": 217.8,
            "path_length_avg": 130.53996595355386,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59.45181722524017,
            "length_improvement": 19.84059704466348,
            "objective_score": -18.867425758639353
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* variant with enhanced adaptive sampling and rewiring strategies focusing on minimizing path length and improving convergence speed. It employs dynamic radius calculations, balanced tree growth, and mutual rewiring between trees. Additionally, this version incorporates heuristic-informed sampling bias that adapts over iterations to concentrate exploration around promising areas, employs a decaying radius for finer local optimizations, and implements a path shortcutting smoothing post-processing step. The planner rigorously checks for collisions at nodes and edges while maintaining efficient rewiring to produce shorter, smoother, and more robust paths efficiently in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows and rewires two trees rooted at start and goal positions, sampling points using an adaptive heuristic bias that shifts towards promising regions as iterations increase. It always extends the smaller tree first to maintain balance and dynamically adjusts the rewiring radius decreasing over time for refined local improvements. Mutual tree connection attempts and rewiring enhance path quality and smoothness. Upon finding a connection, a shortcutting process smooths the path by removing unnecessary nodes, thereby minimizing path length and improving traversal efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node({self.position}, cost={self.cost:.2f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def radius_by_nodes(n_nodes, itr):\n            # Dynamic radius shrinking with node count & iteration progress; radius shrinks faster as iteration count increases\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            # Decay radius as iter increases (slow exponential decay, min bound enforced)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            return (self._is_in_obstacle(pos, obstacles, is_3d) == False)\n\n        def is_free_edge(p1, p2):\n            return (self._is_edge_in_obstacle(p1, p2, obstacles, is_3d) == False)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic informed sampling:\n            # - Early: higher goal bias (goal: 70%, start: 10%)\n            # - Later: increase uniform exploration and biased sampling around best known connection nodes\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    # Sample near best connection region for better local refinement (after some progress)\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        # Pick random midpoint from recent connection attempts or random nodes\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i]+mid_from_goal[i])/2 for i in range(dim))\n                        # Sample in small ball around mid\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):  # try up to 5 samples in this biased region\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sample in free space\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            # fallback to start if stuck\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve local connectivity and path cost\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by removing nodes where direct connection is collision-free\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                # Search for farthest reachable node from current shortened[-1]\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n\n            rand_point = adaptive_sample(itr)\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Post-process: shortcutting for smoother path\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.53314,
    "time_improvement": 0.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010382628440856934,
            "num_nodes_avg": 93.1,
            "path_length_avg": 159.97272222093744,
            "success_improvement": 0.0,
            "time_improvement": -10.092046951276549,
            "length_improvement": 20.047171011283186,
            "objective_score": 0.9818201168736733
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020576214790344237,
            "num_nodes_avg": 272.6,
            "path_length_avg": 237.41024721166414,
            "success_improvement": 0.0,
            "time_improvement": -39.659326842009,
            "length_improvement": 21.219248029042483,
            "objective_score": -7.653948446794204
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014211153984069825,
            "num_nodes_avg": 201.5,
            "path_length_avg": 122.2769154763927,
            "success_improvement": 0.0,
            "time_improvement": 50.96210881549838,
            "length_improvement": 24.914607812175976,
            "objective_score": 20.27155420708471
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional RRT* planner merges strengths from both prior approaches. It grows two trees from start and goal points, alternately extending the smaller tree. Sampling incorporates adaptive goal bias with a probabilistic start/goal preference. Tree extension uses a fixed step size steering function with strict node and edge collision checks and map boundary enforcement. The rewiring radius shrinks dynamically with tree size, enabling local optimization. Incremental rewiring improves path cost and smoothness. Periodic pruning removes dead-end nodes to maintain efficiency. Connection attempts between trees utilize incremental steering, and final path reconstruction merges the best-cost branches. This combination targets enhanced efficiency, robustness, smoothness, reduced path length, and higher success rates.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, sampling free points with a biased probability toward start/goal to balance exploration and exploitation. Each iteration, it extends the smaller tree toward a sampled point with steering constrained to a step size and includes comprehensive collision and boundary checking. After extension, it attempts to incrementally connect the opposing tree using the same steering method. Local rewiring within a shrinking radius dynamically optimizes the trees\u2019 costs. Periodic pruning removes dead-end nodes to keep the tree size manageable. Upon connection, the final path is retrieved by concatenating the paths from both trees, producing an efficient, smooth, and collision-free trajectory.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 25.0,\n                 radius_min: float = 4.5, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.7\n            rand_val = random.random()\n            if rand_val < self.goal_sample_rate:\n                # With 70% chance goal, else start\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for potential improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children and node.valid:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        node.valid = False\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Grow smaller tree first to keep trees balanced\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Periodic pruning to improve efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -8.86231,
    "time_improvement": 28.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.0052844762802124025,
            "num_nodes_avg": 81.4,
            "path_length_avg": 175.03859137343892,
            "success_improvement": -9.999999999999998,
            "time_improvement": 43.966134002765706,
            "length_improvement": 12.5173944144161,
            "objective_score": 10.693319083712934
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018130898475646973,
            "num_nodes_avg": 175.7,
            "path_length_avg": 288.73219942497633,
            "success_improvement": 0.0,
            "time_improvement": -23.061948076957304,
            "length_improvement": 4.188887985747617,
            "objective_score": -6.0808068259376675
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01048731803894043,
            "num_nodes_avg": 135.7,
            "path_length_avg": 139.80011568287077,
            "success_improvement": 0.0,
            "time_improvement": 63.81180857041547,
            "length_improvement": 14.15430727005782,
            "objective_score": 21.974404025136206
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm integrating adaptive informed sampling biased towards both start and goal, dynamic radius rewiring with pruning of dead-ends to maintain tree efficiency, and iterative shortcut smoothing after successful path connection. It alternately extends the smaller tree to balance exploration, rigorously applies collision checks for nodes and edges, and performs path smoothing to ensure shorter and smoother trajectories. These strategies collectively improve planning speed, path optimality, robustness, success rate, and reduce computational overhead and search time.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree by sampling points within the map bounds with goal and start bias. It uses a dynamic radius for neighbor selection to locally optimize path costs via rewiring. After successfully connecting the two trees, it extracts the path and applies iterative shortcut smoothing. Periodic pruning removes dead-end nodes to reduce complexity and enhance efficiency. Comprehensive collision and edge feasibility checks are enforced to ensure valid and safe path construction.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size               # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start      # Tuple[float, ...]\n        goal_position = map.goal        # Tuple[float, ...]\n        obstacles = map.obstacles       # List of obstacles rectangles/cuboids\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate extending smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.55322,
    "time_improvement": 12.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006933975219726563,
            "num_nodes_avg": 72.8,
            "path_length_avg": 163.3649260494454,
            "success_improvement": 0.0,
            "time_improvement": 26.475696419497474,
            "length_improvement": 18.35178014195116,
            "objective_score": 11.613064954239475
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020410585403442382,
            "num_nodes_avg": 254.5,
            "path_length_avg": 244.16867087718578,
            "success_improvement": 0.0,
            "time_improvement": -38.53513131257554,
            "length_improvement": 18.976574409173768,
            "objective_score": -7.765224511937907
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014882683753967285,
            "num_nodes_avg": 157.4,
            "path_length_avg": 128.50251110260547,
            "success_improvement": 0.0,
            "time_improvement": 48.644886454788,
            "length_improvement": 21.091717061491025,
            "objective_score": 18.811809348734606
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements a bidirectional RRT* with adaptive informed sampling biased strongly toward start and goal to balance exploration and focused search. It grows two balanced trees, extending the smaller tree each iteration, rewiring locally with an adaptively shrinking radius to optimize paths incrementally. Periodic pruning removes dead-end nodes to maintain efficiency. Upon successful connection, the raw path is smoothed via iterative shortcutting with collision checks to improve smoothness and reduce length. Parameter tuning focuses on tighter step sizes, refined goal bias, and pruning frequency to enhance success rate, path quality, and computational speed.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, sampling adaptively with strong bias toward roots and uniform elsewhere. Each iteration extends the smaller tree toward a sampled point, rewires neighbors within a dynamic radius, and attempts connection to the opposing tree to form a complete path. Dead-end pruning and shortcut smoothing refine the solution progressively, ensuring collision-free and efficient paths while keeping computational cost bounded.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.18, radius_constant: float = 28.0,\n                 radius_min: float = 4.0, prune_interval: int = 150,\n                 prune_threshold: int = 80, smoothing_iterations: int = 60):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def sample_free():\n            # Adaptive informed sampling strongly biased towards start and goal\n            p_bias = 0.85\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                extracted_path = smoothed if path_length(smoothed) + 1e-12 < path_length(raw_path) else raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.38228,
    "time_improvement": -22.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011345243453979493,
            "num_nodes_avg": 97.4,
            "path_length_avg": 160.85151556772365,
            "success_improvement": 0.0,
            "time_improvement": -20.29912099080036,
            "length_improvement": 19.607958543078883,
            "objective_score": -2.1681445886243313
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03147048950195312,
            "num_nodes_avg": 195.7,
            "path_length_avg": 236.1869952319138,
            "success_improvement": 0.0,
            "time_improvement": -113.60329992734073,
            "length_improvement": 21.625164420379946,
            "objective_score": -29.75595709412623
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009719252586364746,
            "num_nodes_avg": 118.4,
            "path_length_avg": 123.4519934943215,
            "success_improvement": 0.0,
            "time_improvement": 66.46214295763002,
            "length_improvement": 24.193039121276925,
            "objective_score": 24.77725071154439
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements an efficient bidirectional RRT* planner with adaptive sampling bias, informed rewiring, and path shortcutting to improve path quality, success rate, and convergence speed. It grows two trees from start and goal, alternately extends towards sampled points considering goal bias, rewires nearby nodes to optimize costs, and upon connecting the trees, reconstructs and smooths the final path to enhance smoothness and reduce length while maintaining collision-free guarantees.",
    "planning_mechanism": "The planner alternates growth between two trees starting at start and goal positions. At each iteration, it samples a point biased towards the goal to encourage connection, extends the smaller tree towards the sample by a fixed step size if collision-free, then attempts to connect the other tree towards the new node. It rewires nodes within a dynamically computed radius for cost improvement. Upon successful connection, it extracts the path and applies shortcut smoothing to reduce unnecessary waypoints and improve path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1,\n                 radius_constant: float = 20.0, radius_min: float = 5.0, smoothing_iter: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal\n        self.radius_constant = radius_constant    # For rewiring radius calculation\n        self.radius_min = radius_min               # Minimum radius for rewiring\n        self.smoothing_iter = smoothing_iter      # Number of shortcut smoothing iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if self._is_in_obstacle(p, obstacles, is_3d):\n                    continue\n                return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, r)\n\n        def collision_free(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_collision_free(from_pos, to_pos):\n            return in_bounds(to_pos) and not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(new_pos):\n                return None\n            if not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and edge_collision_free(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_through_new + 1e-6 < node.cost and edge_collision_free(new_node.position, node.position):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(curr_node.position, new_pos):\n                    return None\n                new_cost = curr_node.cost + distance(curr_node.position, new_pos)\n                new_node = Node(new_pos, parent=curr_node, cost=new_cost)\n                curr_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr_node, new_node))\n                if distance(new_pos, node.position) <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                curr_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            return path_start + path_goal[::-1][1:]\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n            # Extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 1.97668,
    "time_improvement": -19.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015129446983337402,
            "num_nodes_avg": 118.4,
            "path_length_avg": 166.78616537886685,
            "success_improvement": 0.0,
            "time_improvement": -60.42486708683155,
            "length_improvement": 16.64187760833718,
            "objective_score": -14.799084604382028
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022152400016784667,
            "num_nodes_avg": 265.3,
            "path_length_avg": 246.38834329762886,
            "success_improvement": 0.0,
            "time_improvement": -50.357551464269925,
            "length_improvement": 18.240012005210648,
            "objective_score": -11.459263038238847
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013362503051757813,
            "num_nodes_avg": 171.5,
            "path_length_avg": 128.96814563559352,
            "success_improvement": 0.0,
            "time_improvement": 53.89051646761393,
            "length_improvement": 20.805789407940164,
            "objective_score": 20.32831282187221
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is a hybrid bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighborhood radius based on node density and iteration, heuristic-driven goal/sample switching, lazy collision checking, and efficient rewiring. It employs balanced tree growth alternating expansions, spatial pruning to avoid futile expansions, and aggressive path shortcutting for smoothness. To minimize path length and reduce planning time, it prioritizes rewiring with strict cost improvement, incorporates incremental radius shrinking, uses informed sampling to bias towards promising regions, and applies lazy validation to reduce collision checks, achieving improved success rate, efficiency, shorter and smoother paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by alternately sampling adaptive biased points. It extends the smaller tree towards the sample while rewiring neighbors within a dynamically computed radius based on tree size and iteration for incremental optimization. After extending, it attempts connection attempts to the other tree through steering and incremental node additions. Collision-free checks guard node and edge validity at each step. Once connection is made, the path is extracted by backtracking and smoothed using shortcutting procedures. The planner uses spatial pruning to avoid unnecessary node expansions, lazy collision checking to save time, and heuristic-driven sampling to focus exploration near the goal and along promising paths, thus reducing planning time, improving success, and producing shorter, smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 base_goal_sample_rate: float = 0.15,\n                 min_radius: float = 5.0, max_radius: float = 25.0,\n                 smoothing_trials: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_goal_sample_rate = base_goal_sample_rate\n        self.min_radius = min_radius\n        self.max_radius = max_radius\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration, tree_start_size, tree_goal_size):\n            # Adaptive goal biasing increases over iterations, capped at 0.35\n            goal_bias = min(self.base_goal_sample_rate + iteration / self.max_iter * 0.2, 0.35)\n            # Heuristic driven: bias more towards smaller tree base to balance exploration\n            bias_towards_goal = goal_bias if tree_start_size <= tree_goal_size else goal_bias * 0.7\n            if random.random() < bias_towards_goal:\n                # Alternate choice between start and goal biased sampling to reduce symmetry\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                attempts = 0\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                    if attempts > 30:\n                        # Fallback to start or goal\n                        return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp if marginally out-of-bound due to numerical issues\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n\n        def radius_dynamic(iteration, n_nodes):\n            # Combines iteration and node count to shrink radius dynamically\n            if n_nodes < 2:\n                return self.max_radius\n            r_iter = self.max_radius * (1 - (iteration / self.max_iter) ** 0.8)\n            r_nodes = self.max_radius * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.min_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        # Spatial pruning: avoid expansions too close to existing nodes (within a fraction of step_size)\n        def is_far_enough(tree, pos, min_dist = 0.2 * self.step_size):\n            for node in tree:\n                if distance(node.position, pos) < min_dist:\n                    return False\n            return True\n\n        # Lazy collision checking: check node validity once added, and skip edge collision checks where possible\n        def collision_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos)\n\n        def collision_free_edge(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.7)\n\n        # Initialization\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connect_node_start = None\n        connect_node_goal = None\n\n        for iteration in range(self.max_iter):\n            # Sample with adaptive bias and heuristic\n            q_rand = sample_free(iteration, len(tree_start), len(tree_goal))\n\n            # Alternate growing smaller tree for balancing and faster convergence\n            if len(tree_start) <= len(tree_goal):\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            radius = radius_dynamic(iteration, len(tree_a))\n\n            # --- Extend tree_a towards sampled point ---\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Spatial pruning: skip expansions too close to existing nodes\n            if not is_far_enough(tree_a, new_pos):\n                continue\n\n            # Node and edge collision checking (lazy)\n            if not collision_free_node(new_pos) or not collision_free_edge(nearest_a.position, new_pos):\n                continue\n\n            near = near_nodes(tree_a, new_pos, radius)\n\n            min_cost = nearest_a.cost + distance(nearest_a.position, new_pos)\n            best_parent = nearest_a\n\n            # Rewiring: choose parent with minimal cost path to new node\n            for node in near:\n                cost_through_node = node.cost + distance(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if collision_free_edge(node.position, new_pos):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if path cost improves significantly\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, node.position)\n                if cost_via_new + 1e-8 < node.cost:  # strict improvement\n                    if collision_free_edge(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, node))\n\n            # --- Attempt connection from tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n                if not collision_free_node(new_pos_b) or not collision_free_edge(curr_node_b.position, new_pos_b):\n                    break\n\n                cost_b = curr_node_b.cost + distance(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, radius)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_via_new_b = new_node_b.cost + distance(new_node_b.position, node.position)\n                    if cost_via_new_b + 1e-8 < node.cost:\n                        if collision_free_edge(new_node_b.position, node.position):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_via_new_b)\n                            edges.append((new_node_b, node))\n\n                # Check proximity for connection\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    # Final edge check to confirm connection edge\n                    if collision_free_edge(new_node_b.position, new_node.position):\n                        connected = True\n                        if tree_a is tree_start:\n                            connect_node_start = new_node\n                            connect_node_goal = new_node_b\n                        else:\n                            connect_node_start = new_node_b\n                            connect_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract and merge paths without duplication of connecting node\n                path_start = connect_node_start.path_from_root()\n                path_goal = connect_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing: shortcutting with collision checks\n                smoothed_path = self._path_smooth(full_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=smoothed_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failure to connect within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i + 1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.7):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.67462,
    "time_improvement": -21.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.014790010452270509,
            "num_nodes_avg": 89.3,
            "path_length_avg": 161.20547478429015,
            "success_improvement": -19.999999999999996,
            "time_improvement": -56.82565685523525,
            "length_improvement": 19.431053128716826,
            "objective_score": -23.161486430827203
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.02378835678100586,
            "num_nodes_avg": 204.8,
            "path_length_avg": 236.70521465371112,
            "success_improvement": -9.999999999999998,
            "time_improvement": -61.461470370723994,
            "length_improvement": 21.453201684084284,
            "objective_score": -19.14780077440034
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.01293332576751709,
            "num_nodes_avg": 127.3,
            "path_length_avg": 124.79243388594284,
            "success_improvement": -9.999999999999998,
            "time_improvement": 55.371462278703454,
            "length_improvement": 23.369927971333663,
            "objective_score": 16.285424277877766
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements a hybrid bidirectional RRT* with heuristic-informed adaptive sampling leveraging a potential field guidance to bias exploration towards promising regions while avoiding obstacles. It incorporates dynamic rewiring with a decreasing neighborhood radius for incremental path optimization and efficient pruning of low-utility nodes. The planner alternately grows trees from start and goal, uses a visibility graph approximation for shortcut smoothing, and employs lazy collision checking to reduce overhead. Adaptive step sizes and continuous heuristic updates improve planning speed, robustness, and path quality overall.",
    "planning_mechanism": "The planner starts two trees at start and goal positions and grows them alternately, biased by a heuristic potential guiding sampling near the shortest estimated path corridors. It implements rewiring for cost optimization within a shrinking radius to improve path optimality progressively. Lazy collision checks ensure validity of edges on demand to save computations. When the trees connect, it extracts the path and performs an advanced shortcut smoothing leveraging visibility graph edges to yield a high-quality smooth, short path efficiently. Periodic pruning removes dead-ends to maintain tree efficiency and reduce memory/computation overhead.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n        self._lazy_checked = False     # For lazy collision checking\n        self._edge_valid = True        # Edge validity flag with parent\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        self._lazy_checked = False\n        self._edge_valid = True\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.prune_interval = 250\n        self.prune_threshold = 150\n        self.radius_constant = 30.0\n        self.radius_min = 4.0\n        self.smoothing_iterations = 60\n        self.lazy_collision_cache = {}\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Heuristic estimate: Euclidean distance to goal\n        def heuristic(pos):\n            return dist(pos, goal_position)\n\n        # Biased sampling along corridor between start and goal using Gaussian kernel around line segment\n        def informed_sample():\n            # Sample inside an ellipsoid with foci start and goal to bias towards tight corridor\n            c_min = dist(start_position, goal_position)\n            if c_min == 0:\n                return start_position\n            # Define ellipsoid parameters\n            # Sample uniform radius and angles in ellipse space and transform to workspace\n            # For simplicity, sample Gaussian around line between start and goal:\n            line_vec = tuple(goal_position[d] - start_position[d] for d in range(len(bounds)))\n            dim = len(bounds)\n            # Mean at midpoint\n            mean = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n            # Standard deviation proportional to half distance\n            std_dev = c_min / 3.0\n            while True:\n                sample = tuple(random.gauss(mean[d], std_dev) for d in range(dim))\n                if all(0 <= sample[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * (math.log(n + 1) / (n + 1))**0.5\n            return max(rad, self.radius_min)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        # Lazy collision checking for edge validity - cache results for efficiency\n        def lazy_check_edge(parent_node, child_node):\n            key = (parent_node.position, child_node.position)\n            if key in self.lazy_collision_cache:\n                valid = self.lazy_collision_cache[key]\n            else:\n                valid = not self._is_edge_in_obstacle(parent_node.position, child_node.position, obstacles, is_3d)\n                self.lazy_collision_cache[key] = valid\n            child_node._edge_valid = valid\n            child_node._lazy_checked = True\n            return valid\n\n        def safe_add_node(tree, new_node, parent_node):\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                return False\n            if not lazy_check_edge(parent_node, new_node):\n                return False\n            parent_node.children.append(new_node)\n            tree.append(new_node)\n            return True\n\n        # Rewire tree nodes in decreasing radius for path improvement\n        def rewire(tree, new_node):\n            radius = radius_dynamic(len(tree))\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node or neighbor is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost:\n                    if lazy_check_edge(new_node, neighbor):\n                        neighbor.update_parent(new_node, cost_through_new)\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            if path_start[-1] == path_goal[-1]:\n                full_path = path_start + path_goal[::-1][1:]\n            else:\n                full_path = path_start + path_goal[::-1]\n            return full_path\n\n        # Shortcut smoothing: using visibility graph approximation by attempting to connect non-adjacent nodes if collision-free\n        def shortcut_smooth(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_dead_nodes(nodes, edges, root1, root2):\n            removed = []\n            q = deque([root1, root2])\n            reachable = set()\n            while q:\n                n = q.popleft()\n                reachable.add(n)\n                for c in n.children:\n                    if c not in reachable:\n                        q.append(c)\n            new_nodes = []\n            for n in nodes:\n                if n in reachable:\n                    new_nodes.append(n)\n                else:\n                    # detach dead node\n                    if n.parent and n in n.parent.children:\n                        n.parent.children.remove(n)\n                    removed.append(n)\n            new_edges = [(p,c) for (p,c) in edges if p in reachable and c in reachable]\n            return new_nodes, new_edges, removed\n\n        # Init trees\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        # Alternate growing trees with heuristic guided samples\n        for iteration in range(self.max_iter):\n            # Alternate expansion between smaller tree\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = goal_root, start_root\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = start_root, goal_root\n\n            # 80% bias to informed sampling, 20% random uniform free space sampling\n            sample_pt = informed_sample() if random.random() < 0.8 else tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not in_bounds(sample_pt) or self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_a, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n\n            if not lazy_check_edge(nearest_node, new_node):\n                continue\n\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire near neighbors around new_node for cost improvement\n            rewire(tree_a, new_node)\n\n            # Try connecting tree_b to new_node with breaks on lazy collision failure, stepwise steering\n            connect_node_b = new_node\n            connected_node = None\n            while True:\n                nearest_b = nearest(tree_b, connect_node_b.position)\n                next_pos_b = steer(nearest_b.position, connect_node_b.position)\n                if nearest_b.position == next_pos_b:\n                    break  # no progress\n\n                if not in_bounds(next_pos_b):\n                    break\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(nearest_b.position, next_pos_b, obstacles, is_3d) is True:\n                    break\n\n                cost_b = nearest_b.cost + dist(nearest_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=nearest_b, cost=cost_b)\n\n                if not lazy_check_edge(nearest_b, new_node_b):\n                    break\n\n                nearest_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((nearest_b, new_node_b))\n\n                connect_node_b = new_node_b\n\n                if dist(connect_node_b.position, new_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(connect_node_b.position, new_node.position, obstacles, is_3d):\n                        final_node = Node(new_node.position, parent=connect_node_b,\n                                         cost=connect_node_b.cost + dist(connect_node_b.position, new_node.position))\n                        connect_node_b.children.append(final_node)\n                        tree_b.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((connect_node_b, final_node))\n                        connected_node = final_node\n                    break\n\n            if connected_node is not None:\n                # Extract path from start_root to connected_node in both trees\n                if tree_a is tree_start:\n                    node_start, node_goal = new_node, connected_node\n                else:\n                    node_start, node_goal = connected_node, new_node\n\n                raw_path = extract_path(node_start, node_goal)\n                smoothed_path = shortcut_smooth(raw_path)\n                final_path = smoothed_path\n                success = True\n                break\n\n            # Prune dead-end nodes periodically\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                nodes, edges, _ = prune_dead_nodes(nodes, edges, start_root, goal_root)\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 53.44754,
    "time_improvement": -187.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006427860260009766,
            "num_nodes_avg": 65.3,
            "path_length_avg": 162.96937133411816,
            "success_improvement": 0.0,
            "time_improvement": 31.842278901503946,
            "length_improvement": 18.549474586798826,
            "objective_score": 13.262578587810948
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022130084037780762,
            "num_nodes_avg": 246.1,
            "path_length_avg": 239.94339054278174,
            "success_improvement": 0.0,
            "time_improvement": -50.20608363419225,
            "length_improvement": 20.378665371724665,
            "objective_score": -10.98609201591274
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.18582911491394044,
            "num_nodes_avg": 833.5,
            "path_length_avg": 124.16589820662223,
            "success_improvement": -9.999999999999998,
            "time_improvement": -541.2334935134064,
            "length_improvement": 23.754658621580848,
            "objective_score": -162.61911632970575
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner synergizes adaptive heuristic sampling and dynamic rewiring from bidirectional RRT* variants with incremental connection attempts and periodic pruning from hybrid planners. It balances exploration and exploitation using an adaptive goal/start bias that evolves over iterations, alternately grows and rewires two balanced trees, dynamically adjusts the rewiring radius with iteration progress, and prunes dead-end nodes to sustain efficiency. The planner integrates thorough collision checking, mutual incremental tree connections, and post-processing shortcut smoothing to produce shorter, smoother, and robust paths efficiently across 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, extending the smaller tree each iteration toward adaptively sampled points biased by iteration progress. After successful extension, it incrementally attempts to connect the opposite tree. A dynamic radius for neighbor rewiring shrinks over iterations, enabling global exploration early and fine local refinements late. Dead-end pruning occurs periodically to manage tree size and enhance performance. Upon connection, the final path is shortcut-smoothed for reduced length and improved traversal.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision and pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            rad_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def dynamic_radius(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Adaptive heuristic sampling bias:\n            # Early: strong goal bias ~70%, start bias ~10%\n            # Late: increase uniform exploration + bias around promising mid-regions\n            r = random.random()\n            goal_bias = self.goal_sample_rate\n            if r < goal_bias:\n                subr = random.random()\n                if subr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[i] + mid_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sampling\n            for _ in range(100):\n                candidate = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(candidate):\n                    return candidate\n            return start_position  # fallback\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = dynamic_radius(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_incremental(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if is_free_edge(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if node.is_leaf() and node.valid:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        node.valid = False\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance tree growth: extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_incremental(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n            # Periodic pruning dead-end nodes for efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.94707,
    "time_improvement": -11.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012036538124084473,
            "num_nodes_avg": 66.9,
            "path_length_avg": 157.37715877117898,
            "success_improvement": 0.0,
            "time_improvement": -27.62925379020576,
            "length_improvement": 21.344408676222677,
            "objective_score": -4.019894401817192
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02294914722442627,
            "num_nodes_avg": 181.7,
            "path_length_avg": 242.3378349845835,
            "success_improvement": 0.0,
            "time_improvement": -55.76540610693692,
            "length_improvement": 19.584107698274103,
            "objective_score": -12.812800292426255
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014379000663757325,
            "num_nodes_avg": 112.3,
            "path_length_avg": 125.72856158370777,
            "success_improvement": 0.0,
            "time_improvement": 50.38292663061586,
            "length_improvement": 22.795089171624692,
            "objective_score": 19.673895823509696
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner combines the strengths of both previous algorithms into a bidirectional RRT* variant with adaptive and heuristic-informed sampling, dynamic and decaying rewiring radius, and balanced tree growth. It incorporates mutual rewiring and connection attempts between trees, periodic pruning of dead-end nodes for efficiency, and advanced path shortcutting smoothing. Collision checks rigorously ensure safety, while adaptive sampling focuses exploration near promising regions as iterations progress. This results in improved efficiency, robustness, success rate, and smoother, shorter paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balance. It samples points adaptively and heuristically to balance exploration and exploitation. Each extension uses a dynamic, decaying radius to find near nodes for rewiring and cost optimization. After each expansion, the planner attempts to connect the other tree. Dead-end nodes are pruned periodically to keep the search tree efficient. Upon successful connection, a shortcut smoothing post-process refines the path. Collision checks are enforced for all nodes and edges.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250, prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            # Heuristic adaptive sampling shifting from aggressive goal/start bias to exploration near connection midpoints\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free sample\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                # Use the shorter path between raw, shortcuted and smoothed to improve quality\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return type('PlannerResult', (), {})() if not success_state else \\\n            PlannerResult(\n                success=success_state,\n                path=extracted_path,\n                nodes=nodes,\n                edges=edges,\n            )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.86,
    "time_improvement": 5.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009752225875854493,
            "num_nodes_avg": 84.4,
            "path_length_avg": 160.30622257797762,
            "success_improvement": 0.0,
            "time_improvement": -3.407582686779978,
            "length_improvement": 19.880490738272123,
            "objective_score": 2.9538233416204314
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.018081092834472658,
            "num_nodes_avg": 184.4,
            "path_length_avg": 235.45185784316172,
            "success_improvement": 0.0,
            "time_improvement": -22.723896477563834,
            "length_improvement": 21.869107876772635,
            "objective_score": -2.4433473679146225
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017218947410583496,
            "num_nodes_avg": 175.8,
            "path_length_avg": 122.99644452541483,
            "success_improvement": 0.0,
            "time_improvement": 40.583229878560964,
            "length_improvement": 24.472773630917217,
            "objective_score": 17.069523689751733
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This enhanced bidirectional RRT* planner incorporates adaptive rewiring radius based on the number of nodes, balanced tree growth by always extending the smaller tree first, goal-start informed sampling with a dynamic bias, and periodic pruning of dead-end nodes to improve search efficiency and robustness. Tuned parameters including a refined step size, goal sampling rate, and rewiring radius constants help achieve better path smoothness, shorter paths, higher success rates, and reduced planning time. Collision and edge feasibility are strictly enforced to ensure valid solutions.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling points with bias and extending the smaller tree toward these samples using a step-size limited steering function. Upon adding nodes, it locally rewires neighbors within a shrinking radius for cost optimization. The opposing tree attempts incremental incremental connections after each extension. Periodic pruning of dead-end nodes reduces unnecessary growth, focusing exploration and improving efficiency. Once the trees connect, the optimal path is reconstructed by merging both tree paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(\n        self, max_iter: int = 4500, step_size: float = 4.0,\n        goal_sample_rate: float = 0.12, radius_constant: float = 18.0,\n        radius_min: float = 4.0, prune_interval: int = 150, prune_threshold: int = 60\n    ):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            p_goal_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                # Biased sample toward goal or start to reduce symmetry bias and improve convergence\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Adaptive radius shrinking with problem size to balance rewiring and runtime\n            if n_nodes == 0:\n                return self.radius_min\n            return max(\n                self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1)),\n                self.radius_min\n            )\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Ensure new node is within bounds\n            for d in range(len(new_pos)):\n                if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                    return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                # Ensure new node stays inside map\n                for d in range(len(new_pos)):\n                    if new_pos[d] < 0 or new_pos[d] > bounds[d]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first for balanced search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr != 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.75):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10.09522,
    "time_improvement": -21.0,
    "length_improvement": 5.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.006239748001098633,
            "num_nodes_avg": 89.5,
            "path_length_avg": 181.7971448895594,
            "success_improvement": -19.999999999999996,
            "time_improvement": 33.836924453747734,
            "length_improvement": 9.139534326874573,
            "objective_score": 1.9789842014992367
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.025047683715820314,
            "num_nodes_avg": 206.9,
            "path_length_avg": 306.84594501005284,
            "success_improvement": 0.0,
            "time_improvement": -70.00904599540742,
            "length_improvement": -1.8218656146674426,
            "objective_score": -21.367086921555714
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.0363384485244751,
            "num_nodes_avg": 177.2,
            "path_length_avg": 148.84569612686118,
            "success_improvement": -9.999999999999998,
            "time_improvement": -25.39170897411533,
            "length_improvement": 8.599775962513844,
            "objective_score": -10.897557499731828
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a bidirectional RRT* algorithm with balanced tree growth, adaptive neighbor radius for rewiring, and shortcut path smoothing to improve path quality, efficiency, and success rate. The planner alternates extending the smaller tree towards sampled points biased towards start and goal, attempts connection with the opposite tree after each extension, prunes dead-end nodes periodically to control complexity, and provides collision-free, smooth, and near-optimal paths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, sampling points with bias towards these roots to guide growth. It extends the smaller tree towards samples within step size limits, rewires locally using adaptively shrinking neighbor radius to lower path cost, and attempts to connect the opposite tree at each extension. Invalid or dead nodes are pruned intermittently. Upon connection, the path is extracted and refined through iterative shortcut smoothing, providing a collision-free, shorter, and smoother path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Cost from root\n        self.children = []\n        self.valid = True                  # For collision or validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.95653,
    "time_improvement": 10.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0070808172225952145,
            "num_nodes_avg": 92.9,
            "path_length_avg": 161.14819930966323,
            "success_improvement": 0.0,
            "time_improvement": 24.918659416168012,
            "length_improvement": 19.45967886043232,
            "objective_score": 11.367533596936868
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0237623929977417,
            "num_nodes_avg": 227.0,
            "path_length_avg": 238.90444583071044,
            "success_improvement": 0.0,
            "time_improvement": -61.28524337611435,
            "length_improvement": 20.723422376253854,
            "objective_score": -14.240888537583533
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.00985403060913086,
            "num_nodes_avg": 123.5,
            "path_length_avg": 130.73786629590094,
            "success_improvement": 0.0,
            "time_improvement": 65.99706953559297,
            "length_improvement": 19.71907431274517,
            "objective_score": 23.74293572322693
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an advanced bidirectional RRT* variant that combines adaptive goal biasing, dynamic neighbor radius based on node density, heuristic-informed sampling towards the goal, balanced growth of trees by always extending the smaller tree first, efficient rewiring strategies, lazy collision checking, and iterative path smoothing with shortcutting. It also incorporates pruning of dead-end nodes to control tree complexity dynamically. These collective heuristics focus on rapidly finding a feasible path, continuously optimizing for minimal cost, and producing a collision-free, smooth, and short path with reduced planning time and improved success rate.",
    "planning_mechanism": "The planner grows two trees from start and goal simultaneously, alternately extending the smaller tree toward adaptively sampled points with bias towards start and goal. It maintains a dynamic neighbor radius shrinking with iterations to refine rewiring. Newly added nodes optimize their parent connections and rewire neighbors if beneficial. After each extension, an attempt is made to connect to the opposite tree. Dead-end nodes are pruned at intervals to reduce overhead. Upon connection, the combined path is extracted and refined using iterative shortcut smoothing, ensuring collision-free, smoother, and near-optimal pathways while minimizing search time and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=250,\n                 prune_threshold: int=150,\n                 smoothing_iterations: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increasing up to capped value\n            bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.35)\n            if random.random() < bias:\n                return goal_position if random.random() < 0.65 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clamp inside bounds\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            # Combine iteration and node count for dynamic radius to balance rewiring scope\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1)/c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Linear search neighbor; could be improved with spatial index\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_dead_nodes():\n            removed = 0\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Prune leaf nodes far from connection or with no children\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # --- Extend tree_a towards q_rand ---\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                # Skip failed extension\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                cost_thl = node.cost + dist(node.position, new_pos)\n                if cost_thl + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = cost_thl\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # --- Try to connect tree_b to new_node ---\n            nearest_b = nearest(tree_b, new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            while True:\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees connected\n                if dist(new_node_b.position, new_node.position) <= self.step_size:\n                    if can_connect(new_node_b.position, new_node.position):\n                        # Create connection node to finalize the linkage\n                        final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                        connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connection_node)\n                        tree_b.append(connection_node)\n                        nodes.append(connection_node)\n                        edges.append((new_node_b, connection_node))\n\n                        # Successful connection found\n                        success_state = True\n\n                        if tree_a is tree_start:\n                            path_start = connection_node.path_from_root()\n                            path_goal = new_node.path_from_root()\n                        else:\n                            path_start = new_node.path_from_root()\n                            path_goal = connection_node.path_from_root()\n\n                        # Merge paths without duplicating the connection node\n                        merged_path = path_start + path_goal[::-1][1:]\n\n                        # Iterative shortcut smoothing for path quality\n                        merged_path = shortcut_smoothing(merged_path)\n\n                        extracted_path = merged_path\n                        connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Periodic pruning to reduce search space overhead\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 27.44725,
    "time_improvement": -107.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012405037879943848,
            "num_nodes_avg": 86.4,
            "path_length_avg": 161.5420618792853,
            "success_improvement": 0.0,
            "time_improvement": -31.53663549558978,
            "length_improvement": 19.26283013374403,
            "objective_score": -5.608424621928128
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02358701229095459,
            "num_nodes_avg": 261.6,
            "path_length_avg": 233.03739999615118,
            "success_improvement": 0.0,
            "time_improvement": -60.0948615833243,
            "length_improvement": 22.6703066751551,
            "objective_score": -13.49439713996627
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.09541690349578857,
            "num_nodes_avg": 207.8,
            "path_length_avg": 117.76933935101704,
            "success_improvement": 0.0,
            "time_improvement": -229.25149752325572,
            "length_improvement": 27.682531094110963,
            "objective_score": -63.23894303815452
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This enhanced hybrid bidirectional RRT* planner dynamically adjusts goal bias, uses a KDTree for efficient nearest-neighbor searches, and incorporates batch rewiring limited to a tuned adaptive radius. It balances tree growth by always extending the smaller tree first with step steering and collision checks optimized for early rejection. The planner includes an efficient path shortcutting smoothing pass and prunes redundant nodes post-connection for reduced complexity. Adaptive radius shrinks with node count for faster rewiring and improved path convergence, thus reducing planning time while improving path quality, success rate, smoothness, and robustness.",
    "planning_mechanism": "The planner initializes two trees rooted at start and goal, and iteratively samples points biased adaptively toward the goal. At each iteration, it extends the smaller tree toward the sampled point using fixed-step steering, verifies collisions for new nodes and edges, and locally rewires neighbors within a radius computed adaptively based on node count. Following extension, it attempts to connect the opposite tree toward the new node. Upon successful connection, the path is reconstructed by concatenating branches from both trees, followed by a shortcut smoothing pass. The use of KDTree accelerates nearest neighbor queries, and adaptive goal bias accelerates convergence to the goal while maintaining exploration.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate_start=0.1, goal_sample_rate_end=0.35,\n                 radius_constant: float = 25.0, radius_min: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from bisect import insort\n        from collections import deque\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None  # fallback if scipy not available\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         iteration / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # 85% goal, 15% start to encourage bidirectional connection\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                for _ in range(50):  # limit attempts\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback to start if no free sampled found\n                return start_position\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            # Use KDTree if available, else linear search\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                radius_sq = radius * radius\n                return [node for node in tree if (dist(node.position, pos) <= radius)]\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire neighbors improved cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d)\n                            and not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_redundant_nodes(tree):\n            # Optionally prune nodes not connected to root (or orphan nodes)\n            # Queue BFS from root\n            root = tree[0] if tree else None\n            if root is None:\n                return\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            # Remove nodes not in visited\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Build kdtrees for efficient NN queries\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                # Merge paths avoiding duplicate connection node\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Smooth resulting path\n                extracted_path = smooth_path(merged_path, max_trials=150)\n\n                # Optional prune to reduce tree size after success\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.43151,
    "time_improvement": -0.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012529683113098145,
            "num_nodes_avg": 63.3,
            "path_length_avg": 155.3730580323225,
            "success_improvement": 0.0,
            "time_improvement": -32.85830937989023,
            "length_improvement": 22.346038963095314,
            "objective_score": -5.388285021348006
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01742854118347168,
            "num_nodes_avg": 234.6,
            "path_length_avg": 232.5926149824971,
            "success_improvement": 0.0,
            "time_improvement": -18.294757044629613,
            "length_improvement": 22.817901390432237,
            "objective_score": -0.9248468353024366
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014329338073730468,
            "num_nodes_avg": 175.4,
            "path_length_avg": 126.68648538319522,
            "success_improvement": 0.0,
            "time_improvement": 50.554295450375854,
            "length_improvement": 22.20686625243884,
            "objective_score": 19.60766188560052
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces an informed bidirectional RRT* with adaptive sampling focused within the ellipsoidal heuristically defined region between start and goal, thereby drastically reducing unnecessary exploration and improving convergence speed. It integrates dynamic goal biasing, uses KDTree for efficient neighbor searches and rewiring, and incorporates collision-aware shortcut smoothing. The planner balances exploration and exploitation while maintaining robustness and path quality, resulting in shorter, smoother paths with higher success and efficiency.",
    "planning_mechanism": "The planner simultaneously grows two trees rooted at start and goal positions. At each iteration, it samples points within an informed ellipsoidal space biased towards the goal, extending the smaller tree first toward the sample. Nearest neighbors are found via KDTree to find an optimal parent minimizing cost with rewiring applied to neighbors within an adaptive radius. After extending, the planner attempts to connect the opposite tree in small increments. Upon successful connection, the combined path is shortcut-smoothed to enhance smoothness. The algorithm ensures collision-free nodes and edges throughout and prunes non-connected nodes post-solution to keep complexity low.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.15, goal_sample_rate_end=0.4,\n                 radius_constant: float = 20.0, radius_min: float = 3.0,\n                 shortcut_trials: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.shortcut_trials = shortcut_trials\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def dist_sq(a,b):\n            return sum((a[i]-b[i])**2 for i in range(len(a)))\n\n        # Heuristic: ellipsoidal informed sampling within an ellipse/ellipsoid defined by start-goal segment and current best path cost\n        def informed_sample(c_best, c_min, start, goal):\n            # If no path found yet (c_best == inf), sample uniformly\n            if c_best == float('inf'):\n                return uniform_sample()\n\n            # Compute center and unit vector from start to goal\n            center = tuple((start[d] + goal[d]) / 2 for d in range(len(start)))\n            diff = tuple(goal[d] - start[d] for d in range(len(start)))\n            length = dist(start, goal)\n\n            # Sample a random point in unit n-sphere\n            def sample_unit_sphere(dim):\n                import random\n                import math\n                import numpy as np\n                # Using Marsaglia method\n                vec = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x*x for x in vec))\n                u = [x / norm for x in vec]  # unit vector\n                r = random.uniform(0,1) ** (1.0/dim)\n                return [r*x for x in u]\n\n            n = len(start)\n            # radii of ellipse along axes: major axis length c_best/2, minor axis sqrt(c_best^2 - c_min^2)/2 for others\n            if c_best**2 - c_min**2 < 0:\n                radius_minor = 0.0\n            else:\n                radius_minor = math.sqrt(c_best**2 - c_min**2)/2\n\n            # Build scaling factors along major and minor axes\n            if n == 2:\n                L = [length/2, radius_minor]\n            elif n ==3:\n                L = [length/2, radius_minor, radius_minor]\n            else:\n                # For higher dims fallback to uniform\n                return uniform_sample()\n\n            # Sample inside unit n-ball\n            unit_sphere_sample = sample_unit_sphere(n)\n\n            # Scale sample ellipse radii axis-wise\n            sample_scaled = tuple(unit_sphere_sample[i]*L[i] for i in range(n))\n\n            # Rotate sample to align with start-goal vector; only meaningful in 2D or 3D\n            # Rotation matrix to align x-axis with diff vector\n            # For 2D:\n            if n==2:\n                dx, dy = diff\n                theta = math.atan2(dy, dx)\n                cos_t, sin_t = math.cos(theta), math.sin(theta)\n                x_ellip = sample_scaled[0]*cos_t - sample_scaled[1]*sin_t\n                y_ellip = sample_scaled[0]*sin_t + sample_scaled[1]*cos_t\n                sample_rotated = (x_ellip, y_ellip)\n            elif n==3:\n                # Use Rodrigues' rotation formula to align unit vector (1,0,0) to diff/length\n                ux, uy, uz = 1.0, 0.0, 0.0\n                vx, vy, vz = (diff[d]/length if length>0 else 0 for d in range(3))\n                vx, vy, vz = float(vx), float(vy), float(vz)\n                # Cross product u x v\n                kx = uy*vz - uz*vy\n                ky = uz*vx - ux*vz\n                kz = ux*vy - uy*vx\n                k_norm = math.sqrt(kx*kx + ky*ky + kz*kz)\n                if k_norm < 1e-6:\n                    # vectors are parallel or anti-parallel\n                    if vx < 0:\n                        # 180 degree rotation around any perpendicular axis: choose y-axis\n                        R = [[-1,0,0],[0,-1,0],[0,0,1]]\n                    else:\n                        R = [[1,0,0],[0,1,0],[0,0,1]]\n                else:\n                    kx /= k_norm\n                    ky /= k_norm\n                    kz /= k_norm\n                    cos_a = ux*vx + uy*vy + uz*vz\n                    sin_a = k_norm\n                    K = [\n                        [0, -kz, ky],\n                        [kz, 0, -kx],\n                        [-ky, kx, 0]\n                    ]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n\n                    # Rodrigues formula: R = I + sin(a)*K + (1-cos(a))*K^2\n                    K2 = [[K[0][0]*K[0][0]+K[0][1]*K[1][0]+K[0][2]*K[2][0],\n                           K[0][0]*K[0][1]+K[0][1]*K[1][1]+K[0][2]*K[2][1],\n                           K[0][0]*K[0][2]+K[0][1]*K[1][2]+K[0][2]*K[2][2]],\n                          [K[1][0]*K[0][0]+K[1][1]*K[1][0]+K[1][2]*K[2][0],\n                           K[1][0]*K[0][1]+K[1][1]*K[1][1]+K[1][2]*K[2][1],\n                           K[1][0]*K[0][2]+K[1][1]*K[1][2]+K[1][2]*K[2][2]],\n                          [K[2][0]*K[0][0]+K[2][1]*K[1][0]+K[2][2]*K[2][0],\n                           K[2][0]*K[0][1]+K[2][1]*K[1][1]+K[2][2]*K[2][1],\n                           K[2][0]*K[0][2]+K[2][1]*K[1][2]+K[2][2]*K[2][2]]]\n                    R = [[I[r][c] + sin_a*K[r][c] + (1 - cos_a)*K2[r][c] for c in range(3)] for r in range(3)]\n\n                sample_rotated = tuple(\n                    R[0][0]*sample_scaled[0] + R[0][1]*sample_scaled[1] + R[0][2]*sample_scaled[2],\n                    R[1][0]*sample_scaled[0] + R[1][1]*sample_scaled[1] + R[1][2]*sample_scaled[2],\n                    R[2][0]*sample_scaled[0] + R[2][1]*sample_scaled[1] + R[2][2]*sample_scaled[2]\n                )\n            else:\n                # Higher dims fallback uniform\n                return uniform_sample()\n\n            sample_global = tuple(center[d] + sample_rotated[d] for d in range(n))\n            # Clamp sample_global to bounds to not exceed map\n            clamped = tuple(\n                max(0.0, min(sample_global[d], bounds[d]))\n                for d in range(n)\n            )\n            return clamped\n\n        # Uniform free space sampling respecting obstacles and bounds\n        def uniform_sample(max_retry=50):\n            for _ in range(max_retry):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # fallback\n            return start_position\n\n        # Adaptive radius per RRT* theory for rewiring\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            pts = [node.position for node in tree]\n            return KDTree(pts)\n\n        def nearest(tree, kdtree, point):\n            if kdtree is not None:\n                dist_, idx = kdtree.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, kdtree, pos, radius):\n            if kdtree is not None:\n                idxs = kdtree.query_ball_point(pos, radius)\n                return [tree[i] for i in idxs]\n            else:\n                return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def try_extend(tree, kdtree, point):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, kdtree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors with better cost via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Incrementally connect opposite tree toward node\n        def try_connect(tree, kdtree, node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, kdtree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_redundant_nodes(tree):\n            root = tree[0] if tree else None\n            if root is None:\n                return\n            queue = deque([root])\n            visited = set()\n            while queue:\n                cur = queue.popleft()\n                visited.add(cur)\n                for c in cur.children:\n                    if c not in visited:\n                        queue.append(c)\n            to_remove = [node for node in tree if node not in visited]\n            for node in to_remove:\n                try:\n                    tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                except ValueError:\n                    pass\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        c_best = float('inf')\n        c_min = dist(start_position, goal_position)\n\n        for itr in range(self.max_iter):\n            # Dynamic goal bias\n            goal_bias = ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                         itr / self.max_iter + self.goal_sample_rate_start)\n            if random.random() < goal_bias:\n                # Sample start or goal point to encourage direct connection\n                rand_point = goal_position if random.random() < 0.75 else start_position\n            else:\n                # Informed sample inside the ellipsoidal heuristic region when path exists\n                rand_point = informed_sample(c_best, c_min, start_position, goal_position)\n\n            # Prevent sampling outside bounds (redundant because clamped inside informed_sample)\n            rand_point = tuple(max(0.0, min(rand_point[d], bounds[d])) for d in range(len(bounds)))\n\n            # Balance tree growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Found a connection between two trees\n                success_state = True\n\n                # Combine paths from start and goal trees (avoid duplicate connection node)\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Update best cost and path\n                curr_cost = sum(dist(merged_path[i], merged_path[i+1]) for i in range(len(merged_path)-1))\n                if curr_cost < c_best:\n                    c_best = curr_cost\n                    extracted_path = merged_path\n\n                # Try smoothing path immediately for better solution\n                extracted_path = smooth_path(extracted_path, max_trials=self.shortcut_trials)\n\n                # Prune disconnected nodes after success (optional but improves efficiency)\n                prune_redundant_nodes(tree_start)\n                prune_redundant_nodes(tree_goal)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.80661,
    "time_improvement": -42.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.014142775535583496,
            "num_nodes_avg": 95.7,
            "path_length_avg": 176.40923101432753,
            "success_improvement": 0.0,
            "time_improvement": -49.96271099886489,
            "length_improvement": 11.832361895798496,
            "objective_score": -12.622340920499768
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02535741329193115,
            "num_nodes_avg": 266.6,
            "path_length_avg": 240.9890984054285,
            "success_improvement": 0.0,
            "time_improvement": -72.11130943615451,
            "length_improvement": 20.031664125026975,
            "objective_score": -17.62706000584096
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029992318153381346,
            "num_nodes_avg": 270.5,
            "path_length_avg": 123.13470230361244,
            "success_improvement": 0.0,
            "time_improvement": -3.493357092966143,
            "length_improvement": 24.387875026315196,
            "objective_score": 3.829567877373197
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner leverages bidirectional RRT* with balanced tree growth and adaptive dynamic radius rewiring enhanced by heuristic-informed sampling biased towards both start and goal. It alternates tree expansions prioritizing the smaller tree to maintain balanced search, integrates aggressive yet safe shortcut smoothing for refined path quality, and employs periodic pruning of dead-end and suboptimal nodes to control complexity, thereby improving planning efficiency, robustness, success rate, and path smoothness while minimizing computational overhead.",
    "planning_mechanism": "The planner grows two trees from start and goal positions using heuristic-biased sampling and steers new nodes with step size constraints. It dynamically adjusts the rewiring radius as the trees grow, rewiring locally to minimize path cost. After each successful extension, it attempts to connect the opposite tree. Collision checks ensure all new nodes and edges are obstacle-free. Periodic pruning removes dead ends and weak branches. When connection is found, the path is extracted and iteratively shortcut-smoothed while validated for collision freedom, producing a shorter, smoother final path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=4.0, prune_interval: int=150, prune_threshold: int=120,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_prob = 0.75\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal or start randomly for better exploration/exploitation\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Remove dead ends or isolated invalid nodes\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.31752,
    "time_improvement": -1.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008799076080322266,
            "num_nodes_avg": 76.9,
            "path_length_avg": 164.42238391649204,
            "success_improvement": 0.0,
            "time_improvement": 6.699127058163261,
            "length_improvement": 17.82327286375415,
            "objective_score": 5.574392690199808
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02296609878540039,
            "num_nodes_avg": 197.8,
            "path_length_avg": 246.91293228380363,
            "success_improvement": 0.0,
            "time_improvement": -55.880463400938254,
            "length_improvement": 18.065935631962596,
            "objective_score": -13.150951893888957
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01598212718963623,
            "num_nodes_avg": 131.0,
            "path_length_avg": 129.6794197925504,
            "success_improvement": 0.0,
            "time_improvement": 44.85107860341405,
            "length_improvement": 20.369024227692535,
            "objective_score": 17.52912842656272
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates the strengths of bidirectional RRT* with heuristic-informed adaptive sampling and efficient KDTree-assisted nearest neighbor searches to enhance planning efficiency and path quality. It balances tree growth dynamically, employs adaptive goal bias, and utilizes batch rewiring within a shrinking radius for rapid convergence. Post-connection, it conducts an intensive shortcut smoothing and prunes unnecessary nodes to optimize path smoothness and robustness while minimizing search time and path length in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two search trees at the start and goal positions, alternately extending the smaller tree toward adaptively sampled points with collision-aware fixed step steering. It leverages KDTree structures for efficient neighbor queries during rewiring. The goal bias adapts over iterations to balance exploration and convergence. After successful connection of trees, the path is reconstructed, smoothed by shortcutting, and redundant nodes are pruned for efficiency and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate_start=0.12, goal_sample_rate_end=0.4,\n                 radius_constant: float = 28.0, radius_min: float = 2.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import deque\n        try:\n            from scipy.spatial import cKDTree as KDTree\n        except ImportError:\n            KDTree = None  # fallback if scipy not available\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def clamp_point(p):\n            return tuple(\n                max(0, min(bounds[d], p[d])) for d in range(dim)\n            )\n\n        def adaptive_goal_bias(iteration):\n            return ((self.goal_sample_rate_end - self.goal_sample_rate_start) *\n                    (iteration / self.max_iter) + self.goal_sample_rate_start)\n\n        def sample_free(iteration):\n            bias = adaptive_goal_bias(iteration)\n            r = random.random()\n            if r < bias:\n                # 85% goal, 15% start bias\n                return goal_position if random.random() < 0.85 else start_position\n            for _ in range(50):\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_position\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d_] + (to_pos[d_] - from_pos[d_]) * ratio for d_ in range(dim))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def build_kdtree(tree):\n            if KDTree is None or not tree:\n                return None\n            points = [node.position for node in tree]\n            return KDTree(points)\n\n        def nearest(tree, tree_kd, point):\n            if tree_kd is not None:\n                dist_, idx = tree_kd.query(point)\n                return tree[idx]\n            else:\n                return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, tree_kd, point, radius):\n            if tree_kd is not None:\n                idxs = tree_kd.query_ball_point(point, radius)\n                return [tree[i] for i in idxs]\n            else:\n                return [node for node in tree if dist(node.position, point) <= radius]\n\n        def is_collision_free_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return True\n\n        def is_collision_free_edge(p1, p2):\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return True\n            return False\n\n        def try_extend(tree, tree_kd, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, tree_kd, point)\n            new_pos = steer(nearest_node.position, point)\n            new_pos = clamp_point(new_pos)\n\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, tree_kd, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                cost_candidate = node.cost + dist(node.position, new_pos)\n                if cost_candidate + 1e-9 < min_cost and is_collision_free_edge(node.position, new_pos):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Batch rewire neighbors if cost is improved via new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost + 1e-9 < neighbor.cost and is_collision_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, new_cost)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, tree_kd, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, tree_kd, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                new_pos = clamp_point(new_pos)\n                if not is_collision_free_node(new_pos):\n                    return None\n                if not is_collision_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (is_collision_free_node(node.position)\n                            and is_collision_free_edge(new_pos, node.position)):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path, max_trials=150):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if is_collision_free_edge(p_i, p_j):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        def prune_orphans(tree):\n            if not tree:\n                return\n            root = tree[0]\n            queue = deque([root])\n            visited = set([root])\n            while queue:\n                node = queue.popleft()\n                for c in node.children:\n                    if c not in visited:\n                        visited.add(c)\n                        queue.append(c)\n            to_remove = [n for n in tree if n not in visited]\n            for n in to_remove:\n                try:\n                    tree.remove(n)\n                    if n in nodes:\n                        nodes.remove(n)\n                except ValueError:\n                    pass\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            kdtree_start = build_kdtree(tree_start)\n            kdtree_goal = build_kdtree(tree_goal)\n\n            new_node_start = try_extend(tree_start, kdtree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, kdtree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                extracted_path = shortcut_path(merged_path, max_trials=200)\n\n                prune_orphans(tree_start)\n                prune_orphans(tree_goal)\n\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 12.70171,
    "time_improvement": -45.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.017452144622802736,
            "num_nodes_avg": 110.9,
            "path_length_avg": 164.49868955085455,
            "success_improvement": -9.999999999999998,
            "time_improvement": -85.05355711790152,
            "length_improvement": 17.785136041111127,
            "objective_score": -26.95903992714823
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02953360080718994,
            "num_nodes_avg": 293.2,
            "path_length_avg": 244.24755510363966,
            "success_improvement": 0.0,
            "time_improvement": -100.45683085930482,
            "length_improvement": 18.950397954064215,
            "objective_score": -26.346969666978598
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.014031171798706055,
            "num_nodes_avg": 154.9,
            "path_length_avg": 124.36939740105485,
            "success_improvement": -9.999999999999998,
            "time_improvement": 51.583166530509494,
            "length_improvement": 23.629697857201492,
            "objective_score": 15.200889530593148
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an optimized bidirectional RRT* algorithm with adaptive goal biasing, KD-tree based nearest neighbor search acceleration, geometric rewiring to locally optimize paths, early termination upon tree connection, and path smoothing via shortcutting. It balances exploration and exploitation by alternating tree growth while maintaining collision safety and map boundary constraints. The approach aims to improve planning efficiency, path quality, robustness, and success rate.",
    "planning_mechanism": "The planner simultaneously grows two trees from start and goal positions with sampling biased towards the goal. It uses KD-tree structures for fast nearest and neighbor queries, extends trees by steering towards sampled points within step size limits, and performs collision checks on nodes and edges. Upon connecting the trees, it reconstructs the path and applies smoothing. Rewiring optimizes local costs, and the exploration alternates between trees to speed convergence and improve path quality.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, neighbor_radius: float = 10.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal directly\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # KD-Tree helper for nearest and near queries (brute-force with caching and incremental insert)\n        class KDTree:\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node: Node):\n                self.nodes.append(node)\n\n            def nearest(self, point: Tuple[float, ...]):\n                best_node = None\n                best_dist = float('inf')\n                for node in self.nodes:\n                    d = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - point[i]\n                        d += diff*diff\n                        if d > best_dist*best_dist:\n                            break\n                    else:\n                        dist = math.sqrt(d)\n                        if dist < best_dist:\n                            best_dist = dist\n                            best_node = node\n                return best_node\n\n            def near(self, point: Tuple[float, ...], radius: float):\n                r_sq = radius * radius\n                neighbors = []\n                for node in self.nodes:\n                    d = 0.0\n                    for i in range(dim):\n                        diff = node.position[i] - point[i]\n                        d += diff*diff\n                        if d > r_sq:\n                            break\n                    else:\n                        neighbors.append(node)\n                return neighbors\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0.0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def out_of_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return True\n            return False\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        tree_flag = True  # Alternate which tree to grow\n\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            if tree_flag:\n                new_node = self._extend_tree(tree_start, kd_start, rand_point, obstacles, is_3d, nodes, edges,\n                                            out_of_bounds, steer)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_goal, kd_goal, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 out_of_bounds, steer)\n                if connect_node is not None:\n                    success_state = True\n                    connection_node_start = new_node\n                    connection_node_goal = connect_node\n                    break\n            else:\n                new_node = self._extend_tree(tree_goal, kd_goal, rand_point, obstacles, is_3d, nodes, edges,\n                                            out_of_bounds, steer)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n                connect_node = self._connect_tree(tree_start, kd_start, new_node.position, obstacles, is_3d, nodes, edges,\n                                                 out_of_bounds, steer)\n                if connect_node is not None:\n                    success_state = True\n                    # swap roles\n                    connection_node_start = connect_node\n                    connection_node_goal = new_node\n                    break\n\n            tree_flag = not tree_flag\n\n        extracted_path: List[Tuple[float, ...]] = []\n\n        if success_state:\n            # Construct path from start root to connection\n            path_start = connection_node_start.path_from_root()\n            # Construct path from goal root to connection\n            path_goal = connection_node_goal.path_from_root()\n            path_goal.reverse()\n            extracted_path = path_start + path_goal\n\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _extend_tree(self, tree: List[Node], kd_tree, rand_point, obstacles, is_3d, nodes, edges,\n                     out_of_bounds_fn, steer_fn) -> Node:\n        nearest_node = kd_tree.nearest(rand_point)\n        if nearest_node is None:\n            return None\n\n        new_pos = steer_fn(nearest_node.position, rand_point)\n        if out_of_bounds_fn(new_pos):\n            return None\n\n        # Check collision for node and edge\n        if self._is_in_obstacle(new_pos, obstacles, is_3d):\n            return None\n        if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n            return None\n\n        # Find neighbors for rewiring\n        near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n        # Choose best parent with minimal cost\n        min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n        best_parent = nearest_node\n        for near_node in near_nodes:\n            edge_cost = math.dist(near_node.position, new_pos)\n            candidate_cost = near_node.cost + edge_cost\n            if candidate_cost < min_cost:\n                if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = candidate_cost\n                    best_parent = near_node\n\n        new_node = Node(new_pos)\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n        kd_tree.insert(new_node)\n\n        # Rewiring neighbors to improve their cost via new_node\n        for near_node in near_nodes:\n            if near_node == best_parent:\n                continue\n            potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n            if potential_cost < near_node.cost:\n                if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Rewire\n                    if near_node.parent is not None:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        near_node.parent.children.remove(near_node)\n\n                    near_node.parent = new_node\n                    near_node.cost = potential_cost\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        return new_node\n\n    def _connect_tree(self, tree: List[Node], kd_tree, target_pos, obstacles, is_3d, nodes, edges,\n                      out_of_bounds_fn, steer_fn) -> Node:\n        nearest_node = kd_tree.nearest(target_pos)\n        if nearest_node is None:\n            return None\n\n        current_node = nearest_node\n\n        while True:\n            new_pos = steer_fn(current_node.position, target_pos)\n            if out_of_bounds_fn(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n\n            min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n            best_parent = current_node\n            for near_node in near_nodes:\n                cost_through_near = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_through_near < min_cost:\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_near\n                        best_parent = near_node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.insert(new_node)\n\n            # Rewiring neighbors\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent is not None:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                            near_node.parent.children.remove(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n                        edges.append((new_node, near_node))\n\n            if math.dist(new_node.position, target_pos) <= self.step_size * 0.5:\n                return new_node\n\n            current_node = new_node\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        i = 0\n        while i < len(path) - 1:\n            j = len(path) - 1\n            while j > i + 1:\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    break\n                j -= 1\n            smoothed.append(path[j])\n            i = j\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 24.12631,
    "time_improvement": -89.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.026598191261291503,
            "num_nodes_avg": 118.0,
            "path_length_avg": 164.4739190003182,
            "success_improvement": -9.999999999999998,
            "time_improvement": -182.03352723613924,
            "length_improvement": 17.797516124187126,
            "objective_score": -56.05055494600434
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.033007478713989256,
            "num_nodes_avg": 252.4,
            "path_length_avg": 237.04183176302814,
            "success_improvement": 0.0,
            "time_improvement": -124.03548489933698,
            "length_improvement": 21.34150073894925,
            "objective_score": -32.94234532201124
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.017908143997192382,
            "num_nodes_avg": 174.1,
            "path_length_avg": 120.89637627734098,
            "success_improvement": 0.0,
            "time_improvement": 38.205045302083825,
            "length_improvement": 25.762342045474295,
            "objective_score": 16.613981999720007
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This is a simplified yet robust bidirectional RRT* planner that grows two trees simultaneously from start and goal positions. It employs adaptive goal bias sampling to efficiently guide exploration and uses a steering function capped by a fixed step size to create new nodes. Collision checks ensure nodes and edges are feasible. The algorithm rewires locally within a dynamically computed neighborhood radius that shrinks as the trees grow, improving path cost and smoothness incrementally. By always extending the smaller tree first, it balances exploration, and upon connection of the two trees, it reconstructs an optimal and collision-free path by merging both paths. This approach enhances planning efficiency, path quality, and success rate while maintaining simplicity for generalization.",
    "planning_mechanism": "The planner iteratively samples free points with goal bias and extends the smaller of the two trees toward these points using a steering function respecting step size. It performs collision checks before adding nodes and edges. Local rewiring is done within a radius that decreases logarithmically with the number of nodes, improving path cost and smoothness. When the two trees connect via collision-free edges, the planner reconstructs the combined optimal path and terminates.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                return goal_pos if random.random() < 0.5 else start_pos\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def radius_by_nodes(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_pt = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.74412,
    "time_improvement": 7.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007792139053344726,
            "num_nodes_avg": 83.7,
            "path_length_avg": 168.4674621509865,
            "success_improvement": 0.0,
            "time_improvement": 17.376168915383047,
            "length_improvement": 15.801581641410323,
            "objective_score": 8.373167002896977
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01925923824310303,
            "num_nodes_avg": 273.7,
            "path_length_avg": 286.1481153491476,
            "success_improvement": 0.0,
            "time_improvement": -30.72045932295822,
            "length_improvement": 5.046374505562686,
            "objective_score": -8.206862895774929
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01880514621734619,
            "num_nodes_avg": 223.8,
            "path_length_avg": 134.08189579520482,
            "success_improvement": 0.0,
            "time_improvement": 35.10979369102769,
            "length_improvement": 17.665638752446302,
            "objective_score": 14.066065857797566
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the best heuristics of bidirectional RRT* with adaptive goal biasing, dynamic neighborhood radius tuning, and balanced tree growth. It incorporates strict collision checks, incremental rewiring for local path optimality, and a robust path shortcut smoothing step. By always extending the smaller tree, adjusting goal bias progressively, and pruning via rewiring, it achieves faster convergence, shorter and smoother paths, and improved robustness in both 2D and 3D environments.",
    "planning_mechanism": "The planner initializes two trees at start and goal and iteratively samples free points with adaptive goal biasing increasing over iterations. It always extends the smaller tree towards the sampled point via incremental steering and performs local rewiring within an adaptively computed radius. After adding each new node, it attempts to connect the opposite tree with incremental steps. Upon connection, it merges the two paths and applies shortcut smoothing to enhance path quality. The process terminates once a collision-free path is found or max iterations are reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4500,\n                 step_size: float = 4.5,\n                 goal_sample_rate_start: float = 0.12,\n                 goal_sample_rate_end: float = 0.38,\n                 radius_constant: float = 28.0,\n                 radius_min: float = 4.0,\n                 smoothing_trials: int = 180):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate_start = goal_sample_rate_start\n        self.goal_sample_rate_end = goal_sample_rate_end\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            goal_bias = (self.goal_sample_rate_start +\n                         (self.goal_sample_rate_end - self.goal_sample_rate_start) * iteration / self.max_iter)\n            if random.random() < goal_bias:\n                # 85% towards goal, 15% towards start helps bidirectional convergence\n                return goal_position if random.random() < 0.85 else start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, val)\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if shorter path found via new_node\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and \\\n                       not self._is_in_obstacle(node.position, obstacles, is_3d) and in_bounds(node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path, max_trials=None):\n            if max_trials is None:\n                max_trials = self.smoothing_trials\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) -1)\n                if j >= len(path):\n                    continue\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Balance tree growth by extending smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n                smoothed = smooth_path(merged_path)\n                extracted_path = smoothed\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 33.22961,
    "time_improvement": -119.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.02040078639984131,
            "num_nodes_avg": 90.0,
            "path_length_avg": 161.10437709562194,
            "success_improvement": -9.999999999999998,
            "time_improvement": -116.31943654423233,
            "length_improvement": 19.481580781813083,
            "objective_score": -35.99951480690708
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.038975310325622556,
            "num_nodes_avg": 339.1,
            "path_length_avg": 245.40823717758752,
            "success_improvement": 0.0,
            "time_improvement": -164.54163989817994,
            "length_improvement": 18.565244374306133,
            "objective_score": -45.64944309459275
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.050804519653320314,
            "num_nodes_avg": 332.9,
            "path_length_avg": 125.77833264821045,
            "success_improvement": 0.0,
            "time_improvement": -75.30923310190728,
            "length_improvement": 22.764526739760676,
            "objective_score": -18.039864582620048
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner is a bidirectional RRT* variant with several key optimizations to reduce planning time and improve path quality. It incorporates adaptive goal biasing with alternating direction sampling to avoid exploration stagnation, a dynamically shrinking neighbor radius for faster local rewiring, heuristic-guided sampling favoring progress towards goals, lazy collision checking to minimize expensive collision tests, and spatial pruning to limit unnecessary expansions. The planner alternates tree growth direction for balanced exploration, efficiently rewires the tree to optimize cost, and performs path smoothing through shortcutting to produce shorter, smoother paths. These enhancements collectively yield increased success rates, reduced planning duration, and higher quality paths.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by alternately sampling points with adaptive goal biasing and steering towards them with a fixed step size. It dynamically adjusts the neighbor radius to localize rewiring, rewires nodes for lower cost efficiently, and attempts connections between trees after each extension. Lazy collision checking avoids redundant checks by first verifying nodes and edges before connecting. Spatial pruning prevents expansion of nodes unlikely to improve solutions. Upon connection, the found path is merged and smoothed by shortcutting collision-free edges, resulting in a fast, robust, and high-quality path planning solution.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_base = 0.15\n        self.goal_sample_cap = 0.3\n        self.min_neighbor_radius = 7.0\n        self.max_neighbor_radius = 25.0\n        self.smoothing_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing increasing with iterations, capped\n            goal_bias = min(self.goal_sample_base + iteration / self.max_iter * 0.15, self.goal_sample_cap)\n            # Alternate bias direction to reduce symmetry issues\n            if random.random() < goal_bias:\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                # Heuristic-driven sampling: sample towards goal half the time,\n                # otherwise uniform free space\n                if random.random() < 0.5:\n                    # Sample in a ball towards goal (biased)\n                    center = goal_position\n                    dim = len(bounds)\n                    radius = max(bounds[d] * 0.25 for d in range(dim))\n                    for _ in range(10):\n                        sample = tuple(\n                            random.uniform(max(0, center[d]-radius), min(bounds[d], center[d]+radius))\n                            for d in range(dim)\n                        )\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n                    # fallback uniform random if ball sampling fails\n                # Uniform free sampling\n                for _ in range(20):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback\n                return start_position if random.random() < 0.5 else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            # Clamp slightly out of bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Dynamically shrink radius to focus local rewiring\n            return max(\n                self.min_neighbor_radius,\n                self.max_neighbor_radius * (1 - (iteration / self.max_iter)**0.9)\n            )\n\n        def near_nodes(tree, pos, radius):\n            # Use spatial pruning via distance squared comparison for speed, then linear search\n            r2 = radius * radius\n            result = []\n            for node in tree:\n                d2 = sum((node.position[d] - pos[d])**2 for d in range(len(pos)))\n                if d2 <= r2:\n                    result.append(node)\n            return result\n\n        def nearest(tree, point):\n            best = None\n            best_dist = float('inf')\n            for node in tree:\n                d = math.dist(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best = node\n            return best\n\n        # Lazy collision checks cache: node position and edge validity\n        node_collision_cache = {}\n        edge_collision_cache = {}\n\n        def check_node_collision(pos):\n            key = (round(pos[0],4), round(pos[1],4)) if not is_3d else (round(pos[0],4), round(pos[1],4), round(pos[2],4))\n            if key in node_collision_cache:\n                return node_collision_cache[key]\n            val = self._is_in_obstacle(pos, obstacles, is_3d)\n            node_collision_cache[key] = val\n            return val\n\n        def check_edge_collision(from_pos, to_pos):\n            key = (tuple(round(x,4) for x in from_pos), tuple(round(x,4) for x in to_pos))\n            key_rev = (key[1], key[0])  # since undirected\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if key_rev in edge_collision_cache:\n                return edge_collision_cache[key_rev]\n            val = self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=1.0)\n            edge_collision_cache[key] = val\n            return val\n\n        # Spatial pruning heuristic: prune expansion if cost exceeds best known or much larger than heuristic distance to target\n        def should_prune(node, target_pos, max_cost):\n            # Heuristic: Euclidean distance from node to goal + current cost must be less than max_cost * 1.25 to allow some slack\n            h = math.dist(node.position, target_pos)\n            return (node.cost + h) > (max_cost * 1.25)\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        all_nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        best_cost = float('inf')\n\n        for it in range(self.max_iter):\n            q_rand = sample_free(it)\n\n            # Alternate tree growth direction for balanced exploration\n            if it % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n                root_a, root_b = start_root, goal_root\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n                root_a, root_b = goal_root, start_root\n\n            r = neighbor_radius(it)\n\n            nearest_a = nearest(tree_a, q_rand)\n            if should_prune(nearest_a, goal_position if tree_a is tree_start else start_position, best_cost):\n                continue\n\n            new_pos = steer(nearest_a.position, q_rand)\n\n            # Lazy collision check for node and edge\n            if check_node_collision(new_pos):\n                continue\n            if check_edge_collision(nearest_a.position, new_pos):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not check_edge_collision(node.position, new_pos):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new + 1e-9 < node.cost:  # add epsilon to avoid floating issues\n                    if not check_edge_collision(new_node.position, node.position):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Attempt connecting tree_b to new_node\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_node_b = nearest_b\n\n            extend_success = False\n            extend_iter_limit = max(3, int(self.step_size))\n            for _ in range(extend_iter_limit):\n                pos_b_new = steer(curr_node_b.position, new_node.position)\n                if check_node_collision(pos_b_new) or check_edge_collision(curr_node_b.position, pos_b_new):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                all_nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire neighbors around new_node_b in tree_b\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node_b in near_b:\n                    if node_b == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node_b.position)\n                    if cost_through_new_b + 1e-9 < node_b.cost:\n                        if not check_edge_collision(new_node_b.position, node_b.position):\n                            try:\n                                edges.remove((node_b.parent, node_b))\n                            except ValueError:\n                                pass\n                            node_b.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node_b))\n\n                # Check if connection established within step_size\n                dist_connect = math.dist(new_node_b.position, new_node.position)\n                if dist_connect <= self.step_size and not check_edge_collision(new_node_b.position, new_node.position):\n                    connected = True\n                    extend_success = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected:\n                # Extract path from roots and merge without duplicating connection node\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update best_cost for potential further pruning\n                total_cost = connection_node_start.cost + connection_node_goal.cost + math.dist(connection_node_start.position, connection_node_goal.position)\n                best_cost = min(best_cost, total_cost)\n\n                # Path smoothing by iterative shortcutting\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=all_nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=100):\n        import random\n        import math\n\n        if len(path) < 3:\n            return path[:]\n\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut path by removing intermediate nodes\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 144.84568,
    "time_improvement": -483.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.049432682991027835,
            "num_nodes_avg": 189.5,
            "path_length_avg": 153.45427942338446,
            "success_improvement": -9.999999999999998,
            "time_improvement": -424.158722213374,
            "length_improvement": 23.305026069508077,
            "objective_score": -127.58661145011057
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.15793004035949706,
            "num_nodes_avg": 671.6,
            "path_length_avg": 225.66624058956205,
            "success_improvement": 0.0,
            "time_improvement": -971.9368625121973,
            "length_improvement": 25.116306743682713,
            "objective_score": -286.55779740492267
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.044450783729553224,
            "num_nodes_avg": 317.2,
            "path_length_avg": 117.0670286324166,
            "success_improvement": -19.999999999999996,
            "time_improvement": -53.38463702800561,
            "length_improvement": 28.11379218324113,
            "objective_score": -20.392632671753454
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This enhanced bidirectional RRT* planner employs an advanced sampling technique integrating adaptive bidirectional goal biasing and a dynamic connection radius that shrinks logarithmically with node count to efficiently balance exploration and exploitation. It expands the smaller tree first to maintain balanced growth and applies incremental rewiring on both trees at each extension to optimize local path costs continuously. The planner adds a heuristic-informed sampling distribution that samples around the line connecting start and goal to accelerate convergence and path optimality. It also prunes redundant nodes periodically to improve performance and path quality. Rigorous collision checks on nodes and edges ensure robust obstacle avoidance in both 2D and 3D environments. The overall improvement focuses on reducing path length, smoothing, and search time while enhancing success rate and robustness.",
    "planning_mechanism": "The planning mechanism alternates tree growth from start and goal, sampling points with a hybrid strategy of uniform random sampling, weighted goal-start biasing, and heuristic sampling along the corridor defined by start and goal. The smaller tree is extended first towards each sampled point, creating new nodes after passing collision checks. Upon node addition, neighbors within a dynamically reduced radius are rewired to ensure minimal cost connections. Immediately after extension in one tree, the planner attempts connection and rewiring with the other tree by extending it toward the new node, thereby bridging both trees sooner. Periodic pruning of inactive or suboptimal nodes maintains efficiency. Once a connecting edge between the two trees is found, a combined optimal path is extracted, guaranteeing a smooth and short path from start to goal.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks, pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        # Constants for dynamic radius (RRT*)\n        self.radius_constant = 30.0\n        self.radius_min = 5.0\n\n        # Sampling probabilities\n        self.goal_sample_rate = 0.15  # bias towards goal/start during sampling\n        self.heuristic_sample_rate = 0.2  # bias toward line corridor between start and goal\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Efficient nearest search could use spatial indexing (not implemented here)\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(dim)) <= radius_sq)]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            # Hybrid sampling:\n            # 1) Adaptive goal/start biasing with weighted probabilities\n            # 2) Heuristic corridor sampling around a corridor line between start and goal\n            # 3) Uniform random otherwise\n\n            p = random.random()\n            # Bias toward goal or start:\n            if p < self.goal_sample_rate:\n                if random.random() < 0.7:\n                    candidate = goal_position\n                else:\n                    candidate = start_position\n                if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n\n            # Heuristic corridor sampling - sample around a narrow corridor line from start to goal\n            if p < self.goal_sample_rate + self.heuristic_sample_rate:\n                # Sample a random point along the line between start and goal with some Gaussian noise perpendicular to it\n                vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n                length = distance(start_position, goal_position)\n                if length == 0:\n                    candidate = start_position  # Start and goal same\n                else:\n                    t = random.uniform(0, 1)\n                    base_point = tuple(start_position[d] + t * vec[d] for d in range(dim))\n\n                    # Generate noise perpendicular to vec\n                    # For 2D, create a perpendicular vector; for 3D approximate by random vector orthogonalized\n                    noise_scale = self.step_size * 1.5  # Noise radius\n\n                    if dim == 2:\n                        perpendicular = (-vec[1], vec[0])\n                        norm = math.hypot(*perpendicular)\n                        if norm > 1e-8:\n                            perp_unit = (perpendicular[0] / norm, perpendicular[1] / norm)\n                            offset_magnitude = random.gauss(0, noise_scale / 2)\n                            candidate = (base_point[0] + perp_unit[0] * offset_magnitude,\n                                         base_point[1] + perp_unit[1] * offset_magnitude)\n                        else:\n                            candidate = base_point\n                    else:\n                        import numpy as np\n                        v = np.array(vec)\n                        if np.linalg.norm(v) < 1e-8:\n                            candidate = base_point\n                        else:\n                            v_unit = v / np.linalg.norm(v)\n                            # Random vector\n                            random_vec = np.random.randn(dim)\n                            # Orthogonalize random_vec against v_unit\n                            orth_vec = random_vec - np.dot(random_vec, v_unit) * v_unit\n                            norm_orth = np.linalg.norm(orth_vec)\n                            if norm_orth > 1e-8:\n                                orth_unit = orth_vec / norm_orth\n                                offset = orth_unit * random.gauss(0, noise_scale / 2)\n                                candidate = tuple(base_point[d] + offset[d] for d in range(dim))\n                            else:\n                                candidate = base_point\n\n                    # Check bounds and collision\n                    if in_bounds(candidate) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        return candidate\n\n            # Uniform random sampling\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                    self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            # Choose best parent minimizing cost + edge cost\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors if passing cost can be improved via new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Update parent and edges\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                        self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_through_new)\n                            edges.append((new_node, neighbor))\n\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    # Final connection edge check\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Periodic pruning for efficiency (remove invalid/isolated nodes)\n        def prune_tree(tree):\n            # Identify leaves and remove if cost is significantly larger than root-to-goal estimate\n            # (simple heuristic pruning)\n            prune_threshold_factor = 3.0  # prune if node cost > factor * distance start->goal\n            dist_sg = distance(start_position, goal_position)\n            to_remove = []\n            for node in tree:\n                if not node.children and node != start_root and node != goal_root:\n                    if node.cost > prune_threshold_factor * dist_sg:\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                # Remove associated edges\n                edges[:] = [(p, c) for (p, c) in edges if c != node]\n\n        # Main bidirectional balanced growth loop with enhanced sampling and rewiring\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Grow smaller tree first for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n            # Periodic pruning every 200 iterations to sustain performance\n            if itr > 0 and itr % 200 == 0:\n                prune_tree(tree_start)\n                prune_tree(tree_goal)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.49564,
    "time_improvement": -24.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005855727195739746,
            "num_nodes_avg": 62.2,
            "path_length_avg": 161.04529423881394,
            "success_improvement": 0.0,
            "time_improvement": 37.908883377700924,
            "length_improvement": 19.511109825771033,
            "objective_score": 15.274886978464483
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.029883909225463866,
            "num_nodes_avg": 281.1,
            "path_length_avg": 281.81190466557365,
            "success_improvement": 0.0,
            "time_improvement": -102.83451977739406,
            "length_improvement": 6.4852759109088955,
            "objective_score": -29.55330075103644
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030866360664367674,
            "num_nodes_avg": 254.3,
            "path_length_avg": 140.50480936521626,
            "success_improvement": 0.0,
            "time_improvement": -6.509382504584504,
            "length_improvement": 13.72158289763604,
            "objective_score": 0.7915018281518567
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive informed sampling, dynamic neighbor radius rewiring, balanced tree growth, dead-end pruning, and iterative shortcut smoothing to efficiently search in complex environments. It integrates fast connection attempts like RRT-Connect, while maintaining asymptotic optimality and robustness through rewiring and pruning.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree to balance expansion. Samples are adaptively biased towards start and goal for directed exploration. Each extension uses a dynamic radius depending on tree size to perform rewiring optimizing path cost. Dead-end pruning is periodically applied to remove unnecessary nodes and reduce computational burden. Upon connecting the two trees without collision, the resultant path is shortcut-smoothed iteratively to improve path quality and smoothness. Collision and edge validity checks are enforced rigorously, ensuring robustness and feasibility.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D or 3D\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Choose between goal and start with bias p_bias\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.83895,
    "time_improvement": 9.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009789466857910156,
            "num_nodes_avg": 98.0,
            "path_length_avg": 163.5535741174694,
            "success_improvement": 0.0,
            "time_improvement": -3.8024668886310224,
            "length_improvement": 18.257495650743063,
            "objective_score": 2.5107590635593064
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01988651752471924,
            "num_nodes_avg": 202.9,
            "path_length_avg": 241.16005059975564,
            "success_improvement": 0.0,
            "time_improvement": -34.97806467482155,
            "length_improvement": 19.974936403379097,
            "objective_score": -6.498432121770645
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.009808039665222168,
            "num_nodes_avg": 127.6,
            "path_length_avg": 124.92422072194663,
            "success_improvement": 0.0,
            "time_improvement": 66.15576874505864,
            "length_improvement": 23.28900291505477,
            "objective_score": 24.504531206528544
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner implements an advanced bidirectional RRT* algorithm with hybrid adaptive sampling combining goal bias, heuristic corridor sampling, and uniform random sampling. It dynamically adjusts connection radius logarithmically with node count, grows the smaller tree first to maintain balance, and performs incremental rewiring after each node addition to optimize path costs. Periodic pruning removes costly leaf nodes to boost efficiency. Rigorous collision checking for nodes and edges ensures robust obstacle avoidance. The approach improves convergence speed, path smoothness, and success rate while reducing search time and path length in both 2D and 3D environments.",
    "planning_mechanism": "The planner alternates growth between start and goal trees, sampling points via a weighted blend of goal bias, heuristic corridor around the start-goal line, and uniform random sampling within bounds. It steers from nearest nodes toward samples with fixed step size, adding collision-free nodes and rewiring neighbors within a dynamically shrinking radius. Upon adding a node to one tree, it attempts immediate connection and rewiring with the other tree toward that node. Pruning of expensive leaves occurs periodically. Once trees connect, the planner extracts an optimal, smooth path by merging root-to-node paths from both trees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        self.radius_constant = 30.0\n        self.radius_min = 5.0\n\n        self.goal_sample_rate = 0.15\n        self.heuristic_sample_rate = 0.2\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: list = []\n        nodes: list = []\n        edges: list = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import math\n        import random\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if sum((node.position[d] - pos[d])**2 for d in range(dim)) <= r2]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt(math.log(n_nodes)/n_nodes))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def sample_free():\n            p = random.random()\n            # Goal/start biasing\n            if p < self.goal_sample_rate:\n                candidate = goal_position if random.random() < 0.7 else start_position\n                if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n\n            # Heuristic corridor sampling\n            if p < self.goal_sample_rate + self.heuristic_sample_rate:\n                vec = tuple(goal_position[d] - start_position[d] for d in range(dim))\n                length = distance(start_position, goal_position)\n                if length < 1e-8:\n                    candidate = start_position\n                else:\n                    t = random.uniform(0,1)\n                    base_point = tuple(start_position[d] + t * vec[d] for d in range(dim))\n\n                    noise_scale = self.step_size * 1.5\n\n                    if dim == 2:\n                        perp = (-vec[1], vec[0])\n                        norm = math.hypot(*perp)\n                        if norm > 1e-8:\n                            perp_unit = (perp[0]/norm, perp[1]/norm)\n                            offset_mag = random.gauss(0, noise_scale/2)\n                            candidate = (base_point[0] + perp_unit[0]*offset_mag,\n                                         base_point[1] + perp_unit[1]*offset_mag)\n                        else:\n                            candidate = base_point\n                    else:\n                        import numpy as np\n                        v = np.array(vec)\n                        v_norm = np.linalg.norm(v)\n                        if v_norm < 1e-8:\n                            candidate = base_point\n                        else:\n                            v_unit = v / v_norm\n                            rand_vec = np.random.randn(dim)\n                            orth_vec = rand_vec - np.dot(rand_vec,v_unit)*v_unit\n                            norm_orth = np.linalg.norm(orth_vec)\n                            if norm_orth > 1e-8:\n                                orth_unit = orth_vec / norm_orth\n                                offset = orth_unit * random.gauss(0, noise_scale/2)\n                                candidate = tuple(base_point[d] + offset[d] for d in range(dim))\n                            else:\n                                candidate = base_point\n\n                    if in_bounds(candidate) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        return candidate\n\n            # Uniform random sampling\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not in_bounds(new_pos)) or self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_through_new)\n                            edges.append((new_node, neighbor))\n\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_tree(tree):\n            prune_factor = 3.0\n            dist_sg = distance(start_position, goal_position)\n            to_remove = []\n            for node in tree:\n                if not node.children and node != start_root and node != goal_root:\n                    if node.cost > prune_factor * dist_sg:\n                        to_remove.append(node)\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                tree.remove(node)\n                if node in nodes:\n                    nodes.remove(node)\n                edges[:] = [(p,c) for (p,c) in edges if c != node]\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            if itr > 0 and itr % 200 == 0:\n                prune_tree(tree_start)\n                prune_tree(tree_goal)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x+w and y <= py <= y+h and z <= pz <= z+d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x+w and y <= py <= y+h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*i/steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 14.58851,
    "time_improvement": -58.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010329079627990723,
            "num_nodes_avg": 90.6,
            "path_length_avg": 162.83570472385142,
            "success_improvement": 0.0,
            "time_improvement": -9.524242906873567,
            "length_improvement": 18.616279873873946,
            "objective_score": 0.8659831027127192
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0341623067855835,
            "num_nodes_avg": 296.2,
            "path_length_avg": 285.9585348100092,
            "success_improvement": 0.0,
            "time_improvement": -131.8737832812528,
            "length_improvement": 5.109283742243886,
            "objective_score": -38.54027823592706
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03837146759033203,
            "num_nodes_avg": 284.4,
            "path_length_avg": 133.28619401084208,
            "success_improvement": 0.0,
            "time_improvement": -32.40697091830817,
            "length_improvement": 18.154247581926974,
            "objective_score": -6.0912417591070565
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned and optimized bidirectional RRT* variant featuring balanced tree growth with dynamic, decaying rewiring radius and heuristic adaptive sampling. It integrates mutual rewiring and connection attempts between the two growing trees, combined with periodic pruning of dead-end nodes and aggressive shortcut smoothing for path quality. Collision checks ensure all nodes and edges are obstacle-free, while adaptive sampling shifts focus from start/goal bias towards promising middle regions as iterations progress, enhancing efficiency, robustness, success rate, and resulting in smoother, shorter paths in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal positions alternately extending the smaller tree to keep balanced growth. Sampling is adaptively biased, progressively favoring exploration near the midpoint between trees. Nodes are added if collision-free with rewiring performed locally using a radius that decays with iterations and node count. After each extension, it attempts to connect and mutually rewire the opposite tree. Dead-ends are pruned periodically to maintain efficiency. Upon finding a connection, the raw path is shortcut and smoothed aggressively with collision validation, outputting the shortest highest-quality path found within the iteration budget.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self,\n                 max_iter: int = 5000,\n                 step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 3.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 20 and len(tree_goal) > 20:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 4 * (1 - itr / self.max_iter)\n                        for _ in range(7):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            # Fallbacks\n            if is_free_node(start_position):\n                return start_position\n            if is_free_node(goal_position):\n                return goal_position\n            return tuple(bounds[d]/2 for d in range(dim))\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.00464,
    "time_improvement": -21.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011858797073364258,
            "num_nodes_avg": 75.7,
            "path_length_avg": 160.299997433265,
            "success_improvement": 0.0,
            "time_improvement": -25.7445791904621,
            "length_improvement": 19.883602005766534,
            "objective_score": -3.746653355985323
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021180176734924318,
            "num_nodes_avg": 184.2,
            "path_length_avg": 235.78565562855914,
            "success_improvement": 0.0,
            "time_improvement": -43.75866773039373,
            "length_improvement": 21.758342478696097,
            "objective_score": -8.775931823378901
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.027430248260498048,
            "num_nodes_avg": 172.0,
            "path_length_avg": 122.9161912557353,
            "success_improvement": 0.0,
            "time_improvement": 5.347480516360658,
            "length_improvement": 24.522053973038755,
            "objective_score": 6.5086549495159485
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with adaptive informed sampling biased toward start and goal. It extends the smaller of two trees each iteration, dynamically adjusts the rewiring radius to optimize path cost, and prunes dead-ends periodically to maintain efficiency. Upon connecting the trees, a shortcut path smoothing is applied to improve path quality while rigorously checking collisions and edge feasibility. The approach balances exploration and exploitation, enhancing planning speed, path smoothness, and success rate without excessive complexity.",
    "planning_mechanism": "The planner grows two trees from start and goal, sampling points biased towards these points. Each iteration extends the smaller tree toward a sample with steering and rewiring via nearby nodes in a dynamic radius. It attempts to connect the trees after extensions. Dead-end pruning reduces complexity, and iterative shortcut smoothing refines the final path. All nodes and edges undergo collision and obstacle intersection checks to ensure safety and validity.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15,\n                 radius_constant: float=25.0,\n                 radius_min: float=5.0,\n                 prune_interval: int=200,\n                 prune_threshold: int=100,\n                 smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            bias_prob = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            if distance <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            return max(self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1)), self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path: List[Tuple[float, ...]]):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.92955,
    "time_improvement": -16.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00610663890838623,
            "num_nodes_avg": 71.6,
            "path_length_avg": 164.5770735955512,
            "success_improvement": 0.0,
            "time_improvement": 35.24834474755979,
            "length_improvement": 17.74596044895973,
            "objective_score": 14.123695514059882
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.020606112480163575,
            "num_nodes_avg": 232.9,
            "path_length_avg": 247.8890045532666,
            "success_improvement": 0.0,
            "time_improvement": -39.862254896407975,
            "length_improvement": 17.74204183096025,
            "objective_score": -8.410268102730342
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04159536361694336,
            "num_nodes_avg": 163.0,
            "path_length_avg": 125.74184748902557,
            "success_improvement": 0.0,
            "time_improvement": -43.53154691828184,
            "length_improvement": 22.78693082540316,
            "objective_score": -8.50207791040392
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner integrates the adaptive bidirectional RRT* framework with dynamic neighbor radius rewiring, heuristic sampling biasing towards both start and goal, incremental rewiring optimization, lazy collision checks, and enhanced path shortcut smoothing. It alternates tree growth from start and goal with adaptive sampling bias balancing exploration and focused search, dynamically controls neighbor radius to balance global exploration and local path refinement, and incrementally rewires nodes to minimize path cost while ensuring collision-free connections. The planner employs efficient incremental connection attempts between trees and performs iterative shortcut-based smoothing after path extraction to minimize path length and improve smoothness, resulting in improved planning efficiency, higher success rates, shorter and smoother paths, and reduced computational overhead.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions by sampling points with adaptive goal bias, steering nodes towards these samples within step size limits, and adding collision-free nodes. It dynamically adjusts the neighbor radius for rewiring to locally optimize connections and path costs. Each newly added node rewires its neighborhood if cheaper paths exist without collisions. The trees attempt incremental connection via steering; upon successful connection, the algorithm extracts and merges the paths from both trees and applies iterative shortcut smoothing to the combined path. This process results in efficient and robust path planning with minimized planning time and improved path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=8.0,\n                 max_neighbor_radius: float=25.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def adaptive_goal_bias(iteration, toggle_start):\n            bias = min(self.goal_sample_rate + 0.25 * (iteration / self.max_iter), 0.4)\n            if random.random() < bias:\n                return start_position if toggle_start else goal_position\n            attempts = 100\n            for _ in range(attempts):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            return start_position if toggle_start else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            if in_bounds(new_p):\n                return new_p\n            return tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def neighbor_radius(iteration):\n            factor = (1.0 - (iteration / self.max_iter) ** 0.95)\n            radius = max(self.min_neighbor_radius, self.max_neighbor_radius * factor)\n            return radius\n\n        def near_nodes(tree, pos, radius):\n            # Linear search - could be optimized with spatial structures if needed\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        final_path = []\n        toggle_start_tree = True  # alternate which tree grows sampling bias\n\n        for it in range(self.max_iter):\n            q_rand = adaptive_goal_bias(it, toggle_start_tree)\n\n            tree_a = tree_start if toggle_start_tree else tree_goal\n            tree_b = tree_goal if toggle_start_tree else tree_start\n\n            radius = neighbor_radius(it)\n\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                toggle_start_tree = not toggle_start_tree\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                toggle_start_tree = not toggle_start_tree\n                continue\n\n            near = near_nodes(tree_a, new_pos, radius)\n\n            # Find best parent minimizing cost with collision check\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_candidate = node.cost + math.dist(node.position, new_pos)\n                if cost_candidate < min_cost and \\\n                   not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = cost_candidate\n                    best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths via new_node found\n            for node in near:\n                if node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost and \\\n                   not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((node.parent, node))\n                    except ValueError:\n                        pass\n                    node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, node))\n\n            # Attempt incremental connection from tree_b to new_node\n            curr_node_b = nearest(tree_b, new_node.position)\n            connected_node_b = None\n            while True:\n                new_pos_b = steer(curr_node_b.position, new_node.position)\n\n                if self._is_in_obstacle(new_pos_b, obstacles, is_3d) or \\\n                   self._is_edge_in_obstacle(curr_node_b.position, new_pos_b, obstacles, is_3d):\n                    break\n\n                cost_b = curr_node_b.cost + math.dist(curr_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b)\n                new_node_b.cost = cost_b\n                new_node_b.parent = curr_node_b\n                curr_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_node_b, new_node_b))\n\n                # Rewire around new_node_b\n                near_b = near_nodes(tree_b, new_pos_b, radius)\n                for node in near_b:\n                    if node == curr_node_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost and \\\n                       not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node_b, cost_through_new_b)\n                        edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size * 0.5:\n                    connected_node_b = new_node_b\n                    break\n\n                curr_node_b = new_node_b\n\n            if connected_node_b:\n                success_state = True\n                connection_start = new_node if toggle_start_tree else connected_node_b\n                connection_goal = connected_node_b if toggle_start_tree else new_node\n\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n\n                merged_path = path_start + path_goal[::-1][1:]  # avoid duplicate connection node\n\n                # Improved smoothing: iterative shortcutting with early stopping on improvements\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, max_trials=200)\n\n                final_path = merged_path\n                break\n\n            toggle_start_tree = not toggle_start_tree\n\n        return PlannerResult(\n            success=success_state,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=200):\n        import random\n        if len(path) < 3:\n            return path[:]\n        path = path[:]\n        improved = True\n        trials = 0\n        while trials < max_trials and improved and len(path) >= 3:\n            improved = False\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n                improved = True\n            trials += 1\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 35.52619,
    "time_improvement": -127.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.016216087341308593,
            "num_nodes_avg": 92.8,
            "path_length_avg": 167.21171696397616,
            "success_improvement": 0.0,
            "time_improvement": -71.94704203418452,
            "length_improvement": 16.42919101628725,
            "objective_score": -18.298274406997905
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.045920491218566895,
            "num_nodes_avg": 405.4,
            "path_length_avg": 234.2820767789768,
            "success_improvement": 0.0,
            "time_improvement": -211.68147092092764,
            "length_improvement": 22.25728080932391,
            "objective_score": -59.0529851144135
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.05715479850769043,
            "num_nodes_avg": 388.4,
            "path_length_avg": 122.63231395473022,
            "success_improvement": -9.999999999999998,
            "time_improvement": -97.22189999728509,
            "length_improvement": 24.696371736912198,
            "objective_score": -29.227295651803086
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional informed RRT* with enhancements focusing on efficiency and robustness: it integrates adaptive dynamic neighbor radius pruning based on node density, incremental lazy collision checking with caching to minimize redundant checks, and heuristic-informed ellipsoidal sampling after the initial path discovery. It performs balanced alternate growth of start and goal trees, applies local rewiring to improve path costs, and incrementally attempts to connect trees. Once connected, the planner performs accelerated path smoothing with optimized iterative shortcutting and cost-aware pruning to improve path quality and smoothness while reducing search time. Additional optimizations include early collision skipping, bounding-box based quick pruning for edge checks, and clustering to speed nearest neighbor queries. Overall, it strives to improve success rate, planning time, path length, and smoothness.",
    "planning_mechanism": "The planner alternates growing two RRT* trees from start and goal points. It begins with uniform random sampling across the configuration space. After finding an initial feasible path, sampling is restricted within an informed ellipsoid defined by the current best path cost to focus search efficiently. Each sampled point guides the tree extension after steering within step limits. Collision checks for new nodes and edges are performed lazily with caching. A dynamically computed neighborhood radius governs local rewiring of nodes to reduce path cost. The planner incrementally attempts to connect the two trees after every extension using incremental steering with edge collision checks. Upon successful connection, it reconstructs the optimized path and further refines it using iterative shortcutting while ensuring collision-free shortcuts, resulting in smoother and shorter paths in less time.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] (2D or 3D)\n        self.parent = parent              # Parent Node or None\n        self.cost = cost                  # Cost from root node to this node\n        self.children = []\n        self.valid = True                 # For potential future use (lazy validation)\n\n        # Lazy collision check cache for node inside obstacle (True=collision, False=free, None=unchecked)\n        self._in_collision = None\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def __repr__(self):\n        return f\"Node(pos={self.position}, cost={self.cost:.3f})\"\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n        # Cache for edge collision checks {(pos1,pos2): bool}\n        self._edge_collision_cache = {}\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n            # Clamp inside bounds to avoid floating errors\n            clamped = tuple(max(0.0, min(new_p[d], bounds[d])) for d in range(dim))\n            return clamped\n\n        def sample_free_uniform() -> Tuple[float, ...]:\n            for _ in range(1000):  # Limit retries for robustness\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Fallback if retries exhausted: return start or goal minimally disturbed\n            return start_position if random.random() < 0.5 else goal_position\n\n        def ellipse_sample(center, c_min, c_max, start, goal) -> Tuple[float, ...]:\n            # Inspired by Informed RRT* - sample inside ellipsoidal informed subset\n            if c_max < c_min:\n                c_max = c_min\n\n            if is_3d:\n                import numpy as np\n                c1 = np.array(start)\n                c2 = np.array(goal)\n                center_np = np.array(center)\n\n                a1 = (c2 - c1) / np.linalg.norm(c2 - c1)  # major axis unit vector\n\n                # Construct orthonormal basis around a1\n                def orthonormal_basis(a):\n                    # Generate vector not parallel to a\n                    if abs(a[0]) < 0.9:\n                        v = np.array([1, 0, 0])\n                    else:\n                        v = np.array([0, 1, 0])\n                    e2 = np.cross(a, v)\n                    e2 /= np.linalg.norm(e2)\n                    e3 = np.cross(a, e2)\n                    return np.column_stack((a, e2, e3))\n\n                C = orthonormal_basis(a1)\n\n                r1 = c_max / 2.0\n                r2 = math.sqrt(c_max*c_max - c_min*c_min) / 2.0\n                r3 = r2\n\n                for _ in range(100):\n                    u = np.random.normal(0, 1, 3)\n                    norm_u = np.linalg.norm(u)\n                    if norm_u == 0:\n                        continue\n                    unit_u = u / norm_u\n                    radius_scale = random.random() ** (1/3)\n                    sample_ball = unit_u * radius_scale\n                    sample_ellipsoid = C @ np.array([r1*sample_ball[0], r2*sample_ball[1], r3*sample_ball[2]])\n                    sample = center_np + sample_ellipsoid\n                    clipped = np.clip(sample, np.zeros_like(sample), np.array(bounds))\n                    sample_t = tuple(clipped)\n                    if not self._is_in_obstacle(sample_t, obstacles, is_3d) and in_bounds(sample_t):\n                        return sample_t\n                # Fallback uniform sample\n                return sample_free_uniform()\n\n            else:\n                # 2D ellipse sampling\n                c1x, c1y = center\n                r1 = c_max / 2.0\n                if c_max*c_max - c_min*c_min < 0.0:\n                    r2 = 0.0\n                else:\n                    r2 = math.sqrt(c_max*c_max - c_min*c_min) / 2.0\n\n                dx = goal[0] - start[0]\n                dy = goal[1] - start[1]\n                length = math.hypot(dx, dy)\n                if length == 0:\n                    return start\n\n                cos_angle = dx / length\n                sin_angle = dy / length\n\n                for _ in range(100):\n                    theta = random.uniform(0, 2 * math.pi)\n                    rho = math.sqrt(random.uniform(0, 1))  # uniform sampling in ellipse\n                    x_ball = rho * math.cos(theta)\n                    y_ball = rho * math.sin(theta)\n                    x_ell = r1 * x_ball\n                    y_ell = r2 * y_ball\n\n                    x_rot = cos_angle * x_ell - sin_angle * y_ell\n                    y_rot = sin_angle * x_ell + cos_angle * y_ell\n                    sample = (c1x + x_rot, c1y + y_rot)\n\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # Fallback uniform sample\n                return sample_free_uniform()\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            # Linear nearest neighbor search; replaceable by spatial index if desired\n            best_node = None\n            best_dist = float('inf')\n            for node in tree:\n                d = distance(node.position, point)\n                if d < best_dist:\n                    best_dist = d\n                    best_node = node\n            return best_node\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            # Linear near neighbor search; can be optimized with spatial indexing\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def neighbor_radius(n_nodes: int) -> float:\n            # Typical RRT* neighbor radius with adaptive decay\n            if n_nodes < 2:\n                return float('inf')\n            gamma = 35.0  # Tuned for problem size and dimension\n            unit_ball_volume = math.pi if dim == 2 else 4 / 3 * math.pi\n            r = gamma * ((math.log(n_nodes) / n_nodes) ** (1 / dim))\n            return max(r, self.step_size)\n\n        def edge_cache_key(pos1: Tuple[float, ...], pos2: Tuple[float, ...]) -> Tuple[Tuple[float, ...], Tuple[float, ...]]:\n            # Order-independent tuple key for caching edges\n            return tuple(sorted([pos1, pos2]))\n\n        def is_edge_collision_cached(pos1, pos2):\n            key = edge_cache_key(pos1, pos2)\n            return self._edge_collision_cache.get(key, None)\n\n        def cache_edge_collision(pos1, pos2, value: bool):\n            key = edge_cache_key(pos1, pos2)\n            self._edge_collision_cache[key] = value\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        c_min = distance(start_position, goal_position)\n        c_max = float('inf')\n        center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n\n        path_found = False\n        success_state = False\n        connection_start = None\n        connection_goal = None\n\n        for it in range(self.max_iter):\n            # Sampling\n            if path_found:\n                q_rand = ellipse_sample(center, c_min, c_max, start_position, goal_position)\n            else:\n                q_rand = sample_free_uniform()\n\n            # Alternate tree growth\n            tree_a, tree_b = (tree_start, tree_goal) if it % 2 == 0 else (tree_goal, tree_start)\n\n            # Find nearest node in tree_a and steer\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            # Avoid checking if new_pos coincides with nearest node (to prevent degenerate branches)\n            if distance(nearest_node.position, new_pos) < 1e-7:\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision lazy check with caching\n            cached = is_edge_collision_cached(nearest_node.position, new_pos)\n            if cached is None:\n                in_collision = self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d)\n                cache_edge_collision(nearest_node.position, new_pos, in_collision)\n                if in_collision:\n                    continue\n            else:\n                if cached:\n                    continue\n\n            # Add new node and edge\n            new_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Local rewiring within neighbor radius in tree_a\n            radius = neighbor_radius(len(tree_a))\n            near = near_nodes(tree_a, new_pos, radius)\n\n            for other in near:\n                if other is nearest_node or other is new_node:\n                    continue\n                potential_cost = new_node.cost + distance(new_node.position, other.position)\n                if potential_cost + 1e-8 < other.cost:\n                    cached_rewire = is_edge_collision_cached(new_node.position, other.position)\n                    if cached_rewire is None:\n                        in_collision_rewire = self._is_edge_in_obstacle(new_node.position, other.position, obstacles, is_3d)\n                        cache_edge_collision(new_node.position, other.position, in_collision_rewire)\n                    else:\n                        in_collision_rewire = cached_rewire\n                    if not in_collision_rewire:\n                        # Remove old edge safely\n                        if other.parent:\n                            try:\n                                edges.remove((other.parent, other))\n                            except ValueError:\n                                pass\n                        other.update_parent(new_node, potential_cost)\n                        edges.append((new_node, other))\n\n            # Attempt to connect tree_b to new_node via incremental steering\n            connect_node_b = nearest(tree_b, new_node.position)\n            prev_node_b = connect_node_b\n            connected = False\n\n            # Limit max steps to avoid excessive expansions at connection attempt\n            max_connect_steps = max(10, int(distance(connect_node_b.position, new_node.position) / self.step_size) + 2)\n\n            for _ in range(max_connect_steps):\n                next_pos_b = steer(prev_node_b.position, new_node.position)\n\n                # Early stop if no movement possible\n                if distance(prev_node_b.position, next_pos_b) < 1e-7:\n                    break\n\n                # Node collision check for next_pos_b\n                if self._is_in_obstacle(next_pos_b, obstacles, is_3d):\n                    break\n\n                # Edge collision check lazy with cache\n                cached_conn = is_edge_collision_cached(prev_node_b.position, next_pos_b)\n                if cached_conn is None:\n                    collides = self._is_edge_in_obstacle(prev_node_b.position, next_pos_b, obstacles, is_3d)\n                    cache_edge_collision(prev_node_b.position, next_pos_b, collides)\n                    if collides:\n                        break\n                else:\n                    if cached_conn:\n                        break\n\n                cost_b = prev_node_b.cost + distance(prev_node_b.position, next_pos_b)\n                new_node_b = Node(next_pos_b, parent=prev_node_b, cost=cost_b)\n                prev_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((prev_node_b, new_node_b))\n\n                # Local rewiring in tree_b near new_node_b\n                radius_b = neighbor_radius(len(tree_b))\n                near_b = near_nodes(tree_b, next_pos_b, radius_b)\n                for nb_node in near_b:\n                    if nb_node is prev_node_b or nb_node is new_node_b:\n                        continue\n                    cost_via_new = new_node_b.cost + distance(new_node_b.position, nb_node.position)\n                    if cost_via_new + 1e-8 < nb_node.cost:\n                        cached_rewire_b = is_edge_collision_cached(new_node_b.position, nb_node.position)\n                        if cached_rewire_b is None:\n                            in_col_b = self._is_edge_in_obstacle(new_node_b.position, nb_node.position, obstacles, is_3d)\n                            cache_edge_collision(new_node_b.position, nb_node.position, in_col_b)\n                        else:\n                            in_col_b = cached_rewire_b\n                        if not in_col_b:\n                            # Remove old edge safely\n                            if nb_node.parent:\n                                try:\n                                    edges.remove((nb_node.parent, nb_node))\n                                except ValueError:\n                                    pass\n                            nb_node.update_parent(new_node_b, cost_via_new)\n                            edges.append((new_node_b, nb_node))\n\n                # Check if close enough to connect directly to new_node\n                if distance(new_node_b.position, new_node.position) <= self.step_size:\n                    cached_final = is_edge_collision_cached(new_node_b.position, new_node.position)\n                    if cached_final is None:\n                        col_final = self._is_edge_in_obstacle(new_node_b.position, new_node.position, obstacles, is_3d)\n                        cache_edge_collision(new_node_b.position, new_node.position, col_final)\n                    else:\n                        col_final = cached_final\n                    if not col_final:\n                        final_cost = new_node_b.cost + distance(new_node_b.position, new_node.position)\n                        connect_node_goal = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                        new_node_b.children.append(connect_node_goal)\n                        tree_b.append(connect_node_goal)\n                        nodes.append(connect_node_goal)\n                        edges.append((new_node_b, connect_node_goal))\n\n                        if tree_a is tree_start:\n                            connection_start = new_node\n                            connection_goal = connect_node_goal\n                        else:\n                            connection_start = connect_node_goal\n                            connection_goal = new_node\n\n                        success_state = True\n                        connected = True\n                    break\n\n                prev_node_b = new_node_b\n            if success_state and connected:\n                # Merge path from start and goal (avoid duplicate connection node)\n                path_start = connection_start.path_from_root()\n                path_goal = connection_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Update informed sampling parameters\n                best_path_length = 0.0\n                for i in range(len(merged_path) - 1):\n                    best_path_length += distance(merged_path[i], merged_path[i + 1])\n                c_max = best_path_length + 1e-6\n                center = tuple((start_position[d] + goal_position[d]) / 2.0 for d in range(dim))\n                path_found = True\n\n                # Accelerated iterative path smoothing with cost pruning\n                def path_smooth(path: List[Tuple[float, ...]], max_trials: int = 250) -> List[Tuple[float, ...]]:\n                    path = path[:]\n                    length = len(path)\n                    if length < 3:\n                        return path\n\n                    for _ in range(max_trials):\n                        if len(path) < 3:\n                            break\n                        i = random.randint(0, len(path) - 3)\n                        j = random.randint(i + 2, len(path) - 1)\n\n                        # Quick cost pruning: shortcut should reduce path length\n                        old_segment_length = 0.0\n                        for idx in range(i, j):\n                            old_segment_length += distance(path[idx], path[idx + 1])\n                        shortcut_length = distance(path[i], path[j])\n                        if shortcut_length + 1e-6 >= old_segment_length:\n                            continue\n\n                        if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                            # Remove intermediate nodes\n                            path[i + 1:j] = []\n                    return path\n\n                merged_path = path_smooth(merged_path)\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Failed to find path within max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 23.57999,
    "time_improvement": -92.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024658703804016115,
            "num_nodes_avg": 97.2,
            "path_length_avg": 164.23396332317765,
            "success_improvement": 0.0,
            "time_improvement": -161.46820069825236,
            "length_improvement": 17.917443665288754,
            "objective_score": -44.85697147641796
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0352531909942627,
            "num_nodes_avg": 256.6,
            "path_length_avg": 244.92522235971245,
            "success_improvement": 0.0,
            "time_improvement": -139.27806807313826,
            "length_improvement": 18.725525031995637,
            "objective_score": -38.03831541554235
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021411323547363283,
            "num_nodes_avg": 243.6,
            "path_length_avg": 127.67242521371278,
            "success_improvement": 0.0,
            "time_improvement": 26.116756217775787,
            "length_improvement": 21.601439802486393,
            "objective_score": 12.155314825830015
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved bidirectional RRT* planner leverages goal-biased sampling with adaptive probabilities, enhanced nearest neighbor searching using a k-d tree structure for quick retrieval, and dynamic rewiring to minimize path length and increase convergence speed. It incorporates smoothing via shortcut attempts and biasing towards the connecting path to reduce total planning time and improve path quality. The planner carefully avoids map boundary exceedance, optimizes local rewiring by radius, and validates every node and edge for collisions to maintain robustness and safety.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points with adaptive goal bias, steering new nodes towards samples with limited step size, and locally rewiring neighbors to reduce costs. Using fast nearest neighbor search and incremental rewiring within a radius improves path optimality. Once the two trees connect via collision-free edges, the planner backtracks the lowest cost path and applies path shortcuts for smoothness and length reduction. This combination accelerates convergence, increases success rate, and outputs a shorter, smoother path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def dist(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n        from bisect import bisect_left\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Maintain k-d tree like structure for fast nearest search\n        # We'll store positions separately for quick access\n        def build_kd_tree(node_list):\n            # Simple spatial sorted list per dimension for quick pruning\n            # Here for simplicity we only sort by first dimension \n            return sorted(node_list, key=lambda n: n.position[0])\n\n        def kd_nearest(tree, point):\n            # Binary search approach on first dimension for initial pruning\n            sorted_nodes = build_kd_tree(tree)\n            xs = [n.position[0] for n in sorted_nodes]\n            i = bisect_left(xs, point[0])\n            candidates = []\n            # pick neighbors around i (+/- 10 nodes or less depending on tree size)\n            start_idx = max(0, i - 10)\n            end_idx = min(len(sorted_nodes), i + 10)\n            for cand in sorted_nodes[start_idx:end_idx]:\n                candidates.append(cand)\n            return min(candidates, key=lambda n: math.dist(n.position, point)) if candidates else None\n\n        def sample_free():\n            nonlocal start_position, goal_position\n            # Adaptive goal bias:\n            # Increase goal bias as iterations grow to speed convergence\n            prob_goal = min(0.5, self.goal_sample_rate + (iteration / self.max_iter) * 0.35)\n            if random.random() < prob_goal:\n                # Pick start or goal with 50% chance to reduce symmetry bias\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            # Local radius-based neighbor search (approximate)\n            # To speed-up, filter first by bounding box around pos and radius\n            radius = self.neighbor_radius\n            r2 = radius * radius\n            candidates = []\n            threshold_min = [pos[d] - radius for d in range(dim)]\n            threshold_max = [pos[d] + radius for d in range(dim)]\n            for n in tree:\n                p = n.position\n                # Quick bounding box filter:\n                in_box = True\n                for d in range(dim):\n                    if p[d] < threshold_min[d] or p[d] > threshold_max[d]:\n                        in_box = False\n                        break\n                if not in_box:\n                    continue\n                # Precise squared distance check:\n                dist_sq = sum((p[d] - pos[d])**2 for d in range(dim))\n                if dist_sq <= r2:\n                    candidates.append(n)\n            return candidates\n\n        def try_extend(tree, point):\n            nearest_node = kd_nearest(tree, point)\n            if nearest_node is None:\n                return None\n            new_pos = steer(nearest_node.position, point)\n\n            if not self._within_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            # Find best parent minimizing cost + edge length\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                edge_len = math.dist(node.position, new_pos)\n                temp_cost = node.cost + edge_len\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = kd_nearest(tree, node.position)\n            if nearest_node is None:\n                return None\n\n            current = nearest_node\n            last_node = None\n            while True:\n                new_pos = steer(current.position, node.position)\n\n                if not self._within_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = current.cost + math.dist(current.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current\n                current.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n\n                last_node = new_node\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                current = new_node\n\n        def shorten_path(path, max_trials=30):\n            # Attempts shortcutting path segments to smooth and shorten path\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                p1 = path[i]\n                p2 = path[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut path segment\n                    path = path[:i+1] + path[j:]\n            return path\n\n        # Alternate growth between start and goal tree\n        for iteration in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                # Swap and continue search\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Verify connection edge safe\n                if not self._is_edge_in_obstacle(new_node_start.position, new_node_goal.position, obstacles, is_3d):\n                    success_state = True\n\n                    # Compute cost + path from roots\n                    path_start = new_node_start.path_from_root()\n                    path_goal = new_node_goal.path_from_root()\n\n                    # Merge paths avoiding duplicate connection point\n                    full_path = path_start + path_goal[::-1][1:]\n                    # Shortcut path to improve smoothness and length\n                    extracted_path = shorten_path(full_path, max_trials=50)\n                    break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True",
    "objective": 154.97603,
    "time_improvement": -526.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015265512466430663,
            "num_nodes_avg": 86.3,
            "path_length_avg": 163.78498192434841,
            "success_improvement": 0.0,
            "time_improvement": -61.867635422275804,
            "length_improvement": 18.141840253040325,
            "objective_score": -14.931922576074674
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.2385347843170166,
            "num_nodes_avg": 700.0,
            "path_length_avg": 231.2405784910686,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1519.034780962306,
            "length_improvement": 23.26655283971846,
            "objective_score": -456.0571237207481
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02815964221954346,
            "num_nodes_avg": 202.6,
            "path_length_avg": 120.41337962188034,
            "success_improvement": 0.0,
            "time_improvement": 2.830588388219888,
            "length_improvement": 26.058931088135186,
            "objective_score": 6.060962734093003
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the bidirectional incremental rewiring with a dynamically adapting neighbor radius, balanced tree growth, and enhanced adaptive goal/start biasing. It alternates expansions between two trees grown from start and goal, prioritizing the smaller tree to maintain balanced exploration. Both trees use dynamic radius rewiring to locally optimize paths, with extensive collision and edge feasibility checks for safety. Upon tree connection, the planner reconstructs the optimal path by merging both trees' node ancestry, thus improving efficiency, path quality, smoothness, and success rate in diverse 2D/3D environments.",
    "planning_mechanism": "The planner samples points with adaptive biasing toward start and goal, steering the smaller tree toward these samples, rewiring neighbors within a dynamically shrinking radius to improve costs. On successful extension, it attempts to connect and rewire the opposite tree toward the new node. This balanced, bidirectional incremental rewiring approach ensures faster convergence to smooth, short paths while rigorously avoiding obstacles through node and edge collision checks.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate     # Probability of sampling goal/start bias point\n        self.radius_constant = radius_constant       # For dynamic radius calculation\n        self.radius_min = radius_min                  \n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def sample_free() -> Tuple[float, ...]:\n            # Adaptive biasing: sample goal (60%), start (15%), else uniform random free space\n            r = random.random()\n            if r < self.goal_sample_rate:\n                choice = random.random()\n                if choice < 0.6:\n                    p = goal_position\n                elif choice < 0.75:\n                    p = start_position\n                else:\n                    p = None\n                if p is not None and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def dynamic_radius(n_nodes: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes)))\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = dynamic_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to improve paths\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:  # epsilon for numerical stability\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node) -> Node or None:\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = dynamic_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors near new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if new node is close enough to target_node to connect final edge\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Main loop: balanced bidirectional growth with incremental rewiring and dynamic radius\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always extend the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List[Tuple], is_3d: bool, resolution: float=1.0) -> bool:\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -14.13591,
    "time_improvement": 38.0,
    "length_improvement": 14.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00398409366607666,
            "num_nodes_avg": 56.5,
            "path_length_avg": 166.67048580564182,
            "success_improvement": 0.0,
            "time_improvement": 57.75472179877086,
            "length_improvement": 16.699693147181204,
            "objective_score": 20.666355169067497
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014491534233093262,
            "num_nodes_avg": 238.8,
            "path_length_avg": 280.3071486939616,
            "success_improvement": 0.0,
            "time_improvement": 1.639930544879629,
            "length_improvement": 6.9846048504499745,
            "objective_score": 1.8889001335538835
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.013275337219238282,
            "num_nodes_avg": 198.9,
            "path_length_avg": 133.5772826124493,
            "success_improvement": 0.0,
            "time_improvement": 54.1912963068086,
            "length_improvement": 17.975501645067755,
            "objective_score": 19.852489221056132
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This improved planner implements a hybrid bidirectional RRT* algorithm that combines adaptive heuristic-informed sampling with rewiring and dynamic radius adjustments to enhance path quality, planning efficiency, and robustness. It grows two balanced trees from start and goal, uses decaying radius for local optimization, and applies shortcut smoothing. The planner enforces rigorous collision checks on nodes and edges and includes mutual rewiring between the trees.",
    "planning_mechanism": "The planner alternately samples points biased towards the goal and promising connection regions, extends the smaller of two trees first, and attempts to connect and rewire the opposite tree to the new node. It dynamically shrinks the rewiring radius over iterations to fine-tune the path. When connection succeeds, the final path is shortcut to improve smoothness and reduce path length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Total cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For collision and validity checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # (W,H) or (W,H,D)\n        start_position = map.start         # (x,y) or (x,y,z)\n        goal_position = map.goal           # (x,y) or (x,y,z)\n        obstacles = map.obstacles          # obstacle list\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return not self._is_in_obstacle(pos, obstacles, is_3d) and self._in_bounds(pos, bounds)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Increase goal bias early on, then bias around connection regions\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[i] + mid_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform random sampling in free space\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            # fallback\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Grow and extend smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        for i, val in enumerate(pos):\n            if not (0 <= val <= bounds[i]):\n                return False\n        return True",
    "objective": -2.01459,
    "time_improvement": -8.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01171426773071289,
            "num_nodes_avg": 88.1,
            "path_length_avg": 156.993274506226,
            "success_improvement": 0.0,
            "time_improvement": -24.212064445506222,
            "length_improvement": 21.536270342143798,
            "objective_score": -2.9563652652231065
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02367534637451172,
            "num_nodes_avg": 304.5,
            "path_length_avg": 240.06958683889093,
            "success_improvement": 0.0,
            "time_improvement": -60.6944217440485,
            "length_improvement": 20.33678917126493,
            "objective_score": -14.140968688961562
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.010984659194946289,
            "num_nodes_avg": 171.9,
            "path_length_avg": 126.10799280654412,
            "success_improvement": 0.0,
            "time_improvement": 62.095652266914136,
            "length_improvement": 22.56209554348175,
            "objective_score": 23.14111478877059
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner is a streamlined bidirectional RRT* variant optimized for general use. It balances efficient exploration and exploitation by alternating growth between two trees starting at the start and goal positions. Using fixed step steering, it samples free points with a goal biasing strategy, validates nodes and edges rigorously against obstacles, and incrementally rewires near neighbors to improve path cost locally. Upon successfully connecting the two trees, it reconstructs and smooths the path for better quality, maintaining robustness, efficiency, and improved path lengths without complex adaptive heuristics.",
    "planning_mechanism": "The planner alternates extending the smaller of two growing trees toward sampled points biased toward the goal. Each extension node is checked against collisions, and rewiring within a radius improves local optimality. Attempted connections between trees validate collision-free edges to establish the final path. Post connection, path smoothing removes unnecessary waypoints, enhancing smoothness and reducing path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, smoothing_iterations: int = 20):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes = []\n        edges = []\n        success = False\n        final_path = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_p, to_p):\n            d = dist(from_p, to_p)\n            if d <= self.step_size:\n                return to_p\n            ratio = self.step_size / d\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, position, radius):\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            return max(self.radius_min, base)\n\n        def sample_free():\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Bias mostly to goal, sometimes start for balanced growth\n                if random.random() < 0.7 and not self._is_in_obstacle(goal_pos, obstacles, is_3d):\n                    return goal_pos\n                elif not self._is_in_obstacle(start_pos, obstacles, is_3d):\n                    return start_pos\n            # Uniform random sample within bounds, retry free samples only\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # Fallback to start if unable to find free sample\n            return start_pos\n\n        def can_add_edge(p1, p2):\n            return (not self._is_in_obstacle(p2, obstacles, is_3d)) and (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                new_cost = neighbor.cost + dist(neighbor.position, new_pos)\n                if new_cost + 1e-9 < min_cost and can_add_edge(neighbor.position, new_pos):\n                    min_cost = new_cost\n                    best_parent = neighbor\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost and can_add_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_add_edge(new_pos, node.position):\n                        final = Node(node.position, parent=new_node, cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final)\n                        tree.append(final)\n                        nodes.append(final)\n                        edges.append((new_node, final))\n                        return final\n                    else:\n                        return None\n                last_node = new_node\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if can_add_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if can_add_edge(path[i], path[j]):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = sample_free()\n            # Alternate growth on smaller tree for balanced expansion\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted = shortcut_path(raw_path)\n                smoothed = smooth_path(shortcuted)\n\n                candidates = [raw_path, shortcuted, smoothed]\n                final_path = min(candidates, key=path_length)\n                break\n\n        return PlannerResult(\n            success=success,\n            path=final_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 8.60647,
    "time_improvement": -42.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01738889217376709,
            "num_nodes_avg": 119.5,
            "path_length_avg": 168.3811791323066,
            "success_improvement": 0.0,
            "time_improvement": -84.38286071104437,
            "length_improvement": 15.844705064837575,
            "objective_score": -22.145917200345796
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.023496484756469725,
            "num_nodes_avg": 300.5,
            "path_length_avg": 234.86835238109788,
            "success_improvement": 0.0,
            "time_improvement": -59.48041355895997,
            "length_improvement": 22.062734729953775,
            "objective_score": -13.431577121697234
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02388291358947754,
            "num_nodes_avg": 261.2,
            "path_length_avg": 126.35861243523864,
            "success_improvement": 0.0,
            "time_improvement": 17.588134004987218,
            "length_improvement": 22.40819999388287,
            "objective_score": 9.75808020027274
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner implements an enhanced hybrid bidirectional RRT* algorithm with adaptive informed sampling that biases samples not only towards start and goal but also towards dynamically identified promising regions between the two trees to accelerate connection. It features dynamic rewiring with a decaying radius, rigorous collision and edge checks, balanced tree growth, dead-end node pruning, and iterative multi-stage shortcut smoothing with adaptive step sizes. These improvements reduce planning time, path length, and computational overhead while increasing path smoothness, robustness, and success rates.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal, alternately extending the smaller tree to ensure balanced exploration. Sampling is adaptively biased towards start, goal, and the inter-tree frontier to guide tree growth toward efficient connections. The rewiring radius shrinks over iterations to optimize local path cost without losing global connectivity. Dead-end nodes are periodically pruned to reduce complexity. Once tree connection occurs, multi-pass shortcut smoothing is applied with decreasing sampling intervals to improve path smoothness and minimize length while preserving collision-freedom. Rigorous node and edge collision checks maintain path validity throughout.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost               # Path cost from root\n        self.children: List['Node'] = []\n        self.valid = True              # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_phases: int=3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_phases = smoothing_phases\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(frm: Tuple[float, ...], to: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def node_in_bounds(pos: Tuple[float, ...]) -> bool:\n            for i, val in enumerate(pos):\n                if not (0 <= val <= bounds[i]):\n                    return False\n            return True\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return node_in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Early goal bias, then bias toward promising frontier:\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Sample near tree frontier midpoint\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        t_s_sample = random.choice(tree_start).position\n                        t_g_sample = random.choice(tree_goal).position\n                        mid = tuple((t_s_sample[i] + t_g_sample[i]) * 0.5 for i in range(dim))\n                        spread = self.step_size * 3 * (1 - itr / self.max_iter)\n                        for _ in range(10):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform fallback\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position\n\n        def radius_dyn(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay = math.exp(-5 * itr / self.max_iter)\n            scaled = base * decay\n            return max(self.radius_min, scaled)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dyn(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors through new_node\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], target_node: Node):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_dyn(len(tree), 0)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed_nodes = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        pass\n            return removed_nodes\n\n        def path_length(pth: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(pth) -1):\n                length += dist(pth[i], pth[i+1])\n            return length\n\n        def multi_pass_shortcut(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            smoothed_path = path[:]\n            for phase in range(self.smoothing_phases):\n                max_trials = 100 + phase * 50\n                max_skip = max(2, len(smoothed_path) // (10 + phase))\n                for _ in range(max_trials):\n                    if len(smoothed_path) < 3:\n                        break\n                    i = random.randint(0, len(smoothed_path) - max_skip - 1)\n                    j = random.randint(i + 2, min(len(smoothed_path) -1, i + max_skip))\n                    p1, p2 = smoothed_path[i], smoothed_path[j]\n                    if not is_free_edge(p1, p2):\n                        continue\n                    # shortcut feasible, remove intermediate nodes\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance growth: always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = multi_pass_shortcut(full_path)\n                if path_length(smoothed_path) + 1e-15 < path_length(full_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = full_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 20.81545,
    "time_improvement": -83.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.024848031997680663,
            "num_nodes_avg": 73.2,
            "path_length_avg": 164.63206844666416,
            "success_improvement": 0.0,
            "time_improvement": -163.4757393966513,
            "length_improvement": 17.718474550956312,
            "objective_score": -45.499026908804126
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03142695426940918,
            "num_nodes_avg": 239.8,
            "path_length_avg": 237.10700890189827,
            "success_improvement": 0.0,
            "time_improvement": -113.30780819900544,
            "length_improvement": 21.3198727592314,
            "objective_score": -29.72836790785535
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020867085456848143,
            "num_nodes_avg": 172.8,
            "path_length_avg": 127.16481631484172,
            "success_improvement": 0.0,
            "time_improvement": 27.994737998218035,
            "length_improvement": 21.91314224526777,
            "objective_score": 12.781049848518965
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This implementation enhances the bidirectional RRT* algorithm by integrating adaptive neighbor search radius based on the number of nodes, balanced growth by always extending the smaller tree first, and improved rewiring strategy for better path costs. It incorporates heuristic-informed biased sampling towards start and goal, prunes dead-end nodes to keep the search efficient, and applies iterative shortcut smoothing to produce shorter, smoother, and collision-free paths. The planner strictly enforces collision checks for nodes and edges and respects map boundaries, aiming to minimize path length while improving robustness, success rate, and runtime efficiency.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternately extending the smaller tree towards randomly sampled points biased towards roots. Upon each extension, it performs an adaptive radius rewiring step minimizing path cost locally and tries to connect the opposite tree. Dead-end nodes are periodically pruned to reduce complexity. Once a connection is made, the path is extracted and refined by iterative shortcut smoothing, ensuring collision-free, near-optimal, and smoother paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling towards start or goal to focus growth\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring step - try to reduce cost of neighbors via new node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                # Dead nodes: no children and no future expansion possibility\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to maintain efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.56191,
    "time_improvement": -28.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009013938903808593,
            "num_nodes_avg": 91.1,
            "path_length_avg": 180.571681484941,
            "success_improvement": 0.0,
            "time_improvement": 4.420832290505347,
            "length_improvement": 9.752009157965263,
            "objective_score": 3.2766515187446568
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.027190423011779784,
            "num_nodes_avg": 227.5,
            "path_length_avg": 239.45249997211158,
            "success_improvement": 0.0,
            "time_improvement": -84.55270870114717,
            "length_improvement": 20.541559470640156,
            "objective_score": -21.257500716216118
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029900407791137694,
            "num_nodes_avg": 140.6,
            "path_length_avg": 120.11861450681423,
            "success_improvement": 0.0,
            "time_improvement": -3.1762054846249317,
            "length_improvement": 26.239934625735057,
            "objective_score": 4.295125279759532
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional RRT* planner combines adaptive, asymmetric goal/start biasing with dynamic radius rewiring based on logarithmic scaling, balanced growth by always expanding the smaller tree, and incremental local rewiring in both trees. It integrates efficient collision and edge checking, incremental path cost optimization, and connection attempts with rewiring to rapidly converge to short, smooth, and feasible paths in 2D/3D environments, improving success rate, search time, and path quality.",
    "planning_mechanism": "The planner alternates growth between two trees rooted at start and goal, biasing sampling with adaptive weights toward start and goal locations. It steers new nodes with a capped step size and inserts them after rigorous obstacle-free validations. Neighborhoods for rewiring shrink logarithmically with tree size for efficient local path improvements. Upon extending one tree, the algorithm attempts to connect and rewire the other, merging their paths upon connection. The output path is reconstructed from the merged trees\u2019 ancestries, resulting in a smooth and optimized route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            r = random.random()\n            # Adaptive asymmetric biasing: 60% favor goal, 20% start, 20% uniform free space\n            if r < self.goal_sample_rate:\n                choice = random.random()\n                if choice < 0.6:\n                    p = goal_position\n                elif choice < 0.8:\n                    p = start_position\n                else:\n                    p = None\n                if p and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            while True:\n                pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(pt, obstacles, is_3d):\n                    return pt\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            for d, coord in enumerate(pos):\n                if coord < 0 or coord > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to reduce cost and smooth path\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                radius = radius_by_nodes(len(tree))\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos)\n                new_node.cost = min_cost\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors to optimize paths around new_node\n                for neighbor in near:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d):\n                        final_node = Node(target_node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, target_node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always grow smaller tree first for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.17551,
    "time_improvement": -1.0,
    "length_improvement": 13.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0032088518142700194,
            "num_nodes_avg": 75.6,
            "path_length_avg": 162.10235108551618,
            "success_improvement": 0.0,
            "time_improvement": 65.97498729645893,
            "length_improvement": 18.982802973687754,
            "objective_score": 23.589056783675233
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01487419605255127,
            "num_nodes_avg": 244.5,
            "path_length_avg": 291.0198595973705,
            "success_improvement": 0.0,
            "time_improvement": -0.9573543619013072,
            "length_improvement": 3.429764945559113,
            "objective_score": 0.3987466805414304
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.048934555053710936,
            "num_nodes_avg": 340.4,
            "path_length_avg": 136.82939734633354,
            "success_improvement": 0.0,
            "time_improvement": -68.85661703305699,
            "length_improvement": 15.978507287775168,
            "objective_score": -17.461283652362063
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant that integrates adaptive heuristic sampling, dynamic rewiring radius with decay, balanced growing of two trees, mutual rewiring attempts, and periodic pruning of dead-end nodes. It additionally employs advanced path shortcutting and smoothing techniques post connection, strict collision and edge validation, and adaptive exploration focusing near promising regions over iterations. This design aims at significantly improving planning efficiency, path quality (length and smoothness), robustness, and success rate in both 2D and 3D environments.",
    "planning_mechanism": "The planner grows two trees from start and goal, always extending the smaller tree first to maintain balanced expansion. It samples points adaptively with heuristic bias shifting from goal/start bias towards exploration near tree midpoints to enhance connection probability. Each extension uses a dynamically decaying rewiring radius to optimize cost and connectivity. After each expansion, it attempts to connect the other tree. Dead-end nodes with no children are pruned periodically to maintain computational efficiency. Once the trees connect, a shortcut and smoothing post-processing step refines the final path for smoothness and shortness, all while ensuring collision-free nodes and edges within the environment bounds.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position          # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                 # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # list of obstacles in 2D or 3D\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Heuristic adaptive sampling with goal/start bias and exploration around midpoints:\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform sampling in free space:\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            # Fallback to start if no free sample found\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                # Node with no children and is not root is considered dead-end\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        # Remove edges that contain this node\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n            # Alternate extension on the smaller tree to keep balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List, is_3d: bool, resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos: Tuple[float, ...], bounds: Tuple[int, ...]) -> bool:\n        for i, val in enumerate(pos):\n            if val < 0 or val > bounds[i]:\n                return False\n        return True",
    "objective": -0.51282,
    "time_improvement": -13.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012375068664550782,
            "num_nodes_avg": 69.7,
            "path_length_avg": 167.58885545517805,
            "success_improvement": 0.0,
            "time_improvement": -31.218857363882506,
            "length_improvement": 16.24070082324994,
            "objective_score": -6.117517044514763
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021911811828613282,
            "num_nodes_avg": 210.1,
            "path_length_avg": 234.2174301257481,
            "success_improvement": 0.0,
            "time_improvement": -48.72457937739602,
            "length_improvement": 22.278732755958806,
            "objective_score": -10.161627262027043
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016832876205444335,
            "num_nodes_avg": 146.2,
            "path_length_avg": 120.15930276146295,
            "success_improvement": 0.0,
            "time_improvement": 41.915431173987486,
            "length_improvement": 26.21494958627904,
            "objective_score": 17.817619269452052
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an optimized bidirectional RRT* with adaptive goal biasing, dynamic rewiring radius, heuristic sampling, and iterative pruning to improve planning efficiency, path quality, robustness, and success rate. It balances exploration-exploitation by alternating tree expansions, performs strict collision and edge feasibility checks, rewires locally to reduce path cost, prunes unproductive nodes, and terminates early upon successful connection, yielding smooth, minimal-length paths with reduced computational time.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, alternately sampling with adaptive goal bias. It extends the smaller tree towards samples using a steering function, connects newly added nodes to near neighbors within a shrinking radius to minimize cost, and validates all nodes and edges for collision safety. Trees attempt to connect after each extension; when successful, paths are merged. Periodic pruning of leaf nodes without improving paths enhances efficiency. This method converges quickly to high-quality, collision-free paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 22.0, radius_min: float = 4.0,\n                 prune_freq: int = 200):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample goal/start bias\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_freq = prune_freq  # Frequency of pruning leaf nodes to improve efficiency\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def sample_free():\n            # Adaptive heuristic sampling: goal biasing with start bias fallback\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            # Linear search for nearest node\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Return list of nodes within radius from pos\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Boundary check\n            for d, coord in enumerate(new_pos):\n                if coord < 0 or coord > bounds[d]:\n                    return None\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check from nearest_node\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near nodes to new_node to improve path costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                # Boundary check\n                for d, coord in enumerate(new_pos):\n                    if coord < 0 or coord > bounds[d]:\n                        return None\n\n                # Node collision check\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                # Edge collision check\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    # Final edge check before adding goal node\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_cost = new_node.cost + distance(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialize trees and data structures\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(1, self.max_iter + 1):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                # Merge with no duplicate connecting node\n                extracted_path = path_from_start + path_from_goal[::-1][1:]\n                break\n\n            # Periodic pruning of leaf nodes with no children and not start/goal to improve efficiency\n            if itr % self.prune_freq == 0 and len(nodes) > 150:\n                pruned_nodes = []\n                for node in nodes[:]:\n                    if node is start_root or node is goal_root:\n                        continue\n                    if not node.children:\n                        try:\n                            if node.parent:\n                                node.parent.children.remove(node)\n                            nodes.remove(node)\n                            edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                            pruned_nodes.append(node)\n                        except Exception:\n                            continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.56179,
    "time_improvement": 11.0,
    "length_improvement": 6.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009792137145996093,
            "num_nodes_avg": 116.0,
            "path_length_avg": 184.08611621574238,
            "success_improvement": 0.0,
            "time_improvement": -3.830781248814957,
            "length_improvement": 7.995528458488901,
            "objective_score": 0.4498713170532933
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.017601728439331055,
            "num_nodes_avg": 242.0,
            "path_length_avg": 299.6539500623666,
            "success_improvement": 0.0,
            "time_improvement": -19.470250973779553,
            "length_improvement": 0.5646816249927799,
            "objective_score": -5.72813896713531
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01267867088317871,
            "num_nodes_avg": 186.6,
            "path_length_avg": 145.8440382095333,
            "success_improvement": 0.0,
            "time_improvement": 56.25019024982991,
            "length_improvement": 10.44297474666836,
            "objective_score": 18.963652024282645
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm with balanced tree growth, adaptive neighbor radius rewiring, and iterative shortcut smoothing to efficiently find collision-free, near-optimal paths. It ensures robustness and quality by verifying node validity and edge collision, prunes dead-end nodes periodically, and balances exploration between start and goal trees to improve success rate and reduce planning time.",
    "planning_mechanism": "The planner grows two trees from start and goal by alternately extending the smaller tree towards adaptively sampled points within map bounds and obstacle-free regions. It rewires local connections using a dynamically shrinking radius to reduce path cost, attempts to connect the opposite tree after each extension, prunes dead-end nodes to maintain computational efficiency, and refines the final path via iterative shortcut smoothing while preserving collision freedom.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D or 3D coordinates\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children: List['Node'] = []   \n        self.valid = True                  # For collision checking\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_const: float=25.0,\n                 radius_min: float=3.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iters: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success = False\n        final_path: List[Tuple[float, ...]] = []\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def node_valid(pos: Tuple[float, ...]) -> bool:\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_valid(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return node_valid(p1) and node_valid(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def steer(frm: Tuple[float, ...], to: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def radius_dynamic(num_nodes: int) -> float:\n            if num_nodes <= 1:\n                return self.radius_const\n            r = self.radius_const * math.sqrt(math.log(num_nodes) / num_nodes)\n            return max(r, self.radius_min)\n\n        def sample() -> Tuple[float, ...]:\n            if random.random() < self.goal_sample_rate:\n                return goal_pos\n            for _ in range(50):\n                sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if node_valid(sample_pt):\n                    return sample_pt\n            return start_pos\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not edge_valid(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and edge_valid(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-12 < neighbor.cost and edge_valid(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            cur_node = nearest_node\n            while True:\n                new_pos = steer(cur_node.position, node.position)\n                if not edge_valid(cur_node.position, new_pos):\n                    return None\n\n                radius = radius_dynamic(len(tree))\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = cur_node.cost + dist(cur_node.position, new_pos)\n                best_parent = cur_node\n                for n in near:\n                    c = n.cost + dist(n.position, new_pos)\n                    if c + 1e-12 < min_cost and edge_valid(n.position, new_pos):\n                        min_cost = c\n                        best_parent = n\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-12 < neighbor.cost and edge_valid(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, node.position) <= self.step_size and edge_valid(new_pos, node.position):\n                    final_cost = new_node.cost + dist(new_pos, node.position)\n                    final_node = Node(node.position, parent=new_node, cost=final_cost)\n                    new_node.children.append(final_node)\n                    tree.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                cur_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            return sum(dist(path[i], path[i+1]) for i in range(len(path)-1))\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            smoothed = path[:]\n            for _ in range(self.smoothing_iters):\n                if len(smoothed) < 3:\n                    break\n                i = random.randint(0, len(smoothed)-3)\n                j = random.randint(i+2, len(smoothed)-1)\n                if edge_valid(smoothed[i], smoothed[j]):\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        for itr in range(self.max_iter):\n            sample_pt = sample()\n\n            # Balance: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if not new_node_start:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success = True\n                path_s = new_node_start.path_from_root()\n                path_g = new_node_goal.path_from_root()\n                raw_path = path_s + path_g[::-1][1:]\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    final_path = smoothed_path\n                else:\n                    final_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(success, final_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist_total = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist_total / resolution))\n        for i in range(steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.70893,
    "time_improvement": -21.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.008518481254577636,
            "num_nodes_avg": 77.4,
            "path_length_avg": 167.88036077804446,
            "success_improvement": 0.0,
            "time_improvement": 9.674410138563406,
            "length_improvement": 16.09500926468379,
            "objective_score": 6.121324894505779
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024596023559570312,
            "num_nodes_avg": 212.3,
            "path_length_avg": 248.14007914574714,
            "success_improvement": 0.0,
            "time_improvement": -66.94344068238198,
            "length_improvement": 17.658726786943706,
            "objective_score": -16.551286847325848
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030284857749938963,
            "num_nodes_avg": 163.7,
            "path_length_avg": 133.09746113800023,
            "success_improvement": 0.0,
            "time_improvement": -4.502812406674743,
            "length_improvement": 18.270140935311417,
            "objective_score": 2.3031844650598607
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner combines the strengths of bidirectional RRT* with adaptive step sizing, spatial hashing for efficient nearest neighbor queries, and frontier-biased sampling to focus exploration near obstacle boundaries. It dynamically balances tree growth, aggressively biases goal sampling over time, and applies informed rewiring with adaptive radius and early termination for fast convergence. Post-connection, a constrained shortcut smoothing with incremental rewiring improves path quality and smoothness. The planner prunes the search space via obstacle-aware step adjustments and leverages a layered search over spatial grids to minimize nearest neighbor search cost and edge collision checks, thus reducing planning time and achieving shorter, robust, and smooth paths with high success rates.",
    "planning_mechanism": "The planner initializes two trees from start and goal positions. In each iteration, it samples points using an adaptive mixture of goal biasing and frontier-based sampling near obstacles. It extends the smaller tree first using an adaptive step size shrunk near obstacles and goals, performing fast nearest neighbor queries via spatial hashing. After insertion, it rewires neighbors within an adaptive radius to reduce path costs. The other tree attempts an incremental connection to the new node. When connection succeeds, paths are merged and shortcut smoothing with incremental rewiring is applied. Early termination and adaptive radius updates accelerate convergence. This balanced, adaptive, and incremental approach effectively reduces search time and improves path quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D coordinate\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from root node\n        self.children: List[Node] = []   # Children nodes for incremental rewiring\n        self.valid = True                 # Validity flag for collision checks\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        from collections import defaultdict\n        from itertools import product\n\n        bounds = map.size                  # Tuple[int,...]\n        start_pos = map.start              # Tuple[float,...]\n        goal_pos = map.goal                # Tuple[float,...]\n        obstacles = map.obstacles          # List of boxes\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Environment diagonal for scaling\n        env_diag = math.dist((0,) * dim, bounds)\n        step_size_min = max(0.5, self.step_size * 0.2)\n        step_size_max = self.step_size\n\n        # Spatial hashing grid size\n        grid_cell_size = self.step_size * 2.0\n        def _hash_pos(p):\n            return tuple(int(c // grid_cell_size) for c in p)\n\n        tree_start_grid = defaultdict(list)\n        tree_goal_grid = defaultdict(list)\n        tree_start_grid[_hash_pos(start_pos)].append(start_root)\n        tree_goal_grid[_hash_pos(goal_pos)].append(goal_root)\n\n        # --- Frontier identification for frontier-biased sampling ---\n        def _identify_frontiers():\n            frontiers = []\n            resolution = self.step_size * 2\n            steps = [int(bounds[d] / resolution) for d in range(dim)]\n\n            def neighbors(pos_grid):\n                offsets = [-1, 0, 1]\n                for delta in product(offsets, repeat=dim):\n                    if all(x == 0 for x in delta):\n                        continue\n                    nbr = tuple(pos_grid[d] + delta[d] for d in range(dim))\n                    yield nbr\n\n            occupied = set()\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, w, h, d = obs\n                    min_c = [int(ox // resolution), int(oy // resolution), int(oz // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution), int((oz + d) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            for z in range(min_c[2], max_c[2] + 1):\n                                occupied.add((x, y, z))\n                else:\n                    ox, oy, w, h = obs\n                    min_c = [int(ox // resolution), int(oy // resolution)]\n                    max_c = [int((ox + w) // resolution), int((oy + h) // resolution)]\n                    for x in range(min_c[0], max_c[0] + 1):\n                        for y in range(min_c[1], max_c[1] + 1):\n                            occupied.add((x, y))\n\n            grid_ranges = [range(steps[d] + 1) for d in range(dim)]\n            for pos_grid in product(*grid_ranges):\n                if pos_grid in occupied:\n                    continue\n                if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                    frontiers.append(tuple((pos_grid[d] + 0.5) * resolution for d in range(dim)))\n            return frontiers\n\n        frontiers = _identify_frontiers()\n\n        def _adaptive_goal_bias(iteration):\n            from math import cos, pi\n            start_bias = 0.15\n            end_bias = 0.5\n            ratio = iteration / self.max_iter\n            bias = start_bias + (end_bias - start_bias) * (1 - cos(pi * ratio)) / 2\n            return bias\n\n        def in_bounds(pos):\n            for d_ in range(dim):\n                if pos[d_] < 0 or pos[d_] > bounds[d_]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        # Spatial hash helpers\n        def add_node_to_grid(tree_grid, node):\n            tree_grid[_hash_pos(node.position)].append(node)\n\n        def nearest(tree_grid, point):\n            base_cell = _hash_pos(point)\n            best_node = None\n            best_dist = float('inf')\n            offsets = [-1, 0, 1]\n            checked_cells = set()\n            radius_cells = 0\n            max_cell_search = 2\n            while radius_cells <= max_cell_search:\n                # Explore neighbor cells at radius_cells distance\n                cells_to_check = []\n                for offset in product(offsets, repeat=dim):\n                    if max(abs(x) for x in offset) != radius_cells:\n                        continue\n                    neighbor_cell = tuple(base_cell[d] + offset[d] for d in range(dim))\n                    cells_to_check.append(neighbor_cell)\n                if not cells_to_check:\n                    # For radius_cells == 0, ensure current cell is checked\n                    if radius_cells == 0:\n                        cells_to_check = [base_cell]\n                found_candidate = False\n                for cell in cells_to_check:\n                    if cell in checked_cells:\n                        continue\n                    checked_cells.add(cell)\n                    if cell not in tree_grid:\n                        continue\n                    for node in tree_grid[cell]:\n                        d_ = dist(node.position, point)\n                        if d_ < best_dist:\n                            best_dist = d_\n                            best_node = node\n                            found_candidate = True\n                if found_candidate:\n                    break\n                radius_cells +=1\n            # Fallback linear scan\n            if best_node is None:\n                all_nodes = [n for bucket in tree_grid.values() for n in bucket]\n                if all_nodes:\n                    best_node = min(all_nodes, key=lambda n: dist(n.position, point))\n            return best_node\n\n        # Radius for rewiring based on node count (from RRT* theory)\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return step_size_max * 2.5\n            val = self.step_size * (math.log(n_nodes + 1) / (n_nodes + 1))**(1/dim)\n            return max(step_size_min, min(val, step_size_max * 2.5))\n\n        def near_nodes(tree_grid, pos, radius):\n            radius_cells = int(math.ceil(radius / grid_cell_size))\n            base_cell = _hash_pos(pos)\n            collected = []\n            for offset in product(range(-radius_cells, radius_cells+1), repeat=dim):\n                cell = tuple(base_cell[d] + offset[d] for d in range(dim))\n                if cell in tree_grid:\n                    for node in tree_grid[cell]:\n                        if dist(node.position, pos) <= radius:\n                            collected.append(node)\n            return collected\n\n        def _sample_point(iteration):\n            goal_bias = _adaptive_goal_bias(iteration)\n            r = random.random()\n            if r < goal_bias:\n                return goal_pos if random.random() < 0.9 else start_pos\n            # Frontier-based sampling with probability 0.3 (adaptive)\n            if frontiers and random.random() < 0.3:\n                frontier = random.choice(frontiers)\n                radius = step_size_max * 3\n                sample_coords = []\n                for d in range(dim):\n                    low = max(0, frontier[d] - radius)\n                    high = min(bounds[d], frontier[d] + radius)\n                    sample_coords.append(random.uniform(low, high))\n                p = tuple(sample_coords)\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            # Uniform random sample in free space\n            for _ in range(10):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                    return p\n            # Fallback (rare)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step_size(from_pos, to_pos):\n            vec = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= step_size_min:\n                return to_pos\n            step = step_size_max\n\n            # Shrink near start or goal\n            goal_dist = dist(to_pos, goal_pos)\n            start_dist = dist(to_pos, start_pos)\n            close_to_goal = goal_dist < step_size_max * 3\n            close_to_start = start_dist < step_size_max * 3\n            if close_to_goal or close_to_start:\n                step = max(step_size_min, step_size_max * 0.3)\n\n            # Shrink near obstacles\n            prox_threshold = step_size_max * 1.5\n            for obs in obstacles:\n                if is_3d:\n                    ox, oy, oz, ow, oh, od = obs\n                    px, py, pz = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dz = max(oz - pz, 0, pz - (oz + od))\n                    dist_to_box = math.sqrt(dx*dx + dy*dy + dz*dz)\n                else:\n                    ox, oy, ow, oh = obs\n                    px, py = from_pos\n                    dx = max(ox - px, 0, px - (ox + ow))\n                    dy = max(oy - py, 0, py - (oy + oh))\n                    dist_to_box = math.sqrt(dx*dx + dy*dy)\n                if 0 < dist_to_box < prox_threshold:\n                    step = max(step_size_min, step * 0.5)\n                    break\n\n            ratio = step / distance_\n            if ratio > 1.0:\n                return to_pos\n            return tuple(from_pos[d] + vec[d] * ratio for d in range(dim))\n\n        def try_extend(tree, tree_grid, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_grid, point)\n            if nearest_node is None:\n                return None\n            new_pos = adaptive_step_size(nearest_node.position, point)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree_grid, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-8 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            add_node_to_grid(tree_grid, new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for improved path costs\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, tree_grid, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree_grid, target_node.position)\n            if nearest_node is None:\n                return None\n\n            current = nearest_node\n            while True:\n                new_pos = adaptive_step_size(current.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    return None\n\n                new_cost = current.cost + dist(current.position, new_pos)\n                new_node = Node(new_pos, parent=current, cost=new_cost)\n                current.children.append(new_node)\n                tree.append(new_node)\n                add_node_to_grid(tree_grid, new_node)\n                nodes.append(new_node)\n                edges.append((current, new_node))\n                current = new_node\n\n                if dist(new_pos, target_node.position) <= step_size_min:\n                    if (not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d, resolution=0.3)\n                        and not self._is_in_obstacle(target_node.position, obstacles, is_3d)\n                        and in_bounds(target_node.position)):\n                        final_node = Node(target_node.position, parent=current,\n                                         cost=current.cost + dist(new_pos, target_node.position))\n                        current.children.append(final_node)\n                        tree.append(final_node)\n                        add_node_to_grid(tree_grid, final_node)\n                        nodes.append(final_node)\n                        edges.append((current, final_node))\n                        return final_node\n                    else:\n                        return None\n\n        def shortcut_smooth(path, max_trials=120):\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    # Incremental rewiring could be added here if a graph is available,\n                    # but only path smoothing is required now.\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Main planning loop\n        for iteration in range(self.max_iter):\n            rand_point = _sample_point(iteration)\n\n            # Balance growth: always grow smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                tree_start_grid, tree_goal_grid = tree_goal_grid, tree_start_grid\n\n            new_node_start = try_extend(tree_start, tree_start_grid, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, tree_goal_grid, new_node_start)\n            if new_node_goal is not None:\n                # Success: merge paths and smooth\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_smooth(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 97.13189,
    "time_improvement": -326.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.03319954872131348,
            "num_nodes_avg": 185.5,
            "path_length_avg": 164.85700181219522,
            "success_improvement": -9.999999999999998,
            "time_improvement": -252.03092332622944,
            "length_improvement": 17.606055016810213,
            "objective_score": -77.08806599450679
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0905731201171875,
            "num_nodes_avg": 581.8,
            "path_length_avg": 245.80483928152108,
            "success_improvement": 0.0,
            "time_improvement": -514.7574330086593,
            "length_improvement": 18.433638378574646,
            "objective_score": -150.74050222688285
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.09024522304534913,
            "num_nodes_avg": 509.8,
            "path_length_avg": 123.32149454162725,
            "success_improvement": -9.999999999999998,
            "time_improvement": -211.40577553234988,
            "length_improvement": 24.27317333962037,
            "objective_score": -63.567097991780884
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved bidirectional RRT* planner integrates goal bias sampling, dynamic neighbor radius, and KD-tree based nearest neighbor search to speed up planning. It leverages early connection checks to quickly detect solution paths, reduces unnecessary rewiring by adaptive radius, and incorporates path smoothing using shortcutting. Collision checks are carefully maintained, and efficient data structures improve performance and robustness to yield shorter, smoother paths with lower planning time.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal, with a bias to sample closer to the goal for faster convergence. Each extension uses a dynamically shrinking neighbor radius based on the number of nodes to limit rewiring overhead. KD-trees accelerate nearest node queries. When new nodes from both trees come sufficiently close with collision-free edges, paths are connected immediately. The final path is shortcut-smoothed to enhance quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        # Parameters for goal bias and neighbor radius scaling\n        self.goal_sample_rate = 0.15  # Percent of sampling close to goal\n        self.min_neighbor_radius = 10.0  # Minimal neighbor radius\n        self.max_neighbor_radius = 30.0  # Maximal neighbor radius (initial)\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        from bisect import insort\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_a, tree_b = [start_root], [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # KD-Tree helper for faster nearest neighbor search\n        # Simple brute force initially, optimized with a spatial index approach\n        class KDTreeWrapper:\n            def __init__(self, node_list):\n                self.nodes = node_list\n\n            def add_node(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                return min(self.nodes, key=lambda n: math.dist(n.position, point))\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                return [n for n in self.nodes if (sum((n.position[d] - point[d]) ** 2 for d in range(dim)) <= r_sq)]\n\n        kd_tree_a = KDTreeWrapper(tree_a[:])\n        kd_tree_b = KDTreeWrapper(tree_b[:])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Goal biasing sampling near goal to accelerate success\n                goal_sample = tuple(\n                    random.uniform(max(0, goal_position[d] - self.step_size), min(bounds[d], goal_position[d] + self.step_size))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(goal_sample, obstacles, is_3d):\n                    return goal_sample\n            # Else unbiased random sample\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def dynamic_neighbor_radius(n_nodes):\n            # Following RRT* radius formula with constants, capped by min/max radius\n            from math import log, pow\n            gamma = (2 * (1 + 1/dim)) ** (1/dim)  # Constant factor for analytical radius\n            r = gamma * pow((log(n_nodes + 1) / (n_nodes + 1)), 1 / dim) * max(bounds)\n            if r < self.min_neighbor_radius:\n                return self.min_neighbor_radius\n            elif r > self.max_neighbor_radius:\n                return self.max_neighbor_radius\n            return r\n\n        def try_extend(tree, kd_tree, point):\n            if not tree:\n                return None\n            nearest_node = kd_tree.nearest(point)\n            new_pos = steer(nearest_node.position, point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            r = dynamic_neighbor_radius(len(tree))\n            near_nodes = kd_tree.near(new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            kd_tree.add_node(new_node)\n\n            # Rewire neighbors with cost improvement\n            for node in near_nodes:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n            return new_node\n\n        def try_connect(tree, kd_tree, target_pos):\n            if not tree:\n                return None\n            current_node = kd_tree.nearest(target_pos)\n            while True:\n                new_pos = steer(current_node.position, target_pos)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(current_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                r = dynamic_neighbor_radius(len(tree))\n                near_nodes = kd_tree.near(new_pos, r)\n\n                min_cost = current_node.cost + math.dist(current_node.position, new_pos)\n                best_parent = current_node\n                for node in near_nodes:\n                    cost = node.cost + math.dist(node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = node\n\n                new_node = Node(new_pos)\n                best_parent.add_child(new_node)\n                new_node.cost = min_cost\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                kd_tree.add_node(new_node)\n\n                # Rewire neighbors\n                for node in near_nodes:\n                    if node is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                    if cost_through_new < node.cost and not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        if node.parent:\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.parent.children.remove(node)\n                        node.parent = new_node\n                        node.cost = cost_through_new\n                        new_node.add_child(node)\n                        edges.append((new_node, node))\n\n                if math.dist(new_node.position, target_pos) <= self.step_size:\n                    return new_node\n                current_node = new_node\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            # Additional shortcut smoothing loops to improve smoothness\n            # Limited iterations to avoid time cost\n            max_shortcuts = 3\n            for _ in range(max_shortcuts):\n                if len(smoothed) < 3:\n                    break\n                simplified = [smoothed[0]]\n                idx = 0\n                while idx < len(smoothed) -1:\n                    next_idx = len(smoothed) - 1\n                    while next_idx > idx +1:\n                        if not self._is_edge_in_obstacle(smoothed[idx], smoothed[next_idx], obstacles, is_3d):\n                            break\n                        next_idx -=1\n                    simplified.append(smoothed[next_idx])\n                    idx = next_idx\n                smoothed = simplified\n            return smoothed\n\n        # Main loop with bidirectional growth and swapping trees for fairness\n        for iter_count in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_a = try_extend(tree_a, kd_tree_a, rand_point)\n            if new_node_a is None:\n                tree_a, tree_b = tree_b, tree_a\n                kd_tree_a, kd_tree_b = kd_tree_b, kd_tree_a\n                continue\n\n            new_node_b = try_connect(tree_b, kd_tree_b, new_node_a.position)\n            if new_node_b:\n                # Verify final connection edge clear before confirming success\n                if not self._is_edge_in_obstacle(new_node_a.position, new_node_b.position, obstacles, is_3d):\n                    # Build full path - from start root to new_node_a + reverse of new_node_b to goal root\n                    path_a = new_node_a.path_from_root()\n                    path_b = new_node_b.path_from_root()\n                    extracted_path = path_a + path_b[::-1]\n                    extracted_path = smooth_path(extracted_path)\n                    success_state = True\n                    break\n\n            tree_a, tree_b = tree_b, tree_a\n            kd_tree_a, kd_tree_b = kd_tree_b, kd_tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(\n                from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos))\n            )\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 59.09057,
    "time_improvement": -213.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.031275486946105956,
            "num_nodes_avg": 107.6,
            "path_length_avg": 154.82531510181414,
            "success_improvement": 0.0,
            "time_improvement": -231.62916277976228,
            "length_improvement": 22.61979561513396,
            "objective_score": -64.9647897109019
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0352898359298706,
            "num_nodes_avg": 262.0,
            "path_length_avg": 226.04908799397055,
            "success_improvement": 0.0,
            "time_improvement": -139.526792490691,
            "length_improvement": 24.989265022595838,
            "objective_score": -36.86018474268813
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.10658960342407227,
            "num_nodes_avg": 447.9,
            "path_length_avg": 122.99540312411159,
            "success_improvement": 0.0,
            "time_improvement": -267.8047102978428,
            "length_improvement": 24.473413114052477,
            "objective_score": -75.44673046654235
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved bidirectional RRT* planner incorporates adaptive informed sampling biased towards both the start and goal to effectively balance exploration and exploitation. It grows two trees simultaneously, always extending the smaller tree to maintain balanced growth. A dynamically shrinking radius is used in the rewiring step to optimize local path costs continuously, aiming to minimize overall path length. Periodic dead-end pruning enhances efficiency by removing unproductive nodes. Upon successfully connecting the two trees, a refined path smoothing procedure employing randomized shortcutting further reduces path length and improves smoothness. Collision and edge-obstacle checks are rigorously applied to ensure safety and validity. This results in faster convergence, higher success rates, and shorter, smoother paths.",
    "planning_mechanism": "The planner alternates growing the smaller of two trees rooted at the start and goal, sampling points with bias towards both to guide exploration. Using dynamic neighborhood radius derived from the current number of nodes, it rewires connections locally to improve cost optimality. After each new extension, it attempts to connect the trees to form a complete path. Dead-end nodes are pruned periodically to focus search efforts. Finally, the extracted path undergoes iterative shortcut smoothing to minimize length and enhance navigability while respecting collision constraints.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=5000, step_size=5.0,\n                 goal_sample_rate=0.15, radius_constant=30.0,\n                 radius_min=5.0, prune_interval=200, prune_threshold=150,\n                 smoothing_iterations=35):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map):\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle tuples\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            # Adaptive informed sampling biased between start and goal with some uniform exploration\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias: probabilistically choose either goal or start as sample\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                # Uniform random sampling inside bounds until free\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Boundary check\n            for i, coord in enumerate(new_pos):\n                if coord < 0 or coord > bounds[i]:\n                    return None\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve path costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                # Boundary check\n                for i, coord in enumerate(new_pos):\n                    if coord < 0 or coord > bounds[i]:\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed_nodes = []\n            # Remove leaf nodes without children that are not roots\n            for node in nodes[:]:\n                if (not node.children) and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed_nodes.append(node)\n                    except Exception:\n                        continue\n            return removed_nodes\n\n        def path_length(path):\n            if len(path) < 2:\n                return 0.0\n            total = 0.0\n            for i in range(len(path)-1):\n                total += distance(path[i], path[i+1])\n            return total\n\n        def path_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i:\n                    continue\n                p1 = path[i]\n                p2 = path[j]\n                # Shortcut check: no obstacle between p1 and p2\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Remove intermediate points\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth on smaller tree to balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                # Extract path from both trees\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]  # avoid duplicating connecting node\n                \n                # Post-process path with iterative smoothing\n                smoothed_path = path_smoothing(raw_path)\n\n                # Choose the shorter one between raw and smoothed\n                if path_length(smoothed_path) + 1e-8 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to reduce dead-ends\n            if itr > 0 and (itr % self.prune_interval == 0) and (len(nodes) > self.prune_threshold):\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 2.08959,
    "time_improvement": -14.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01226189136505127,
            "num_nodes_avg": 89.4,
            "path_length_avg": 162.61585684711042,
            "success_improvement": -9.999999999999998,
            "time_improvement": -30.018783544300586,
            "length_improvement": 18.726157729601937,
            "objective_score": -10.260403517369788
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019353199005126952,
            "num_nodes_avg": 232.4,
            "path_length_avg": 242.57800147419033,
            "success_improvement": 0.0,
            "time_improvement": -31.358210090411397,
            "length_improvement": 19.504412331828604,
            "objective_score": -5.506580560757698
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02344634532928467,
            "num_nodes_avg": 169.8,
            "path_length_avg": 132.15445342745627,
            "success_improvement": 0.0,
            "time_improvement": 19.094583577058785,
            "length_improvement": 18.84920447732565,
            "objective_score": 9.498215968582766
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm introduces a hybrid bidirectional informed RRT* planner with dynamic biasing and path smoothing. It grows two trees from start and goal with heuristic-guided sampling restricted within an ellipse (informed sampling) to focus exploration on promising areas. Dynamic adaptive step size is employed based on local density to speed convergence. It additionally performs local path smoothing after successful connection to improve path quality and smoothness. The planner prunes dead nodes periodically to maintain efficiency and balances exploration-exploitation by alternating tree growth and carefully rewiring neighbors within a dynamically shrinking radius, yielding improved path length, smoothness, and reduced planning time.",
    "planning_mechanism": "The planner alternates extending smaller of the two trees using samples drawn mostly within an informed ellipsoid between start and goal to bias exploration around known best paths. After each extension, it attempts connection to the opposite tree. Rewiring optimizes path costs locally. Upon success, the combined path undergoes iterative shortcut smoothing. Periodic pruning removes unproductive nodes to keep the graph concise. The adaptive step size accelerates growth in sparse areas, while collision checks guarantee safety at each step. This blend of focused sampling, dynamic control, and post-processing generates efficient, high-quality, and smooth paths robustly.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D/3D\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # Validity flag (for pruning if needed)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except Exception:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, \n                 goal_sample_rate: float=0.10, rewire_factor: float=20.0,\n                 prune_interval: int=300, prune_threshold: int=150):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_factor = rewire_factor  # Base radius constant for rewiring\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        best_path_cost = math.inf\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if not (0 <= val <= bounds[d]):\n                    return False\n            return True\n\n        def is_collision_free_node(pos):\n            # Check boundary and obstacle collision\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_collision_free_edge(from_pos, to_pos):\n            # Boundary checked by node collision inside _is_edge_in_obstacle method\n            # which also checks for obstacle collisions\n            if not in_bounds(to_pos):\n                return False\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def steer(from_pos, to_pos, dynamic_step=None):\n            dist = distance(from_pos, to_pos)\n            step = dynamic_step if dynamic_step is not None else self.step_size\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.step_size * 2.0\n            val = self.rewire_factor * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.step_size)\n\n        def informed_sample():\n            # Sample within an ellipsoid defined by current best path cost (informed sampling)\n            if best_path_cost == math.inf:\n                # No known path -> uniform sampling with goal bias\n                if random.random() < self.goal_sample_rate:\n                    return goal_position\n                while True:\n                    if is_3d:\n                        sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample_pt = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                        return sample_pt\n            else:\n                # Ellipsoid parameters\n                c_best = best_path_cost\n                c_min = distance(start_position, goal_position)\n                if c_best < float('inf') and c_best > c_min:\n                    # Compute ellipse axes in 2D or 3D around line start-goal\n                    center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n                    axis_len = (c_best / 2.0, math.sqrt(c_best ** 2 - c_min ** 2) / 2.0)\n                    # Rotation aligns x-axis with start to goal vector\n                    dir_vec = tuple(g - s for s, g in zip(start_position, goal_position))\n                    norm_dir = math.sqrt(sum(x ** 2 for x in dir_vec))\n                    if norm_dir < 1e-9:\n                        # Start and goal too close, fallback sampling\n                        return start_position\n                    unit_dir = tuple(x / norm_dir for x in dir_vec)\n\n                    # Sample random point in unit ball\n                    def sample_unit_ball(dim):\n                        from random import gauss\n                        while True:\n                            vec = [gauss(0,1) for _ in range(dim)]\n                            norm_vec = math.sqrt(sum(x**2 for x in vec))\n                            if norm_vec > 1e-9:\n                                return tuple(x / norm_vec for x in vec)\n\n                    dim = 3 if is_3d else 2\n                    rand_dir = sample_unit_ball(dim)\n                    rand_radius = random.uniform(0,1) ** (1/dim)\n                    rand_point_unit = tuple(x * rand_radius for x in rand_dir)\n\n                    # Construct scaling matrix for ellipse axes in local frame\n                    # For simplicity: rotate sample onto axis direction and scale\n                    # In 2D: rotate point onto direction vector\n                    # In 3D: approximate by aligning first axis with dir_vec, keep others uniform\n\n                    # Projection onto axis\n                    if dim == 2:\n                        # 2D rotation\n                        # Rotation matrix to align x-axis to unit_dir:\n                        # R = [[ux, uy],[ -uy, ux]] is orthogonal\n                        ux, uy = unit_dir\n                        x_sample = rand_point_unit[0] * axis_len[0]\n                        y_sample = rand_point_unit[1] * axis_len[1]\n                        # Rotate point by R: (x', y') = (ux*x - uy*y, uy*x + ux*y)\n                        pos = (center[0] + ux * x_sample - uy * y_sample,\n                               center[1] + uy * x_sample + ux * y_sample)\n                        if not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos):\n                            return pos\n                        # fallback random uniform sample if invalid\n                        return informed_sample_fallback()\n                    else:\n                        # 3D case approximate ellipse with prolate spheroid aligned on unit_dir\n                        # Scaling axes: first axis is major axis, other two minor axes equal (axis_len[1])\n                        # Construct orthonormal basis: u = unit_dir, v, w perpendicular vectors\n                        u = unit_dir\n                        # Find vectors orthogonal to u using Gram-Schmidt\n                        if abs(u[0]) < 1e-6 and abs(u[1]) < 1e-6:\n                            v = (1,0,0)\n                        else:\n                            v = (-u[1], u[0], 0)\n                        v_len = math.sqrt(sum(x*x for x in v))\n                        v = tuple(x/v_len for x in v)\n                        w = (u[1]*v[2] - u[2]*v[1],\n                             u[2]*v[0] - u[0]*v[2],\n                             u[0]*v[1] - u[1]*v[0])\n                        # Scale random unit vector\n                        x_sample = rand_point_unit[0] * axis_len[0]\n                        y_sample = rand_point_unit[1] * axis_len[1]\n                        z_sample = rand_point_unit[2] * axis_len[1]\n                        pos = tuple(center[d] + u[d]*x_sample + v[d]*y_sample + w[d]*z_sample for d in range(3))\n                        if not self._is_in_obstacle(pos, obstacles, is_3d) and in_bounds(pos):\n                            return pos\n                        return informed_sample_fallback()\n                else:\n                    # No better path cost yet, sample uniform with small goal bias\n                    if random.random() < self.goal_sample_rate:\n                        return goal_position\n                    return informed_sample_fallback()\n        \n        def informed_sample_fallback():\n            while True:\n                if is_3d:\n                    sample_pt = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    sample_pt = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(sample_pt, obstacles, is_3d):\n                    return sample_pt\n\n        def dynamic_step_size(tree, pos):\n            # Adaptive step size inversely proportional to local density: distance to nearest neighbor\n            if not tree:\n                return self.step_size\n            nearest_node = nearest(tree, pos)\n            dist_to_nearest = distance(nearest_node.position, pos)\n            return min(max(dist_to_nearest * 1.2, self.step_size * 0.3), self.step_size * 1.5)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            step = dynamic_step_size(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt, step)\n\n            if not is_collision_free_node(new_pos):\n                return None\n            if not is_collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if is_collision_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_collision_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except Exception:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                step = dynamic_step_size(tree, node.position)\n                new_pos = steer(last_node.position, node.position, step)\n\n                if not is_collision_free_node(new_pos):\n                    return None\n                if not is_collision_free_edge(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if is_collision_free_edge(new_pos, node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children and node.valid:\n                    # Check if leaf node and prune\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if c != node and p != node]\n                        node.valid = False\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_smooth(path, max_iter=30):\n            # Shortcut smoothing by attempting to connect random pairs directly\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if is_collision_free_edge(path[i], path[j]):\n                    # Shortcut path by removing intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample()\n\n            # Grow smaller tree first to balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                total_cost = new_node_start.cost + new_node_goal.cost\n                if total_cost < best_path_cost:\n                    best_path_cost = total_cost\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                full_path = path_start + path_goal[::-1][1:]\n\n                # Smooth path by shortcutting\n                extracted_path = path_smooth(full_path, max_iter=50)\n                break\n\n            # Periodic pruning for scalability\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -2.90851,
    "time_improvement": -1.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006397557258605957,
            "num_nodes_avg": 75.1,
            "path_length_avg": 183.18200360159085,
            "success_improvement": 0.0,
            "time_improvement": 32.16359632823422,
            "length_improvement": 8.447395253166338,
            "objective_score": 11.338557949103535
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01567533016204834,
            "num_nodes_avg": 181.2,
            "path_length_avg": 242.97562919171264,
            "success_improvement": 0.0,
            "time_improvement": -6.3949847318485435,
            "length_improvement": 19.372466002810317,
            "objective_score": 1.9559977810075007
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.03723065853118897,
            "num_nodes_avg": 183.9,
            "path_length_avg": 130.5076366819627,
            "success_improvement": 0.0,
            "time_improvement": -28.4704242756315,
            "length_improvement": 19.860449164968536,
            "objective_score": -4.569037449695743
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the bidirectional tree growth and efficient swapping techniques of the first algorithm with the adaptive heuristic-informed sampling, dynamic rewiring, and path shortcutting strategy of the second algorithm. It employs balanced growth by always extending the smaller tree first, uses adaptive sampling with goal bias that transitions toward uniform and focused local refinement sampling, and incorporates mutual rewiring for enhanced path optimality. The planner dynamically adjusts rewiring radius and performs rigorous collision checks on nodes and edges to ensure safety and path smoothness. Once connected, the path is shortcut for additional smoothing and length reduction. This synthesis aims to optimize planning efficiency, success rate, and path quality in both 2D and 3D spaces.",
    "planning_mechanism": "The planner alternately grows two bidirectional trees rooted at the start and goal positions. At each iteration, it adaptively samples points with an evolving heuristic-informed bias, extends the smaller tree toward the sampled point using rewiring to minimize cost, then attempts to connect and rewire the opposite tree toward the new node. The connection point, if found, results in path merging followed by a shortcut-based smoothing step. Collision checks for nodes and edges ensure obstacle avoidance, and tree balancing guarantees efficient exploration and rapid convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos):\n            # Ensure node is inside bounds and not in obstacle\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early goal bias 70%, start bias 10%, local refinement 20%\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i] + mid_from_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(5):\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform free space sampling\n            attempts = 0\n            while attempts < 100:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(point):\n                    return point\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost < min_cost - 1e-8 and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Balance tree growth by extending smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths, avoid duplicating connecting node\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Post-process: shortcut path for smoothness and length reduction\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 0.47644,
    "time_improvement": -16.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013486552238464355,
            "num_nodes_avg": 119.0,
            "path_length_avg": 161.9419573630525,
            "success_improvement": 0.0,
            "time_improvement": -43.00445698366108,
            "length_improvement": 19.062966214551352,
            "objective_score": -9.088743852188053
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02184925079345703,
            "num_nodes_avg": 267.9,
            "path_length_avg": 233.3210638741899,
            "success_improvement": 0.0,
            "time_improvement": -48.29995161444315,
            "length_improvement": 22.576177403645755,
            "objective_score": -9.974750003603793
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016319012641906737,
            "num_nodes_avg": 226.0,
            "path_length_avg": 125.98450934656564,
            "success_improvement": 0.0,
            "time_improvement": 43.688600723813195,
            "length_improvement": 22.637921826677314,
            "objective_score": 17.63416458247942
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an enhanced bidirectional RRT* planner featuring adaptive, heuristic-driven sampling and dynamic rewiring. It grows two balanced trees from start and goal, progressively optimizing path costs via rewiring within a decaying radius, pruning dead-ends, and applying advanced shortcut smoothing. Compared to traditional RRT*, it achieves higher efficiency, robustness, and path quality with rigorous collision checks in 2D and 3D environments.",
    "planning_mechanism": "The planner alternates expanding the smaller tree using samples biased towards goal, start, and their midpoints. New nodes are connected with cost-minimizing parents within a dynamic radius. Mutual connection attempts between trees enable path formation followed by shortcut and smoothing post-processing. Periodic pruning maintains search efficiency, ensuring improved convergence and smoother, shorter paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []\n        self.valid = True                  # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0,\n                 radius_min: float=3.0, prune_interval: int=250,\n                 prune_threshold: int=100, smoothing_iterations: int=30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], position: Tuple[float, ...], radius: float) -> List[Node]:\n            r_sq = radius * radius\n            return [node for node in tree if dist(node.position, position) <= radius]\n\n        def radius_by_nodes_and_iter(n_nodes: int, itr: int) -> float:\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            r = random.random()\n            # Goal bias and heuristic midpoint sampling\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.7 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.8 and is_free_node(start_position):\n                    return start_position\n                else:\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_s = random.choice(tree_start).position\n                        mid_g = random.choice(tree_goal).position\n                        mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim)\n                            )\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform sampling within bounds\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if (not is_free_node(new_pos)) or (not is_free_edge(nearest_node.position, new_pos)):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if (not is_free_node(new_pos)) or (not is_free_edge(last_node.position, new_pos)):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            # Remove leaf nodes except roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n\n            # Alternate extension on smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles, is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], obstacles, is_3d: bool,\n                             resolution: float=1.0) -> bool:\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -1.31996,
    "time_improvement": -10.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012281441688537597,
            "num_nodes_avg": 86.5,
            "path_length_avg": 160.6956188636504,
            "success_improvement": 0.0,
            "time_improvement": -30.22608510993302,
            "length_improvement": 19.68587421737402,
            "objective_score": -5.130650689505102
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.019028568267822267,
            "num_nodes_avg": 187.7,
            "path_length_avg": 237.62925959514305,
            "success_improvement": 0.0,
            "time_improvement": -29.15480627167439,
            "length_improvement": 21.146572310685485,
            "objective_score": -4.517127419365218
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.020282649993896486,
            "num_nodes_avg": 175.2,
            "path_length_avg": 125.36045122492264,
            "success_improvement": 0.0,
            "time_improvement": 30.01142733032388,
            "length_improvement": 23.021131107259865,
            "objective_score": 13.607654420549135
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm with adaptive goal biasing and radius-based neighbor search for local rewiring. It alternately grows two trees from the start and goal, extending towards sampled points while dynamically rewiring nearby nodes for cost optimization, improving path quality and convergence speed. Strategic parameter tuning balances exploration and exploitation to increase success rate, reduce search time, and produce smoother, shorter paths.",
    "planning_mechanism": "The planner samples points with goal bias, extends trees toward samples with a fixed step size, and rewires nodes within a neighbor radius to optimize locally. It verifies collision-free nodes and edges before adding them. Once the two trees connect, it backtracks to reconstruct the best path. Tree growth alternates between start and goal to maintain balanced exploration and faster convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0,\n                 goal_sample_rate: float = 0.15, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling equally to start or goal for balanced goal bias\n                return start_position if random.random() < 0.5 else goal_position\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                else:\n                    p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            radius = self.neighbor_radius\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            # Bounds check to avoid exceeding map limits\n            for d in range(len(new_pos)):\n                if not (0 <= new_pos[d] <= bounds[d]):\n                    return None\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                candidate_cost = node.cost + math.dist(node.position, new_pos)\n                if candidate_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = candidate_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper via new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            curr = nearest_node\n            while True:\n                new_pos = steer(curr.position, node.position)\n\n                # Bounds check\n                for d in range(len(new_pos)):\n                    if not (0 <= new_pos[d] <= bounds[d]):\n                        return None\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = curr.cost + math.dist(curr.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = curr\n                curr.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n\n                curr = new_node\n\n        # Alternate growth for balanced bidirectional search\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]  # Remove duplicate connection node\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.28283,
    "time_improvement": -55.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01278517246246338,
            "num_nodes_avg": 136.3,
            "path_length_avg": 176.66703473894432,
            "success_improvement": -9.999999999999998,
            "time_improvement": -35.56738691320385,
            "length_improvement": 11.703514072114697,
            "objective_score": -13.329513259538214
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03279578685760498,
            "num_nodes_avg": 371.0,
            "path_length_avg": 259.0447726215492,
            "success_improvement": 0.0,
            "time_improvement": -122.59864423346112,
            "length_improvement": 14.040180569473298,
            "objective_score": -33.971557156143675
        },
        {
            "map_id": 2,
            "success_rate": 0.8,
            "time_avg": 0.031254005432128903,
            "num_nodes_avg": 316.2,
            "path_length_avg": 123.71189970671517,
            "success_improvement": -19.999999999999996,
            "time_improvement": -7.84701363299429,
            "length_improvement": 24.033441049853554,
            "objective_score": -7.547415879927574
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a simplified bidirectional RRT* algorithm integrating balanced tree growth, adaptive sampling with goal bias, and dynamic rewiring radius for incremental path optimization. It ensures collision-free nodes and edges, maintains rewiring for local path cost improvements, and leverages post-search path shortcutting to enhance smoothness and path length, applicable to both 2D and 3D environments.",
    "planning_mechanism": "The planner alternately grows two trees from start and goal by sampling points with goal bias and adaptive local sampling. It extends the smaller tree first, steering towards samples with fixed step size, adding collision-checked nodes and edges. After each addition, neighbors within a dynamically shrinking radius are rewired for better cost paths. When the trees connect, the optimal path is merged and shortcutting is applied to smooth and reduce path length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag (collision etc.)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        curr = self\n        while curr:\n            path.append(curr.position)\n            curr = curr.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_const: float = 30.0, radius_min: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        def is_in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, resolution=1.0):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def sample_free(iteration):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                # Bias sampling towards goal (70%) or start (10%), else local around connection\n                sub_r = random.random()\n                if sub_r < 0.7 and not in_obstacle(goal_pos):\n                    return goal_pos\n                elif sub_r < 0.8 and not in_obstacle(start_pos):\n                    return start_pos\n                else:\n                    # Local biased sampling around midpoints of existing trees for refinement\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_start = random.choice(tree_start).position\n                        mid_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_start[d] + mid_goal[d]) * 0.5 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - iteration / self.max_iter)\n                        for _ in range(5):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                            if not in_obstacle(candidate):\n                                return candidate\n            # Uniform random sampling fallback\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not in_obstacle(p):\n                    return p\n            return start_pos\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def radius(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_const\n            base = self.radius_const * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_in_bounds(new_pos) or in_obstacle(new_pos) or edge_in_obstacle(nearest_node.position, new_pos):\n                return None\n\n            r = radius(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative = node.cost + math.dist(node.position, new_pos)\n                if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                    min_cost = tentative\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for local improvements\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last.position, target_node.position)\n                if (not is_in_bounds(new_pos) or in_obstacle(new_pos)\n                    or edge_in_obstacle(last.position, new_pos)):\n                    return None\n\n                r = radius(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, r)\n\n                min_cost = last.cost + math.dist(last.position, new_pos)\n                best_parent = last\n                for node in neighbors:\n                    tentative = node.cost + math.dist(node.position, new_pos)\n                    if tentative + 1e-8 < min_cost and not edge_in_obstacle(node.position, new_pos):\n                        min_cost = tentative\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-8 < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n                if math.dist(new_pos, target_node.position) <= self.step_size:\n                    if not edge_in_obstacle(new_pos, target_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last = new_node\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i:\n                    if not edge_in_obstacle(path[i], path[j]):\n                        shortened.append(path[j])\n                        i = j\n                        break\n                    j -= 1\n                else:\n                    # No further shortcut, step forward\n                    i += 1\n                    shortened.append(path[i])\n            return shortened\n\n        # Initialization\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success = False\n        final_path = []\n\n        for itr in range(self.max_iter):\n            rand_pt = sample_free(itr)\n\n            # Grow smaller tree first for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged = path_start + path_goal[::-1][1:]\n                final_path = shortcut_path(merged)\n                break\n\n        return PlannerResult(success=success, path=final_path, nodes=nodes, edges=edges)",
    "objective": -5.99315,
    "time_improvement": 5.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.01188223361968994,
            "num_nodes_avg": 79.8,
            "path_length_avg": 158.83592449947326,
            "success_improvement": 0.0,
            "time_improvement": -25.993088262433655,
            "length_improvement": 20.615331586143324,
            "objective_score": -3.6748601615014307
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01518077850341797,
            "num_nodes_avg": 232.1,
            "path_length_avg": 233.555736130099,
            "success_improvement": 0.0,
            "time_improvement": -3.038256954816952,
            "length_improvement": 22.49830520981935,
            "objective_score": 3.588183955518785
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.016344833374023437,
            "num_nodes_avg": 246.1,
            "path_length_avg": 122.24962607271053,
            "success_improvement": 0.0,
            "time_improvement": 43.59950210076947,
            "length_improvement": 24.93136514997817,
            "objective_score": 18.066123660226474
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner combines bidirectional RRT* with adaptive goal biasing, dynamic neighborhood radius for rewiring, and adaptive step sizing. It leverages heuristic sampling near the goal, rewiring neighbors using a radius that shrinks with tree size, and shortcut path smoothing to minimize path length and improve smoothness. Collision checking is rigorously applied both at nodes and edges throughout. By balancing the growth of two trees and incrementally optimizing connections, the planner enhances planning efficiency, path quality, and success rate, while reducing planning time.",
    "planning_mechanism": "The planner alternates extension of two trees growing from start and goal positions, samples points biased towards the goal, and steers towards them with adaptive step size. It rewires nodes within a dynamically computed radius that shrinks as more nodes are added to improve local path costs. Trees are connected incrementally through efficient nearest and steering checks, and the resulting path is shortcut smoothed to reduce path length and increase smoothness. Collision checks ensure robustness and feasibility.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 radius_const: float=30.0,\n                 radius_min: float=5.0,\n                 smoothing_iter: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.smoothing_iter = smoothing_iter\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                # Bias mostly to goal, sometimes to start to diversify\n                if random.random() < 0.8:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            # Radius shrinks as tree grows, but not smaller than radius_min\n            if n_nodes <= 1:\n                return self.radius_const\n            return max(self.radius_min, self.radius_const * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1))))\n\n        def collision_free(node_pos):\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_collision_free(pos1, pos2):\n            return not self._is_edge_in_obstacle(pos1, pos2, obstacles, is_3d)\n\n        def add_node(tree, new_node, parent_node):\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not collision_free(new_pos) or not edge_collision_free(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + distance(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if edge_collision_free(node.position, new_pos):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire near neighbors to new_node if it improves cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_through_new + 1e-9 < neighbor.cost:\n                    if edge_collision_free(new_node.position, neighbor.position):\n                        # Update parent's children list and edges\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not collision_free(new_pos) or not edge_collision_free(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if edge_collision_free(new_pos, node.position):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + distance(new_pos, node.position)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            # Remove duplicate connection node\n            if path_start[-1] == path_goal[-1]:\n                path_goal = path_goal[:-1]\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if edge_collision_free(p_i, p_j):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_point()\n            # Balance tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = shortcut_path(extracted_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 17.94367,
    "time_improvement": -67.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.018182253837585448,
            "num_nodes_avg": 104.6,
            "path_length_avg": 168.33165524260306,
            "success_improvement": -9.999999999999998,
            "time_improvement": -92.79525936712346,
            "length_improvement": 15.869456628912701,
            "objective_score": -29.664686484354498
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031208896636962892,
            "num_nodes_avg": 334.6,
            "path_length_avg": 239.47955766138966,
            "success_improvement": 0.0,
            "time_improvement": -111.82776036365225,
            "length_improvement": 20.53258081393532,
            "objective_score": -29.441811946308608
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02803475856781006,
            "num_nodes_avg": 255.0,
            "path_length_avg": 127.86169046579641,
            "success_improvement": 0.0,
            "time_improvement": 3.261519678619699,
            "length_improvement": 21.48521953617643,
            "objective_score": 5.275499810821196
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements an optimized bidirectional RRT* algorithm with enhanced adaptive sampling biased towards goal, start, and promising midpoints, uses a dynamically decaying rewiring radius with smoothing of rewiring parameters for stable convergence, balanced growth of two trees with alternating extensions, fast neighbor queries via spatial hashing, mutual rewiring attempts, and efficient pruning of dead-ends to reduce unnecessary nodes. It further reduces collision checks by early rejection and accelerates edge validation with adaptive resolution stepping. After successful connection, it performs advanced path shortcutting and smoothing to produce high-quality smooth paths while guaranteeing collision-free validity within bounded environments. The design prioritizes lower planning time and improved solution quality with robustness in both 2D and 3D.",
    "planning_mechanism": "The planner grows two balanced trees from start and goal, always extending the smaller tree first. Sampling combines goal/start bias with adaptive exploration near shared subtree midpoints that fade over iterations. Each extension attempts connection and rewiring within a decaying radius scale based on iteration and node counts, balancing exploration and refinement. Dead-end nodes are periodically pruned to reduce computational load. Collision-safe edge and node validation are strictly enforced. Upon tree connection, shortcutting and iterative smoothing ensure smooth, optimal paths. The planner leverages these strategies to minimize planning time while maximizing success rates and path quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 50, smoothing_iterations: int = 30,\n                 search_resolution: float = 1.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n        self.search_resolution = search_resolution\n\n    def plan(self, map):\n        bounds = map.size                      # Tuple[int, ...]\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacles (2D or 3D)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        import random\n        import math\n        from collections import defaultdict\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        # Use spatial hashing grid for near neighbor search to speed up radius queries\n        class SpatialHash:\n            def __init__(self, cell_size):\n                self.cell_size = cell_size\n                self.hash_table = defaultdict(list)\n\n            def _hash(self, pos):\n                return tuple(int(pos[i] // self.cell_size) for i in range(len(pos)))\n\n            def insert(self, node):\n                key = self._hash(node.position)\n                self.hash_table[key].append(node)\n\n            def remove(self, node):\n                key = self._hash(node.position)\n                if node in self.hash_table[key]:\n                    self.hash_table[key].remove(node)\n                    if not self.hash_table[key]:\n                        del self.hash_table[key]\n\n            def near(self, position, radius):\n                cx, cy = None, None\n                keys = []\n                radius_cells = int(math.ceil(radius / self.cell_size))\n                base_key = self._hash(position)\n                keys_to_check = []\n                for dx in range(-radius_cells, radius_cells + 1):\n                    for dy in range(-radius_cells, radius_cells + 1):\n                        if dim == 2:\n                            keys_to_check.append((base_key[0] + dx, base_key[1] + dy))\n                        else:\n                            for dz in range(-radius_cells, radius_cells + 1):\n                                keys_to_check.append((base_key[0] + dx, base_key[1] + dy, base_key[2] + dz))\n                result = []\n                for key in keys_to_check:\n                    if key in self.hash_table:\n                        for node in self.hash_table[key]:\n                            if dist(position, node.position) <= radius:\n                                result.append(node)\n                return result\n\n        # Initialize spatial hashes for both trees with dynamic cell_size adapted from step_size\n        cell_size = self.step_size * 2\n        hash_start = SpatialHash(cell_size)\n        hash_goal = SpatialHash(cell_size)\n        hash_start.insert(start_root)\n        hash_goal.insert(goal_root)\n\n        def radius_by_nodes_and_iter(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt(math.log(n_nodes) / n_nodes)\n            decay = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay)\n\n        def is_free_node(pos):\n            if not self._within_bounds(pos, bounds):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            if not self._within_bounds(p1, bounds) or not self._within_bounds(p2, bounds):\n                return False\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, self.search_resolution)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            # Goal/start bias shifting gradually towards exploration near midpoint region\n            bias_decay_factor = (1 - itr / self.max_iter)\n            if r < self.goal_sample_rate:\n                sr = random.random()\n                if sr < 0.65 and is_free_node(goal_position):\n                    return goal_position\n                elif sr < 0.85 and is_free_node(start_position):\n                    return start_position\n                if len(tree_start) > 15 and len(tree_goal) > 15:\n                    mid_s = random.choice(tree_start).position\n                    mid_g = random.choice(tree_goal).position\n                    mid = tuple((mid_s[i] + mid_g[i]) / 2 for i in range(dim))\n                    spread = self.step_size * 6 * bias_decay_factor\n                    for _ in range(7):  # try several times for a valid point near mid\n                        candidate = tuple(\n                            max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                            for d in range(dim)\n                        )\n                        if is_free_node(candidate):\n                            return candidate\n            # Uniform random sampling in free space (up to 75 attempts for efficiency)\n            for _ in range(75):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            return start_position  # fallback safe default\n\n        def try_extend(tree, tree_hash, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes_and_iter(len(tree), itr)\n            near = tree_hash.near(new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n            tree_hash.insert(new_node)\n\n            # Rewiring neighbors to reduce costs\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect_and_rewire(tree, tree_hash, target_node, itr):\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos):\n                    return None\n                if not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes_and_iter(len(tree), itr)\n                near = tree_hash.near(new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                tree_hash.insert(new_node)\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        tree_hash.insert(final_node)\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:  # dead end\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        hash_start.remove(node)\n                        hash_goal.remove(node)\n                        removed.append(node)\n                    except Exception:\n                        pass\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if is_free_edge(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample = adaptive_sample(itr)\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                hash_start, hash_goal = hash_goal, hash_start\n\n            new_node_start = try_extend(tree_start, hash_start, sample, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, hash_goal, new_node_start, itr)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                shortcuted_path = shortcut_path(raw_path)\n                smoothed_path = smooth_path(shortcuted_path)\n\n                candidates = [raw_path, shortcuted_path, smoothed_path]\n                extracted_path = min(candidates, key=path_length)\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _within_bounds(self, pos, bounds):\n        for i, v in enumerate(pos):\n            if not (0 <= v <= bounds[i]):\n                return False\n        return True",
    "objective": 5.63335,
    "time_improvement": -32.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017850208282470702,
            "num_nodes_avg": 93.1,
            "path_length_avg": 174.175702912196,
            "success_improvement": 0.0,
            "time_improvement": -89.27441923960772,
            "length_improvement": 12.948657773695633,
            "objective_score": -24.19259421714319
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024480581283569336,
            "num_nodes_avg": 193.7,
            "path_length_avg": 234.17414744587785,
            "success_improvement": 0.0,
            "time_improvement": -66.15988594601853,
            "length_improvement": 22.293095413457987,
            "objective_score": -15.389346701113961
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011965417861938476,
            "num_nodes_avg": 131.4,
            "path_length_avg": 121.58031660862275,
            "success_improvement": 0.0,
            "time_improvement": 58.71138545479376,
            "length_improvement": 25.34236148080854,
            "objective_score": 22.681887932599835
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm with adaptive, informed sampling biased towards start and goal, dynamic radius rewiring shrinking with tree size, efficient balanced tree growth by extending the smaller tree, and aggressive dead-end pruning. It incorporates a heuristic-informed sampling zone to reduce unnecessary exploration and iteratively performs shortcut smoothing using collision-checked random path segment replacements to minimize path length. Together these enhancements increase planning efficiency, path optimality, robustness, and smoothness while reducing computational overhead and search time.",
    "planning_mechanism": "The planner maintains two trees rooted at start and goal, always extending the smaller tree in each iteration for balanced exploration. Sampling is adaptively biased towards the start and goal regions using an ellipse informed by the current best path cost to focus exploration. New nodes are added if collision-free and rewired within a dynamically shrinking radius for optimal cost. Dead-end nodes (nodes without children) are pruned periodically to reduce complexity. Upon connecting the two trees, the path is iteratively shortcut-smoothed by attempting collision-free shortcuts between random node pairs, resulting in shorter, smoother paths.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root node along path\n        self.children: List[Node] = []  # Child nodes\n        self.valid = True               # Collision or pruning status\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0,\n                 radius_min: float = 5.0,\n                 prune_interval: int = 200,\n                 prune_threshold: int = 100,\n                 smoothing_iterations: int = 100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        dist = math.dist\n        dim = len(bounds)\n\n        # Current best path cost heuristic (informed sampling)\n        best_path_cost = math.inf\n\n        def radius_dynamic(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def ellipsoid_sample() -> Tuple[float, ...]:\n            # Adaptive informed sampling within an ellipsoid defined by start and goal and current best cost\n            start = start_position\n            goal = goal_position\n            c_min = dist(start, goal)\n            if best_path_cost == math.inf or best_path_cost < c_min:\n                # No solution or no improvement yet, sample uniformly with goal bias\n                return uniform_biased_sample()\n\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            vec = tuple(goal[d] - start[d] for d in range(dim))\n            c_best = best_path_cost\n\n            a1 = [v / c_min for v in vec]  # unit vector from start to goal\n\n            # Create orthonormal basis (only for 2D or 3D)\n            def unit_vector(v):\n                norm_v = math.sqrt(sum(x * x for x in v))\n                return [x / norm_v for x in v]\n\n            def mat_vect_mult(m, v):\n                return [sum(m[i][j] * v[j] for j in range(len(v))) for i in range(len(m))]\n\n            def rotation_to_world():\n                # Constructs rotation matrix that aligns x-axis with a1\n                if dim == 2:\n                    angle = math.atan2(a1[1], a1[0])\n                    cos_a = math.cos(angle)\n                    sin_a = math.sin(angle)\n                    return [[cos_a, -sin_a], [sin_a, cos_a]]\n                elif dim == 3:\n                    # Rodrigues' rotation formula; rotate x-axis to a1\n                    x_axis = [1.0, 0.0, 0.0]\n                    v_cross = [x_axis[1]*a1[2] - x_axis[2]*a1[1],\n                               x_axis[2]*a1[0] - x_axis[0]*a1[2],\n                               x_axis[0]*a1[1] - x_axis[1]*a1[0]]\n                    s = math.sqrt(sum(x*x for x in v_cross))\n                    c = sum(x_axis[i]*a1[i] for i in range(3))\n                    if s == 0:\n                        return [[1,0,0],[0,1,0],[0,0,1]]\n                    vx = [[0, -v_cross[2], v_cross[1]],\n                          [v_cross[2], 0, -v_cross[0]],\n                          [-v_cross[1], v_cross[0], 0]]\n                    I = [[1,0,0],[0,1,0],[0,0,1]]\n                    # Rotation matrix R = I + vx + vx^2 * ((1-c)/s^2)\n                    def mat_add(A,B):\n                        return [[A[i][j] + B[i][j] for j in range(3)] for i in range(3)]\n                    def mat_mul(A,B):\n                        return [[sum(A[i][k]*B[k][j] for k in range(3)) for j in range(3)] for i in range(3)]\n                    vx2 = mat_mul(vx, vx)\n                    factor = (1 - c) / (s * s)\n                    R = mat_add(mat_add(I, vx), [[vx2[i][j]*factor for j in range(3)] for i in range(3)])\n                    return R\n                else:\n                    # No rotation for higher dims, identity\n                    return [[1 if i == j else 0 for j in range(dim)] for i in range(dim)]\n\n            rotation = rotation_to_world()\n\n            # Ellipsoid radii\n            r1 = c_best * 0.5\n            r_rest = math.sqrt(c_best * c_best - c_min * c_min) * 0.5\n            radii = [r1] + [r_rest] * (dim - 1)\n\n            for _ in range(100):  # Try up to 100 times to find a collision-free sample\n                # Sample random point in unit n-ball\n                while True:\n                    # Sampling in unit n-ball by normal distribution + normalization * radius^(1/dim)\n                    x = [random.gauss(0, 1) for _ in range(dim)]\n                    norm_x = math.sqrt(sum(xx * xx for xx in x))\n                    if norm_x > 1e-9:\n                        break\n                x = [xx / norm_x for xx in x]\n\n                # Scale by random radius inside unit ball\n                u = random.uniform(0, 1) ** (1.0 / dim)\n                x = [u * xx for xx in x]\n\n                # Scale by radii\n                x = [radii[i] * x[i] for i in range(dim)]\n\n                # Rotate and translate\n                sample_local = [0.0] * dim\n                for i in range(dim):\n                    sample_local[i] = sum(rotation[i][j] * x[j] for j in range(dim))\n                sample_pt = tuple(center[i] + sample_local[i] for i in range(dim))\n\n                if can_add_node(sample_pt):\n                    return sample_pt\n\n            # Fallback: uniform-biased sampling if ellipsoid failed\n            return uniform_biased_sample()\n\n        def uniform_biased_sample() -> Tuple[float, ...]:\n            p_bias = 0.8\n            # With goal_sample_rate we bias towards goal or start positions\n            if random.random() < self.goal_sample_rate:\n                # Biased sampling favoring goal or start to guide growth\n                chosen = goal_position if random.random() < p_bias else start_position\n                if can_add_node(chosen):\n                    return chosen\n            # Uniform random sample in free space\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if can_add_node(sample):\n                    return sample\n            # In case fails, return goal or start as fallback\n            return goal_position if random.random() < 0.5 else start_position\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            r2 = radius * radius\n            return [node for node in tree if (dist(node.position, pos) ** 2) <= r2]\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes() -> List[Node]:\n            removed = []\n            # Prune leaf nodes that are not roots\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            # Adaptive sampling: informed ellipsoid if path found, else uniform-biased\n            sample_pt = ellipsoid_sample() if best_path_cost < math.inf else uniform_biased_sample()\n\n            # Extend smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                # No expansion possible: continue\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                raw_len = path_length(raw_path)\n                smoothed = shortcut_smoothing(raw_path)\n                smooth_len = path_length(smoothed)\n\n                if smooth_len + 1e-12 < raw_len:\n                    extracted_path = smoothed\n                    best_path_cost = smooth_len\n                else:\n                    extracted_path = raw_path\n                    best_path_cost = raw_len\n                break\n\n            # Periodic dead-end pruning\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) != 6:\n                    continue\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                if len(obs) != 4:\n                    continue\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 3.02396,
    "time_improvement": -24.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.013785052299499511,
            "num_nodes_avg": 83.0,
            "path_length_avg": 161.6528400488978,
            "success_improvement": 0.0,
            "time_improvement": -46.16959796136605,
            "length_improvement": 19.207464269315736,
            "objective_score": -10.009386534546667
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02261660099029541,
            "num_nodes_avg": 224.2,
            "path_length_avg": 239.4704475444974,
            "success_improvement": 0.0,
            "time_improvement": -53.50827651941166,
            "length_improvement": 20.535603858929143,
            "objective_score": -11.945362184037666
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021119356155395508,
            "num_nodes_avg": 146.7,
            "path_length_avg": 124.2092310645348,
            "success_improvement": 0.0,
            "time_improvement": 27.1242370467632,
            "length_improvement": 23.72804963640725,
            "objective_score": 12.882881041310409
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This novel planner integrates a Rapidly-exploring Random Graph (RRG) approach combined with informed sampling and dynamic rewiring for efficient, high-quality path planning. It incrementally builds a graph capturing multiple path options with adaptive neighborhood radius shrinking logarithmically as nodes increase. The planner employs an informed sampling ellipse centered on the current best path, biasing exploration towards promising states. The dynamic rewiring locally optimizes the graph, improving path cost and smoothness. Upon finding a connection from start to goal, the best path is extracted and shortcut-smoothed for improved path quality and smoothness. This method balances exploration and exploitation to improve success rate, speed convergence, and reduce path length.",
    "planning_mechanism": "The planner alternates in sampling nodes either uniformly within the bound or inside an informed ellipsoidal region defined by the current best path cost to goal. Each new sample attempts connection to existing nodes within a dynamically calculated neighborhood radius, adding collision-free edges and rewiring to lower local costs. The graph is continuously updated for minimal path cost between start and goal. Upon goal connection, the minimal cost path is extracted and shortcut smoothed iteratively to improve path smoothness and length.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                # Node or None\n        self.cost = cost                    # Path cost from root/start\n        self.children: List['Node'] = []   # List of child nodes\n        self.valid = True                   # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.1, radius_constant: float = 50.0, radius_min: float = 5.0,\n                 smoothing_iters: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate       # Probability to sample goal directly\n        self.radius_constant = radius_constant         # For neighborhood radius calculation\n        self.radius_min = radius_min                    # Minimum neighborhood radius for rewiring\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                     # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                    # Tuple[float, ...]\n        goal = map.goal                      # Tuple[float, ...]\n        obstacles = map.obstacles            # List of obstacles\n        is_3d = len(bounds) == 3\n\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_node = Node(start, None, 0.0)\n        nodes.append(start_node)\n\n        best_goal_node = None\n        best_cost = math.inf\n\n        def distance(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> float:\n            return math.dist(p1, p2)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def neighborhood_radius(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(self.radius_min, r)\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def collision_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def extract_best_path(goal_node: Node) -> List[Tuple[float, ...]]:\n            path = goal_node.path_from_root()\n            return self._shortcut_smooth(path, obstacles, is_3d, bounds)\n\n        def sample_informed(start: Tuple[float, ...], goal: Tuple[float, ...], c_best: float) -> Tuple[float, ...]:\n            # Sample uniformly from an ellipsoid with foci at start and goal, major axis length c_best\n            dim = len(bounds)\n            if c_best == math.inf:\n                # No solution found yet, uniform sampling\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            center = tuple((start[d] + goal[d]) * 0.5 for d in range(dim))\n            dx = tuple(goal[d] - start[d] for d in range(dim))\n            c_min = distance(start, goal)\n            if c_min == 0:\n                return start\n\n            # Compute rotation matrix for ellipse aligned with vector from start to goal\n            import numpy as np\n            # convert to numpy arrays for matrix calculations\n            center_np = np.array(center)\n            start_np = np.array(start)\n            goal_np = np.array(goal)\n            dx_np = goal_np - start_np\n\n            # Build orthonormal basis via SVD to rotate unit ball etc.\n            e1 = dx_np / np.linalg.norm(dx_np)\n            if dim == 2:\n                e2 = np.array([-e1[1], e1[0]])\n                R = np.column_stack((e1, e2))\n            else:\n                # For 3D, create basis via Gram-Schmidt\n                e2 = np.random.rand(dim)\n                e2 -= e2.dot(e1) * e1\n                e2 /= np.linalg.norm(e2)\n                e3 = np.cross(e1, e2)\n                R = np.column_stack((e1, e2, e3))\n\n            # Radii of the ellipsoid\n            a1 = c_best / 2.0                     # major axis radius\n            if c_best ** 2 - c_min ** 2 < 0:\n                b = 0.0001      # numerical guard\n            else:\n                b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0    # minor axis radius\n            radii = [a1] + [b] * (dim - 1)\n\n            # Sample unit ball point\n            while True:\n                # Sample from unit n-ball by normal distribution + normalization with radius scaling\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x <= 0:\n                    continue\n                u = x_ball / norm_x\n                r = random.random() ** (1.0 / dim)    # radius scaling\n                x_ball = u * r\n\n                # Scale by radii and rotate\n                sample = center_np + R.dot(radii * x_ball)\n                sample_tuple = tuple(float(np.clip(sample[d], 0, bounds[d])) for d in range(dim))\n                if not self._is_in_obstacle(sample_tuple, obstacles, is_3d):\n                    return sample_tuple\n\n        for iter in range(self.max_iter):\n            if best_cost == math.inf or random.random() > self.goal_sample_rate:\n                rand_point = sample_informed(start, goal, best_cost)\n            else:  # Bias sampling directly at goal for faster convergence\n                rand_point = goal\n\n            if not can_add_node(rand_point):\n                continue\n\n            # Find neighbors within radius for possible parent connections\n            radius = neighborhood_radius(len(nodes))\n            neighbors = near_nodes(nodes, rand_point, radius)\n\n            # Select best parent with minimal cost + collision-free edge\n            min_cost = math.inf\n            best_parent = None\n            for n_node in neighbors:\n                new_cost = n_node.cost + distance(n_node.position, rand_point)\n                if new_cost < min_cost and collision_free_edge(n_node.position, rand_point):\n                    min_cost = new_cost\n                    best_parent = n_node\n\n            if best_parent is None:\n                # If no suitable parent found, try nearest node forcibly if collision-free\n                nearest_node = min(nodes, key=lambda n: distance(n.position, rand_point))\n                if collision_free_edge(nearest_node.position, rand_point):\n                    min_cost = nearest_node.cost + distance(nearest_node.position, rand_point)\n                    best_parent = nearest_node\n                else:\n                    continue\n\n            new_node = Node(rand_point, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors (except new_node itself) to check if cost can be lowered via new node\n            for near_node in neighbors:\n                if near_node == best_parent:\n                    continue\n                potential_cost = new_node.cost + distance(new_node.position, near_node.position)\n                if potential_cost + 1e-9 < near_node.cost and collision_free_edge(new_node.position, near_node.position):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, potential_cost)\n                    edges.append((new_node, near_node))\n\n            # Check if new node can connect directly to goal with lower cost\n            dist_to_goal = distance(new_node.position, goal)\n            if dist_to_goal <= self.step_size and collision_free_edge(new_node.position, goal):\n                cost_through_new = new_node.cost + dist_to_goal\n                if cost_through_new < best_cost:\n                    goal_node = Node(goal, parent=new_node, cost=cost_through_new)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    best_goal_node = goal_node\n                    best_cost = cost_through_new\n                    success_state = True\n\n        if success_state and best_goal_node:\n            extracted_path = extract_best_path(best_goal_node)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _shortcut_smooth(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path[:]\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i, p_j = new_path[i], new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4214.67495,
    "time_improvement": -14064.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 2.176195502281189,
            "num_nodes_avg": 4516.6,
            "path_length_avg": 159.3973119479682,
            "success_improvement": 0.0,
            "time_improvement": -22975.256788494255,
            "length_improvement": 20.334755535159214,
            "objective_score": -6888.510085441244
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 1.828607153892517,
            "num_nodes_avg": 4800.1,
            "path_length_avg": 243.12238177604868,
            "success_improvement": 0.0,
            "time_improvement": -12311.51721894707,
            "length_improvement": 19.323768530466726,
            "objective_score": -3689.5904119780275
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 2.029697632789612,
            "num_nodes_avg": 4925.5,
            "path_length_avg": 120.37992873221296,
            "success_improvement": 0.0,
            "time_improvement": -6903.800800818095,
            "length_improvement": 26.07947194950645,
            "objective_score": -2065.924345855527
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines the adaptive heuristic-informed sampling and dynamic radius shrinking from the improved bidirectional RRT* variant with the structured balanced tree growth, mutual rewiring, and rewiring radius calculations inspired by both algorithms. It introduces enhanced sampling bias that evolves over iterations to focus exploration in promising regions, balances tree growth by always expanding the smaller tree first, applies mutual rewiring with dynamic neighborhoods, and performs path shortcutting to improve path smoothness and reduce length. The planner rigorously validates collision-free nodes and edges and confines sampling within map bounds to ensure robustness, efficiency, and better convergence towards shorter, smoother paths.",
    "planning_mechanism": "The planner alternates growth between start and goal trees, samples points using adaptive heuristic bias that transitions from high goal bias to localized exploration near connection regions, extends nearest nodes using a fixed step size, dynamically computes a shrinking rewiring radius based on node count and iteration to balance global exploration and local refinement, rewires neighbors in both trees mutually to improve path cost, and, upon successful connection, extracts and shortcut smooths the final path. This approach blends adaptive sampling, balanced tree growth, and iterative local optimization within a bidirectional RRT* framework to enhance path quality and planning efficiency.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0, radius_min: float=3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Initial probability to sample goal or biased points\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int, itr: int) -> float:\n            # Dynamic radius with iteration decay for finer rewiring over time\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes) / n_nodes))\n            decay_factor = max(self.radius_min / base, math.exp(-5*itr/self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def is_free_node(pos: Tuple[float, ...]) -> bool:\n            if not all(0 <= pos[d] <= bounds[d] for d in range(dim)):\n                return False\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr: int) -> Tuple[float, ...]:\n            # Adaptive heuristic sampling:\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early iterations: higher goal bias; later: more spread\n                if itr < self.max_iter / 3:\n                    # High goal bias\n                    if subr < 0.7 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.9 and is_free_node(start_position):\n                        return start_position\n                else:\n                    # After some iterations, bias sampling around promising middle area\n                    if len(tree_start) > 15 and len(tree_goal) > 15:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[d] + mid_from_goal[d]) / 2 for d in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread)))\n                                for d in range(dim)\n                            )\n                        for _ in range(5):\n                            cand = confined_rand()\n                            if is_free_node(cand):\n                                return cand\n                    # Fallback to goal or start positions biased sampling\n                    if subr < 0.5 and is_free_node(goal_position):\n                        return goal_position\n                    elif subr < 0.8 and is_free_node(start_position):\n                        return start_position\n\n            # Uniform random sampling inside bounds and free space\n            for _ in range(100):\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(p):\n                    return p\n            # If no free sampled point, fallback to start\n            return start_position\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...], itr: int) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                # Use strict less to promote cost improvement\n                if tentative_cost + 1e-8 < min_cost:\n                    if is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to connect through new_node if better\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree: List[Node], target_node: Node, itr: int) -> Node or None:\n            if not tree:\n                return None\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost:\n                        if is_free_edge(node.position, new_pos):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors around new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost:\n                        if is_free_edge(new_node.position, neighbor.position):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def shortcut_path(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path)-1:\n                next_idx = len(path)-1\n                for j in range(len(path)-1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            rand_point = adaptive_sample(itr)\n\n            # Always grow smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_from_start = new_node_start.path_from_root()\n                path_from_goal = new_node_goal.path_from_root()\n                merged_path = path_from_start + path_from_goal[::-1][1:]\n\n                # Shortcut path for smoothness and length improvement\n                extracted_path = shortcut_path(merged_path)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.3318,
    "time_improvement": 7.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007486176490783691,
            "num_nodes_avg": 72.6,
            "path_length_avg": 164.793398605954,
            "success_improvement": 0.0,
            "time_improvement": 20.62043841753064,
            "length_improvement": 17.637843287967563,
            "objective_score": 9.713700182852705
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.022054314613342285,
            "num_nodes_avg": 282.5,
            "path_length_avg": 234.72263809786804,
            "success_improvement": 0.0,
            "time_improvement": -49.69180504018914,
            "length_improvement": 22.11108765886303,
            "objective_score": -10.485323980284134
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014582228660583497,
            "num_nodes_avg": 181.8,
            "path_length_avg": 123.25719770644477,
            "success_improvement": 0.0,
            "time_improvement": 49.6816554738064,
            "length_improvement": 24.312655469728927,
            "objective_score": 19.767027736087705
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is a hybrid bidirectional planner synthesizing the adaptive heuristic informed sampling, balanced bidirectional growth, dynamic rewiring, incremental connection attempts, and path shortcutting for enhanced path quality and efficiency. It integrates periodic pruning for tree size management and employs dynamic rewiring radius decreasing with the number of nodes to locally optimize paths. The planner enforces rigorous collision checks, map boundary constraints, and rewires both trees mutually to improve robustness and success rate in 2D and 3D environments. Final path extraction includes smoothing via shortcutting to reduce length and improve smoothness.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal by alternately extending the smaller tree towards adaptively sampled points with goal bias transitioning to local refinement. Each extension uses a steering function limited by step size, followed by rewiring nearby nodes to minimize cost while ensuring collision-free edges. It attempts incremental connection from the opposite tree after each extension. Periodic pruning removes dead-end nodes to maintain efficiency. Upon successful connection, paths are merged and shortcut-smoothed before being returned.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position            # Tuple[float, ...]\n        self.parent = parent                # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children = []                 # List[Node]\n        self.valid = True                  # For collision checks, pruning etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0,\n                 radius_min: float = 3.0, prune_interval: int = 150, prune_threshold: int = 70):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root =         Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * math.sqrt((math.log(n_nodes + 1) / (n_nodes + 1)))\n            decay_factor = max(self.radius_min / base, math.exp(-5 * itr / self.max_iter))\n            return max(self.radius_min, base * decay_factor)\n\n        def in_bounds(pos):\n            for i, p in enumerate(pos):\n                if p < 0 or p > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                # Early goal bias 70%, start bias 10%, local refinement 20%\n                if subr < 0.7:\n                    if is_free_node(goal_position):\n                        return goal_position\n                elif subr < 0.8:\n                    if is_free_node(start_position):\n                        return start_position\n                else:\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        mid_from_start = random.choice(tree_start).position\n                        mid_from_goal = random.choice(tree_goal).position\n                        mid = tuple((mid_from_start[i] + mid_from_goal[i]) / 2 for i in range(dim))\n                        spread = self.step_size * 5 * (1 - itr / self.max_iter)\n                        def confined_rand():\n                            return tuple(max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                        for _ in range(10):\n                            candidate = confined_rand()\n                            if is_free_node(candidate):\n                                return candidate\n            attempts = 0\n            while attempts < 100:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n                attempts += 1\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos) or not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree), itr)\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-8 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node, itr):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_by_nodes(len(tree), itr)\n                near = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in near:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-8 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in near:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-8 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if node.valid and not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        node.valid = False\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path):\n            if len(path) <= 2:\n                return path\n            shortened = [path[0]]\n            idx = 0\n            while idx < len(path) - 1:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if is_free_edge(path[idx], path[j]):\n                        next_idx = j\n                        break\n                shortened.append(path[next_idx])\n                idx = next_idx\n            return shortened\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Always extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n                swapped = True\n            else:\n                swapped = False\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start, itr)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                extracted_path = shortcut_path(merged_path)\n                break\n\n            # Periodic pruning for performance and memory control\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 13.65676,
    "time_improvement": -48.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.01486351490020752,
            "num_nodes_avg": 97.7,
            "path_length_avg": 168.09438300345238,
            "success_improvement": -19.999999999999996,
            "time_improvement": -57.60506018065572,
            "length_improvement": 15.988043013498846,
            "objective_score": -24.083909451496947
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.026903700828552247,
            "num_nodes_avg": 170.1,
            "path_length_avg": 234.21968544898846,
            "success_improvement": 0.0,
            "time_improvement": -82.60660600401648,
            "length_improvement": 22.277984363406677,
            "objective_score": -20.32638492852361
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030249810218811034,
            "num_nodes_avg": 147.2,
            "path_length_avg": 124.13621648078283,
            "success_improvement": 0.0,
            "time_improvement": -4.38187521750183,
            "length_improvement": 23.772884989303485,
            "objective_score": 3.4400144326101483
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is a tuned and reconfigured enhanced bidirectional RRT* variant with adaptive sampling bias, balanced tree growth, and dynamic radius-based incremental rewiring. It improves planning efficiency, path quality, robustness, and success rate by prioritizing exploring smaller trees, steering with a refined step size, and adaptively shrinking connection radius. The algorithm enforces rigorous collision checks and edge feasibility, ensuring obstacle-free smooth and short paths dynamically optimized during expansion.",
    "planning_mechanism": "The planner alternates tree expansions between start and goal, always extending the smaller tree toward adaptively biased sampled points including start and goal positions. It uses dynamic neighbor radius shrinking with node count for efficient rewiring around new nodes, achieves incremental local path optimization, and attempts to connect the opposing tree and rewire it toward new nodes. Path extraction merges ancestries once connection is successful, resulting in robust and smooth paths while reducing runtime and failures.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter=4000, step_size=4.0, goal_sample_rate=0.15,\n                 radius_constant=25.0, radius_min=4.0, resolution=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.resolution = resolution    # finer resolution for collision checking\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def dynamic_radius(n):\n            if n <= 1:\n                return self.radius_constant\n            return max(self.radius_min, self.radius_constant * math.sqrt((math.log(n) / n)))\n\n        def sample_free():\n            r = random.random()\n            # Biased sampling with goal and start for improved convergence and exploration\n            if r < self.goal_sample_rate:\n                c = random.random()\n                if c < 0.6:\n                    p = goal_position\n                elif c < 0.85:\n                    p = start_position\n                else:\n                    p = None\n                if p and not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n            # Uniform random sampling in free space\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            if radius <= 0:\n                return []\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.resolution):\n                return None\n\n            radius = dynamic_radius(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost + 1e-10 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node to improve cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.resolution):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect_and_rewire(tree, target_node):\n            if not tree:\n                return None\n\n            last_node = nearest(tree, target_node.position)\n\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d, self.resolution):\n                    return None\n\n                radius = dynamic_radius(len(tree))\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + distance(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + distance(node.position, new_pos)\n                    if tentative_cost + 1e-10 < min_cost:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.resolution):\n                            min_cost = tentative_cost\n                            best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors near new_node\n                for neighbor in neighbors:\n                    if neighbor == best_parent:\n                        continue\n                    cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-10 < neighbor.cost:\n                        if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.resolution):\n                            try:\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                            neighbor.update_parent(new_node, cost_via_new)\n                            edges.append((new_node, neighbor))\n\n                # Check if new node close enough to target_node to finalize connection\n                if distance(new_pos, target_node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, target_node.position, obstacles, is_3d, self.resolution):\n                        final_node = Node(target_node.position,\n                                         cost=new_node.cost + distance(new_pos, target_node.position))\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect_and_rewire(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -0.83061,
    "time_improvement": -5.0,
    "length_improvement": 12.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.009269905090332032,
            "num_nodes_avg": 99.5,
            "path_length_avg": 166.4588186358659,
            "success_improvement": 0.0,
            "time_improvement": 1.706698621444585,
            "length_improvement": 16.805482364196887,
            "objective_score": 3.8731060592727533
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.024648571014404298,
            "num_nodes_avg": 324.9,
            "path_length_avg": 294.8151195202668,
            "success_improvement": 0.0,
            "time_improvement": -67.30010211132563,
            "length_improvement": 2.1703693037844696,
            "objective_score": -19.755956772640793
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014330768585205078,
            "num_nodes_avg": 204.6,
            "path_length_avg": 136.7140646540946,
            "success_improvement": 0.0,
            "time_improvement": 50.549359238572876,
            "length_improvement": 16.049328508568138,
            "objective_score": 18.37467347328549
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a balanced bidirectional RRT* algorithm with adaptive informed sampling, dynamic neighborhood radius for rewiring, periodic pruning of dead-end nodes, and shortcut path smoothing to enhance path quality and search efficiency. It alternates tree expansions from start and goal, ensuring collision-free nodes and edges, dynamically optimizes connections, and smooths the final path for improved smoothness and shorter lengths.",
    "planning_mechanism": "The planner grows two trees from start and goal positions, extending the smaller tree each iteration for balanced exploration. Samples are adaptively biased towards the goal for directed search. New nodes are added only if collision-free, and neighborhood rewiring optimizes path costs dynamically based on tree size. Periodic pruning removes dead-end nodes to reduce computational load. Upon connecting the trees, iterative shortcut smoothing improves path smoothness and quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=25.0,\n                 radius_min: float=5.0, prune_interval: int=200,\n                 prune_threshold: int=100, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d) and in_bounds(sample):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p,c) for (p,c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) -1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree for balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.02303,
    "time_improvement": 7.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007739663124084473,
            "num_nodes_avg": 82.0,
            "path_length_avg": 168.76230537487686,
            "success_improvement": 0.0,
            "time_improvement": 17.932596654354978,
            "length_improvement": 15.654221831994624,
            "objective_score": 8.510623362705418
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.021677231788635253,
            "num_nodes_avg": 201.1,
            "path_length_avg": 241.8012510559584,
            "success_improvement": 0.0,
            "time_improvement": -47.132387090927615,
            "length_improvement": 19.76216439923414,
            "objective_score": -10.187283247431456
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.014474320411682128,
            "num_nodes_avg": 134.9,
            "path_length_avg": 124.33994290272581,
            "success_improvement": 0.0,
            "time_improvement": 50.054010384144235,
            "length_improvement": 23.647784693544356,
            "objective_score": 19.74576005395214
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* algorithm that combines adaptive goal bias sampling, dynamic neighborhood radius for efficient rewiring, and strategic tree growth balancing. It improves planning efficiency and path quality by implementing early path shortening on connection, advanced smoothing via adaptive shortcutting, and efficient collision checking with adjustable resolution. The rewiring step aggressively optimizes local paths, and pruning techniques avoid expanding invalid nodes, thereby reducing search time and improving success rates in complex 2D/3D environments.",
    "planning_mechanism": "The planner incrementally builds two trees rooted at start and goal, extending the smaller tree each iteration with bias towards both start and goal. New nodes are collision-checked before insertion, and edges are verified for obstacle intersections. Neighborhood rewiring recalculates parent nodes to minimize path costs. Upon successfully connecting the two trees, the optimal path is extracted, followed by iterative shortcut smoothing to reduce path length and improve smoothness. The planner employs bounds checking, adaptive radius scaling for rewiring, and obstacle-aware steering to maximize robustness and efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        # Remove self from old parent's children list if exists\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2, radius_constant: float=25.0, radius_min: float=3.0,\n                 collision_resolution: float=0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.collision_resolution = collision_resolution  # resolution for edge collision checking\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increases over time to focus sampling towards start/goal\n            adapt_goal_bias = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.2, 0.5)\n            if random.random() < adapt_goal_bias:\n                # 50% chance to sample start or goal for balanced biasing\n                return start_position if random.random() < 0.5 else goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def steer(from_pos, to_pos):\n            distance_ = dist(from_pos, to_pos)\n            if distance_ <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            radius_sq = radius * radius\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes <= 1:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in neighbors:\n                temp_cost = node.cost + dist(node.position, new_pos)\n                if temp_cost + 1e-9 < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Attempt rewiring neighbors to new_node if it reduces cost\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d, self.collision_resolution):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            # Edge might already be removed during update_parent\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, cost=new_cost, parent=last_node)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if (not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d, self.collision_resolution) and\n                        not self._is_in_obstacle(node.position, obstacles, is_3d)):\n                        final_node = Node(node.position,\n                                          parent=new_node,\n                                          cost=new_node.cost + dist(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def smooth_path(path: list, max_trials=300) -> list:\n            if len(path) < 3:\n                return path\n            for _ in range(max_trials):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_resolution):\n                    # shortcut -> remove intermediate nodes between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free(itr)\n\n            # Always extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n                # Post smoothing to reduce path length and improve smoothness\n                extracted_path = smooth_path(merged_path, max_trials=300)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 40.78481,
    "time_improvement": -139.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.8,
            "time_avg": 0.029625916481018068,
            "num_nodes_avg": 98.9,
            "path_length_avg": 160.59540833817158,
            "success_improvement": -19.999999999999996,
            "time_improvement": -214.137966776132,
            "length_improvement": 19.73595847483519,
            "objective_score": -70.29419833787257
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.04458100795745849,
            "num_nodes_avg": 329.0,
            "path_length_avg": 241.14670241214208,
            "success_improvement": 0.0,
            "time_improvement": -202.58984097496088,
            "length_improvement": 19.97936578361856,
            "objective_score": -56.78107913576455
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.029155874252319337,
            "num_nodes_avg": 228.4,
            "path_length_avg": 122.92782755045646,
            "success_improvement": 0.0,
            "time_improvement": -0.6070717815693442,
            "length_improvement": 24.514908587097775,
            "objective_score": 4.720860182948752
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* variant optimized with fast KD-tree nearest neighbor queries, adaptive informed sampling restricted within an ellipsoidal subset based on the best found path cost, and dynamic goal biasing to enhance focused exploration. It integrates efficient cost-aware rewiring for local path optimization, alternating tree growth to balance exploration/exploitation, and aggressive early termination upon tree connection to reduce planning time. Post-planning path smoothing uses iterative shortcutting with collision validation to improve path quality while ensuring feasibility and robustness, ultimately delivering faster convergence and higher-quality paths in complex environments.",
    "planning_mechanism": "The planner simultaneously grows two trees from the start and goal positions. It samples points within an ellipsoidal informed subset that shrinks as better solutions are found, thus focusing sampling and improving convergence speed. It alternates tree expansion with cost-based rewiring to locally optimize path segments. Connections between trees are attempted efficiently with verified collision checks. Upon successful connection, the path is extracted and refined through shortcut smoothing, maintaining collision-free guarantees. The approach balances exploration and exploitation, utilizes informed heuristics, and ensures robustness via strict obstacle checks.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D position\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost to reach this node from start\n        self.children = []\n        self.valid = True               # Validity flag (collision-free)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.20,\n                 neighbor_radius: float = 20.0, smoothing_iter: int = 150, collision_resolution: float = 0.5):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n        self.smoothing_iter = smoothing_iter\n        self.collision_resolution = collision_resolution\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if self._is_in_obstacle(start_position, obstacles, is_3d) or \\\n           self._is_in_obstacle(goal_position, obstacles, is_3d):\n            return PlannerResult(success=False, path=[], nodes=[], edges=[])\n\n        class KDTree:\n            __slots__ = ['nodes']\n\n            def __init__(self):\n                self.nodes = []\n\n            def insert(self, node):\n                self.nodes.append(node)\n\n            def nearest(self, point):\n                best_node = None\n                best_dist_sq = float('inf')\n                x, y = point[0], point[1]\n                for node in self.nodes:\n                    pos = node.position\n                    dist_sq = 0\n                    if dim == 2:\n                        dx = pos[0] - x\n                        dy = pos[1] - y\n                        dist_sq = dx*dx + dy*dy\n                    else:\n                        dz = pos[2] - point[2]\n                        dx = pos[0] - x\n                        dy = pos[1] - y\n                        dist_sq = dx*dx + dy*dy + dz*dz\n                    if dist_sq < best_dist_sq:\n                        best_dist_sq = dist_sq\n                        best_node = node\n                return best_node\n\n            def near(self, point, radius):\n                r_sq = radius * radius\n                neighbors = []\n                px, py = point[0], point[1]\n                for node in self.nodes:\n                    pos = node.position\n                    d_sq = 0\n                    if dim == 2:\n                        dx = pos[0] - px\n                        dy = pos[1] - py\n                        d_sq = dx*dx + dy*dy\n                    else:\n                        dz = pos[2] - point[2]\n                        dx = pos[0] - px\n                        dy = pos[1] - py\n                        d_sq = dx*dx + dy*dy + dz*dz\n                    if d_sq <= r_sq:\n                        neighbors.append(node)\n                return neighbors\n\n        def in_bounds(pos):\n            for d in range(dim):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(dim))\n\n        def informed_sample(c_best, start, goal):\n            # If no solution, sample uniformly with goal bias\n            if c_best == float('inf'):\n                if random.random() < self.goal_sample_rate:\n                    return goal\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            import numpy as np\n\n            center = tuple((start[d] + goal[d]) / 2.0 for d in range(dim))\n            dist_start_goal = math.dist(start, goal)\n            if dist_start_goal == 0:\n                return start\n\n            a = c_best / 2.0\n            c = dist_start_goal / 2.0\n            # Degenerate case fallback\n            if a <= c:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            b = math.sqrt(a * a - c * c)\n\n            def sample_unit_ball():\n                while True:\n                    if dim == 2:\n                        x = random.uniform(-1, 1)\n                        y = random.uniform(-1, 1)\n                        if x*x + y*y <= 1:\n                            return np.array([x, y])\n                    else:\n                        x = random.uniform(-1,1)\n                        y = random.uniform(-1,1)\n                        z = random.uniform(-1,1)\n                        if x*x + y*y + z*z <= 1:\n                            return np.array([x, y, z])\n\n            dir_vec = np.array([(goal[d] - start[d]) / dist_start_goal for d in range(dim)])\n\n            if dim == 2:\n                cos_theta = dir_vec[0]\n                sin_theta = dir_vec[1]\n                while True:\n                    sample_ball = sample_unit_ball()\n                    x_ellip = sample_ball[0] * a\n                    y_ellip = sample_ball[1] * b\n                    sample_x = center[0] + cos_theta * x_ellip - sin_theta * y_ellip\n                    sample_y = center[1] + sin_theta * x_ellip + cos_theta * y_ellip\n                    sample = (sample_x, sample_y)\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                e1 = np.array([1.0, 0.0, 0.0])\n                v = np.cross(e1, dir_vec)\n                s = np.linalg.norm(v)\n                c = np.dot(e1, dir_vec)\n                if s < 1e-10:\n                    R = np.eye(3) if c > 0 else -np.eye(3)\n                else:\n                    vx = np.array([[0, -v[2], v[1]],\n                                   [v[2], 0, -v[0]],\n                                   [-v[1], v[0], 0]])\n                    R = np.eye(3) + vx + vx @ vx * ((1 - c) / (s*s))\n\n                while True:\n                    sample_ball = sample_unit_ball()\n                    scaled = np.array([a*sample_ball[0], b*sample_ball[1], b*sample_ball[2]])\n                    rotated = R.dot(scaled)\n                    sample_np = np.array(center) + rotated\n                    sample = tuple(sample_np.tolist())\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def choose_parent(new_pos, near_nodes):\n            min_cost = float('inf')\n            best_parent = None\n            for node in near_nodes:\n                dist_edge = math.dist(node.position, new_pos)\n                c_through = node.cost + dist_edge\n                if c_through < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    min_cost = c_through\n                    best_parent = node\n            return best_parent, min_cost if best_parent else (None, None)\n\n        def rewire(new_node, near_nodes):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                dist_edge = math.dist(new_node.position, near_node.position)\n                c_through_new = new_node.cost + dist_edge\n                if c_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, self.collision_resolution):\n                    # Remove old edge\n                    if near_node.parent:\n                        try:\n                            edges.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        if near_node in near_node.parent.children:\n                            near_node.parent.children.remove(near_node)\n                    near_node.parent = new_node\n                    near_node.cost = c_through_new\n                    new_node.add_child(near_node)\n                    edges.append((new_node, near_node))\n\n        def extend(tree, kd_tree, sample_point):\n            nearest_node = kd_tree.nearest(sample_point)\n            if nearest_node is None:\n                return None\n\n            new_pos = steer(nearest_node.position, sample_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                return None\n\n            near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n            parent_node, min_cost = choose_parent(new_pos, near_nodes)\n\n            if parent_node is None:\n                # fallback\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n                parent_node = nearest_node\n                min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n\n            new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n            parent_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((parent_node, new_node))\n            kd_tree.insert(new_node)\n\n            rewire(new_node, near_nodes)\n\n            return new_node\n\n        def connect(tree, kd_tree, target_node):\n            nearest_node = kd_tree.nearest(target_node.position)\n            if nearest_node is None:\n                return None\n\n            curr_node = nearest_node\n            while True:\n                new_pos = steer(curr_node.position, target_node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                    return None\n\n                near_nodes = kd_tree.near(new_pos, self.neighbor_radius)\n                parent_node, min_cost = choose_parent(new_pos, near_nodes)\n                if parent_node is None:\n                    if self._is_edge_in_obstacle(curr_node.position, new_pos, obstacles, is_3d, self.collision_resolution):\n                        return None\n                    parent_node = curr_node\n                    min_cost = curr_node.cost + math.dist(curr_node.position, new_pos)\n\n                new_node = Node(new_pos, parent=parent_node, cost=min_cost)\n                parent_node.add_child(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((parent_node, new_node))\n                kd_tree.insert(new_node)\n\n                rewire(new_node, near_nodes)\n\n                if math.dist(new_node.position, target_node.position) <= self.step_size * 0.5:\n                    return new_node\n\n                curr_node = new_node\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            path_goal.reverse()\n            return path_start + path_goal\n\n        def shortcut_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iter):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i, p_j = path[i], path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, self.collision_resolution):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        # Initialize trees\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        kd_start = KDTree()\n        kd_goal = KDTree()\n        kd_start.insert(start_root)\n        kd_goal.insert(goal_root)\n\n        success_state = False\n        connection_node_start = None\n        connection_node_goal = None\n        c_best = float('inf')\n\n        tree_flag = True  # True: extend start tree, False: extend goal tree\n\n        for _ in range(self.max_iter):\n            sample_pt = informed_sample(c_best, start_position, goal_position)\n\n            if tree_flag:\n                new_node = extend(tree_start, kd_start, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_goal, kd_goal, new_node)\n                if connect_node is not None:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = new_node\n                        connection_node_goal = connect_node\n                        break\n            else:\n                new_node = extend(tree_goal, kd_goal, sample_pt)\n                if new_node is None:\n                    tree_flag = not tree_flag\n                    continue\n\n                connect_node = connect(tree_start, kd_start, new_node)\n                if connect_node is not None:\n                    total_cost = new_node.cost + connect_node.cost\n                    if total_cost < c_best:\n                        c_best = total_cost\n                        success_state = True\n                        connection_node_start = connect_node\n                        connection_node_goal = new_node\n                        break\n\n            tree_flag = not tree_flag\n\n        extracted_path = []\n        if success_state and connection_node_start and connection_node_goal:\n            extracted_path = extract_path(connection_node_start, connection_node_goal)\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            t = i / steps\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * t for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 55.22279,
    "time_improvement": -194.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.032877445220947266,
            "num_nodes_avg": 97.9,
            "path_length_avg": 159.39714582146087,
            "success_improvement": -9.999999999999998,
            "time_improvement": -248.61550362904143,
            "length_improvement": 20.33483856359086,
            "objective_score": -75.51768337599425
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.05726780891418457,
            "num_nodes_avg": 339.2,
            "path_length_avg": 234.25891948975692,
            "success_improvement": 0.0,
            "time_improvement": -288.7004351463622,
            "length_improvement": 22.264965181333025,
            "objective_score": -82.15713750764206
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.04169485569000244,
            "num_nodes_avg": 262.8,
            "path_length_avg": 120.76243174191418,
            "success_improvement": 0.0,
            "time_improvement": -43.87486044917882,
            "length_improvement": 25.844592059180915,
            "objective_score": -7.993539722917462
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm enhanced with adaptive goal biasing and dynamic neighbor radius that shrinks over time to focus rewiring locally, improving path quality and convergence speed. It applies strict collision and edge feasibility checks, rewiring using the nearest nodes within an adaptively reduced radius to minimize path length, and leverages a heuristic cost check to more aggressively seek lower-cost connections. Tree growing alternates between start and goal; when the trees connect, the best path is extracted and subjected to post-processing smoothing for enhanced path smoothness.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal by sampling free space points with an adaptive goal bias, steering a step towards them, and adding collision-free nodes. Each new node rewires its neighbors within an adaptively decreasing radius to locally optimize paths based on cost and collision checks. Once the two trees connect, the planner reconstructs the shortest path by backtracking from the connection nodes and applies smoothing to reduce unnecessary detours and shorten path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        from math import dist\n        return dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0, goal_sample_rate=0.15,\n                 initial_neighbor_radius=15.0, min_neighbor_radius=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n        self.min_neighbor_radius = min_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(p):\n            for d in range(len(bounds)):\n                if p[d] < 0 or p[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Adaptive goal biasing with 2x chance for goal (more focused search)\n            r = random.random()\n            if r < self.goal_sample_rate:\n                return goal_position\n            elif r < 2 * self.goal_sample_rate:\n                return start_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            return [n for n in tree if (self._dist_sq(n.position, pos) <= r_sq)]\n\n        def can_connect(p1, p2):\n            if not in_bounds(p2):\n                return False\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire_nodes(new_node, near, tree, edges):\n            for neighbor in near:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-7 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, new_cost)\n                        edges.append((new_node, neighbor))\n\n        def try_extend(tree, point, neighbor_radius):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            near = near_nodes(tree, new_pos, neighbor_radius)\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                if node == nearest_node:\n                    continue\n                edge_clear = not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d)\n                if edge_clear:\n                    temp_cost = node.cost + math.dist(node.position, new_pos)\n                    if temp_cost + 1e-7 < min_cost:\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire_nodes(new_node, near, tree, edges)\n            return new_node\n\n        def try_connect(to_tree, from_node, neighbor_radius):\n            current_nearest = nearest(to_tree, from_node.position)\n\n            # Attempt to step repeatedly from current_nearest towards from_node.position\n            last_node = None\n            while True:\n                new_pos = steer(current_nearest.position, from_node.position)\n                if not can_connect(current_nearest.position, new_pos):\n                    break\n\n                new_cost = current_nearest.cost + math.dist(current_nearest.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = current_nearest\n                current_nearest.children.append(new_node)\n\n                to_tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((current_nearest, new_node))\n\n                current_nearest = new_node\n                last_node = new_node\n\n                if math.dist(new_pos, from_node.position) <= self.step_size:\n                    # Connect final edge if feasible\n                    if can_connect(new_pos, from_node.position):\n                        final_cost = new_node.cost + math.dist(new_pos, from_node.position)\n                        final_node = Node(from_node.position)\n                        final_node.cost = final_cost\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n\n                        to_tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n\n                        return final_node\n                    break\n\n            # Try partial connect if direct connection not possible\n            # Attempt to rewire near after connect\n            if last_node:\n                near = near_nodes(to_tree, last_node.position, neighbor_radius)\n                rewire_nodes(last_node, near, to_tree, edges)\n\n            return None\n\n        def extract_path(node_start, node_goal):\n            path1 = node_start.path_from_root()\n            path2 = node_goal.path_from_root()\n            return path1 + path2[::-1][1:]\n\n        def smooth_path(path, max_iter=50):\n            # Shortcut smoothing: randomly attempts to replace subpaths with direct edges if collision free\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                import random\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if j <= i + 1:\n                    continue\n                if self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    continue\n                # Remove intermediate nodes between i and j\n                path = path[:i+1] + path[j:]\n            return path\n\n        # Initialize\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        # Dynamic neighbor radius shrinks linearly from initial to min radius over iterations\n        def neighbor_radius(it):\n            decay = it / self.max_iter\n            r = self.initial_neighbor_radius - decay * (self.initial_neighbor_radius - self.min_neighbor_radius)\n            return max(r, self.min_neighbor_radius)\n\n        for it in range(self.max_iter):\n            radius = neighbor_radius(it)\n            rand_point = sample_free()\n\n            # Grow tree_start toward random sample\n            new_node_start = try_extend(tree_start, rand_point, radius)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Try connect goal tree to new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start, radius)\n\n            if new_node_goal is not None:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                extracted_path = smooth_path(extracted_path, max_iter=100)\n                break\n\n            # Alternate trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _dist_sq(self, p1, p2):\n        return sum((p1[d] - p2[d]) ** 2 for d in range(len(p1)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 174.36803,
    "time_improvement": -591.0,
    "length_improvement": 23.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.039312434196472165,
            "num_nodes_avg": 103.5,
            "path_length_avg": 161.41255409610545,
            "success_improvement": -9.999999999999998,
            "time_improvement": -316.8488139569571,
            "length_improvement": 19.327556879013677,
            "objective_score": -96.18913281128438
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.16566729545593262,
            "num_nodes_avg": 383.1,
            "path_length_avg": 233.25216791160543,
            "success_improvement": 0.0,
            "time_improvement": -1024.4528305550743,
            "length_improvement": 22.59903941488543,
            "objective_score": -302.8160412835452
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15394141674041747,
            "num_nodes_avg": 337.7,
            "path_length_avg": 120.01242215465547,
            "success_improvement": 0.0,
            "time_improvement": -431.1998203218904,
            "length_improvement": 26.30514312709546,
            "objective_score": -124.09891747114803
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e1",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* variant with adaptive informed sampling guided by cost-to-go heuristics and dynamic neighborhood radius based on node density. It integrates a lazy collision-checking mechanism combined with batch rewiring steps for local optimizations to improve path quality and reduce computational overhead. The algorithm employs a heuristic-driven sampling domain shaped as an ellipse between start and goal to accelerate convergence toward the optimal path while periodic smoothing and shortcutting reduce path jaggedness and length. The planner balances exploration and exploitation by alternating tree growth and adaptively pruning low-potential branches to boost success rate and planning efficiency.",
    "planning_mechanism": "The planner grows two trees bidirectionally from start and goal using informed ellipse sampling biased by the current best path cost. Nodes are incrementally connected and rewired locally using a radius that shrinks with increased samples, improving path costs. Lazy collision checks delay expensive verification until necessary. Upon tree connection, the path is extracted and smoothed by shortcutting to improve smoothness and length. Periodic pruning removes dead-end or poor-quality branches, focusing search on promising regions and reducing computation time.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    # Utility to check if node is a leaf (no children)\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        # Cost heuristic for informed sampling - Euclidean distance\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        # Adaptive radius shrinking with number of nodes for rewiring\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        # Steer function limits step size\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        # Nearest neighbor in a tree\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        # Nearby nodes within radius for rewiring\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        # Informed sampling inside an ellipse defined between start and goal with current best path cost\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                # Uniform random sample in bounds avoiding obstacles\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                if cost_best < c_min:\n                    cost_best = c_min * 1.0001  # numerical safeguard\n                # Ellipse parameters\n                c_best = cost_best\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n                import numpy as np  # assume allowed, else re-implement manually\n                # Construct rotation matrix using orthonormal basis\n                dim = len(start_pos)\n                # First diag matrix: lengths of ellipse axes\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                # Orthonormal basis: construct only principal axis vec and some orthonormal complement\n                e1 = np.array(vec)\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    # Gram-Schmidt to complete basis for 3D\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    # Scale by ellipse axes lengths\n                    sample = np.dot(C, np.dot(L, sample_in_unit_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        # Lazy collision check: defer edge collision checking until connection attempt\n        lazy_checked_edges = set()\n\n        # Try extending tree toward sampled point with rewiring\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n\n            near = near_nodes(tree, new_pos, r)\n\n            # Pick best parent minimizing cost\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if (node, new_pos) not in lazy_checked_edges and self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d) is False:\n                        lazy_checked_edges.add((node, new_pos))\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            # Final edge collision check with best parent (lazy collision confirms edge feasibility)\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors if cheaper through new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d) is False:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        # Attempt connection between two trees by extending along edge(s) towards target node, with collision checks\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    # Final edge check\n                    if self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) is False and self._is_in_obstacle(node.position, obstacles, is_3d) is False:\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        # Prune dead leaf nodes to focus search on promising branches\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node.is_leaf() and node is not start_root and node is not goal_root:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        # Shortcut smoothing post path extraction: attempts shortcuts for path segments to remove jaggedness\n        def shortcut_path(raw_path):\n            if len(raw_path) < 3:\n                return raw_path\n            smooth_path = raw_path[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d) is False:\n                    # shortcut possible: remove intermediate points\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        # Alternate tree growth with heuristic informed sampling\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            # Use best_path_cost to sample informed or uniform\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            # Alternate tree turn\n            tree_turn = 1 - tree_turn\n\n            # Periodic pruning to reduce tree size and focus search\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        # Once done, apply smoothing if success\n        if success and best_path:\n            smoothed = shortcut_path(best_path)\n            path = smoothed\n        else:\n            path = []\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.52887,
    "time_improvement": 8.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.0066823244094848635,
            "num_nodes_avg": 78.4,
            "path_length_avg": 161.6097494634053,
            "success_improvement": 0.0,
            "time_improvement": 29.144072060046668,
            "length_improvement": 19.229000529779853,
            "objective_score": 12.58902172396997
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02199399471282959,
            "num_nodes_avg": 192.7,
            "path_length_avg": 241.84558651954626,
            "success_improvement": 0.0,
            "time_improvement": -49.28238879008597,
            "length_improvement": 19.747452392480206,
            "objective_score": -10.835226158529748
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0162661075592041,
            "num_nodes_avg": 131.4,
            "path_length_avg": 124.81292096319058,
            "success_improvement": 0.0,
            "time_improvement": 43.87115829032658,
            "length_improvement": 23.357347671741252,
            "objective_score": 17.832817021446225
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid bidirectional RRT* planner combines adaptive dual goal bias sampling, dynamic logarithmically shrinking rewiring radius, balanced tree growth by always extending the smaller tree, and strict collision and edge checks. It integrates dynamic neighborhood rewiring and incremental path cost optimization from both trees, achieving efficient exploration and exploitation for rapid convergence towards shorter, smoother, and collision-free paths. The planner prioritizes exploration balance, robust connectivity, and path quality by fusing features from both existing algorithms while minimizing redundant complexity.",
    "planning_mechanism": "The planner alternately grows the smaller of the two trees rooted at start and goal, sampling points with a combined adaptive bias to both. New nodes are steered within a capped step size, validated against obstacles, and connected if feasible. A dynamically computed neighborhood radius shrinks logarithmically with tree size, used to locally rewire nodes for improved costs and path smoothness. The connection attempt aggressively extends the opposing tree towards the new node, and once the trees connect, the shortest path is reconstructed by merging root-to-connection nodes paths, ensuring efficient and high-quality path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=30.0, radius_min: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # combined start/goal bias probability\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            r = random.random()\n            # Adaptive combined goal bias: sample start or goal to encourage quicker connection\n            if r < self.goal_sample_rate:\n                return goal_position if random.random() < 0.5 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(self.radius_min, r)\n\n        def can_add_node(pos):\n            # Check bounds\n            for d, c in enumerate(pos):\n                if c < 0 or c > bounds[d]:\n                    return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, point):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not can_add_node(new_pos):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire nearby nodes to reduce path costs and smooth\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = last_node\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                dist_to_goal_node = distance(new_pos, node.position)\n                if dist_to_goal_node <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position)\n                        final_node.cost = new_node.cost + dist_to_goal_node\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Always grow the smaller tree first to balance exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.89491,
    "time_improvement": 9.0,
    "length_improvement": 10.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.00653841495513916,
            "num_nodes_avg": 96.5,
            "path_length_avg": 169.30748576140869,
            "success_improvement": 0.0,
            "time_improvement": 30.670013828531275,
            "length_improvement": 15.381745914805562,
            "objective_score": 12.277353331520494
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.014479446411132812,
            "num_nodes_avg": 250.2,
            "path_length_avg": 279.8781340289073,
            "success_improvement": 0.0,
            "time_improvement": 1.7219756195050526,
            "length_improvement": 7.126966430527068,
            "objective_score": 1.9419859719569295
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.030144548416137694,
            "num_nodes_avg": 276.5,
            "path_length_avg": 149.2443762081235,
            "success_improvement": 0.0,
            "time_improvement": -4.01865229899951,
            "length_improvement": 8.354962375726615,
            "objective_score": 0.46539678544547014
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner combining adaptive heuristic sampling, balanced tree growth, dynamic neighbor radius rewiring, robust collision and edge checks, and iterative path shortcut smoothing to deliver efficient, high-quality, and reliable path planning. The planner employs goal and start biased sampling with exploration-exploitation balancing, rigorous node and edge validation, pruning of unreachable nodes, and continuous local rewiring to optimize path cost and smoothness while minimizing search time and increasing success probability.",
    "planning_mechanism": "The planner grows two RRT* trees from start and goal positions alternately extending the smaller tree towards adaptively sampled free points biased by a heuristic considering both roots. It applies dynamic radius-based rewiring to locally optimize paths, ensuring collision-free nodes and edges. After each extension, it attempts to connect the opposite tree iteratively steering towards the new node with strict collision checks. Dead-end nodes are pruned periodically to maintain efficiency. Upon connection, the path extracted is refined with shortcut smoothing to improve smoothness and shorten length before returning the final result.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_iterations: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            # Heuristic combined biasing: sample biased towards goal or start probablistically,\n            # otherwise uniform random sample inside bounds and free of obstacles.\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and (not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            # Validate node and edge with collision check\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -3.8946,
    "time_improvement": 1.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.012160468101501464,
            "num_nodes_avg": 117.4,
            "path_length_avg": 167.13698372878477,
            "success_improvement": 0.0,
            "time_improvement": -28.943343470885495,
            "length_improvement": 16.46654196893765,
            "objective_score": -5.389694647478118
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01968672275543213,
            "num_nodes_avg": 205.0,
            "path_length_avg": 245.9300674795564,
            "success_improvement": 0.0,
            "time_improvement": -33.62197448673282,
            "length_improvement": 18.392083425808032,
            "objective_score": -6.408175660858239
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.010268330574035645,
            "num_nodes_avg": 163.6,
            "path_length_avg": 129.37297565250577,
            "success_improvement": 0.0,
            "time_improvement": 64.5674603272544,
            "length_improvement": 20.557199390185517,
            "objective_score": 23.481677976213422
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant combining adaptive informed sampling with balanced tree growth, dynamic radius rewiring, dead-end pruning, and iterative shortcut smoothing. It carefully tunes sampling bias and radius parameters for faster convergence and higher path quality while maintaining rigorous collision checking and map-bound enforcement.",
    "planning_mechanism": "The planner grows two trees from start and goal nodes alternately extending the smaller tree. Sampling is adaptively biased toward start and goal to accelerate connection. Each extension rewires neighbors within a dynamically shrinking radius to locally optimize path cost. Upon connection, the combined path undergoes iterative shortcut smoothing to improve path length and smoothness. Periodic pruning of dead-end nodes reduces computational overhead and maintains tree efficiency, resulting in faster, more reliable, and smoother path generation.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=6.0,\n                 goal_sample_rate: float=0.12, radius_constant: float=25.0,\n                 radius_min: float=6.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import random\n        import math\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling: 75% goal, 25% start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_constant\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def can_add_node(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            for d in range(len(pos)):\n                if not (0 <= pos[d] <= bounds[d]):\n                    return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend the smaller tree first to balance search\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -10.57241,
    "time_improvement": 23.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007777166366577148,
            "num_nodes_avg": 80.3,
            "path_length_avg": 171.23724890700797,
            "success_improvement": 0.0,
            "time_improvement": 17.534931577843007,
            "length_improvement": 14.417268842547337,
            "objective_score": 8.143933241862369
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.016112327575683594,
            "num_nodes_avg": 189.3,
            "path_length_avg": 245.16595802095776,
            "success_improvement": 0.0,
            "time_improvement": -9.361067912931885,
            "length_improvement": 18.645640795144555,
            "objective_score": 0.9208077851493459
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.011360478401184083,
            "num_nodes_avg": 122.6,
            "path_length_avg": 126.91888301133925,
            "success_improvement": 0.0,
            "time_improvement": 60.79882715607561,
            "length_improvement": 22.064160108889748,
            "objective_score": 22.652480168600633
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This simplified bidirectional RRT* planner grows two trees from start and goal points, alternately extending the smaller tree by sampling free points with a goal bias. It uses a fixed step size steering method with collision and boundary checks for nodes and edges. Local rewiring within a dynamically shrinking radius improves path cost and smoothness. The planner ensures no nodes or edges cross obstacles or map boundaries, attempts connections between trees incrementally, and returns an optimized, smooth, collision-free path upon success.",
    "planning_mechanism": "The planner alternates growth between two trees to balance exploration from start and goal. Each iteration samples a point biased towards goal and start, extends the smaller tree toward this sample while ensuring collision-free paths, rewires locally for path improvement, and tries connecting to the other tree incrementally. The process continues until a collision-free connecting path is found or iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 20.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free():\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate growth by extending smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            # Try to extend one tree toward sample\n            nearest_node = nearest(tree_start, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = radius_by_nodes(len(tree_start))\n            near = near_nodes(tree_start, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_start.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new node\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-8 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Try incremental connection to opposite tree\n            def try_connect(tree, node):\n                nearest_node = nearest(tree, node.position)\n                last_node = nearest_node\n                while True:\n                    next_pos = steer(last_node.position, node.position)\n                    if not in_bounds(next_pos):\n                        return None\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                        return None\n                    if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d):\n                        return None\n\n                    new_cost = last_node.cost + distance(last_node.position, next_pos)\n                    new_node = Node(next_pos, parent=last_node, cost=new_cost)\n                    last_node.children.append(new_node)\n                    tree.append(new_node)\n                    nodes.append(new_node)\n                    edges.append((last_node, new_node))\n\n                    if distance(next_pos, node.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(next_pos, node.position, obstacles, is_3d):\n                            final_cost = new_node.cost + distance(next_pos, node.position)\n                            final_node = Node(node.position, parent=new_node, cost=final_cost)\n                            new_node.children.append(final_node)\n                            tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((new_node, final_node))\n                            return final_node\n                        else:\n                            return None\n                    last_node = new_node\n\n            new_node_goal = try_connect(tree_goal, new_node)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -9.23875,
    "time_improvement": 25.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.005178022384643555,
            "num_nodes_avg": 93.2,
            "path_length_avg": 179.70989031533733,
            "success_improvement": 0.0,
            "time_improvement": 45.094916308313046,
            "length_improvement": 10.182724101430104,
            "objective_score": 15.565019712779934
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.016203022003173827,
            "num_nodes_avg": 267.5,
            "path_length_avg": 291.4688856637927,
            "success_improvement": 0.0,
            "time_improvement": -9.976648709529675,
            "length_improvement": 3.280762905492302,
            "objective_score": -2.3368420317604417
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01702110767364502,
            "num_nodes_avg": 206.0,
            "path_length_avg": 145.683599504576,
            "success_improvement": 0.0,
            "time_improvement": 41.26590797091255,
            "length_improvement": 10.541493776502337,
            "objective_score": 14.488071146574232
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an advanced bidirectional RRT* variant combining adaptive informed sampling with dynamically shrinking rewiring radius, balanced tree extension based on size, aggressive pruning of dead-end nodes, and iterative path shortcut smoothing. It integrates a KD-tree inspired nearest neighbor heuristic for faster queries and enforces rigorous collision and boundary checks. These enhancements improve planning efficiency, path quality, robustness, and reduce total computation time while producing smooth, minimal-length paths.",
    "planning_mechanism": "The planner alternates extensions between the smaller of two trees (start and goal), uses biased informed sampling towards start/goal to accelerate connection, employs dynamic radius rewiring to locally optimize cost, prunes dead-end nodes regularly to limit tree size, and performs iterative shortcut smoothing after connection. KD-tree-inspired spatial queries and early connection checks reduce overhead and enable faster convergence to high-quality, smooth paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node: 'Node'):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 6000, step_size: float=5.5,\n                 goal_sample_rate: float=0.12, radius_const: float=30.0,\n                 radius_min: float=5.0, prune_interval: int=100,\n                 prune_threshold: int=150, smoothing_iters: int=80):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacle rects/cuboids\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_const\n            val = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def _is_in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        # KD-tree inspired nearest heuristic: simple spatial hashing bucket\n        # For performance with modest node counts, direct search is used here with filtering for radius queries\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                # squared distance check for efficiency\n                d_sq = 0\n                for dd in range(len(pos)):\n                    diff = node.position[dd] - pos[dd]\n                    d_sq += diff*diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def can_add_node(pos):\n            if not _is_in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def sample_free():\n            p_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                # Adaptive bias: 70% goal, 30% start\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    trials += 1\n                    if trials > 1000:\n                        # Fallback to start or goal if too many failures\n                        return random.choice([start_position, goal_position])\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        # Extend function with rewiring and collision checks.\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        # Try to connect tree to node by incremental steering and rewiring on the connecting tree\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Prune leaf nodes to keep tree size manageable and efficient\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        # Iterative shortcut smoothing, tries random pairs on path to shortcut if no collision\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first for balanced search & efficiency\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                # Combined path with join at the connecting nodes\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n                # Accept shorter/smoother path if improvement found\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            # Periodic pruning to limit tree growth and improve efficiency\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -4.35147,
    "time_improvement": 7.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.005747389793395996,
            "num_nodes_avg": 81.8,
            "path_length_avg": 166.18830619036038,
            "success_improvement": -9.999999999999998,
            "time_improvement": 39.05763741944944,
            "length_improvement": 16.94068188443104,
            "objective_score": 10.105427602721042
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.01903247833251953,
            "num_nodes_avg": 159.0,
            "path_length_avg": 244.78127177341085,
            "success_improvement": 0.0,
            "time_improvement": -29.18134550685893,
            "length_improvement": 18.773292706595587,
            "objective_score": -4.999745110738561
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.025402522087097167,
            "num_nodes_avg": 125.4,
            "path_length_avg": 128.28244561261585,
            "success_improvement": 0.0,
            "time_improvement": 12.34447847688249,
            "length_improvement": 21.22685052931281,
            "objective_score": 7.948713648927308
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner is a bidirectional RRT* variant designed for enhanced planning efficiency and path quality. It integrates adaptive goal biasing with heuristic-driven sampling that alternates focus between start and goal to resolve symmetry issues. It employs a dynamically shrinking neighbor radius for rewiring, enabling aggressive and efficient cost optimization while maintaining computational speed. Lazy collision checking is used to reduce unnecessary computations while balanced tree expansions avoid local minima. Spatial pruning is applied to limit search space, and robust path smoothing via randomized shortcutting further optimizes the final path for length and smoothness.",
    "planning_mechanism": "The planner initializes two trees at start and goal positions and alternately samples points using adaptive biasing between the two. For each iteration, the closest node in the active tree is extended toward the sampled point within step size constraints, ensuring collision-free nodes and edges. The new node connects optimally by rewiring nearby neighbors within a dynamically shrinking radius. Subsequently, the opposite tree attempts incremental connection to this new node, and successful connection signals path completion. The resulting path is merged and smoothed through multiple randomized shortcut attempts, producing a collision-free, optimized final route.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 min_neighbor_radius: float = 7.0, max_neighbor_radius: float = 20.0,\n                 goal_sample_rate: float = 0.15, smoothing_trials: int = 120):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def sample_free(iteration):\n            # Adaptive goal biasing; capped at 0.3\n            goal_bias = min(self.goal_sample_rate + (iteration / self.max_iter) * 0.15, 0.3)\n            if random.random() < goal_bias:\n                # Alternate bias between start and goal to avoid symmetry\n                return start_position if (iteration % 2 == 0) else goal_position\n            else:\n                attempts = 0\n                while attempts < 30:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                    attempts += 1\n                # Fallback\n                return start_position if (iteration % 2 == 0) else goal_position\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                new_p = to_pos\n            else:\n                ratio = self.step_size / dist\n                new_p = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n            # Clamp inside bounds\n            clamped = tuple(max(0, min(new_p[d], bounds[d])) for d in range(len(bounds)))\n            return clamped\n\n        def neighbor_radius(iteration):\n            # Shrink radius sub-linearly for efficient rewiring\n            return max(self.min_neighbor_radius,\n                       self.max_neighbor_radius * (1 - (iteration / self.max_iter) ** 0.85))\n\n        def near_nodes(tree, pos, radius):\n            # Linear neighbor search (could be optimized by spatial indexing)\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        # Spatial pruning to skip nodes significantly far from start-goal bounding box\n        def in_prune_region(pos):\n            margin = self.max_neighbor_radius + self.step_size\n            min_b = tuple(min(start_position[d], goal_position[d]) - margin for d in range(len(bounds)))\n            max_b = tuple(max(start_position[d], goal_position[d]) + margin for d in range(len(bounds)))\n            return all(min_b[d] <= pos[d] <= max_b[d] for d in range(len(bounds)))\n\n        # Initialize trees\n        start_root = Node(start_position, None, 0.0)\n        goal_root = Node(goal_position, None, 0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        connected = False\n        connection_node_start = None\n        connection_node_goal = None\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Alternate tree expansions for balanced growth\n            if iteration % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            r = neighbor_radius(iteration)\n\n            nearest_a = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_a.position, q_rand)\n\n            if not in_bounds(new_pos):\n                continue\n            if not in_prune_region(new_pos):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            # Edge collision check\n            if self._is_edge_in_obstacle(nearest_a.position, new_pos, obstacles, is_3d):\n                continue\n\n            near = near_nodes(tree_a, new_pos, r)\n\n            # Choose best parent minimizing cost + heuristic\n            min_cost = nearest_a.cost + math.dist(nearest_a.position, new_pos)\n            best_parent = nearest_a\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            new_node.parent = best_parent\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if improved cost paths found\n            for node in near:\n                if node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, node.position)\n                if cost_through_new < node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, node.position, obstacles, is_3d):\n                        try:\n                            edges.remove((node.parent, node))\n                        except ValueError:\n                            pass\n                        node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, node))\n\n            # Try connecting the other tree to this new node (stepwise)\n            nearest_b = nearest(tree_b, new_node.position)\n            curr_b = nearest_b\n            while True:\n                pos_b_new = steer(curr_b.position, new_node.position)\n\n                if not in_bounds(pos_b_new):\n                    break\n                if not in_prune_region(pos_b_new):\n                    break\n\n                if self._is_in_obstacle(pos_b_new, obstacles, is_3d):\n                    break\n                if self._is_edge_in_obstacle(curr_b.position, pos_b_new, obstacles, is_3d):\n                    break\n\n                cost_b = curr_b.cost + math.dist(curr_b.position, pos_b_new)\n                new_node_b = Node(pos_b_new, curr_b, cost_b)\n                curr_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((curr_b, new_node_b))\n\n                near_b = near_nodes(tree_b, pos_b_new, r)\n                for node in near_b:\n                    if node is curr_b:\n                        continue\n                    cost_through_new_b = new_node_b.cost + math.dist(new_node_b.position, node.position)\n                    if cost_through_new_b < node.cost:\n                        if not self._is_edge_in_obstacle(new_node_b.position, node.position, obstacles, is_3d):\n                            try:\n                                edges.remove((node.parent, node))\n                            except ValueError:\n                                pass\n                            node.update_parent(new_node_b, cost_through_new_b)\n                            edges.append((new_node_b, node))\n\n                if math.dist(new_node_b.position, new_node.position) <= self.step_size:\n                    connected = True\n                    if tree_a is tree_start:\n                        connection_node_start = new_node\n                        connection_node_goal = new_node_b\n                    else:\n                        connection_node_start = new_node_b\n                        connection_node_goal = new_node\n                    break\n\n                curr_b = new_node_b\n\n            if connected:\n                path_start = connection_node_start.path_from_root()\n                path_goal = connection_node_goal.path_from_root()\n                merged_path = path_start + path_goal[::-1][1:]\n\n                # Path smoothing with randomized shortcuts\n                merged_path = self._path_smooth(merged_path, obstacles, is_3d, self.smoothing_trials)\n\n                return PlannerResult(\n                    success=True,\n                    path=merged_path,\n                    nodes=nodes,\n                    edges=edges\n                )\n\n        # Fail if no path found after max_iter\n        return PlannerResult(\n            success=False,\n            path=[],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smooth(self, path, obstacles, is_3d, max_trials=120):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_trials):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 23.27567,
    "time_improvement": -73.0,
    "length_improvement": 26.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.017285633087158202,
            "num_nodes_avg": 101.4,
            "path_length_avg": 161.35454750996308,
            "success_improvement": 0.0,
            "time_improvement": -83.28795451500281,
            "length_improvement": 19.356548013237518,
            "objective_score": -21.115076751853337
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03474357128143311,
            "num_nodes_avg": 347.2,
            "path_length_avg": 235.35903530909974,
            "success_improvement": 0.0,
            "time_improvement": -135.81906714588325,
            "length_improvement": 21.899909533900487,
            "objective_score": -36.36573823698488
        },
        {
            "map_id": 2,
            "success_rate": 0.6,
            "time_avg": 0.028833627700805664,
            "num_nodes_avg": 261.1,
            "path_length_avg": 101.76248882134416,
            "success_improvement": -40.0,
            "time_improvement": 0.5048921972477305,
            "length_improvement": 37.51170158822934,
            "objective_score": -12.346192023179812
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "path_expert",
    "algorithm_description": "This planner implements an enhanced bidirectional RRT* algorithm focusing on minimizing path length and improving planning efficiency. It dynamically adjusts the rewiring radius to optimize local connectivity, uses adaptive informed sampling biased toward start and goal regions, aggressively prunes unpromising dead-end nodes, balances tree growth by always extending the smaller tree, and performs iterative path shortcut smoothing to improve path quality and smoothness. Nearest neighbor searches utilize an efficient radius-based filtering approach, and rigorous collision and edge-intersection checks ensure valid paths within map boundaries and free of obstacles. The combination of these techniques results in faster convergence to high-quality, shorter, and smoother paths.",
    "planning_mechanism": "The planner alternates extensions between the smaller of two trees grown from start and goal positions. Samples are drawn with a strong bias towards the goal and start to guide the exploration. Each extension step uses a dynamically shrinking radius to locate near neighbors for rewiring, improving path costs locally. Periodic pruning removes leaf nodes without children to maintain tree compactness and efficiency. Once trees connect, iterative shortcut smoothing refines the path by attempting collision-free shortcuts between non-adjacent waypoints. This balanced, adaptive, and pruning-augmented bidirectional RRT* process yields robust and efficient path planning with high solution quality.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag (unused but kept for extensibility)\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def remove_child(self, child_node: 'Node'):\n        try:\n            self.children.remove(child_node)\n        except ValueError:\n            pass\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_const: float=25.0, radius_min: float=4.0,\n                 prune_interval: int=80, prune_threshold: int=120, smoothing_iters: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_const = radius_const\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles (rect/cuboid)\n\n        import math\n        import random\n\n        is_3d = (len(bounds) == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def radius_dynamic(n):\n            if n <= 1:\n                return self.radius_const\n            val = self.radius_const * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def _is_in_bounds(pos):\n            for d in range(len(pos)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def nearest(tree, point):\n            # Nearest node by Euclidean distance\n            min_node = None\n            min_dist = float('inf')\n            for node in tree:\n                d = dist(node.position, point)\n                if d < min_dist:\n                    min_dist = d\n                    min_node = node\n            return min_node\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            result = []\n            for node in tree:\n                d_sq = 0\n                for dd in range(len(pos)):\n                    diff = node.position[dd] - pos[dd]\n                    d_sq += diff * diff\n                    if d_sq > r_sq:\n                        break\n                if d_sq <= r_sq:\n                    result.append(node)\n            return result\n\n        def can_add_node(pos):\n            if not _is_in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def sample_free():\n            # Adaptive biased sampling: goal biased more strongly with fallback sampling\n            p_bias = 0.75\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    trials += 1\n                    if trials > 1000:\n                        return random.choice([start_position, goal_position])\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.remove_child(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iters):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n                smoothed = shortcut_smoothing(raw_path)\n\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 11.33275,
    "time_improvement": -35.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.01879124641418457,
            "num_nodes_avg": 94.4,
            "path_length_avg": 160.26993757888138,
            "success_improvement": -9.999999999999998,
            "time_improvement": -99.2527031365738,
            "length_improvement": 19.89862563206727,
            "objective_score": -30.79608581455868
        },
        {
            "map_id": 1,
            "success_rate": 0.8,
            "time_avg": 0.02179224491119385,
            "num_nodes_avg": 151.9,
            "path_length_avg": 242.368891390616,
            "success_improvement": -19.999999999999996,
            "time_improvement": -47.91302898440496,
            "length_improvement": 19.573802132067545,
            "objective_score": -20.459148268907978
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01705174446105957,
            "num_nodes_avg": 117.8,
            "path_length_avg": 122.87939797776122,
            "success_improvement": 0.0,
            "time_improvement": 41.160190768132146,
            "length_improvement": 24.544647262179197,
            "objective_score": 17.256986682875482
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates bidirectional incremental RRT* exploration with adaptive goal and start bias sampling, dynamic radius rewiring, periodic pruning of dead-ends, and iterative shortcut smoothing. It alternately grows the smaller tree (start or goal) to balance exploration, performs rigorous collision and edge feasibility checks, and rewires locally for path cost improvements. After successful connection, the path undergoes shortcut smoothing to enhance smoothness and reduce length. Pruning of dead-end nodes maintains tree efficiency and robustness, collectively improving planning speed, success rate, and path quality.",
    "planning_mechanism": "The planner grows two bidirectional trees rooted at start and goal by alternatively extending the smaller tree towards random samples biased towards goal and start. It dynamically adjusts neighbor search radius based on tree size for rewiring, promoting path optimality. Each extension includes collision-checking for new nodes and edges. Upon connecting the two trees, it backtracks paths and applies shortcut smoothing to optimize the trajectory. It periodically prunes dead-end nodes to constrain tree complexity and keep search efficient, thus balancing exploration and exploitation for robust, efficient path planning.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=20.0,\n                 radius_min: float=5.0, prune_interval: int=150,\n                 prune_threshold: int=150, smoothing_iterations: int=50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        import random\n        import math\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias towards goal and start equally to avoid symmetry bias\n                return goal_position if random.random() < 0.6 else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            d = dist(from_pos, to_pos)\n            if d <= self.step_size:\n                return to_pos\n            ratio = self.step_size / d\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            rad = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(rad, self.radius_min)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def can_add_node(pos):\n            if not in_bounds(pos) or self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost:\n                    if can_connect(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for improved cost\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if can_connect(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node is not start_root and node is not goal_root and not node.children]\n            for node in to_remove:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                    removed.append(node)\n                except Exception:\n                    continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr > 0 and itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -5.12832,
    "time_improvement": 4.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006788301467895508,
            "num_nodes_avg": 74.3,
            "path_length_avg": 162.69392262951396,
            "success_improvement": 0.0,
            "time_improvement": 28.02034589024646,
            "length_improvement": 18.687141201885662,
            "objective_score": 12.143532007451071
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02096395492553711,
            "num_nodes_avg": 205.0,
            "path_length_avg": 249.99621723754436,
            "success_improvement": 0.0,
            "time_improvement": -42.29108038960891,
            "length_improvement": 17.042797372138992,
            "objective_score": -9.278764642454874
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021456432342529298,
            "num_nodes_avg": 161.2,
            "path_length_avg": 124.3211347251352,
            "success_improvement": 0.0,
            "time_improvement": 25.96110100558861,
            "length_improvement": 23.659334047608677,
            "objective_score": 12.520197111198318
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner integrates bidirectional RRT* with adaptive sampling and dynamic radius rewiring for efficient and high-quality path planning. It grows two trees alternately from start and goal, with goal biasing to direct sampling. Each new node connects to the best nearby parent within an adaptive radius and rewires neighbors to reduce path costs. Incremental connection attempts between trees use steering and collision checks. The radius dynamically shrinks to balance exploration and exploitation, improving convergence, path smoothness, and success rate while ensuring collision-free paths and boundary respect.",
    "planning_mechanism": "The planner iteratively samples collision-free points biased towards the start or goal, extends the smaller of two trees towards the sample using fixed step size steering, connects and rewires nodes locally within an adaptive radius based on the number of nodes to optimize path costs, and incrementally tries to connect the other tree to the newly added node. The search alternates growth between trees to cover space efficiently. Once connected, the path is reconstructed from both roots and returned.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free():\n            # Adaptive goal bias: with equal chance sample start or goal to reduce symmetry bias\n            if random.random() < self.goal_sample_rate:\n                return start_position if random.random() < 0.5 else goal_position\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            nearest_node = nearest(tree_start, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            radius = radius_by_nodes(len(tree_start))\n            near = near_nodes(tree_start, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_start.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for local cost improvement\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Try to incrementally connect other tree to new_node\n            def try_connect(other_tree, node):\n                nearest_node_ot = nearest(other_tree, node.position)\n                last_node = nearest_node_ot\n                while True:\n                    next_pos = steer(last_node.position, node.position)\n                    if not in_bounds(next_pos):\n                        return None\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                        return None\n                    if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d):\n                        return None\n\n                    new_cost = last_node.cost + distance(last_node.position, next_pos)\n                    new_node_ot = Node(next_pos, parent=last_node, cost=new_cost)\n                    last_node.children.append(new_node_ot)\n                    other_tree.append(new_node_ot)\n                    nodes.append(new_node_ot)\n                    edges.append((last_node, new_node_ot))\n\n                    if distance(next_pos, node.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(next_pos, node.position, obstacles, is_3d):\n                            final_cost = new_node_ot.cost + distance(next_pos, node.position)\n                            final_node_ot = Node(node.position, parent=new_node_ot, cost=final_cost)\n                            new_node_ot.children.append(final_node_ot)\n                            other_tree.append(final_node_ot)\n                            nodes.append(final_node_ot)\n                            edges.append((new_node_ot, final_node_ot))\n                            return final_node_ot\n                        return None\n                    last_node = new_node_ot\n\n            new_node_goal = try_connect(tree_goal, new_node)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.77813,
    "time_improvement": 17.0,
    "length_improvement": 9.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007270336151123047,
            "num_nodes_avg": 93.7,
            "path_length_avg": 175.8249739754734,
            "success_improvement": 0.0,
            "time_improvement": 22.90909826347018,
            "length_improvement": 12.12436794823313,
            "objective_score": 9.297603068687682
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.017373061180114745,
            "num_nodes_avg": 263.4,
            "path_length_avg": 284.32913532868247,
            "success_improvement": 0.0,
            "time_improvement": -17.918191189297552,
            "length_improvement": 5.649973615185909,
            "objective_score": -4.2454626337520835
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.01591005325317383,
            "num_nodes_avg": 196.4,
            "path_length_avg": 148.58224972447996,
            "success_improvement": 0.0,
            "time_improvement": 45.09978140808732,
            "length_improvement": 8.761547923854202,
            "objective_score": 15.282244007197034
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm implements an enhanced bidirectional RRT* planner with tuned parameters for improved planning efficiency, path quality, robustness, and success rate. It features adaptive goal biasing with balanced tree growth, dynamic rewiring radius that shrinks with tree size, and strict collision and boundary checks. Integrated pruning of redundant nodes and early stopping upon finding a valid connection reduce search time. The approach carefully ensures nodes and edges are collision-free and within bounds, aiming for smoother, shorter, and more reliable paths.",
    "planning_mechanism": "The planner grows two trees from start and goal points alternately by sampling points with goal bias and extending the smaller tree. It dynamically adjusts the rewiring radius based on node count to rewire locally and improve path cost. Connection attempts between trees are incremental and collision-free. Throughout, bounds and collision checks prevent invalid expansions or connections. When trees connect, the optimal path is extracted by merging the backtracked paths. The planner stops early once a high-quality path is found, leveraging dynamic parameter tuning to balance exploration and exploitation for improved performance.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0,\n                 goal_sample_rate: float = 0.12, radius_constant: float = 15.0, radius_min: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free():\n            # Adaptive goal bias: more biased towards goal as iteration passes\n            p_goal = self.goal_sample_rate + 0.2 * min(1.0, len(tree_start)/(self.max_iter/10))\n            if random.random() < p_goal:\n                return goal_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [node for node in tree if (sum((node.position[d] - pos[d])**2 for d in range(len(pos)))) <= r2]\n\n        def radius_by_nodes(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        # Initialize trees, nodes, edges\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        success_state = False\n        extracted_path = []\n        best_path_cost = float('inf')\n\n        for itr in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Balance tree sizes: extend smaller first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            nearest_node = nearest(tree_start, rand_point)\n            new_pos = steer(nearest_node.position, rand_point)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            rewiring_radius = radius_by_nodes(len(tree_start))\n            near = near_nodes(tree_start, new_pos, rewiring_radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_start.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors around new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-10 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            # Incremental connection attempt to opposite tree\n            def try_connect(tree, node):\n                nearest_node = nearest(tree, node.position)\n                last_node = nearest_node\n                while True:\n                    next_pos = steer(last_node.position, node.position)\n\n                    if not in_bounds(next_pos):\n                        return None\n                    if self._is_in_obstacle(next_pos, obstacles, is_3d):\n                        return None\n                    if self._is_edge_in_obstacle(last_node.position, next_pos, obstacles, is_3d):\n                        return None\n\n                    new_cost = last_node.cost + distance(last_node.position, next_pos)\n                    new_node_conn = Node(next_pos, parent=last_node, cost=new_cost)\n                    last_node.children.append(new_node_conn)\n                    tree.append(new_node_conn)\n                    nodes.append(new_node_conn)\n                    edges.append((last_node, new_node_conn))\n\n                    if distance(next_pos, node.position) <= self.step_size:\n                        if not self._is_edge_in_obstacle(next_pos, node.position, obstacles, is_3d):\n                            final_cost = new_node_conn.cost + distance(next_pos, node.position)\n                            final_node = Node(node.position, parent=new_node_conn, cost=final_cost)\n                            new_node_conn.children.append(final_node)\n                            tree.append(final_node)\n                            nodes.append(final_node)\n                            edges.append((new_node_conn, final_node))\n                            return final_node\n                        else:\n                            return None\n                    last_node = new_node_conn\n\n            new_node_goal = try_connect(tree_goal, new_node)\n\n            if new_node_goal:\n                path_start = new_node.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                candidate_path = path_start + path_goal[::-1][1:]\n                path_cost = new_node.cost + new_node_goal.cost\n\n                # Accept path if better and update\n                if path_cost < best_path_cost:\n                    best_path_cost = path_cost\n                    extracted_path = candidate_path\n                    success_state = True\n\n                    # Early stopping if path is reasonably short relative to map diagonal\n                    diagonal = math.dist((0,) * len(bounds), bounds)\n                    if best_path_cost <= diagonal * 1.3:\n                        break\n\n            # Optional pruning to remove nodes too far from start-goal corridor for efficiency (not mandatory)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6105.42998,
    "time_improvement": -20348.0,
    "length_improvement": 11.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.16205146312713622,
            "num_nodes_avg": 636.4,
            "path_length_avg": 171.68568889086208,
            "success_improvement": -9.999999999999998,
            "time_improvement": -1618.3102899946657,
            "length_improvement": 14.193142848796523,
            "objective_score": -487.6544584286404
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 8.772035193443298,
            "num_nodes_avg": 11912.5,
            "path_length_avg": 256.83077290369636,
            "success_improvement": -9.999999999999998,
            "time_improvement": -59439.45089675104,
            "length_improvement": 14.774860578800912,
            "objective_score": -17833.880296909552
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02486231327056885,
            "num_nodes_avg": 219.2,
            "path_length_avg": 154.85249072637475,
            "success_improvement": 0.0,
            "time_improvement": 14.208556594079665,
            "length_improvement": 4.911242223017806,
            "objective_score": 5.244815422827461
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This planner implements a streamlined bidirectional RRT* algorithm with adaptive sampling bias, dynamic neighbor radius for rewiring, and iterative shortcut smoothing to efficiently find and optimize collision-free paths in both 2D and 3D spaces. It balances exploration by always extending the smaller tree, rigorously checks node and edge collisions, and incrementally connects trees to establish solution paths with enhanced smoothness and quality.",
    "planning_mechanism": "The planner alternates growing two trees from start and goal positions by sampling points biased towards these states. Each extension uses a dynamic radius based on the current tree size for local rewiring to improve path costs. It ensures new nodes and connecting edges are collision-free and within bounds. When the trees connect, the resulting path is shortcut-smoothed iteratively to enhance smoothness and shorten path length. Dead-end pruning is included periodically to remove redundant nodes and reduce computational load, boosting overall efficiency and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0,\n                 radius_min: float = 5.0, prune_interval: int = 250,\n                 smoothing_iterations: int = 40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            p_bias = 0.8\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_bias else start_position\n            else:\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def radius_dynamic(n: int) -> float:\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos: Tuple[float, ...]) -> bool:\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos):\n                return None\n            if not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos):\n                    return None\n                if not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path: List[Tuple[float, ...]]) -> float:\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if not can_connect(p1, p2):\n                    continue\n                path = path[:i + 1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always extend smaller tree for better balance\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed_path = shortcut_smoothing(raw_path)\n                if path_length(smoothed_path) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed_path\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > 200:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.65759,
    "time_improvement": 9.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.006646060943603515,
            "num_nodes_avg": 86.8,
            "path_length_avg": 166.138702845762,
            "success_improvement": 0.0,
            "time_improvement": 29.528591183616104,
            "length_improvement": 16.96547315929892,
            "objective_score": 12.251671986944615
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02330734729766846,
            "num_nodes_avg": 233.5,
            "path_length_avg": 246.29505596357498,
            "success_improvement": 0.0,
            "time_improvement": -58.196658969209636,
            "length_improvement": 18.2709678987007,
            "objective_score": -13.804804111022749
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.012709426879882812,
            "num_nodes_avg": 157.3,
            "path_length_avg": 124.72154139382317,
            "success_improvement": 0.0,
            "time_improvement": 56.144061696065926,
            "length_improvement": 23.413460232130713,
            "objective_score": 21.525910555245922
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This improved planner implements a hybrid bidirectional RRT* algorithm that combines adaptive informed sampling biased towards start, goal, and dynamically identified promising inter-tree frontiers. It features balanced tree growth by always extending the smaller tree, a dynamically decaying rewiring radius to optimize local path costs efficiently, and periodic pruning of dead-end nodes to reduce complexity. After successful tree connection, it applies iterative multi-phase shortcut smoothing with adaptive step sizes to enhance path smoothness and minimize length, while strictly enforcing collision and edge checks throughout to guarantee safety and robustness. This approach improves planning efficiency, increases success rate, and yields shorter, smoother paths with reduced computational overhead.",
    "planning_mechanism": "The planner alternates growth between two balanced trees rooted at start and goal positions, sampling adaptively to bias exploration towards promising regions between the trees. Using a decaying connection radius, it rewires the trees locally to find lower-cost paths. After each successful extension, it attempts tree connection and on success extracts the combined path. To keep the tree lean, dead-end nodes are periodically pruned. Finally, multi-pass shortcut smoothing refines the path to reduce unnecessary detours while preserving collision-free guarantees.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 30.0,\n                 radius_min: float = 3.0, prune_interval: int = 200,\n                 prune_threshold: int = 100, smoothing_phases: int = 3):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_phases = smoothing_phases\n\n    def plan(self, map):\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        from math import sqrt, log, exp, dist\n        import random\n\n        def node_in_bounds(pos):\n            for i, val in enumerate(pos):\n                if val < 0 or val > bounds[i]:\n                    return False\n            return True\n\n        def is_free_node(pos):\n            return node_in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def is_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def steer(frm, to):\n            d = dist(frm, to)\n            if d <= self.step_size:\n                return to\n            ratio = self.step_size / d\n            return tuple(frm[i] + ratio * (to[i] - frm[i]) for i in range(dim))\n\n        def nearest(tree, p):\n            return min(tree, key=lambda n: dist(n.position, p))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius*radius\n            return [node for node in tree if sum((node.position[i] - pos[i])**2 for i in range(dim)) <= r2]\n\n        def radius_dyn(n_nodes, itr):\n            if n_nodes <= 1:\n                return self.radius_constant\n            base = self.radius_constant * sqrt(log(n_nodes) / n_nodes)\n            decay = exp(-5 * itr / self.max_iter)\n            return max(self.radius_min, base * decay)\n\n        def adaptive_sample(itr):\n            r = random.random()\n            # Bias sampling: goal, start, then frontier zone\n            if r < self.goal_sample_rate:\n                subr = random.random()\n                if subr < 0.6 and is_free_node(goal_position):\n                    return goal_position\n                elif subr < 0.85 and is_free_node(start_position):\n                    return start_position\n                else:\n                    # Sample near frontier midpoint between two trees\n                    if len(tree_start) > 10 and len(tree_goal) > 10:\n                        t_s_sample = random.choice(tree_start).position\n                        t_g_sample = random.choice(tree_goal).position\n                        mid = tuple((t_s_sample[i] + t_g_sample[i]) * 0.5 for i in range(dim))\n                        spread = self.step_size * 3 * (1 - itr / self.max_iter)\n                        for _ in range(15):\n                            candidate = tuple(\n                                max(0, min(bounds[d], mid[d] + random.uniform(-spread, spread))) for d in range(dim))\n                            if is_free_node(candidate):\n                                return candidate\n            # Uniform fallback\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if is_free_node(sample):\n                    return sample\n            # If all fails, return start as fallback\n            return start_position\n\n        def try_extend(tree, point, itr):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n            if not is_free_node(new_pos):\n                return None\n            if not is_free_edge(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dyn(len(tree), itr)\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in neighbors:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, cost=min_cost)\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors via new node to improve cost\n            for neighbor in neighbors:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n            return new_node\n\n        def try_connect(tree, target_node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, target_node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, target_node.position)\n                if not is_free_node(new_pos) or not is_free_edge(last_node.position, new_pos):\n                    return None\n\n                radius = radius_dyn(len(tree), 0)\n                neighbors = near_nodes(tree, new_pos, radius)\n\n                min_cost = last_node.cost + dist(last_node.position, new_pos)\n                best_parent = last_node\n                for node in neighbors:\n                    tentative_cost = node.cost + dist(node.position, new_pos)\n                    if tentative_cost + 1e-15 < min_cost and is_free_edge(node.position, new_pos):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n                new_node = Node(new_pos, cost=min_cost)\n                new_node.parent = best_parent\n                best_parent.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for neighbor in neighbors:\n                    if neighbor is best_parent:\n                        continue\n                    cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_via_new + 1e-15 < neighbor.cost and is_free_edge(new_node.position, neighbor.position):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n                if dist(new_pos, target_node.position) <= self.step_size:\n                    if is_free_edge(new_pos, target_node.position):\n                        final_cost = new_node.cost + dist(new_pos, target_node.position)\n                        final_node = Node(target_node.position, cost=final_cost)\n                        final_node.parent = new_node\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_ends():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if not node.children:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path)-1):\n                length += dist(path[i], path[i+1])\n            return length\n\n        def multi_pass_shortcut(path):\n            if len(path) < 3:\n                return path\n            smoothed_path = path[:]\n            for phase in range(self.smoothing_phases):\n                max_trials = 100 + phase * 50\n                max_skip = max(2, len(smoothed_path) // (10 + phase))\n                for _ in range(max_trials):\n                    if len(smoothed_path) < 3:\n                        break\n                    i = random.randint(0, len(smoothed_path) - max_skip - 1)\n                    j = random.randint(i + 2, min(len(smoothed_path) - 1, i + max_skip))\n                    p1, p2 = smoothed_path[i], smoothed_path[j]\n                    if not is_free_edge(p1, p2):\n                        continue\n                    # Shortcut feasible, remove intermediate nodes\n                    smoothed_path = smoothed_path[:i+1] + smoothed_path[j:]\n            return smoothed_path\n\n        for itr in range(self.max_iter):\n            sample_pt = adaptive_sample(itr)\n\n            # Balance tree growth: extend smaller tree first\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt, itr)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                combined_path = path_start + path_goal[::-1][1:]\n                smoothed = multi_pass_shortcut(combined_path)\n                if path_length(smoothed) + 1e-15 < path_length(combined_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = combined_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_ends()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 18.36471,
    "time_improvement": -76.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.022461485862731934,
            "num_nodes_avg": 77.1,
            "path_length_avg": 157.14880453996443,
            "success_improvement": 0.0,
            "time_improvement": -138.1700327890403,
            "length_improvement": 21.458537926157746,
            "objective_score": -37.15930225148054
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031866955757141116,
            "num_nodes_avg": 210.4,
            "path_length_avg": 237.59490079802845,
            "success_improvement": 0.0,
            "time_improvement": -116.29428128029156,
            "length_improvement": 21.157973721977953,
            "objective_score": -30.656689639691873
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021286320686340333,
            "num_nodes_avg": 148.4,
            "path_length_avg": 124.112925804458,
            "success_improvement": 0.0,
            "time_improvement": 26.54809885915918,
            "length_improvement": 23.78718686762088,
            "objective_score": 12.721867031271929
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with adaptive rewiring, dynamic radius adjustment, heuristic informed sampling towards the goal, and enhanced collision checking. It further improves efficiency and path quality by integrating lazy collision edge checking with a caching mechanism, uses goal- and informed-biased sampling with dynamic adjustment of sampling probabilities, and employs a priority-driven pruning strategy to discard nodes unlikely to contribute to an optimal path. Local path smoothing is applied after path extraction to improve path smoothness and reduce length.",
    "planning_mechanism": "The planner grows two trees alternately from start and goal positions. Each iteration samples points biased towards the goal, informed by a dynamic heuristic that balances exploration and exploitation. Extensions use a fixed step-size steering function with strict collision checks for nodes and edges. Rewiring considers a dynamically shrinking radius to incrementally optimize local paths. After connecting the trees, the planner backtracks to build the initial path, then applies local smoothing to reduce unnecessary detours. Periodic pruning removes dead-end and suboptimal nodes to maintain efficiency and robustness, ensuring faster convergence to high-quality, smooth, and collision-free paths.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to current node\n        self.children = []\n        self.valid = True               # For collision state caching\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def disconnect(self):\n        # Disconnect node from its parent and children\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\n        for child in self.children[:]:\n            child.parent = None\n        self.children.clear()\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.2, radius_constant: float = 20.0, radius_min: float = 5.0,\n                 pruning_interval: int = 200, smoothing_iterations: int = 30):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.pruning_interval = pruning_interval\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        nodes: List[Node] = []\n        edges: List[Tuple[Node, Node]] = []\n\n        # Cache for edge collision checks: {(from_pos, to_pos): True/False}\n        edge_collision_cache = {}\n\n        def distance(p1, p2):\n            return math.dist(p1, p2)\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            # Linear nearest neighbor search, can be replaced with KDTree for optimization\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes):\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def is_edge_collision_cached(p1, p2):\n            key = (p1, p2) if p1 < p2 else (p2, p1)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            collides = self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n            edge_collision_cache[key] = collides\n            return collides\n\n        def can_connect_points(p1, p2):\n            # Check node collision and edge collision\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if is_edge_collision_cached(p1, p2):\n                return False\n            return True\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not can_connect_points(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost and can_connect_points(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to improve path costs locally\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost and can_connect_points(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_connect_points(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if can_connect_points(new_pos, node.position):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        def sample_free():\n            p_goal_bias = 0.75\n            if math.dist(start_position, goal_position) > 0.5 * max(bounds):  # Large map heuristic\n                dynamic_goal_rate = min(0.95, self.goal_sample_rate + 0.1)\n            else:\n                dynamic_goal_rate = self.goal_sample_rate\n\n            if random.random() < dynamic_goal_rate:\n                # Heavy bias to goal with small probability start bias for quick start connections\n                if random.random() < p_goal_bias:\n                    return goal_position\n                else:\n                    return start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def prune_nodes():\n            # Remove leaf nodes with high costs (beyond median path cost) periodically to reduce tree size\n            if len(nodes) < 50:\n                return\n            costs = [node.cost for node in nodes if node.parent is not None]\n            if not costs:\n                return\n            median_cost = sorted(costs)[len(costs)//2]\n            to_prune = [node for node in nodes if not node.children and node is not start_root and node is not goal_root and node.cost > median_cost*1.5]\n\n            for node in to_prune:\n                try:\n                    if node.parent:\n                        node.parent.children.remove(node)\n                    nodes.remove(node)\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                except Exception:\n                    continue\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path)-3)\n                j = random.randint(i+2, len(path)-1)\n                if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                    # Shortcut points between i and j\n                    path = path[:i+1] + path[j:]\n            return path\n\n        import random\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Extend the smaller tree first to balance growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                extracted_path = smooth_path(extracted_path)\n                break\n\n            if itr > 0 and itr % self.pruning_interval == 0:\n                prune_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.10698,
    "time_improvement": -24.0,
    "length_improvement": 16.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007276272773742676,
            "num_nodes_avg": 124.6,
            "path_length_avg": 173.47229947536502,
            "success_improvement": 0.0,
            "time_improvement": 22.846149373418374,
            "length_improvement": 13.300212050663868,
            "objective_score": 9.513887222158285
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03372855186462402,
            "num_nodes_avg": 317.1,
            "path_length_avg": 255.466925471393,
            "success_improvement": 0.0,
            "time_improvement": -128.92970824642,
            "length_improvement": 15.227431297851316,
            "objective_score": -35.63342621435574
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019130492210388185,
            "num_nodes_avg": 217.2,
            "path_length_avg": 133.51747362394906,
            "success_improvement": 0.0,
            "time_improvement": 33.9871345866375,
            "length_improvement": 18.01222796696099,
            "objective_score": 13.79858596938345
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m1",
    "algorithm_description": "This planner is an advanced bidirectional RRT* variant that integrates adaptive informed sampling within an ellipse guided by heuristic cost-to-go, lazy collision checking, dynamic neighborhood radii for rewiring, periodic pruning of low-potential branches, and path smoothing by shortcutting. It balances exploration and exploitation by alternating tree growth, pruning unpromising branches, and applying efficient local optimizations to improve the path quality, smoothness, and computation time.",
    "planning_mechanism": "The planner grows two trees from start and goal by sampling points within an informed ellipse bounded by the current best path cost, steering towards samples while avoiding obstacles. Lazy collision checks reduce unnecessary computations by deferring edge validations until connection attempts. Nodes rewire locally using a dynamic radius shrinking with node count to optimize path costs. Upon connection, the path is extracted and shortcut smoothing removes jaggedness. Periodic pruning of dead leaves focuses search on promising areas, enhancing robustness and planning efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Validity flag for collision or pruning\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def is_leaf(self):\n        return len(self.children) == 0\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15,\n                 radius_constant: float = 30.0, radius_min: float = 5.0,\n                 prune_interval: int = 300, prune_threshold: int = 150,\n                 smoothing_trials: int = 50):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_trials = smoothing_trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos, cost=0.0)\n        goal_root = Node(goal_pos, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def heuristic(a, b):\n            return math.dist(a, b)\n\n        def dynamic_radius(n):\n            if n == 0:\n                return self.radius_min\n            r = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(r, self.radius_min)\n\n        def steer(from_p, to_p):\n            dist = math.dist(from_p, to_p)\n            if dist <= self.step_size:\n                return to_p\n            ratio = self.step_size / dist\n            return tuple(from_p[d] + (to_p[d] - from_p[d]) * ratio for d in range(len(from_p)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r2 = radius * radius\n            return [n for n in tree if sum((n.position[d] - pos[d]) ** 2 for d in range(len(pos))) <= r2]\n\n        def informed_sample(cost_best):\n            if cost_best == float('inf'):\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = heuristic(start_pos, goal_pos)\n                if cost_best < c_min:\n                    cost_best = c_min * 1.0001\n                c_best = cost_best\n                center = tuple((start_pos[d] + goal_pos[d]) / 2 for d in range(len(start_pos)))\n                vec = tuple((goal_pos[d] - start_pos[d]) / c_min for d in range(len(start_pos)))\n                import numpy as np\n\n                dim = len(start_pos)\n                L = np.diag([c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1))\n                e1 = np.array(vec)\n                if dim == 2:\n                    e2 = np.array([-e1[1], e1[0]])\n                    C = np.column_stack((e1, e2))\n                else:\n                    a = np.array([1.0, 0.0, 0.0])\n                    if abs(np.dot(a, e1)) > 0.9:\n                        a = np.array([0.0, 1.0, 0.0])\n                    v2 = a - np.dot(a, e1) * e1\n                    v2 /= np.linalg.norm(v2)\n                    v3 = np.cross(e1, v2)\n                    C = np.column_stack((e1, v2, v3))\n\n                while True:\n                    sample_in_unit_ball = np.random.uniform(-1, 1, dim)\n                    if np.linalg.norm(sample_in_unit_ball) > 1.0:\n                        continue\n                    sample = np.dot(C, np.dot(L, sample_in_unit_ball)) + np.array(center)\n                    sample_t = tuple(sample)\n                    if all(0 <= sample_t[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(sample_t, obstacles, is_3d):\n                        return sample_t\n\n        lazy_checked_edges = set()\n\n        def try_extend(tree, sample_pt):\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not self._pos_in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n\n            n_nodes = len(tree)\n            r = dynamic_radius(n_nodes)\n            near = near_nodes(tree, new_pos, r)\n\n            min_cost = nearest_node.cost + heuristic(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + heuristic(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    key = (node, new_pos)\n                    if key not in lazy_checked_edges:\n                        if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                            lazy_checked_edges.add(key)\n                            min_cost = tentative_cost\n                            best_parent = node\n\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                return None\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + heuristic(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not self._pos_in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + heuristic(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if heuristic(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d) and not self._is_in_obstacle(node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node, cost=new_node.cost + heuristic(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_branches():\n            removed = []\n            for node in nodes[:]:\n                if node is start_root or node is goal_root:\n                    continue\n                if node.is_leaf():\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if c != node and p != node]\n                        removed.append(node)\n                    except Exception:\n                        continue\n            return removed\n\n        def shortcut_path(path_raw):\n            if len(path_raw) < 3:\n                return path_raw[:]\n            smooth_path = path_raw[:]\n            for _ in range(self.smoothing_trials):\n                if len(smooth_path) < 3:\n                    break\n                i = random.randint(0, len(smooth_path) - 3)\n                j = random.randint(i + 2, len(smooth_path) - 1)\n                pt_i = smooth_path[i]\n                pt_j = smooth_path[j]\n                if not self._is_edge_in_obstacle(pt_i, pt_j, obstacles, is_3d):\n                    del smooth_path[i + 1:j]\n            return smooth_path\n\n        best_path_cost = float('inf')\n        best_path = []\n\n        tree_turn = 0\n        for itr in range(self.max_iter):\n            sample_pt = informed_sample(best_path_cost)\n\n            if tree_turn == 0:\n                new_node = try_extend(tree_start, sample_pt)\n                if new_node is None:\n                    tree_turn = 1\n                    continue\n                connect_node = try_connect(tree_goal, new_node)\n                if connect_node:\n                    success = True\n                    path_start = new_node.path_from_root()\n                    path_goal = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n            else:\n                new_node = try_extend(tree_goal, sample_pt)\n                if new_node is None:\n                    tree_turn = 0\n                    continue\n                connect_node = try_connect(tree_start, new_node)\n                if connect_node:\n                    success = True\n                    path_goal = new_node.path_from_root()\n                    path_start = connect_node.path_from_root()\n                    candidate_path = path_start + path_goal[::-1][1:]\n                    candidate_cost = sum(heuristic(candidate_path[i], candidate_path[i + 1]) for i in range(len(candidate_path) - 1))\n                    if candidate_cost < best_path_cost:\n                        best_path_cost = candidate_cost\n                        best_path = candidate_path\n                    break\n\n            tree_turn = 1 - tree_turn\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_branches()\n\n        if success and best_path:\n            extracted_path = shortcut_path(best_path)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _pos_in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 6.65444,
    "time_improvement": -35.0,
    "length_improvement": 20.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.011026954650878907,
            "num_nodes_avg": 85.1,
            "path_length_avg": 174.74718142142586,
            "success_improvement": 0.0,
            "time_improvement": -16.92415037958939,
            "length_improvement": 12.663038307546405,
            "objective_score": -2.544637452367535
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.031798171997070315,
            "num_nodes_avg": 224.6,
            "path_length_avg": 237.3695073335063,
            "success_improvement": 0.0,
            "time_improvement": -115.82741729549011,
            "length_improvement": 21.232766898906675,
            "objective_score": -30.501671808865698
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021157193183898925,
            "num_nodes_avg": 131.5,
            "path_length_avg": 122.26079564464422,
            "success_improvement": 0.0,
            "time_improvement": 26.99367424457449,
            "length_improvement": 24.924506359944548,
            "objective_score": 13.083003545361256
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m2",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* algorithm with adaptive radius tuning, heuristic sampling bias, incremental local rewiring, and subtree pruning for efficiency. It dynamically balances tree growth by always expanding the smaller tree, rigorously checks collisions for nodes and edges, and prunes orphaned nodes to reduce search overhead. Adaptive rewiring radius shrinks with increasing nodes to locally optimize paths, improving smoothness and shortening the final path. The method aims to increase success rate, reduce planning time, and achieve high-quality, smooth, collision-free paths.",
    "planning_mechanism": "The planner grows trees from start and goal alternately, sampling points biased towards the goal and start to efficiently explore the free space. It extends the smaller tree toward sampled points, ensuring nodes and edges are collision-free and within map bounds. Local rewiring improves path costs incrementally within a diminishing radius. After each successful extension, an attempt to connect the trees is performed via incremental steering and collision checks. Periodic pruning removes nodes without children, focusing the search. On success, the optimal path is reconstructed by concatenating paths from both trees.",
    "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children: List['Node'] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0,\n                 goal_sample_rate: float = 0.15, radius_constant: float = 25.0, radius_min: float = 4.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos: Tuple[float, ...]) -> bool:\n            return all(0 <= pos[d] <= bounds[d] for d in range(len(pos)))\n\n        def sample_free() -> Tuple[float, ...]:\n            p_goal_bias = 0.7\n            if random.random() < self.goal_sample_rate:\n                return goal_position if random.random() < p_goal_bias else start_position\n            else:\n                while True:\n                    if is_3d:\n                        sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        sample = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...]) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def distance(a: Tuple[float, ...], b: Tuple[float, ...]) -> float:\n            return math.dist(a, b)\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree: List[Node], pos: Tuple[float, ...], radius: float) -> List[Node]:\n            return [node for node in tree if distance(node.position, pos) <= radius]\n\n        def radius_by_nodes(n_nodes: int) -> float:\n            if n_nodes == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n_nodes + 1) / (n_nodes + 1))\n            return max(val, self.radius_min)\n\n        def try_extend(tree: List[Node], sample_pt: Tuple[float, ...]) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            radius = radius_by_nodes(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + distance(node.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = tentative_cost\n                        best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            edges.append((best_parent, new_node))\n            nodes.append(new_node)\n\n            # Local rewiring to improve path cost/smoothness\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + distance(new_node.position, neighbor.position)\n                if cost_via_new + 1e-9 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_via_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree: List[Node], node: Node) -> Node or None:\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not in_bounds(new_pos):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(last_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = last_node.cost + distance(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if distance(new_pos, node.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_pos, node.position, obstacles, is_3d):\n                        final_node = Node(node.position, parent=new_node,\n                                         cost=new_node.cost + distance(new_pos, node.position))\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n\n                last_node = new_node\n\n        # Initialization\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n\n        # Main planning loop\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Always grow smaller tree first for balanced exploration\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            # Prune orphan nodes every 200 iterations to keep data structures compact\n            if itr > 0 and itr % 200 == 0 and len(nodes) > 150:\n                prune_candidates = [node for node in nodes if not node.children and node not in (start_root, goal_root)]\n                for node in prune_candidates:\n                    try:\n                        if node.parent:\n                            node.parent.children.remove(node)\n                        nodes.remove(node)\n                        edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    except Exception:\n                        continue\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...],\n                             obstacles: List[Tuple], is_3d: bool, resolution: float = 1.0) -> bool:\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -9.02461,
    "time_improvement": 25.0,
    "length_improvement": 8.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.003792262077331543,
            "num_nodes_avg": 66.8,
            "path_length_avg": 168.00394756644715,
            "success_improvement": 0.0,
            "time_improvement": 59.788805209842266,
            "length_improvement": 16.033241775694147,
            "objective_score": 21.14328991809151
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.016602730751037596,
            "num_nodes_avg": 198.8,
            "path_length_avg": 296.5552711651429,
            "success_improvement": 0.0,
            "time_improvement": -12.689638208731068,
            "length_improvement": 1.5929281160643172,
            "objective_score": -3.4883058394064568
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.021316719055175782,
            "num_nodes_avg": 196.3,
            "path_length_avg": 150.75164495033886,
            "success_improvement": 0.0,
            "time_improvement": 26.44320435834594,
            "length_improvement": 7.429408568609701,
            "objective_score": 9.418843021225722
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm implements a simplified, efficient bidirectional RRT* style planner that grows two trees simultaneously from start and goal, performs collision-free extensions with rewiring to locally optimize path costs, and merges the trees when possible. It ensures path quality and smoothness by combining rewiring with strict collision and edge checks while maintaining concise, generalizable code for 2D and 3D environments.",
    "planning_mechanism": "The planner alternately samples points with goal biasing, extends one tree towards the sample by connecting to the best parent in a local neighborhood, rewires nearby nodes to improve costs, and then tries to connect the other tree to the new node. On successful connection, it reconstructs and returns the combined path.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start + tree_goal)\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Bias equally to start or goal to reduce symmetry issues\n                return start_position if random.random() < 0.5 else goal_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if not self._in_bounds(new_pos, bounds):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                cost_through_node = node.cost + math.dist(node.position, new_pos)\n                if cost_through_node < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost_through_node\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n\n                if not self._in_bounds(new_pos, bounds):\n                    return None\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        for _ in range(self.max_iter):\n            rand_point = sample_free()\n\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                extracted_path = path_start + path_goal[::-1][1:]\n                break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -7.49033,
    "time_improvement": 24.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.007081270217895508,
            "num_nodes_avg": 84.1,
            "path_length_avg": 163.23743000027963,
            "success_improvement": 0.0,
            "time_improvement": 24.913856087208234,
            "length_improvement": 18.415501441896335,
            "objective_score": 11.157257114541737
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.01687190532684326,
            "num_nodes_avg": 260.3,
            "path_length_avg": 257.61537888491745,
            "success_improvement": -9.999999999999998,
            "time_improvement": -14.516637996740839,
            "length_improvement": 14.51450176983004,
            "objective_score": -6.452091045056242
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.010714864730834961,
            "num_nodes_avg": 188.7,
            "path_length_avg": 131.43786298183764,
            "success_improvement": -9.999999999999998,
            "time_improvement": 63.026621812955405,
            "length_improvement": 19.289234179070217,
            "objective_score": 17.765833379700666
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "cross_over",
    "algorithm_description": "This planner is an enhanced bidirectional RRT* variant integrating adaptive goal biasing, dynamic neighbor radius based on node density and iteration, heuristic-informed sampling, balanced tree growth extending the smaller tree first, efficient rewiring, lazy collision and edge checking, along with periodic pruning of dead-end nodes and iterative shortcut smoothing. These combined heuristics prioritize rapid discovery of feasible paths, continuous cost optimization, and robust collision avoidance, producing smooth, short paths with minimized planning time and improved success rates.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, alternately extending the smaller tree toward adaptively sampled points biased toward the goal and start positions. It dynamically adjusts neighbor radius according to iteration and node density for effective rewiring. Each new node selects the best parent among nearby nodes to minimize cost, rewires neighbors to optimize paths, and attempts connection to the opposite tree. Periodic pruning removes dead ends to control tree complexity. Once connected, the combined path is extracted and refined through iterative shortcut smoothing to ensure collision-free, smooth, and near-optimal routes, reducing overall search time and path length.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.2,\n                 min_neighbor_radius: float=5.0,\n                 max_neighbor_radius: float=30.0,\n                 prune_interval: int=250,\n                 prune_threshold: int=150,\n                 smoothing_iterations: int=100):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.min_neighbor_radius = min_neighbor_radius\n        self.max_neighbor_radius = max_neighbor_radius\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        def in_bounds(pos):\n            for d in range(len(bounds)):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_free(iteration):\n            # Adaptive goal bias increasing over iterations up to capped value\n            bias = min(self.goal_sample_rate + iteration / self.max_iter * 0.15, 0.35)\n            # Heuristic: bias sampling towards goal more frequently, sometimes start to balance growth\n            if random.random() < bias:\n                return goal_position if random.random() < 0.7 else start_position\n            else:\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                new_pos = to_pos\n            else:\n                ratio = self.step_size / distance_between\n                new_pos = tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n            if in_bounds(new_pos):\n                return new_pos\n            # Clamp inside bounds if out of limits\n            return tuple(max(0, min(new_pos[d], bounds[d])) for d in range(len(bounds)))\n\n        def neighbor_radius(iteration, n_nodes):\n            c = max(n_nodes, 1)\n            r_iter = self.max_neighbor_radius * (1.0 - (iteration / self.max_iter)**0.95)\n            r_nodes = self.min_neighbor_radius + (self.max_neighbor_radius - self.min_neighbor_radius) * math.sqrt(math.log(c + 1) / c)\n            return max(self.min_neighbor_radius, min(r_iter, r_nodes))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            # Linear search for neighbors; could be optimized with spatial structures\n            return [node for node in tree if dist(node.position, pos) <= radius]\n\n        def can_add_node(pos):\n            if not in_bounds(pos):\n                return False\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            return True\n\n        def can_connect(p1, p2):\n            if not in_bounds(p1) or not in_bounds(p2):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        def prune_dead_nodes():\n            # Remove leaf nodes with no children except roots to control tree size\n            removed = 0\n            for node in nodes[:]:\n                if node in (start_root, goal_root):\n                    continue\n                if not node.children:\n                    if node.parent:\n                        try:\n                            node.parent.children.remove(node)\n                        except ValueError:\n                            pass\n                    try:\n                        nodes.remove(node)\n                    except ValueError:\n                        pass\n                    # Remove edges containing this node\n                    edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                    removed += 1\n            return removed\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        nodes = [start_root, goal_root]\n        edges = []\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        success_state = False\n        extracted_path = []\n\n        for iteration in range(self.max_iter):\n            q_rand = sample_free(iteration)\n\n            # Always extend smaller tree first for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_a, tree_b = tree_goal, tree_start\n            else:\n                tree_a, tree_b = tree_start, tree_goal\n\n            r = neighbor_radius(iteration, len(nodes))\n\n            # Extend tree_a towards q_rand using RRT* logic\n            nearest_node = nearest(tree_a, q_rand)\n            new_pos = steer(nearest_node.position, q_rand)\n\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                continue  # Extension failed\n\n            near = near_nodes(tree_a, new_pos, r)\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n\n            # Choose best parent for minimal cost\n            for node in near:\n                potential_cost = node.cost + dist(node.position, new_pos)\n                if potential_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = potential_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to optimize paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            # Attempt to connect tree_b to new_node with incremental extension\n            nearest_b = nearest(tree_b, new_node.position)\n            last_node_b = nearest_b\n\n            connected = False\n            while True:\n                new_pos_b = steer(last_node_b.position, new_node.position)\n                if not can_add_node(new_pos_b) or not can_connect(last_node_b.position, new_pos_b):\n                    break\n\n                cost_b = last_node_b.cost + dist(last_node_b.position, new_pos_b)\n                new_node_b = Node(new_pos_b, parent=last_node_b, cost=cost_b)\n                last_node_b.children.append(new_node_b)\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((last_node_b, new_node_b))\n\n                # Rewire neighbors of new_node_b in tree_b\n                near_b = near_nodes(tree_b, new_pos_b, r)\n                for neighbor_b in near_b:\n                    if neighbor_b is last_node_b:\n                        continue\n                    cost_b_via_new = new_node_b.cost + dist(new_node_b.position, neighbor_b.position)\n                    if cost_b_via_new + 1e-12 < neighbor_b.cost and can_connect(new_node_b.position, neighbor_b.position):\n                        try:\n                            edges.remove((neighbor_b.parent, neighbor_b))\n                        except ValueError:\n                            pass\n                        neighbor_b.update_parent(new_node_b, cost_b_via_new)\n                        edges.append((new_node_b, neighbor_b))\n\n                # Check if trees connected successfully\n                if dist(new_node_b.position, new_node.position) <= self.step_size and can_connect(new_node_b.position, new_node.position):\n                    # Connection node finalizing linkage\n                    final_cost = new_node_b.cost + dist(new_node_b.position, new_node.position)\n                    connection_node = Node(new_node.position, parent=new_node_b, cost=final_cost)\n                    new_node_b.children.append(connection_node)\n                    tree_b.append(connection_node)\n                    nodes.append(connection_node)\n                    edges.append((new_node_b, connection_node))\n\n                    success_state = True\n\n                    if tree_a is tree_start:\n                        path_start = connection_node.path_from_root()\n                        path_goal = new_node.path_from_root()\n                    else:\n                        path_start = new_node.path_from_root()\n                        path_goal = connection_node.path_from_root()\n\n                    merged_path = path_start + path_goal[::-1][1:]\n\n                    # Smooth path with iterative shortcutting\n                    merged_path = shortcut_smoothing(merged_path)\n\n                    extracted_path = merged_path\n                    connected = True\n                    break\n\n                last_node_b = new_node_b\n\n            if connected:\n                break\n\n            # Pruning dead ends periodically to reduce overhead\n            if iteration > 0 and iteration % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 22.26668,
    "time_improvement": -88.0,
    "length_improvement": 21.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.015244626998901367,
            "num_nodes_avg": 104.5,
            "path_length_avg": 165.59287350842615,
            "success_improvement": 0.0,
            "time_improvement": -61.6461766765514,
            "length_improvement": 17.238273415862448,
            "objective_score": -15.04619831979293
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.02926177978515625,
            "num_nodes_avg": 214.1,
            "path_length_avg": 236.51605640952343,
            "success_improvement": 0.0,
            "time_improvement": -98.61186854016405,
            "length_improvement": 21.515970789013974,
            "objective_score": -25.28036640424642
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.05911562442779541,
            "num_nodes_avg": 174.0,
            "path_length_avg": 124.3939271210007,
            "success_improvement": 0.0,
            "time_improvement": -103.98804778582107,
            "length_improvement": 23.61463513145955,
            "objective_score": -26.47348730945441
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "time_expert",
    "algorithm_description": "This improved planner implements a bidirectional RRT* algorithm enhanced with heuristic-biased sampling, dynamic rewiring radius, balanced tree expansion, and an efficient collision checking scheme. To reduce planning time, it integrates an early connection check after node extension, a more adaptive rewiring radius, and incorporates caching of collision checks where possible. Aggressive yet safe shortcut smoothing iteratively improves path quality. Periodic pruning of dead-end nodes limits tree complexity, improving robustness and computational overhead. The planner carefully balances exploration-exploitation by alternating tree expansions based on their sizes and biased sampling towards the start and goal positions, thereby increasing success rate and path smoothness.",
    "planning_mechanism": "The planner grows two trees rooted at start and goal positions, alternately extending the smaller tree towards heuristic-biased sampled points. New nodes are steered with step size limits and collision-checked individually and along edges. After each extension, it attempts to connect the opposite tree by incremental steering. Local rewiring using a dynamically adapting radius minimizes path costs. Periodic pruning removes dead-end nodes to manage complexity. Upon connection, the path is extracted and aggressively shortcut-smoothed with collision validation to produce a high-quality, short, and smooth final path efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.15, radius_constant: float=28.0,\n                 radius_min: float=4.0, prune_interval: int=150, prune_threshold: int=120,\n                 smoothing_iterations: int=40):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.radius_constant = radius_constant\n        self.radius_min = radius_min\n        self.prune_interval = prune_interval\n        self.prune_threshold = prune_threshold\n        self.smoothing_iterations = smoothing_iterations\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        def sample_free():\n            bias_prob = 0.75\n            if random.random() < self.goal_sample_rate:\n                # Bias randomly towards goal or start for balanced search\n                return goal_position if random.random() < bias_prob else start_position\n            else:\n                # Sample until free and in bounds\n                trials = 0\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                    if in_bounds(sample) and not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                    trials += 1\n                    if trials > 100:\n                        # Fallback in rare case to goal to avoid infinite sampling\n                        return goal_position\n\n        def steer(from_pos, to_pos):\n            distance_between = dist(from_pos, to_pos)\n            if distance_between <= self.step_size:\n                return to_pos\n            ratio = self.step_size / distance_between\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: dist(node.position, point))\n\n        def near_nodes(tree, pos, radius):\n            r_sq = radius * radius\n            res = []\n            for node in tree:\n                # Using squared dist for speed\n                dx = [node.position[d] - pos[d] for d in range(len(pos))]\n                dist_sq = sum(x*x for x in dx)\n                if dist_sq <= r_sq:\n                    res.append(node)\n            return res\n\n        def radius_dynamic(n):\n            if n == 0:\n                return self.radius_min\n            val = self.radius_constant * math.sqrt(math.log(n + 1) / (n + 1))\n            return max(val, self.radius_min)\n\n        def can_add_node(pos):\n            return in_bounds(pos) and not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def can_connect(p1, p2):\n            return in_bounds(p1) and in_bounds(p2) and not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def try_extend(tree, sample_pt):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, sample_pt)\n            new_pos = steer(nearest_node.position, sample_pt)\n            if not can_add_node(new_pos) or not can_connect(nearest_node.position, new_pos):\n                return None\n\n            radius = radius_dynamic(len(tree))\n            near = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                tentative_cost = node.cost + dist(node.position, new_pos)\n                if tentative_cost + 1e-12 < min_cost and can_connect(node.position, new_pos):\n                    min_cost = tentative_cost\n                    best_parent = node\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring around new_node for lower-cost paths\n            for neighbor in near:\n                if neighbor is best_parent:\n                    continue\n                cost_via_new = new_node.cost + dist(new_node.position, neighbor.position)\n                if cost_via_new + 1e-12 < neighbor.cost and can_connect(new_node.position, neighbor.position):\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    neighbor.update_parent(new_node, cost_via_new)\n                    edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            if not tree:\n                return None\n            nearest_node = nearest(tree, node.position)\n            last_node = nearest_node\n            while True:\n                new_pos = steer(last_node.position, node.position)\n                if not can_add_node(new_pos) or not can_connect(last_node.position, new_pos):\n                    return None\n\n                new_cost = last_node.cost + dist(last_node.position, new_pos)\n                new_node = Node(new_pos, parent=last_node, cost=new_cost)\n                last_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((last_node, new_node))\n\n                if dist(new_pos, node.position) <= self.step_size:\n                    if can_connect(new_pos, node.position):\n                        final_cost = new_node.cost + dist(new_pos, node.position)\n                        final_node = Node(node.position, parent=new_node, cost=final_cost)\n                        new_node.children.append(final_node)\n                        tree.append(final_node)\n                        nodes.append(final_node)\n                        edges.append((new_node, final_node))\n                        return final_node\n                    else:\n                        return None\n                last_node = new_node\n\n        def prune_dead_nodes():\n            removed = []\n            to_remove = [node for node in nodes if node not in (start_root, goal_root) and not node.children]\n            for node in to_remove:\n                if node.parent:\n                    try:\n                        node.parent.children.remove(node)\n                    except ValueError:\n                        pass\n                try:\n                    nodes.remove(node)\n                except ValueError:\n                    pass\n                edges[:] = [(p, c) for (p, c) in edges if p != node and c != node]\n                removed.append(node)\n            return removed\n\n        def path_length(path):\n            length = 0.0\n            for i in range(len(path) - 1):\n                length += dist(path[i], path[i + 1])\n            return length\n\n        def shortcut_smoothing(path):\n            if len(path) < 3:\n                return path\n            for _ in range(self.smoothing_iterations):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if can_connect(p1, p2):\n                    path = path[:i+1] + path[j:]\n            return path\n\n        for itr in range(self.max_iter):\n            sample_pt = sample_free()\n\n            # Alternate expanding the smaller tree for balanced growth\n            if len(tree_start) > len(tree_goal):\n                tree_start, tree_goal = tree_goal, tree_start\n\n            new_node_start = try_extend(tree_start, sample_pt)\n            if new_node_start is None:\n                continue\n\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                # Connection found; extract and smooth path\n                success_state = True\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n                raw_path = path_start + path_goal[::-1][1:]\n\n                smoothed = shortcut_smoothing(raw_path)\n\n                if path_length(smoothed) + 1e-12 < path_length(raw_path):\n                    extracted_path = smoothed\n                else:\n                    extracted_path = raw_path\n                break\n\n            if itr % self.prune_interval == 0 and len(nodes) > self.prune_threshold:\n                prune_dead_nodes()\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 4.78465,
    "time_improvement": -29.0,
    "length_improvement": 19.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.010508489608764649,
            "num_nodes_avg": 85.3,
            "path_length_avg": 169.57733512935985,
            "success_improvement": 0.0,
            "time_improvement": -11.426613981732185,
            "length_improvement": 15.246877794359904,
            "objective_score": -0.37860863564767433
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.03050069808959961,
            "num_nodes_avg": 166.4,
            "path_length_avg": 240.33070052357533,
            "success_improvement": 0.0,
            "time_improvement": -107.0209223031525,
            "length_improvement": 20.250142816817537,
            "objective_score": -28.05624812758224
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.019695973396301268,
            "num_nodes_avg": 140.1,
            "path_length_avg": 126.45206307167311,
            "success_improvement": 0.0,
            "time_improvement": 32.035850060921085,
            "length_improvement": 22.350815673551054,
            "objective_score": 14.080918152986538
        }
    ],
    "success_rate": 1.0
}
