{
    "operator": "e1",
    "algorithm_description": "This algorithm, named Informed Batch Informed Tree (IBIT*), combines the advantages of sampling-based batch processing and informed heuristic guidance. It incrementally samples batches of points within an informed set and builds a single-tree structure that rewires to improve path quality dynamically. The planner prioritizes node expansions by heuristic costs, prunes unpromising nodes early using cost-to-come and cost-to-go estimates, and smooths the final path by shortcutting. It is designed to improve planning efficiency, path length, and robustness, especially in cluttered environments.",
    "planning_mechanism": "The planner iteratively samples a batch of points confined to an ellipsoidal informed subset bounded by the current best cost. It then constructs a tree by connecting the best candidate nodes first using a prioritized search queue sorted by estimated total cost (cost-to-come + heuristic to goal). Nodes and edges are added only if collision-free. Rewiring of nearby nodes reduces path cost dynamically. After each batch, pruning removes nodes outside the informed set or with costs exceeding the current best path. Once a path connects start and goal, path shortcuts are applied to enhance smoothness before termination.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost-to-come\n        self.children = []\n        self.valid = True               # Flag for pruning/validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def disconnect(self):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n            self.parent = None\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, batch_size: int = 100, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.batch_size = batch_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import heapq\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def heuristic(pos):\n            return math.dist(pos, goal_pos)\n\n        # Ellipsoidal informed sampler parameters\n        c_best = float('inf')\n        c_min = math.dist(start_pos, goal_pos)\n        x_center = [(s + g) * 0.5 for s, g in zip(start_pos, goal_pos)]\n        a1 = [g - s for s, g in zip(start_pos, goal_pos)]\n        a1_norm = math.sqrt(sum(x * x for x in a1))\n        if a1_norm != 0:\n            a1 = [x / a1_norm for x in a1]\n        else:\n            a1 = [1.0] + [0.0] * (dim - 1)\n\n        # Nodes and edges containers\n        nodes = []\n        edges = []\n\n        start_node = Node(start_pos, cost=0.0)\n        goal_node = Node(goal_pos)\n        nodes.append(start_node)\n\n        # Holds unexplored nodes, sorted by estimated total cost f = g + h\n        open_queue = []\n        heapq.heappush(open_queue, (heuristic(start_node.position), start_node))\n\n        # Sampled points not yet connected in the tree\n        sampled_points = set()\n\n        success_state = False\n        extracted_path = []\n\n        def rotate_to_world_frame(x_ball):\n            import numpy as np\n            a1_vec = np.array(a1).reshape((dim, 1))\n            id_mat = np.eye(dim)\n            M = a1_vec @ id_mat[0].reshape((1, dim))\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n            return C @ x_ball\n\n        def informed_sample():\n            import numpy as np\n            import random as rnd\n            if c_best == float('inf'):\n                # Uniform sample in bounds\n                while True:\n                    sample = tuple(rnd.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            else:\n                r1 = c_best * 0.5\n                r2 = math.sqrt(c_best ** 2 - c_min ** 2) * 0.5\n                L = np.diag([r1] + [r2] * (dim - 1))\n                while True:\n                    x_ball = np.random.normal(0, 1, dim)\n                    x_ball = x_ball / np.linalg.norm(x_ball)\n                    radius = np.random.random() ** (1.0 / dim)\n                    x_ball = x_ball * radius\n                    x_rand = rotate_to_world_frame(x_ball) + np.array(x_center)\n                    if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                        sample = tuple(x_rand)\n                        if not self._is_in_obstacle(sample, obstacles, is_3d):\n                            return sample\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, node, radius):\n            result = []\n            for n in tree:\n                if n.valid and math.dist(n.position, node.position) <= radius:\n                    result.append(n)\n            return result\n\n        def try_rewire(new_node, near_nodes_list):\n            for near in near_nodes_list:\n                if near == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire\n                        if near.parent:\n                            near.disconnect()\n                        near.parent = new_node\n                        new_node.children.append(near)\n                        near.cost = cost_through_new\n\n        def prune_nodes():\n            # Mark nodes as invalid if cost + heuristic >= c_best or outside informed subset\n            heapq.heapify(open_queue)  # Rebuild priority queue\n            new_queue = []\n            for f_cost, node in open_queue:\n                if node.valid and node.cost + heuristic(node.position) < c_best:\n                    heapq.heappush(new_queue, (f_cost, node))\n                else:\n                    node.valid = False\n                    # Disconnect subtree recursively\n                    self._prune_subtree(node)\n            open_queue.clear()\n            open_queue.extend(new_queue)\n\n        def path_smoothing(path_pts):\n            # Shortcut smoothing by random shortcuts\n            import random\n            smoothed = path_pts[:]\n            iteration = 0\n            max_iter_smooth = 100\n            while iteration < max_iter_smooth:\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 3)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                p1 = smoothed[i]\n                p2 = smoothed[j]\n                if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                    # Shortcut possible, remove intermediate points\n                    smoothed = smoothed[:i + 1] + smoothed[j:]\n                iteration += 1\n            return smoothed\n\n        iter_count = 0\n        samples_pool = set()\n\n        while iter_count < self.max_iter:\n            # Sample a batch of points inside informed set\n            for _ in range(self.batch_size):\n                sample = informed_sample()\n                samples_pool.add(sample)\n\n            # For each sample, try to connect it to the tree with minimal cost\n            for sample in list(samples_pool):\n                if any(math.dist(sample, n.position) < 1e-6 for n in nodes if n.valid):\n                    samples_pool.remove(sample)\n                    continue\n                # Find nearest node in tree\n                nearest = min((n for n in nodes if n.valid), key=lambda n: math.dist(n.position, sample))\n                new_pos = steer(nearest.position, sample, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    samples_pool.remove(sample)\n                    continue\n                if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                    samples_pool.remove(sample)\n                    continue\n\n                new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                est_total_cost = new_cost + heuristic(new_pos)\n                if est_total_cost >= c_best:\n                    samples_pool.remove(sample)\n                    continue  # Prune non-promising samples\n\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.add_child(new_node)\n                nodes.append(new_node)\n                edges.append((nearest, new_node))\n                heapq.heappush(open_queue, (est_total_cost, new_node))\n                samples_pool.remove(sample)\n\n                # Rewire nearby nodes to improve costs\n                near = near_nodes(nodes, new_node, self.rewire_radius)\n                try_rewire(new_node, near)\n\n                # Check if goal can be reached from new node\n                dist_to_goal = math.dist(new_node.position, goal_pos)\n                if dist_to_goal <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, goal_pos, obstacles, is_3d):\n                        goal_node.parent = new_node\n                        goal_node.cost = new_node.cost + dist_to_goal\n                        new_node.children.append(goal_node)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        if goal_node.cost < c_best:\n                            c_best = goal_node.cost\n                            # Extract path and prune tree\n                            extracted_path = goal_node.path_from_root()\n                            prune_nodes()\n                            success_state = True\n\n            # If goal found, we may stop early but try to smooth path first\n            if success_state:\n                extracted_path = path_smoothing(extracted_path)\n                break\n\n            iter_count += 1\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _prune_subtree(self, node):\n        node.valid = False\n        for child in node.children[:]:\n            self._prune_subtree(child)\n        node.children.clear()\n        node.disconnect()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 959.99122,
    "time_improvement": -3209.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.5231126070022583,
            "num_nodes_avg": 809.7,
            "path_length_avg": 164.00869971204878,
            "success_improvement": 0.0,
            "time_improvement": -4923.613413439082,
            "length_improvement": 18.03002825301048,
            "objective_score": -1473.4780183811224
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.6704604864120484,
            "num_nodes_avg": 1087.8,
            "path_length_avg": 231.9158381367891,
            "success_improvement": -9.999999999999998,
            "time_improvement": -4256.248295989689,
            "length_improvement": 23.042478844217857,
            "objective_score": -1277.2659930280631
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.15846560001373292,
            "num_nodes_avg": 502.3,
            "path_length_avg": 122.15836719258887,
            "success_improvement": 0.0,
            "time_improvement": -447.42374687743745,
            "length_improvement": 24.987403599900297,
            "objective_score": -129.22964334325118
        }
    ]
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines RRT (Rapidly-exploring Random Tree) sampling with informed sampling and local rewiring inspired by RRT*. It employs goal biasing, adaptive sampling within an informed subset to accelerate convergence toward the goal, and rewires nodes locally to improve path quality dynamically. The algorithm balances exploration with exploitation, enhancing planning efficiency, path optimality, smoothness, robustness, and success rate.",
    "planning_mechanism": "The planner incrementally builds a tree by randomly sampling points with goal biasing and adaptive sampling near the current best path. For each sample, it finds the nearest node and steers towards the sample with a fixed step size. When adding nodes, it performs collision checks on nodes and edges. It also locally rewires the tree within a defined radius to reduce path cost, improving path quality dynamically while ensuring obstacle avoidance and search efficiency.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(len(bounds)))\n            length = dist(from_pos, to_pos)\n            if length == 0:\n                return from_pos\n            unit = tuple(d / length for d in direction)\n            step = min(self.step_size, length)\n            new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(bounds)))\n            # Ensure new_pos within bounds:\n            new_pos = tuple(\n                min(max(new_pos[d], 0), bounds[d]) for d in range(len(bounds))\n            )\n            return new_pos\n\n        def get_nearest_node(pos):\n            return min(nodes, key=lambda n: dist(n.position, pos))\n\n        def get_nearby_nodes(pos, radius):\n            return [n for n in nodes if dist(n.position, pos) <= radius]\n\n        # Lower bound on heuristic cost (Euclidean distance)\n        def heuristic(pos):\n            return dist(pos, goal_position)\n\n        best_goal_node = None\n        best_cost = math.inf\n\n        for iteration in range(self.max_iter):\n            # Informed sampling: sample uniformly in the space,\n            # but bias more toward the region inside an ellipse defined by current best cost if found\n            if best_goal_node is not None and random.random() > self.goal_sample_rate:\n                c_best = best_cost\n                c_min = dist(start_position, goal_position)\n                if c_best < math.inf:\n                    # Sample in prolate hyperspheroid (ellipse in 2D/3D)\n                    # Adapted from Informed RRT*\n                    import numpy as np\n\n                    dim = len(bounds)\n                    center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n                    a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))  # unit vector from start to goal\n\n                    # Construct rotation matrix C to align x axis with a1\n                    # Using Gram-Schmidt or for 2D/3D simplified approach\n                    def rotation_matrix(direction):\n                        # direction: unit vector a1\n                        # returns orthonormal rotation matrix with a1 as first column\n                        import numpy as np\n                        if dim == 2:\n                            dx, dy = direction\n                            c = dx\n                            s = dy\n                            return np.array([[c, -s],\n                                             [s,  c]])\n                        elif dim == 3:\n                            dx, dy, dz = direction\n                            x_axis = np.array(direction)\n                            x_axis /= np.linalg.norm(x_axis)\n                            # Create arbitrary vector not colinear with x_axis\n                            if abs(x_axis[0]) < 1/64:\n                                v = np.array([1,0,0])\n                            else:\n                                v = np.array([0,1,0])\n                            y_axis = np.cross(v, x_axis)\n                            y_axis /= np.linalg.norm(y_axis)\n                            z_axis = np.cross(x_axis, y_axis)\n                            return np.column_stack((x_axis, y_axis, z_axis))\n                        else:\n                            return np.identity(dim)\n\n                    try:\n                        C = rotation_matrix(np.array(a1))\n                    except Exception:\n                        C = np.identity(dim)\n\n                    # Radii of ellipse axes\n                    r1 = c_best / 2.0\n                    r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0)) / 2.0\n                    r = [r1] + [r2] * (dim -1)\n\n                    # Sample random point in unit ball\n                    def sample_unit_ball(dim):\n                        import random as rnd\n                        import numpy as np\n                        while True:\n                            x = np.array([rnd.uniform(-1,1) for _ in range(dim)])\n                            if np.linalg.norm(x) <= 1:\n                                return x\n\n                    x_ball = sample_unit_ball(dim)\n                    # Scale to ellipsoid\n                    x_ellipsoid = np.multiply(x_ball, r)\n                    # Rotate and translate\n                    sample_np = np.dot(C, x_ellipsoid) + np.array(center)\n                    sample = tuple(float(sample_np[d]) for d in range(dim))\n\n                    # Clip sample inside bounds\n                    sample = tuple(\n                        min(max(sample[d], 0), bounds[d]) for d in range(dim)\n                    )\n                else:\n                    # If somehow best_cost invalid, fallback uniform sampling\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            else:\n                # Goal biasing sampling\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_position\n                else:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = get_nearest_node(sample)\n            new_pos = steer(nearest_node.position, sample)\n\n            # Collision checks for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Create new node with cost updated\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewiring: try to connect new_node to better parents within radius\n            near_nodes = get_nearby_nodes(new_pos, self.rewire_radius)\n            for near_node in near_nodes:\n                if near_node == nearest_node:\n                    continue\n\n                tentative_cost = near_node.cost + dist(near_node.position, new_pos)\n                if tentative_cost < new_node.cost:\n                    # Check edge collision before rewiring\n                    if not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        # Rewire parent\n                        # Remove from old parent's children\n                        if new_node.parent:\n                            new_node.parent.remove_child(new_node)\n                        new_node.parent = near_node\n                        new_node.cost = tentative_cost\n                        near_node.add_child(new_node)\n\n            # After adding new_node, try to rewire neighbors to new_node if better\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    # Check edge collision before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node's parent to new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                        near_node.parent = new_node\n                        near_node.cost = cost_through_new\n                        new_node.add_child(near_node)\n\n            # Check if we can connect goal directly from new_node\n            dist_to_goal = dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_in_obstacle(goal_position, obstacles, is_3d) and \\\n                   not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node = Node(goal_position, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_cost < best_cost:\n                        best_cost = goal_cost\n                        best_goal_node = goal_node\n                    success_state = True\n                    break\n\n        # If success, extract best path\n        if success_state and best_goal_node is not None:\n            path = []\n            node = best_goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Optional path smoothing: shortcutting between non-adjacent nodes to improve smoothness and shorten path\n            def path_smoothing(path, obstacles, is_3d, max_iter=50):\n                import random\n                smoothed = path[:]\n                for _ in range(max_iter):\n                    if len(smoothed) <= 2:\n                        break\n                    i = random.randint(0, len(smoothed) - 3)\n                    j = random.randint(i + 2, len(smoothed) -1)\n                    p1 = smoothed[i]\n                    p2 = smoothed[j]\n                    # Check collision between p1 and p2\n                    if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                        del smoothed[i+1:j]\n                return smoothed\n\n            extracted_path = path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 365.93084,
    "time_improvement": -1236.0,
    "length_improvement": 24.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.10679264068603515,
            "num_nodes_avg": 296.1,
            "path_length_avg": 163.7906716695946,
            "success_improvement": 0.0,
            "time_improvement": -925.5630145893817,
            "length_improvement": 18.138996573053255,
            "objective_score": -274.0411050622039
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.367946720123291,
            "num_nodes_avg": 881.8,
            "path_length_avg": 225.03990649421993,
            "success_improvement": 0.0,
            "time_improvement": -2290.696103702969,
            "length_improvement": 25.324145586342734,
            "objective_score": -682.1440019936222
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.1709836721420288,
            "num_nodes_avg": 524.5,
            "path_length_avg": 117.30990143191698,
            "success_improvement": 0.0,
            "time_improvement": -490.6677692239902,
            "length_improvement": 27.964653653444294,
            "objective_score": -141.60740003650818
        }
    ]
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional RRT* with informed sampling, adaptive step sizing near obstacles, node rejection, rewiring, and pruning techniques. It grows two trees from start and goal, leveraging fast convergence and asymptotic optimality while improving efficiency and path smoothness by focusing exploration within an informed subset and adaptively adjusting expansion steps. The planner performs aggressive pruning and connection attempts to maintain high success rates, shorter path lengths, and faster convergence.",
    "planning_mechanism": "The planner alternates growth between two trees, sampling points informed by current best path cost. For each sample, it uses adaptive step sizes near obstacles, rejects nodes unlikely to improve path cost, and rewires to optimize path quality. It attempts connection between the trees after each extension, updating the best solution and pruning nodes that cannot contribute to a better path. The final path is extracted from the connected trees once a successful path is found or the iteration limit is reached.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, pruning_gap: float = 1e-5):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n        self.pruning_gap = pruning_gap  # tiny margin to prevent float precision issues\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        extracted_path = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float(\"inf\")\n\n        for i in range(self.max_iter):\n            # Alternate growing trees\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n\n            sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Boundary check - ensure new_pos inside map limits\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision and edge collision checks\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune nodes that cannot improve best found path\n            heuristic_to_goal = math.dist(new_pos, goal_position)\n            if new_cost + heuristic_to_goal >= c_best - self.pruning_gap:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in tree_a if better path found through new_node\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node.parent]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + math.dist(near.position, goal_position) >= c_best - self.pruning_gap:\n                    continue  # skip nodes that cannot improve final path\n                if potential_cost < near.cost and not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                    # Rewire near node to new_node\n                    if near.parent:\n                        near.parent.remove_child(near)\n                        if (near.parent, near) in edges:\n                            edges.remove((near.parent, near))\n                    new_node.add_child(near)\n                    near.cost = potential_cost\n                    edges.append((new_node, near))\n\n            # Attempt connection to other tree\n            other_nearest = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            connect_dist = math.dist(new_node.position, other_nearest.position)\n\n            if connect_dist <= self.base_step:\n                # Check edge collision\n                if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                    # Compute total path cost\n                    connect_cost = new_node.cost + connect_dist + other_nearest.cost\n                    if connect_cost < c_best - self.pruning_gap:\n                        c_best = connect_cost\n                        # Extract path from start to goal by joining new_node and other_nearest\n                        path_a = new_node.path_from_root()\n                        path_b = other_nearest.path_from_root()\n                        extracted_path = path_a + path_b[::-1]\n                        success_state = True\n                        # Prune nodes that cannot improve this path\n                        self._prune(tree_a, c_best, goal_position, obstacles, is_3d)\n                        self._prune(tree_b, c_best, goal_position, obstacles, is_3d)\n                        if success_state and c_best <= c_min + 1e-3:\n                            # Found near optimal path, stop early\n                            break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import math\n        import random\n\n        if c_best == float(\"inf\"):\n            # Uniform sampling inside bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        # Ellipsoidal sampling inside prolate hyperspheroid as per informed RRT*\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Degenerate: start == goal\n            return tuple(x_center)\n\n        a1_unit = a1 / norm_a1\n        # Create rotation matrix C that aligns x-axis with vector a1\n        # Start with identity matrix\n        I = np.eye(dim)\n        # Using SVD for rotation matrix construction from a1_unit\n        M = np.outer(a1_unit, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            # Numerical stability safeguard\n            r2 = 0.0\n        else:\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            # Sample random point in unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball)\n            scale = random.random() ** (1 / dim)\n            x_ball *= scale\n            # Map to ellipsoid\n            x_rand = C @ L @ x_ball + x_center\n            # Check bounds\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(2, int(distance))\n        # Check collisions along path with finer resolution\n        close_to_obstacle = False\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                close_to_obstacle = True\n                break\n        if close_to_obstacle:\n            # Reduce step size near obstacles, with a minimum step size\n            return max(self.base_step * 0.3, 1.0)\n        else:\n            return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n    def _prune(self, tree, c_best, goal_position, obstacles, is_3d):\n        '''Prune nodes that cannot possibly improve current best path cost'''\n        import math\n        to_remove = []\n        for node in tree:\n            h_cost = math.dist(node.position, goal_position)\n            if node.cost + h_cost >= c_best - self.pruning_gap:\n                # Mark subtree for removal if root node of that subtree is not start or goal\n                if node.parent is not None:\n                    to_remove.append(node)\n        # Remove nodes marked for pruning\n        for node in to_remove:\n            # Disconnect from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        '''Helper to recursively remove subtree nodes from tree'''\n        for child in node.children[:]:\n            self._remove_subtree(child, tree)\n        if node in tree:\n            tree.remove(node)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 10081.78129,
    "time_improvement": -33623.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 3.0333144903182983,
            "num_nodes_avg": 1931.2,
            "path_length_avg": 152.77535081474505,
            "success_improvement": 0.0,
            "time_improvement": -38126.33914621541,
            "length_improvement": 23.644348062585905,
            "objective_score": -11433.172874252105
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 6.709124517440796,
            "num_nodes_avg": 3120.0,
            "path_length_avg": 230.3338052876067,
            "success_improvement": 0.0,
            "time_improvement": -47982.939848711896,
            "length_improvement": 23.5674508661299,
            "objective_score": -14390.168464440343
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 4.248104596138001,
            "num_nodes_avg": 2744.4,
            "path_length_avg": 116.27889240935409,
            "success_improvement": 0.0,
            "time_improvement": -14759.073638879116,
            "length_improvement": 28.597755302326387,
            "objective_score": -4422.002540603269
        }
    ]
}
{
    "operator": "m1",
    "algorithm_description": "This algorithm is an improved RRT* variant that combines bidirectional tree growth with goal biasing and adaptive rewiring. It incrementally builds two trees from start and goal, samples the space with increased focus near the goal, rewires neighbors within a dynamic radius to optimize the path cost, and performs shortcut smoothing to improve path quality and reduce length.",
    "planning_mechanism": "The planner grows two trees progressively closer, rewiring nodes within a radius that shrinks over iterations to balance exploration and exploitation, uses goal-biased sampling to enhance success rate, connects the trees when possible, and finally extracts and smooths the path to provide a high-quality solution efficiently.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius_constant: float=50.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_constant = neighbor_radius_constant  # Used to scale rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        dim = len(bounds)\n        free_space_volume = 1\n        for b in bounds:\n            free_space_volume *= b\n        # Neighbor radius shrink function: r = r0 * (log(n)/n)^(1/d)\n        def neighbor_radius(n):\n            if n <= 1:\n                return self.neighbor_radius_constant\n            return min(self.neighbor_radius_constant,\n                       self.neighbor_radius_constant * (math.log(n) / n) ** (1.0 / dim))\n\n        def sample():\n            # Goal biasing sampling with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def collision_free(from_pos, to_pos):\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and collision_free(new_node.position, neighbor.position):\n                    # Remove edge from old parent\n                    if neighbor.parent:\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                        if neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    # Rewire\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extend(tree_a, point):\n            nearest_node = nearest(tree_a, point)\n            new_pos = steer(nearest_node.position, point)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n            neighbors = near_nodes(tree_a, new_pos, neighbor_radius(len(tree_a)))\n            # Choose best parent minimizing cost + collision check\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for neighbor in neighbors:\n                c = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if c < min_cost and collision_free(neighbor.position, new_pos):\n                    min_cost = c\n                    best_parent = neighbor\n            best_parent.add_child(new_node)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            rewire(tree_a, new_node, neighbors)\n            return new_node\n\n        def connect_trees(new_node_a, tree_b):\n            nearest_node_b = nearest(tree_b, new_node_a.position)\n            current_node = nearest_node_b\n            while True:\n                next_pos = steer(current_node.position, new_node_a.position)\n                if not collision_free(current_node.position, next_pos):\n                    return None\n                new_node_b = Node(next_pos)\n                neighbors = near_nodes(tree_b, next_pos, neighbor_radius(len(tree_b)))\n\n                min_cost = current_node.cost + math.dist(current_node.position, next_pos)\n                best_parent = current_node\n                for neighbor in neighbors:\n                    c = neighbor.cost + math.dist(neighbor.position, next_pos)\n                    if c < min_cost and collision_free(neighbor.position, next_pos):\n                        min_cost = c\n                        best_parent = neighbor\n\n                best_parent.add_child(new_node_b)\n                new_node_b.cost = min_cost\n                new_node_b.parent = best_parent\n\n                tree_b.append(new_node_b)\n                nodes.append(new_node_b)\n                edges.append((best_parent, new_node_b))\n\n                rewire(tree_b, new_node_b, neighbors)\n\n                if math.dist(new_node_b.position, new_node_a.position) <= self.step_size:\n                    return new_node_b\n\n                current_node = new_node_b\n\n        def extract_path(node_start, node_goal):\n            path_start = node_start.path_from_root()\n            path_goal = node_goal.path_from_root()\n            full_path = path_start + path_goal[::-1][1:]  # remove duplicate connection node\n\n            # Perform simple shortcut smoothing on path\n            smooth_path = [full_path[0]]\n            i = 0\n            while i < len(full_path) - 1:\n                j = len(full_path) - 1\n                while j > i + 1:\n                    if not self._is_edge_in_obstacle(smooth_path[-1], full_path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smooth_path.append(full_path[j])\n                i = j\n            return smooth_path\n\n        for iter_num in range(self.max_iter):\n            rnd = sample()\n            new_node_start = extend(tree_start, rnd)\n            if not new_node_start:\n                continue\n            new_node_goal = connect_trees(new_node_start, tree_goal)\n            if new_node_goal:\n                success_state = True\n                extracted_path = extract_path(new_node_start, new_node_goal)\n                break\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 47.57608,
    "time_improvement": -144.0,
    "length_improvement": 27.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.023780679702758788,
            "num_nodes_avg": 76.3,
            "path_length_avg": 157.68258133234144,
            "success_improvement": 0.0,
            "time_improvement": -199.68812345263564,
            "length_improvement": 21.191761415721647,
            "objective_score": -55.66808475264636
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0432955265045166,
            "num_nodes_avg": 280.9,
            "path_length_avg": 243.4860629831869,
            "success_improvement": 0.0,
            "time_improvement": -210.2902906665801,
            "length_improvement": 19.203086802055434,
            "objective_score": -59.246469839562934
        },
        {
            "map_id": 2,
            "success_rate": 0.4,
            "time_avg": 0.034473729133605954,
            "num_nodes_avg": 182.5,
            "path_length_avg": 94.76986278983743,
            "success_improvement": -60.0,
            "time_improvement": -20.58264296710426,
            "length_improvement": 41.80559521445381,
            "objective_score": -27.813673847240516
        }
    ]
}
{
    "operator": "m2",
    "algorithm_description": "This algorithm is an enhanced RRT* planner with adaptive step sizing and dynamic rewiring radius to balance exploration and exploitation. It applies goal biasing and includes post-smoothing of the final path for better smoothness and shorter path length. The planner prioritizes planning efficiency and path quality by tuning parameters and leveraging an informed rewiring neighborhood based on node density and iteration progress.",
    "planning_mechanism": "The planner incrementally builds a tree from the start position by sampling the space with goal biasing. For each sampled point, it extends towards it using an adaptive step size, selects the best parent among near nodes within a dynamically computed radius, adds the new node ensuring collision-free placement and edges, and performs rewiring to optimize local paths. After reaching the goal, it extracts and smooths the resulting path to improve quality and smoothness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive rewiring radius based on space and iteration\n        def calc_neighbor_radius():\n            unit_ball_volume = math.pi if dim == 2 else (4/3)*math.pi\n            gamma_rrt_star = (2 * (1 + 1/dim)) ** (1/dim) * (bounds[0] * bounds[1] * (bounds[2] if is_3d else 1)) ** (1/dim) if is_3d else (bounds[0]*bounds[1]) ** (1/dim)\n            radius = min(self.step_size * 5, gamma_rrt_star * ((math.log(len(nodes)+1) / (len(nodes)+1)) ** (1/dim)))\n            return max(radius, self.step_size*1.5)\n\n        def is_in_bounds(pos):\n            for d in range(dim):\n                if pos[d] < 0 or pos[d] > bounds[d]:\n                    return False\n            return True\n\n        for iter_count in range(1, self.max_iter + 1):\n            # Goal biasing sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n\n            # Adaptive step size: smaller near obstacles or near goal for finer search\n            adaptive_step = self.step_size\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            if dist_to_goal < self.step_size * 5:\n                adaptive_step = max(self.step_size * 0.3, dist_to_goal / 2)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(adaptive_step, dist_to_sample) for d in range(dim))\n\n            if not is_in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n\n            # Compute neighbor radius dynamically\n            neighbor_radius = calc_neighbor_radius()\n\n            # Find neighbors within radius for better parent selection\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to improve cost\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(near_node.position, new_position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_position, near_node.position, obstacles, is_3d):\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if goal can be connected safely\n            if math.dist(new_position, goal_position) <= neighbor_radius:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + math.dist(new_position, goal_position)\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            # Extract path backwards\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Post-process path smoothing to improve smoothness & length\n            extracted_path = self._path_smoothing(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _path_smoothing(self, path, obstacles, is_3d, max_trials=50):\n        import random\n        import math\n        if len(path) < 3:\n            return path\n        path = path[:]  # copy\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p1 = path[i]\n            p2 = path[j]\n            if not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                # Remove intermediate points between i+1 and j-1\n                del path[i+1:j]\n        return path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 520.47248,
    "time_improvement": -1751.0,
    "length_improvement": 25.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.15365190505981446,
            "num_nodes_avg": 241.0,
            "path_length_avg": 162.37261706459378,
            "success_improvement": 0.0,
            "time_improvement": -1836.3471384275172,
            "length_improvement": 18.847726635005362,
            "objective_score": -547.134596201254
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.4232297420501709,
            "num_nodes_avg": 949.6,
            "path_length_avg": 223.79051507525915,
            "success_improvement": 0.0,
            "time_improvement": -2933.2020483869037,
            "length_improvement": 25.73873592794681,
            "objective_score": -874.8128673304818
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.16712868213653564,
            "num_nodes_avg": 518.3,
            "path_length_avg": 114.76511089943169,
            "success_improvement": 0.0,
            "time_improvement": -484.58480454866145,
            "length_improvement": 29.527308341151148,
            "objective_score": -139.4699796963682
        }
    ]
}
{
    "operator": "m3",
    "algorithm_description": "This algorithm is a streamlined bidirectional RRT* planner that grows two trees from start and goal simultaneously, while incrementally optimizing discovered paths through rewiring. It balances exploration speed and path optimality by attempting to connect the two trees frequently, pruning suboptimal paths and ensuring collision-free expansions.",
    "planning_mechanism": "The planner alternates extending two trees sampled in free space with a fixed step size. For each new node, it chooses the best parent among nearby nodes within a radius, rewires neighbors to improve path costs if possible, and attempts to connect the two trees for early successful path discovery. Collision checks are enforced on nodes and edges throughout.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_pos)]\n        goal_tree = [Node(goal_pos)]\n        nodes = []\n        edges = []\n        success = False\n        final_path = []\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[i]) for i in range(len(bounds)))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def connect_path(node_a, node_b):\n            path_a, path_b = [], []\n            while node_a:\n                path_a.append(node_a.position)\n                node_a = node_a.parent\n            while node_b:\n                path_b.append(node_b.position)\n                node_b = node_b.parent\n            return list(reversed(path_a)) + path_b\n\n        for _ in range(self.max_iter):\n            sample = sample_free()\n            for tree_a, tree_b in [(start_tree, goal_tree), (goal_tree, start_tree)]:\n                nearest_node = nearest(tree_a, sample)\n                new_pos = steer(nearest_node.position, sample, self.step_size)\n\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    continue\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    continue\n\n                new_node = Node(new_pos)\n                near_nodes = near(tree_a, new_pos, self.neighbor_radius)\n\n                min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n                best_parent = nearest_node\n                for near_node in near_nodes:\n                    cost = near_node.cost + distance(near_node.position, new_pos)\n                    if cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        best_parent = near_node\n\n                new_node.update_parent(best_parent, min_cost)\n                tree_a.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                # Rewire neighbors\n                for near_node in near_nodes:\n                    if near_node == best_parent:\n                        continue\n                    new_cost = new_node.cost + distance(new_node.position, near_node.position)\n                    if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, new_cost)\n                        edges.append((new_node, near_node))\n\n                # Attempt connection\n                other_nearest = nearest(tree_b, new_node.position)\n                if distance(new_node.position, other_nearest.position) <= self.step_size:\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        success = True\n                        final_path = connect_path(new_node, other_nearest)\n                        return PlannerResult(success, final_path, start_tree + goal_tree, edges)\n\n        return PlannerResult(success, final_path, start_tree + goal_tree, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 52.73777,
    "time_improvement": -188.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.030731558799743652,
            "num_nodes_avg": 141.4,
            "path_length_avg": 171.36498341999362,
            "success_improvement": 0.0,
            "time_improvement": -287.2842703651179,
            "length_improvement": 14.35342836067697,
            "objective_score": -83.31459543739997
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.049118781089782716,
            "num_nodes_avg": 276.7,
            "path_length_avg": 241.79578195505002,
            "success_improvement": 0.0,
            "time_improvement": -252.02437969998687,
            "length_improvement": 19.763979231943463,
            "objective_score": -71.65451806360736
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0357271671295166,
            "num_nodes_avg": 221.4,
            "path_length_avg": 128.27818950325494,
            "success_improvement": 0.0,
            "time_improvement": -24.96693414014588,
            "length_improvement": 21.229464036852754,
            "objective_score": -3.2441874346732122
        }
    ]
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm implements an informed variant of RRT* that uses heuristic-guided sampling restricted to an ellipsoidal subset between start and goal to improve sampling efficiency and path quality. It incrementally rewires nodes to optimize path costs for smoother, shorter, and more robust paths with improved success rate and reduced search time.",
    "planning_mechanism": "The planner samples points informed by an ellipsoidal heuristic defined by start, goal, and current best path cost. It grows a single tree from the start, steering toward sampled points. For each new node, it performs local rewiring of neighboring nodes to improve costs, ensuring collision-free nodes and edges. The algorithm terminates early when a path reaches the goal within the step size, returning the best path found.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision status\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        import math\n        import random\n\n        nodes: list[Node] = []\n        edges: list[tuple[Node, Node]] = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_node = None\n        min_cost_to_goal = float('inf')\n\n        # Precompute Euclidean distance between start and goal for heuristic\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        dim = len(bounds)\n\n        def sample_informed():\n            # If no solution yet, uniform sample\n            if c_best == float('inf'):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Sample inside prolate hyperspheroid (ellipsoid) defined by start, goal and c_best\n            # Following method from Informed RRT*: transform unit ball sample to ellipsoid\n            a1 = tuple((goal_position[d] - start_position[d]) / c_min for d in range(dim))  # unit vector from start to goal\n            # Center of ellipse\n            center = tuple((start_position[d] + goal_position[d]) / 2 for d in range(dim))\n            while True:\n                # Sample unit ball\n                x = [random.gauss(0,1) for _ in range(dim)]\n                norm = math.sqrt(sum(x_i**2 for x_i in x))\n                if norm == 0:\n                    continue\n                x_unit = [x_i / norm for x_i in x]\n                r = random.uniform(0,1) ** (1/dim)  # Radius for uniform distribution inside unit ball\n                x_ball = [r * x_i for x_i in x_unit]\n\n                # Define ellipse radii\n                L1 = c_best / 2\n                if dim == 2:\n                    # Radii perpendicular to axis\n                    L2 = math.sqrt(c_best**2 - c_min**2) / 2\n                    radii = [L1, L2]\n                elif dim == 3:\n                    L2 = math.sqrt(c_best**2 - c_min**2) / 2\n                    L3 = L2\n                    radii = [L1, L2, L3]\n                else:\n                    radii = [L1] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim - 1)\n\n                # Build rotation matrix aligning x-axis with a1\n                # Using Householder transform or simple rotation for 2D/3D:\n                # For simplicity consider rotation matrix R where R * e1 = a1\n                # For 2D:\n                if dim == 2:\n                    cos_theta = a1[0]\n                    sin_theta = a1[1]\n                    R = [[cos_theta, -sin_theta], [sin_theta, cos_theta]]\n                    x_ellipsoid = [sum(R[i][j]*x_ball[j]*radii[j] for j in range(dim)) for i in range(dim)]\n                elif dim == 3:\n                    # Construct rotation matrix R via cross product trick\n                    import numpy as np\n                    e1 = np.array([1.0,0.0,0.0])\n                    a1_np = np.array(a1)\n                    v = np.cross(e1, a1_np)\n                    s = np.linalg.norm(v)\n                    if s < 1e-10:  # vectors aligned\n                        R = np.eye(3)\n                    else:\n                        c = np.dot(e1, a1_np)\n                        vx = np.array([[0, -v[2], v[1]],\n                                       [v[2], 0, -v[0]],\n                                       [-v[1], v[0], 0]])\n                        R = np.eye(3) + vx + (vx @ vx) * ((1 - c) / (s ** 2))\n                    x_ball_np = np.array(x_ball)\n                    radii_np = np.array(radii)\n                    x_ellipsoid_np = R @ (x_ball_np * radii_np)\n                    x_ellipsoid = x_ellipsoid_np.tolist()\n                else:\n                    # For higher dims, just scale without rotation (conservative)\n                    x_ellipsoid = [x_ball[d] * radii[d] for d in range(dim)]\n\n                sample = tuple(center[d] + x_ellipsoid[d] for d in range(dim))\n\n                # Check bounds and collision\n                if any(sample[d] < 0 or sample[d] > bounds[d] for d in range(dim)):\n                    continue\n                if self._is_in_obstacle(sample, obstacles, is_3d):\n                    continue\n                return sample\n\n        def nearest_node(point):\n            return min(nodes, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(new_pos):\n            return [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius]\n\n        def path_to_root(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return list(reversed(path))\n\n        for _ in range(self.max_iter):\n            sample = sample_informed()\n\n            nearest = nearest_node(sample)\n            new_pos = steer(nearest.position, sample, self.step_size)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Choose parent for new node among nearby nodes with lowest cost reachable via collision free edge\n            neighbors = near_nodes(new_pos)\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n\n            for n in neighbors:\n                # Check collision edge from n to new_pos\n                if self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                    continue\n                cost = n.cost + math.dist(n.position, new_pos)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = n\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to new_node if it improves their cost and path is collision-free\n            for n in neighbors:\n                if n == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, n.position)\n                if cost_through_new < n.cost:\n                    if self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        continue\n                    # Rewire\n                    if n.parent:\n                        n.parent.remove_child(n)\n                        try:\n                            edges.remove((n.parent, n))\n                        except ValueError:\n                            pass\n                    n.parent = new_node\n                    n.cost = cost_through_new\n                    new_node.add_child(n)\n                    edges.append((new_node, n))\n\n            # Check if new_node can connect to goal within step_size\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < min_cost_to_goal:\n                        min_cost_to_goal = goal_node.cost\n                        best_goal_node = goal_node\n                        c_best = min_cost_to_goal\n                        # Can terminate early or continue to improve\n                        # Here: early terminate after first found path\n                        break\n\n        success_state = best_goal_node is not None\n\n        if success_state:\n            extracted_path = path_to_root(best_goal_node)\n\n        return PlannerResult(success_state, extracted_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": 664.88669,
    "time_improvement": -2231.0,
    "length_improvement": 22.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.3563659429550171,
            "num_nodes_avg": 760.1,
            "path_length_avg": 161.45612900235434,
            "success_improvement": 0.0,
            "time_improvement": -4572.229950017661,
            "length_improvement": 19.305778559690552,
            "objective_score": -1367.80782929336
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.29879083633422854,
            "num_nodes_avg": 1037.8,
            "path_length_avg": 233.16630915481664,
            "success_improvement": 0.0,
            "time_improvement": -1754.5966848048874,
            "length_improvement": 22.627530255118966,
            "objective_score": -521.8534993904425
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.13177933692932128,
            "num_nodes_avg": 656.1,
            "path_length_avg": 122.48397517594238,
            "success_improvement": 0.0,
            "time_improvement": -366.5207600424046,
            "length_improvement": 24.787460683166316,
            "objective_score": -104.99873587608812
        }
    ],
    "success_rate": 22.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner integrates the bidirectional search strategy of the dual-tree RRT with the rewiring and path optimization features of RRT*, aiming to balance rapid exploration (via two trees from start and goal) and gradual path quality improvement (via rewiring). It alternates growth between the two trees, extends nodes toward samples, attempts to connect trees efficiently, and locally optimizes paths through rewiring nearby nodes to ensure better cost and smoother paths, thus improving efficiency, robustness, and final path quality.",
    "planning_mechanism": "The planner grows two trees simultaneously from start and goal, sampling points with goal bias, extending towards them with collision checks. After each extension, it performs rewiring locally to improve costs. It attempts to connect the two trees whenever new nodes are added, ensuring a collision-free connection. Once connected, it extracts the path by linking nodes from both trees, yielding efficient, high-quality, and smooth paths with reduced redundant search.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                # In case not found due to rewiring elsewhere\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, neighbor_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        def _distance(a, b):\n            return math.dist(a, b)\n\n        def _steer(from_p, to_p, max_dist):\n            dist = _distance(from_p, to_p)\n            if dist <= max_dist:\n                return to_p\n            ratio = max_dist / dist\n            return tuple(from_p[i] + (to_p[i] - from_p[i]) * ratio for i in range(len(from_p)))\n\n        def _nearest(tree, point):\n            return min(tree, key=lambda node: _distance(node.position, point))\n\n        def _near(tree, point, radius):\n            return [node for node in tree if _distance(node.position, point) <= radius]\n\n        def _is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x,y,z,w,h,d = obs\n                    px,py,pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x,y,w,h = obs\n                    px,py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(from_pos, to_pos, resolution=1.0):\n            distance = _distance(from_pos, to_pos)\n            steps = max(1, int(distance / resolution))\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n                if _is_in_obstacle(interp):\n                    return True\n            return False\n\n        def _rewire(tree, new_node):\n            near_nodes = _near(tree, new_node.position, self.neighbor_radius)\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + _distance(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not _is_edge_in_obstacle(new_node.position, near_node.position):\n                    # Update edges list safely\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n        def _connect_trees(node_a, tree_b):\n            connect_node = _nearest(tree_b, node_a.position)\n            if _is_edge_in_obstacle(node_a.position, connect_node.position):\n                return False, None, None\n            # Attempt to connect by extending from connect_node towards node_a with step_size increments\n            curr = connect_node\n            path_nodes = []\n            while True:\n                new_pos = _steer(curr.position, node_a.position, self.step_size)\n                if _is_in_obstacle(new_pos) or _is_edge_in_obstacle(curr.position, new_pos):\n                    return False, None, None\n                new_cost = curr.cost + _distance(curr.position, new_pos)\n                new_node = Node(new_pos, parent=curr, cost=new_cost)\n                curr.add_child(new_node)\n                tree_b.append(new_node)\n                nodes.append(new_node)\n                edges.append((curr, new_node))\n                path_nodes.append(new_node)\n                if _distance(new_pos, node_a.position) < self.step_size:\n                    final_cost = new_node.cost + _distance(new_pos, node_a.position)\n                    final_node = Node(node_a.position, parent=new_node, cost=final_cost)\n                    new_node.add_child(final_node)\n                    tree_b.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return True, final_node, node_a\n                curr = new_node\n\n        def _extract_path(node_from_start, node_from_goal):\n            path_start = []\n            n = node_from_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_goal = []\n            n = node_from_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n            return path_start[::-1] + path_goal\n\n        def _sample_free():\n            if random.random() < self.goal_sample_rate:\n                # Goal biasing: sample from the opposite tree root position\n                # Alternate biases on each tree expansion step below\n                return None\n            while True:\n                if is_3d:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    p = tuple(random.uniform(0, bounds[i]) for i in range(2))\n                if not _is_in_obstacle(p):\n                    return p\n\n        # Main loop alternating start and goal tree expansion\n        for i in range(self.max_iter):\n            # Alternate trees: expand start_tree in even iterations, goal_tree in odd\n            tree_a, tree_b = (start_tree, goal_tree) if i % 2 == 0 else (goal_tree, start_tree)\n            # Sample with bias: sample goal if expanding start_tree, sample start if expanding goal_tree, else random\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is start_tree else start_position\n                if _is_in_obstacle(sample):\n                    continue\n            else:\n                sample = None\n                while sample is None:\n                    sample = _sample_free()\n            \n            nearest = _nearest(tree_a, sample)\n            new_pos = _steer(nearest.position, sample, self.step_size)\n            if new_pos == nearest.position:\n                continue\n            if _is_in_obstacle(new_pos) or _is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + _distance(nearest.position, new_pos)\n            new_node = Node(new_pos)\n            # Choose best parent from near nodes\n            near_nodes = _near(tree_a, new_pos, self.neighbor_radius)\n            min_cost = new_cost\n            best_parent = nearest\n            for near in near_nodes:\n                if not _is_edge_in_obstacle(near.position, new_pos):\n                    cost_through_near = near.cost + _distance(near.position, new_pos)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring to improve paths locally\n            _rewire(tree_a, new_node)\n\n            # Try to connect trees\n            connected, node_from_b, node_from_a = _connect_trees(new_node, tree_b)\n            if connected:\n                # Grab the nodes from both trees that form the connection and extract path\n                success_state = True\n                # For consistent path extraction, node_from_a belongs to tree_a and node_from_b to tree_b \n                if tree_a is start_tree:\n                    extracted_path = _extract_path(node_from_a, node_from_b)\n                else:\n                    extracted_path = _extract_path(node_from_b, node_from_a)\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
    "objective": 32.40101,
    "time_improvement": -119.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.02413814067840576,
            "num_nodes_avg": 94.7,
            "path_length_avg": 168.54215785312175,
            "success_improvement": 0.0,
            "time_improvement": -216.46947763923316,
            "length_improvement": 15.764249447420628,
            "objective_score": -61.78799340228583
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.0384462833404541,
            "num_nodes_avg": 216.1,
            "path_length_avg": 247.13734395299213,
            "success_improvement": 0.0,
            "time_improvement": -138.63633336638367,
            "length_improvement": 17.991468247941192,
            "objective_score": -37.99260636032686
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.02910740375518799,
            "num_nodes_avg": 172.4,
            "path_length_avg": 134.42424774975285,
            "success_improvement": 0.0,
            "time_improvement": -3.0450481778834115,
            "length_improvement": 17.455414028725084,
            "objective_score": 2.5775683523799935
        }
    ],
    "success_rate": 17.0
}
{
    "operator": "e1",
    "algorithm_description": "This algorithm is a hybrid informed sampling planner combining frontier-guided exploration with dynamic step adjustment and path smoothing. It begins with uniform random sampling biased toward unexplored frontier regions near obstacles to efficiently cover free space. The step size dynamically adapts based on local obstacle density to balance exploration and exploitation. After finding an initial path, a shortcut smoothing procedure refines the path to improve smoothness and reduce length, enhancing path quality while maintaining collision safety. This approach aims at faster convergence, higher success rate, better path smoothness, and efficient obstacle-aware exploration.",
    "planning_mechanism": "The planner incrementally builds a tree rooted at start by sampling primarily near frontiers (boundaries between free space and obstacles) to prioritize promising regions. It dynamically adjusts step size: smaller step near obstacles for precision, larger in free space to speed exploration. Upon reaching the goal, it applies iterative shortcut smoothing on the found path to reduce unnecessary detours. Collision checks for nodes and edges ensure path validity and robustness.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, frontier_sample_rate: float = 0.3, smoothing_iters: int = 100):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.frontier_sample_rate = frontier_sample_rate\n        self.smoothing_iters = smoothing_iters\n\n    def plan(self, map) -> \"PlannerResult\":\n        import random\n        import math\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        frontier_regions = self._identify_frontiers(bounds, obstacles, is_3d)\n\n        for _ in range(self.max_iter):\n\n            if random.random() < self.frontier_sample_rate and frontier_regions:\n                sample = self._sample_near_frontier(frontier_regions, bounds, is_3d)\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            step_size = self._adaptive_step_size(nearest_node.position, obstacles, is_3d, self.base_step_size)\n\n            new_position = self._steer(nearest_node.position, sample, step_size)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            if math.dist(new_position, goal) <= step_size:\n                if not self._is_edge_in_obstacle(new_position, goal, obstacles, is_3d) and not self._is_in_obstacle(goal, obstacles, is_3d):\n                    goal_cost = new_node.cost + math.dist(new_position, goal)\n                    goal_node = Node(goal, parent=new_node, cost=goal_cost)\n                    new_node.add_child(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _identify_frontiers(self, bounds, obstacles, is_3d):\n        frontiers = []\n        # Sample grid for frontier detection\n        resolution = self.base_step_size * 2\n        dims = len(bounds)\n        steps = [int(bounds[d] / resolution) for d in range(dims)]\n\n        def neighbors(pos):\n            offsets = [-1, 0, 1]\n            for delta in self._cartesian_product([offsets]*dims):\n                if all(x == 0 for x in delta):\n                    continue\n                nbr = tuple(pos[d] + delta[d] for d in range(dims))\n                yield nbr\n\n        # Convert obstacles to quick check set approximated by grid cells\n        occupied = set()\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n            else:\n                ox, oy, w, h = obs\n            min_cells = [int(ox // resolution), int(oy // resolution)]\n            max_cells = [int((ox + w) // resolution), int((oy + h) // resolution)]\n            if is_3d:\n                min_cells.append(int(oz // resolution))\n                max_cells.append(int((oz + d) // resolution))\n                ranges = [range(min_cells[i], max_cells[i] + 1) for i in range(3)]\n                for cx in ranges[0]:\n                    for cy in ranges[1]:\n                        for cz in ranges[2]:\n                            occupied.add((cx, cy, cz))\n            else:\n                for cx in range(min_cells[0], max_cells[0] + 1):\n                    for cy in range(min_cells[1], max_cells[1] + 1):\n                        occupied.add((cx, cy))\n\n        # Frontier detection on grid\n        for ix in range(steps[0]+1):\n            for iy in range(steps[1]+1):\n                pos_grid = (ix, iy) if not is_3d else None\n                if is_3d:\n                    for iz in range(steps[2]+1):\n                        pos_grid = (ix, iy, iz)\n                        if pos_grid in occupied:\n                            continue\n                        # Check neighbors occupied?\n                        if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                            frontiers.append(tuple((pos_grid[d] + 0.5)*resolution for d in range(len(bounds))))\n                else:\n                    if pos_grid in occupied:\n                        continue\n                    if any(nbr in occupied for nbr in neighbors(pos_grid)):\n                        frontiers.append(((ix + 0.5) * resolution, (iy + 0.5) * resolution))\n        return frontiers\n\n    def _cartesian_product(self, arrays):\n        # Generator for cartesian product of input arrays (list of lists)\n        if not arrays:\n            yield ()\n        else:\n            for item in arrays[0]:\n                for rest in self._cartesian_product(arrays[1:]):\n                    yield (item,) + rest\n\n    def _sample_near_frontier(self, frontiers, bounds, is_3d):\n        import random\n        frontier = random.choice(frontiers)\n        dim = len(bounds)\n        radius = self.base_step_size * 3\n        sample_coords = []\n        for d in range(dim):\n            low = max(0, frontier[d] - radius)\n            high = min(bounds[d], frontier[d] + radius)\n            sample_coords.append(random.uniform(low, high))\n        return tuple(sample_coords)\n\n    def _adaptive_step_size(self, position, obstacles, is_3d, base_step_size):\n        # Decrease step size near obstacles to improve precision, else use base_step_size\n        query_radius = base_step_size * 2\n        nearby_obstacle = False\n        for obs in obstacles:\n            if is_3d:\n                ox, oy, oz, w, h, d = obs\n                px, py, pz = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dz = max(oz - pz, 0, pz - (oz + d))\n                dist = (dx**2 + dy**2 + dz**2)**0.5\n            else:\n                ox, oy, w, h = obs\n                px, py = position\n                dx = max(ox - px, 0, px - (ox + w))\n                dy = max(oy - py, 0, py - (oy + h))\n                dist = (dx**2 + dy**2)**0.5\n            if dist <= query_radius:\n                nearby_obstacle = True\n                break\n        return base_step_size * 0.5 if nearby_obstacle else base_step_size\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_size / dist for d in range(len(from_pos)))\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(self.smoothing_iters):\n            if len(new_path) < 3:\n                break\n            i = random.randint(0, len(new_path) - 3)\n            j = random.randint(i + 2, len(new_path) - 1)\n            p_i = new_path[i]\n            p_j = new_path[j]\n            if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                # Remove intermediate nodes between i and j\n                new_path = new_path[:i + 1] + new_path[j:]\n        return new_path",
    "objective": 232.0497,
    "time_improvement": -785.0,
    "length_improvement": 18.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 1.0,
            "time_avg": 0.131243896484375,
            "num_nodes_avg": 1106.5,
            "path_length_avg": 172.2950583974712,
            "success_improvement": 0.0,
            "time_improvement": -1291.6427132235647,
            "length_improvement": 13.88858582634635,
            "objective_score": -384.7150968018001
        },
        {
            "map_id": 1,
            "success_rate": 1.0,
            "time_avg": 0.14024708271026612,
            "num_nodes_avg": 1298.2,
            "path_length_avg": 237.7602131001206,
            "success_improvement": 0.0,
            "time_improvement": -851.9152751099193,
            "length_improvement": 21.103117507379686,
            "objective_score": -251.35395903149987
        },
        {
            "map_id": 2,
            "success_rate": 1.0,
            "time_avg": 0.0906510591506958,
            "num_nodes_avg": 1041.2,
            "path_length_avg": 132.21978033208794,
            "success_improvement": 0.0,
            "time_improvement": -212.80617882085417,
            "length_improvement": 18.80908982252286,
            "objective_score": -60.080035681751674
        }
    ],
    "success_rate": 1.0
}
{
    "operator": "e2",
    "algorithm_description": "This hybrid planner combines bidirectional search from the first algorithm with the incremental rewiring optimization of RRT* from the second. Two trees grow simultaneously from start and goal, extending and rewiring locally to improve path quality and convergence speed. Adaptive goal biasing and radius-based neighbor search enhance exploration efficiency and robustness. Collision and edge feasibility checks ensure safety while rewiring improves path smoothness and shortness.",
    "planning_mechanism": "The planner grows two trees alternatingly from start and goal by sampling random points (with goal bias), steering towards them, and extending each tree. When a new node is added, it connects and rewires nearby nodes within a radius to optimize costs locally. Once the trees connect, the best path is reconstructed by backtracking parents from both trees. This approach leverages bidirectional exploration and local rewiring for better path quality and faster convergence.",
    "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0,\n                 goal_sample_rate: float=0.1, neighbor_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position, cost=0.0)\n        goal_root = Node(goal_position, cost=0.0)\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n        nodes.extend([start_root, goal_root])\n\n        def sample_free():\n            if random.random() < self.goal_sample_rate:\n                # With equal probability bias start or goal to reduce symmetry biases\n                if random.random() < 0.5:\n                    return start_position\n                else:\n                    return goal_position\n            else:\n                while True:\n                    if is_3d:\n                        p = tuple(random.uniform(0, bounds[d]) for d in range(3))\n                    else:\n                        p = (random.uniform(0, bounds[0]), random.uniform(0, bounds[1]))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos):\n            return [n for n in tree if math.dist(n.position, pos) <= self.neighbor_radius]\n\n        def try_extend(tree, point):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n\n            # Choose best parent among near nodes (including nearest_node)\n            near = near_nodes(tree, new_pos)\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for node in near:\n                temp_cost = node.cost + math.dist(node.position, new_pos)\n                if temp_cost < min_cost:\n                    if not self._is_edge_in_obstacle(node.position, new_pos, obstacles, is_3d):\n                        min_cost = temp_cost\n                        best_parent = node\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            new_node.parent = best_parent\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if cheaper paths through new_node\n            for neighbor in near:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        neighbor.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, neighbor))\n\n            return new_node\n\n        def try_connect(tree, node):\n            nearest_node = nearest(tree, node.position)\n            while True:\n                new_pos = steer(nearest_node.position, node.position)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.cost = new_cost\n                new_node.parent = nearest_node\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n\n                if math.dist(new_pos, node.position) <= self.step_size:\n                    return new_node\n                nearest_node = new_node\n\n        # Alternate growth between start and goal tree\n        for i in range(self.max_iter):\n            rand_point = sample_free()\n\n            # Extend tree_start towards sample\n            new_node_start = try_extend(tree_start, rand_point)\n            if new_node_start is None:\n                tree_start, tree_goal = tree_goal, tree_start\n                continue\n\n            # Attempt to connect tree_goal towards new_node_start\n            new_node_goal = try_connect(tree_goal, new_node_start)\n            if new_node_goal is not None:\n                success_state = True\n\n                # Choose paths from roots to connection nodes\n                path_start = new_node_start.path_from_root()\n                path_goal = new_node_goal.path_from_root()\n\n                # Merge paths (avoid duplicate connection point)\n                extracted_path = path_start + path_goal[::-1][1:]\n\n                break\n\n            # Swap trees to alternate growth direction\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
    "objective": -6.68311,
    "time_improvement": 27.0,
    "length_improvement": 17.0,
    "other_inf": [
        {
            "map_id": 0,
            "success_rate": 0.9,
            "time_avg": 0.007598710060119629,
            "num_nodes_avg": 103.3,
            "path_length_avg": 161.4550453822259,
            "success_improvement": -9.999999999999998,
            "time_improvement": 19.42719038120736,
            "length_improvement": 19.306320142615537,
            "objective_score": 4.689421142885316
        },
        {
            "map_id": 1,
            "success_rate": 0.9,
            "time_avg": 0.013997030258178712,
            "num_nodes_avg": 235.8,
            "path_length_avg": 259.63765747646863,
            "success_improvement": -9.999999999999998,
            "time_improvement": 4.9963346727016456,
            "length_improvement": 13.8434413164237,
            "objective_score": -0.7324113349047652
        },
        {
            "map_id": 2,
            "success_rate": 0.9,
            "time_avg": 0.012314391136169434,
            "num_nodes_avg": 223.6,
            "path_length_avg": 131.58176022985964,
            "success_improvement": -9.999999999999998,
            "time_improvement": 57.507196585457756,
            "length_improvement": 19.200872600268642,
            "objective_score": 16.092333495691054
        }
    ],
    "success_rate": 1.0
}
