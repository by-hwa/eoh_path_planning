[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "PathPlanning: An improved sample-based path planning algorithm inspired by RRT* with goal biasing, adaptive step size,\n    and rewiring for path optimization. The algorithm biases samples towards the goal to increase efficiency, adapts\n    the maximum extension distance to environment scale, and performs local rewiring to reduce path cost and improve \n    path smoothness. It includes shortcut path smoothing after a path is found and enforces a maximum runtime of 10 seconds \n    for robustness. This approach balances exploration and exploitation to achieve better success rates, faster planning, \n    and higher quality paths with fewer failures in cluttered environments.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize the sample-based graph with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0  # Initialize start vertex cost\n        self._graph = gen_forest(self._services, start_vertex, Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable removability for rewiring\n        # Adaptive max extension distance based on environment diagonal\n        self._max_dist = max(5, int(math.sqrt(self._get_grid().size.width ** 2 + self._get_grid().size.height ** 2) / 20))\n        self._goal_bias = 0.15  # Bias towards goal sampling probability\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 8000\n\n        goal_position: Point = self._get_grid().goal.position\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10:  # Fail if planning takes too long\n                break\n\n            # Goal-biased random sampling\n            if random.random() < self._goal_bias:\n                q_sample = goal_position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Add q_new as vertex in graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire: find nearby vertices and try to update parent if better path found\n            radius = self._max_dist * 2\n            near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            for q_nearby in near_vertices:\n                if q_nearby == q_near:\n                    continue\n                new_line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n                if self._get_grid().is_valid_line_sequence(new_line_seq):\n                    cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearby.position)\n                    if cost_through_new < q_nearby.cost:\n                        # Remove old edge and add new edge for rewiring\n                        for parent_vertex in list(q_nearby.parents):\n                            self._graph.remove_edge(parent_vertex, q_nearby)\n                        self._graph.add_edge(q_new, q_nearby)\n                        q_nearby.cost = cost_through_new\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex and update cost\n                goal_vertex = Vertex(goal_position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_position)\n                self._graph.add_edge(q_new, goal_vertex)\n\n                # Extract and shortcut path\n                self._extract_path(q_new)\n\n                # Optional post-processing for smoothing path (call helper)\n                self._shortcut_path()\n\n                break\n\n            self.key_frame()\n\n    def _get_random_sample(self) -> Point:\n        width = self._get_grid().size.width\n        height = self._get_grid().size.height\n        while True:\n            x = random.randint(0, (width - 1))\n            y = random.randint(0, (height - 1))\n            sample_point = Point(x, y)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        dist = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (dist <= max_dist):\n            new_position = q_sample\n        else:\n            scale = (max_dist / dist)\n            new_x = int(round((q_near.position.x + (direction.x * scale))))\n            new_y = int(round((q_near.position.y + (direction.y * scale))))\n            new_position = Point(new_x, new_y)\n        new_vertex = Vertex(new_position)\n        # Initialize cost for q_near if None\n        if q_near.cost is None:\n            q_near.cost = 0.0\n        new_vertex.cost = (q_near.cost + self._get_grid().get_distance(q_near.position, new_position))\n        return new_vertex\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        path = []\n        current = last_vertex\n        while (current is not None):\n            path.append(current.position)\n            if current.parents:\n                current = min(current.parents, key=(lambda p: p.cost))\n            else:\n                current = None\n        path.reverse()\n        self._path = path\n        for point in path:\n            self.move_agent(point)\n            self.key_frame()\n\n    def _shortcut_path(self) -> None:\n        if ((not hasattr(self, '_path')) or (not self._path) or (len(self._path) < 3)):\n            return\n        shortened_path = [self._path[0]]\n        current_index = 0\n        while (current_index < (len(self._path) - 1)):\n            next_index = (len(self._path) - 1)\n            for j in range((len(self._path) - 1), current_index, (- 1)):\n                line_seq = self._get_grid().get_line_sequence(self._path[current_index], self._path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_index = j\n                    break\n            shortened_path.append(self._path[next_index])\n            current_index = next_index\n        self._path = shortened_path\n        for point in self._path:\n            self.move_agent(point)\n            self.key_frame()",
          "objective": 3067.32,
          "other_inf": null,
          "results": {
               "goal_found_perc": 95.33,
               "average_steps": 21.66,
               "average_distance": 22.99,
               "average_smoothness": 0.47,
               "average_clearance": 2.13,
               "average_time": 0.1316,
               "average_distance_from_goal": 0.31,
               "average_original_distance_from_goal": 8.42,
               "average memory": 55.27,
               "goal_found_perc_improvement": -2.05,
               "average_steps_improvement": -139.87,
               "average_distance_improvement": -141.24,
               "average_smoothness_improvement": -80.77,
               "average_clearance_improvement": 5.45,
               "average_time_improvement": -1753.52,
               "average_distance_from_goal_improvement": -55.0,
               "average_path_deviation": 13.459999999999999,
               "average_memory_improvement": -48.5
          }
     },
     {
          "algorithm": "Improved path planning algorithm combining RRT* with goal biasing, adaptive step size,\n    and rewiring to improve path quality and success rate.\n\n    Key features:\n    - Goal-biased sampling to guide exploration towards the goal efficiently.\n    - Adaptive max_dist step size based on distance to goal and local obstacles.\n    - Rewiring of the graph to optimize path cost and produce shorter, smoother paths.\n    - Early stopping if solution found or after 10 seconds to limit planning time.\n    - Uses helper functions for modular design: sampling, extending, rewiring, and path extraction.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges\n        self._max_dist_base = 10  # Base max extension distance\n        self._goal_bias_prob = 0.2  # Probability of sampling goal directly\n        self._rewire_radius = 20.0  # Radius for rewiring neighbors\n        self._max_time = 10.0  # Maximum allowed planning time in seconds\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._max_time:\n                # Timeout: fail gracefully\n                break\n\n            # Sampling with goal bias\n            q_sample: Point = self._biased_random_sample()\n\n            # Nearest existing vertex in the tree\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance and environment\n            max_dist: float = self._adaptive_max_dist(q_near.position, q_sample)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Insert q_new into the graph with cost update\n            self._graph.add_edge(q_near, q_new)\n\n            mov_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if mov_cost is None:\n                mov_cost = float('inf')\n            q_new.cost = (q_near.cost if q_near.cost is not None else float('inf')) + mov_cost\n\n            # Rewiring step to optimize path locally (RRT*)\n            neighbors: list[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start],\n                                                                            q_new.position,\n                                                                            self._rewire_radius)\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_near:\n                    continue\n                candidate_line = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(candidate_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_near_candidate.position, q_new.position)\n                if mov_cost is None:\n                    continue\n                q_near_cost = q_near_candidate.cost if q_near_candidate.cost is not None else float('inf')\n                cost_through_candidate = q_near_cost + mov_cost\n                if cost_through_candidate < q_new.cost:\n                    # Rewire q_new to q_near_candidate\n                    self._graph.remove_edge(q_near, q_new)\n                    self._graph.add_edge(q_near_candidate, q_new)\n                    q_new.cost = cost_through_candidate\n                    q_near = q_near_candidate\n\n            # Also try rewiring neighbors through q_new for better paths\n            for neighbor in neighbors:\n                if neighbor == q_new:\n                    continue\n                rewiring_line = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(rewiring_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if mov_cost is None:\n                    continue\n                q_new_cost = q_new.cost if q_new.cost is not None else float('inf')\n                cost_through_q_new = q_new_cost + mov_cost\n                neighbor_cost = neighbor.cost if neighbor.cost is not None else float('inf')\n                if cost_through_q_new < neighbor_cost:\n                    # Rewire neighbor parent edges\n                    # Find current parents and remove edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n            # If this new vertex is close enough to goal, attempt connection\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path_with_smoothing(q_new)\n                break\n\n            self.key_frame()\n\n    def _biased_random_sample(self) -> Point:\n        if (random.random() < self._goal_bias_prob):\n            return self._graph.root_vertex_goal.position\n        else:\n            grid_size = self._get_grid().size\n            while True:\n                sample_x = int(round(random.uniform(0, grid_size.width)))\n                sample_y = int(round(random.uniform(0, grid_size.height)))\n                sample = Point(sample_x, sample_y)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, q_near_pos: Point, q_sample_pos: Point) -> float:\n        base_dist = self._max_dist_base\n        dist = Map.get_distance(q_near_pos, q_sample_pos)\n        goal_pos = self._graph.root_vertex_goal.position\n        dist_to_goal = Map.get_distance(q_near_pos, goal_pos)\n        if (dist_to_goal < (base_dist * 2)):\n            base_dist *= 0.5\n        obstacle_nearby = False\n        obstacle_safe_dist = base_dist\n        for obs in self._get_grid().obstacles:\n            obs_dist = Map.get_distance(q_near_pos, obs.position)\n            if (obs_dist <= (obstacle_safe_dist + obs.radius)):\n                obstacle_nearby = True\n                break\n        if obstacle_nearby:\n            base_dist *= 0.3\n        max_dist = min(base_dist, dist)\n        if (max_dist < 1e-05):\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        length = math.hypot(direction.x, direction.y)\n        if (length <= max_dist):\n            new_pos = q_sample\n        else:\n            scale = (max_dist / length)\n            new_x = q_near.position.x + (direction.x * scale)\n            new_y = q_near.position.y + (direction.y * scale)\n            new_pos = Point(new_x, new_y)\n\n        # Ensure position is integer coordinates before querying the grid\n        int_pos = Point(int(round(new_pos.x)), int(round(new_pos.y)))\n        new_vertex = Vertex(int_pos)\n        new_vertex.cost = float('inf')\n        return new_vertex\n\n    def _extract_path_with_smoothing(self, q_new: Vertex) -> None:\n        path = []\n        current_vertex = q_new\n        while (current_vertex is not None):\n            path.append(current_vertex.position)\n            if (len(current_vertex.parents) == 0):\n                break\n            current_vertex = min(current_vertex.parents, key=(lambda v: v.cost))\n        path.reverse()\n        smoothed_path = [path[0]]\n        i = 0\n        while (i < (len(path) - 1)):\n            j = (len(path) - 1)\n            while (j > (i + 1)):\n                line_seq = self._get_grid().get_line_sequence(path[i], path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        for point in smoothed_path:\n            self.move_agent(point)\n            self.key_frame()",
          "objective": 7941.59,
          "other_inf": null,
          "results": {
               "goal_found_perc": 96.67,
               "average_steps": 9.5,
               "average_distance": 10.11,
               "average_smoothness": 0.32,
               "average_clearance": 2.02,
               "average_time": 0.3711,
               "average_distance_from_goal": 0.25,
               "average_original_distance_from_goal": 8.42,
               "average memory": 66.88,
               "goal_found_perc_improvement": -0.68,
               "average_steps_improvement": -4.17,
               "average_distance_improvement": -4.98,
               "average_smoothness_improvement": -23.08,
               "average_clearance_improvement": 0.5,
               "average_time_improvement": -5126.76,
               "average_distance_from_goal_improvement": -25.0,
               "average_path_deviation": 0.47999999999999865,
               "average_memory_improvement": -79.69
          }
     },
     {
          "algorithm": "This algorithm is an improved sample-based path planner inspired by RRT and RRT*. \n    It incorporates goal-biased sampling, adaptive step size control, and rewiring techniques \n    for path quality improvement. The algorithm utilizes heuristic-guided selection of nearest vertices \n    by combining distance and cost-to-go estimates to promote more informed expansions. \n    Rewiring optimizes the connectivity by attempting to shorten paths via nearby vertices. \n    An early stopping criterion based on goal reach and a time limit (10 seconds) improve planning efficiency. \n    The final path is extracted and smoothed before returning to the agent.",
          "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Enable rewiring (edge removals)\n        self._init_displays()\n        self._max_dist_base = 15.0  # base step size\n        self._goal_sample_rate = 0.2  # 20% goal bias sampling\n        self._rewire_radius = 20.0  # rewire radius\n\n    def _find_path_internal(self) -> None:\n        import time\n        import numpy as np\n\n        start_time = time.time()\n        max_time_seconds = 10.0\n        iterations = 10000\n\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n\n        for iteration in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > max_time_seconds:\n                # Timeout: no path found within allowed time\n                break\n\n            # Goal biased sampling\n            if np.random.random() < self._goal_sample_rate:\n                q_sample: Point = goal_pos\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_near: Vertex = self._select_best_nearest_vertex(q_sample)  # heuristic-based nearest vertex\n\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive step size based on distance to goal (shrinks as we get closer)\n            dist_to_sample = self._get_grid().get_distance(q_near.position, q_sample)\n            adaptive_max_dist = min(self._max_dist_base, dist_to_sample)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, adaptive_max_dist)\n\n            # Check valid line between q_near and q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute cost from root to q_near + from q_near to q_new\n            cost_q_near = q_near.cost if hasattr(q_near, 'cost') and q_near.cost is not None else 0.0\n            increment_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            q_new.cost = cost_q_near + increment_cost\n\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewiring: try to connect q_new with better parents in neighborhood for path quality\n            nearby_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, self._rewire_radius)\n            for vertex in nearby_vertices:\n                if vertex == q_near or vertex == q_new:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                    continue\n                cost_vertex = vertex.cost if hasattr(vertex, 'cost') and vertex.cost is not None else 0.0\n                cost_through_vertex = cost_vertex + self._get_grid().get_movement_cost(vertex.position, q_new.position)\n                if cost_through_vertex < q_new.cost:\n                    # Rewire parent\n                    # Remove old edge from q_near to q_new\n                    self._graph.remove_edge(q_near, q_new)\n                    # Add new edge from better vertex to q_new\n                    self._graph.add_edge(vertex, q_new)\n                    q_new.cost = cost_through_vertex\n                    q_near = vertex\n\n            # Check if goal can be connected directly from q_new\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Attempt direct connection to goal vertex\n                goal_vertex = Vertex(goal_pos)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_movement_cost(q_new.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return  # Path found and extracted\n\n            self.key_frame()\n\n\n\n    def _get_random_sample(self) -> Point:\n        import random\n        grid = self._get_grid()\n        size = grid.size\n        while True:\n            x = random.randint(0, (size.width - 1))\n            y = random.randint(0, (size.height - 1))\n            sample_point = Point(x, y)\n            if grid.is_agent_valid_pos(sample_point):\n                return sample_point\n\n\n\n\n    def _select_best_nearest_vertex(self, q_sample: Point) -> Vertex:\n        root_vertices = [self._graph.root_vertex_start]\n        nearby_vertices = self._graph.get_vertices_within_radius(root_vertices, q_sample, self._max_dist_base)\n        if not nearby_vertices:\n            return self._graph.get_nearest_vertex(root_vertices, q_sample)\n        best_vertex = None\n        best_value = float('inf')\n        for vertex in nearby_vertices:\n            cost = getattr(vertex, 'cost', 0.0)\n            if cost is None:\n                cost = 0.0\n            dist = self._get_grid().get_distance(vertex.position, q_sample)\n            value = cost + dist\n            if value < best_value:\n                best_value = value\n                best_vertex = vertex\n        return best_vertex if best_vertex is not None else self._graph.get_nearest_vertex(root_vertices, q_sample)\n\n\n\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        dist = self._get_grid().get_distance(q_near.position, q_sample)\n        if dist > max_dist:\n            scale = (max_dist / dist)\n            new_x = int(round((q_near.position.x + (direction.x * scale))))\n            new_y = int(round((q_near.position.y + (direction.y * scale))))\n        else:\n            new_x = q_sample.x\n            new_y = q_sample.y\n        new_point = Point(new_x, new_y)\n        return Vertex(new_point)\n\n\n\n\n    def _extract_path(self, goal_vertex: Vertex) -> None:\n        path: List[Point] = []\n        current_vertex = goal_vertex\n        while current_vertex is not None:\n            path.append(current_vertex.position)\n            if current_vertex.parents:\n                current_vertex = min(current_vertex.parents, key=lambda v: getattr(v, 'cost', float('inf')))\n            else:\n                current_vertex = None\n        path.reverse()\n        for point in path:\n            self.move_agent(point)\n            self.key_frame()",
          "objective": Infinity,
          "other_inf": null,
          "results": {}
     }
]