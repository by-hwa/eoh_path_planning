[
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This improved PathPlanning algorithm enhances traditional sampling-based planners\n    by integrating an adaptive goal-biased sampling mechanism combined with heuristic-guided extension steps.\n    It uses A*-inspired cost estimates to select promising extension directions and adaptively modulates step sizes\n    based on local environment density and distance to goal to accelerate convergence.\n    The rewiring approach leverages a dynamically shrinking radius to maintain balance between exploration and exploitation.\n    Additionally, it incorporates offline path smoothing by progressively shortcutting and refining paths during planning,\n    enabling higher-quality (shorter and smoother) paths to be found faster.\n    Early stopping enforces a 10-second time budget to ensure timely results.\n    These improvements raise planning efficiency, robustness, path smoothness, and success rate compared to baseline methods.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 4000  # Slightly fewer max iterations for efficiency\n        self._time_limit = 10.0  # seconds\n        self._goal_sample_rate = 0.20  # increased goal bias for faster convergence\n        self._max_dist_base = 20.0  # increased base extension distance\n        self._rewire_radius_initial = 25.0  # initial rewire radius\n        self._rewire_radius_min = 10.0  # minimum rewire radius to maintain connectivity\n        self._rewire_decay_rate = 0.995  # radius decay per iteration for adaptive rewiring\n        self._iteration = 0\n        \n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        \n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.aux['cost'] = 0.0\n        goal_vertex.aux['cost'] = float('inf')\n        \n        self._graph.root_vertices.append(start_vertex)\n        self._graph.root_vertices.append(goal_vertex)\n        \n        rewire_radius = self._rewire_radius_initial\n        \n        for iteration in range(self._max_iter):\n            self._iteration = iteration\n            \n            # Early stopping if time exceeded\n            if (time.time() - start_time) > self._time_limit:\n                return\n            \n            # Sample point with dynamic goal bias and heuristic guidance\n            sample_point = self._get_heuristic_goal_biased_sample(self._goal_sample_rate, goal_vertex.position)\n            \n            # Find nearest vertex for extension\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample_point)\n            \n            if nearest_vertex is None:\n                continue\n            \n            # Adaptive step size: influenced by distance to goal and local density heuristic\n            dist_to_sample = self._get_grid().get_distance(nearest_vertex.position, sample_point)\n            dist_to_goal = self._get_grid().get_distance(nearest_vertex.position, goal_vertex.position)\n            \n            # Use a decreasing step size as we approach goal\n            max_dist_dynamic = max(5.0, min(self._max_dist_base, dist_to_goal * 0.7))\n            max_dist = min(max_dist_dynamic, dist_to_sample)\n            \n            # Generate new vertex toward sample point\n            new_vertex = self._get_new_vertex_heuristic(nearest_vertex, sample_point, max_dist, goal_vertex.position)\n            if new_vertex.position == nearest_vertex.position:\n                continue\n            \n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            cost_to_nearest = nearest_vertex.aux.get('cost', float('inf'))\n            step_cost = self._get_grid().get_movement_cost(nearest_vertex.position, new_vertex.position)\n            new_vertex_cost = cost_to_nearest + step_cost\n            \n            # Find neighbors within rewiring radius (shrinking radius)\n            neighbors = self._graph.get_vertices_within_radius([start_vertex], new_vertex.position, rewire_radius)\n            \n            best_parent = nearest_vertex\n            best_cost = new_vertex_cost\n            \n            # Choose best parent among near vertices by cost + collision check\n            for neighbor in neighbors:\n                if neighbor == nearest_vertex:\n                    continue\n                line_seq_to_new = self._get_grid().get_line_sequence(neighbor.position, new_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_to_new):\n                    cost_through_neighbor = neighbor.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(neighbor.position, new_vertex.position)\n                    if cost_through_neighbor < best_cost:\n                        best_parent = neighbor\n                        best_cost = cost_through_neighbor\n            \n            new_vertex.aux['cost'] = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n            \n            # Rewiring attempt: connect neighbors through new_vertex for better cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    cost_through_new = new_vertex.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(new_vertex.position, neighbor.position)\n                    if cost_through_new < neighbor.aux.get('cost', float('inf')):\n                        for p in list(neighbor.parents):\n                            self._graph.remove_edge(p, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.aux['cost'] = cost_through_new\n            \n            self._graph.root_vertices.append(new_vertex)\n            \n            # Attempt direct connection to goal vertex if close enough\n            if self._get_grid().get_distance(new_vertex.position, goal_vertex.position) <= self._max_dist_base:\n                goal_line_seq = self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    cost_to_goal_candidate = new_vertex.aux.get('cost', float('inf')) + self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal_candidate < goal_vertex.aux.get('cost', float('inf')):\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        goal_vertex.aux['cost'] = cost_to_goal_candidate\n                        \n                        # Extract and smooth path progressively further\n                        self._extract_and_smooth_path_improved(goal_vertex)\n                        return\n            \n            # Decay rewiring radius to focus rewiring as tree grows\n            rewire_radius = max(self._rewire_radius_min, rewire_radius * self._rewire_decay_rate)\n            \n            self.key_frame()\n\n\n\n    def _get_heuristic_goal_biased_sample(self, goal_sample_rate: float, goal_position: Point) -> Point:\n        if (random.random() < goal_sample_rate):\n            return goal_position\n        grid = self._get_grid()\n        size = grid.size\n        while True:\n            sample_x = random.uniform(0, (size.width - 1))\n            sample_y = random.uniform(0, (size.height - 1))\n            sample_point = Point(int(sample_x), int(sample_y))\n            direction_to_goal = Point((goal_position.x - sample_point.x), (goal_position.y - sample_point.y))\n            length = math.sqrt(((direction_to_goal.x ** 2) + (direction_to_goal.y ** 2)))\n            if (length > 1e-05):\n                direction_to_goal = Point((direction_to_goal.x / length), (direction_to_goal.y / length))\n                bias_factor = 0.3\n                biased_x = (sample_point.x + (((direction_to_goal.x * bias_factor) * size.width) * random.random()))\n                biased_y = (sample_point.y + (((direction_to_goal.y * bias_factor) * size.height) * random.random()))\n                biased_point = Point(int(max(0, min((size.width - 1), biased_x))), int(max(0, min((size.height - 1), biased_y))))\n            else:\n                biased_point = sample_point\n            if grid.is_agent_valid_pos(biased_point):\n                return biased_point\n\n\n\n\n    def _get_new_vertex_heuristic(self, nearest_vertex: Vertex, sample_point: Point, max_dist: float, goal_position: Point) -> Vertex:\n        direction = Point((sample_point.x - nearest_vertex.position.x), (sample_point.y - nearest_vertex.position.y))\n        length = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (length > max_dist):\n            scale = (max_dist / length)\n            new_x = (nearest_vertex.position.x + int((direction.x * scale)))\n            new_y = (nearest_vertex.position.y + int((direction.y * scale)))\n        else:\n            (new_x, new_y) = (sample_point.x, sample_point.y)\n        new_position = Point(new_x, new_y)\n        dist_to_goal_from_new = self._get_grid().get_distance(new_position, goal_position)\n        dist_to_goal_from_nearest = self._get_grid().get_distance(nearest_vertex.position, goal_position)\n        if (dist_to_goal_from_new > dist_to_goal_from_nearest):\n            direction_to_goal = Point((goal_position.x - new_position.x), (goal_position.y - new_position.y))\n            dist_to_goal = math.sqrt(((direction_to_goal.x ** 2) + (direction_to_goal.y ** 2)))\n            if (dist_to_goal > 1e-05):\n                move_scale = min((max_dist * 0.3), dist_to_goal)\n                direction_to_goal = Point((direction_to_goal.x / dist_to_goal), (direction_to_goal.y / dist_to_goal))\n                new_x = (new_position.x + int((direction_to_goal.x * move_scale)))\n                new_y = (new_position.y + int((direction_to_goal.y * move_scale)))\n                new_position = Point(max(0, min(new_x, (self._get_grid().size.width - 1))), max(0, min(new_y, (self._get_grid().size.height - 1))))\n        return Vertex(new_position, store_connectivity=True)\n\n\n\n\n    def _extract_and_smooth_path_improved(self, goal_vertex: Vertex) -> None:\n        path: List[Point] = []\n        vertex = goal_vertex\n        while (vertex is not None):\n            path.append(vertex.position)\n            if (not vertex.parents):\n                break\n            vertex = min(vertex.parents, key=(lambda v: v.aux.get('cost', float('inf'))))\n        path.reverse()\n        smoothed_path: List[Point] = [path[0]]\n        last_added = path[0]\n        for i in range(1, len(path)):\n            candidate = path[i]\n            line_seq = self._get_grid().get_line_sequence(last_added, candidate)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            else:\n                smoothed_path.append(path[(i - 1)])\n                last_added = path[(i - 1)]\n        if (smoothed_path[(- 1)] != path[(- 1)]):\n            smoothed_path.append(path[(- 1)])\n        self._trace = [Trace(pos) for pos in smoothed_path]\n        for pos in smoothed_path:\n            self.move_agent(pos)\n            self.key_frame()\n\n\n",
          "objective": 3519.61,
          "other_inf": null,
          "results": {
               "goal_found_perc": 95.33,
               "average_steps": 10.14,
               "average_distance": 10.89,
               "average_smoothness": 0.33,
               "average_clearance": 2.05,
               "average_time": 0.1516,
               "average_distance_from_goal": 0.46,
               "average_original_distance_from_goal": 8.42,
               "average memory": 63.63,
               "goal_found_perc_improvement": -2.05,
               "average_steps_improvement": -13.42,
               "average_distance_improvement": -15.24,
               "average_smoothness_improvement": -26.92,
               "average_clearance_improvement": 2.5,
               "average_time_improvement": -2097.1,
               "average_distance_from_goal_improvement": -130.0,
               "average_path_deviation": 1.4400000000000013,
               "average_memory_improvement": -70.96
          }
     },
     {
          "algorithm": "This algorithm enhances the basic goal-biased RRT* by integrating a clearance-aware sampling strategy \n    that prefers sampling points away from obstacles to improve path safety and robustness.\n    It uses heuristic-guided extension biased by cost-to-go estimates to better guide tree growth towards the goal.\n    Adaptive step sizing is employed based on clearance and distance to goal to balance exploration and exploitation.\n    Rewiring is performed for local optimality improvements in path cost.\n    After a path is found, the algorithm applies shortcut smoothing for improved path quality.\n    The planner respects a strict 10-second time limit for early stopping and dynamically adjusts iteration control for efficiency.\n    The improved clearance awareness aims to reduce collisions and increase success rate and path smoothness.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 5000\n        self._time_limit = 10.0  # seconds allowed for planning\n        self._goal_sample_rate = 0.2  # Increased goal bias for quicker goal convergence\n        self._max_dist_base = 20.0    # Slightly larger base max step size for faster exploration\n        self._rewire_radius = 25.0    # Larger rewire radius for better optimization\n        self._clearance_weight = 5.0  # Weight factor to encourage clearance during sampling\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        start_vertex.aux['cost'] = 0.0\n        self._graph.root_vertices.append(start_vertex)\n        self._graph.root_vertices.append(goal_vertex)\n\n        for iteration in range(self._max_iter):\n\n            # Early stop on time limit\n            if (time.time() - start_time) > self._time_limit:\n                return  # fail if no path found in time\n\n            # Sample point with clearance-awareness and goal bias\n            sample_point = self._get_clearance_aware_sample(self._goal_sample_rate, goal_vertex.position, self._clearance_weight)\n\n            # Find nearest vertex from tree toward sample point\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample_point)\n\n            # Calculate adaptive max_dist based on clearance heuristic and proximity to goal\n            dist_to_goal = self._get_grid().get_distance(nearest_vertex.position, goal_vertex.position)\n            clearance_at_nearest = self._estimate_clearance(nearest_vertex.position)\n            clearance_factor = max(1.0, clearance_at_nearest / self._clearance_weight)\n            max_dist = min(self._max_dist_base * clearance_factor, dist_to_goal * 0.8)\n\n            # Create a new vertex extended towards the sample point with max_dist constraint\n            new_vertex = self._get_new_vertex(nearest_vertex, sample_point, max_dist)\n            if new_vertex.position == nearest_vertex.position:\n                continue  # no meaningful extension\n\n            # Check collision for path from nearest to new vertex\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate cost to new vertex using current cost + movement cost\n            cost_to_nearest = nearest_vertex.aux.get('cost', float('inf'))\n            step_cost = self._get_grid().get_movement_cost(nearest_vertex.position, new_vertex.position)\n            new_cost = cost_to_nearest + step_cost\n\n            # Find neighbors in rewire radius for better connection and rewiring\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], new_vertex.position, self._rewire_radius)\n\n            # Select best parent based on minimal cost and valid path\n            best_parent = nearest_vertex\n            best_cost = new_cost\n            for near_vertex in near_vertices:\n                if near_vertex == nearest_vertex:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost_to_near = near_vertex.aux.get('cost', float('inf'))\n                    candidate_cost = cost_to_near + self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position)\n                    # Heuristic: prioritize vertices with higher clearance by discounting cost slightly\n                    clearance_near = self._estimate_clearance(near_vertex.position)\n                    candidate_cost -= self._clearance_weight * (clearance_near / 100.0)\n                    if candidate_cost < best_cost:\n                        best_parent = near_vertex\n                        best_cost = candidate_cost\n\n            # Set auxiliary cost and add edge from best parent to new vertex\n            new_vertex.aux['cost'] = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n\n            # Rewiring for neighbors considering new vertex as better path provider\n            for near_vertex in near_vertices:\n                if near_vertex == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    cost_through_new = new_vertex.aux.get('cost', float('inf')) + \\\n                                       self._get_grid().get_movement_cost(new_vertex.position, near_vertex.position)\n                    current_cost = near_vertex.aux.get('cost', float('inf'))\n                    if cost_through_new < current_cost:\n                        # Remove old parents and add new edge from new_vertex\n                        for p in list(near_vertex.parents):\n                            self._graph.remove_edge(p, near_vertex)\n                        self._graph.add_edge(new_vertex, near_vertex)\n                        near_vertex.aux['cost'] = cost_through_new\n\n            # Add new vertex to forest root vertices for exploration\n            self._graph.root_vertices.append(new_vertex)\n\n            # Try connecting new vertex directly to goal if close enough\n            dist_to_goal_from_new = self._get_grid().get_distance(new_vertex.position, goal_vertex.position)\n            if dist_to_goal_from_new <= self._max_dist_base * 1.2:\n                goal_line_seq = self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    cost_to_goal_new = new_vertex.aux.get('cost', float('inf')) + \\\n                                       self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal_new < goal_vertex.aux.get('cost', float('inf')):\n                        # Remove all previous parents from goal and add edge from new_vertex\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        goal_vertex.aux['cost'] = cost_to_goal_new\n\n                        # Extract and smooth the found path\n                        self._extract_and_smooth_path(goal_vertex)\n                        return\n\n            self.key_frame()\n\n\n\n    def _get_clearance_aware_sample(self, goal_sample_rate: float, goal_pos: Point, clearance_weight: float) -> Point:\n        'Generate a clearance-aware sample point for RRT planning with goal bias.\\n\\n    Args:\\n        goal_sample_rate (float): Probability of sampling the goal directly.\\n        goal_pos (Point): Position of the goal to bias sampling.\\n        clearance_weight (float): Weight factor to prefer samples with higher clearance.\\n\\n    Returns:\\n        Point: A sampled point in the map.\\n    '\n        if (random.random() < goal_sample_rate):\n            return goal_pos\n        grid = self._get_grid()\n        size = grid.size\n        num_samples = 10\n        best_sample = None\n        best_score = (- float('inf'))\n        for _ in range(num_samples):\n            x = random.uniform(0, (size.width - 1))\n            y = random.uniform(0, (size.height - 1))\n            sample = Point(int(round(x)), int(round(y)))\n            if (not grid.is_agent_valid_pos(sample)):\n                continue\n            clearance = self._estimate_clearance(sample)\n            score = (clearance * clearance_weight)\n            if (score > best_score):\n                best_score = score\n                best_sample = sample\n        if (best_sample is None):\n            while True:\n                x = random.randint(0, (size.width - 1))\n                y = random.randint(0, (size.height - 1))\n                sample = Point(x, y)\n                if grid.is_agent_valid_pos(sample):\n                    best_sample = sample\n                    break\n        return best_sample\n\n\n\n\n    def _estimate_clearance(self, pos: Point) -> float:\n        grid = self._get_grid()\n        max_clearance_distance = 50\n        clearance = 0.0\n        for d in range(1, (max_clearance_distance + 1)):\n            points_to_check = []\n            (x0, y0) = (pos.x, pos.y)\n            for x in range((x0 - d), ((x0 + d) + 1)):\n                points_to_check.append(Point(x, (y0 - d)))\n                points_to_check.append(Point(x, (y0 + d)))\n            for y in range(((y0 - d) + 1), (y0 + d)):\n                points_to_check.append(Point((x0 - d), y))\n                points_to_check.append(Point((x0 + d), y))\n            all_clear = True\n            for pt in points_to_check:\n                if (not grid.is_agent_valid_pos(pt)):\n                    all_clear = False\n                    break\n            if all_clear:\n                clearance = float(d)\n            else:\n                break\n        return clearance\n\n\n\n\n    def _get_new_vertex(self, nearest_vertex: Vertex, sample_point: Point, max_dist: float) -> Vertex:\n        from math import sqrt\n        direction_x = (sample_point.x - nearest_vertex.position.x)\n        direction_y = (sample_point.y - nearest_vertex.position.y)\n        dist = sqrt(((direction_x ** 2) + (direction_y ** 2)))\n        if (dist == 0):\n            return Vertex(nearest_vertex.position, store_connectivity=True)\n        scale = min((max_dist / dist), 1.0)\n        new_x = (nearest_vertex.position.x + (direction_x * scale))\n        new_y = (nearest_vertex.position.y + (direction_y * scale))\n        new_pos = Point(int(round(new_x)), int(round(new_y)))\n        return Vertex(new_pos, store_connectivity=True)\n\n\n\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        path = []\n        current = goal_vertex\n        while current.parents:\n            path.append(current.position)\n            current = next(iter(current.parents))\n        path.append(current.position)\n        path.reverse()\n        smoothed_path = [path[0]]\n        grid = self._get_grid()\n        i = 0\n        while (i < (len(path) - 1)):\n            j = (len(path) - 1)\n            while (j > (i + 1)):\n                line_seq = grid.get_line_sequence(path[i], path[j])\n                if grid.is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        self._last_path = smoothed_path\n        for point in smoothed_path:\n            self.move_agent(point)\n            self.key_frame()\n\n\n\n\n    def sqrt(value: float) -> float:\n        return (value ** 0.5)\n",
          "objective": 8228.94,
          "other_inf": null,
          "results": {
               "goal_found_perc": 94.67,
               "average_steps": 10.87,
               "average_distance": 11.53,
               "average_smoothness": 0.34,
               "average_clearance": 2.16,
               "average_time": 0.3019,
               "average_distance_from_goal": 0.47,
               "average_original_distance_from_goal": 8.42,
               "average memory": 337.93,
               "goal_found_perc_improvement": -2.73,
               "average_steps_improvement": -20.91,
               "average_distance_improvement": -21.62,
               "average_smoothness_improvement": -30.77,
               "average_clearance_improvement": 6.93,
               "average_time_improvement": -4212.86,
               "average_distance_from_goal_improvement": -135.0,
               "average_path_deviation": 2.049999999999999,
               "average_memory_improvement": -807.93
          }
     },
     {
          "algorithm": "This PathPlanning algorithm improves upon basic sampling-based planners\n    by integrating goal-biased sampling, heuristic-guided extension using cost-to-go estimates,\n    adaptive step size based on distance to goal, and rewiring for path optimization (RRT* style).\n    It also performs path smoothing via shortcutting after path extraction.\n    The algorithm employs early stopping with a 10-second time limit, and dynamic iteration control.\n    This combination aims to increase success rate, find higher-quality (shorter and smoother)\n    paths, and improve overall planning efficiency and robustness.",
          "code": "\nfrom typing import List\n\nimport torch\nimport numpy as np\nimport random\nimport time\nimport math\n\nfrom memory_profiler import profile\nfrom typing import TYPE_CHECKING, List, Tuple, Type, Any, Dict, Union, Optional\n\nfrom algorithms.basic_testing import BasicTesting\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\nfrom algorithms.configuration.entities.agent import Agent\nfrom algorithms.configuration.entities.entity import Entity\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.entities.obstacle import Obstacle\nfrom algorithms.configuration.entities.trace import Trace\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.bresenhams_algo import bresenhamline\n\nfrom simulator.services.services import Services\n\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\n\nfrom structures import Point, Size, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\n\n\nclass PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        self._max_iter = 5000\n        self._time_limit = 10.0  # seconds\n        self._goal_sample_rate = 0.15  # goal bias sampling probability\n        self._max_dist_base = 15.0      # base maximum extension distance\n        self._rewire_radius = 20.0      # radius within which to attempt rewiring\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        # Add start and goal vertices to graph explicitly with connectivity enabled\n        start_vertex.aux['cost'] = 0.0\n        self._graph.root_vertices.append(start_vertex)\n        self._graph.root_vertices.append(goal_vertex)\n\n        for iteration in range(self._max_iter):\n            \n            # Time limit check, stop search if over limit\n            if (time.time() - start_time) > self._time_limit:\n                return  # path not found in time\n            \n            # Sample point with goal bias\n            sample_point = self._get_sample_with_goal_bias(self._goal_sample_rate, goal_vertex.position)\n\n            # Find nearest vertex in tree to sample\n            nearest_vertex = self._graph.get_nearest_vertex([start_vertex], sample_point)\n\n            # Adaptive step size based on distance to goal and nearest vertex\n            dist_to_sample = self._get_grid().get_distance(nearest_vertex.position, sample_point)\n            dist_to_goal = self._get_grid().get_distance(nearest_vertex.position, goal_vertex.position)\n            max_dist = min(self._max_dist_base, dist_to_goal * 0.75, dist_to_sample)\n\n            # Create new vertex extended towards sample with max_dist limiting step size\n            new_vertex = self._get_new_vertex(nearest_vertex, sample_point, max_dist)\n            if new_vertex.position == nearest_vertex.position:\n                continue\n            \n            # Check collision for path from nearest to new vertex\n            line_seq = self._get_grid().get_line_sequence(nearest_vertex.position, new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            \n            # Calculate new cost from start through nearest to new_vertex\n            cost_to_nearest = nearest_vertex.aux.get('cost', float('inf'))\n            step_cost = self._get_grid().get_movement_cost(nearest_vertex.position, new_vertex.position)\n            new_cost = cost_to_nearest + step_cost\n\n            # Find near neighbors within rewire radius for potential better parent\n            near_vertices = self._graph.get_vertices_within_radius([start_vertex], new_vertex.position, self._rewire_radius)\n            best_parent = nearest_vertex\n            best_cost = new_cost\n\n            for near_vertex in near_vertices:\n                if near_vertex == nearest_vertex:\n                    continue\n                line_seq_near = self._get_grid().get_line_sequence(near_vertex.position, new_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_near):\n                    cost_to_near = near_vertex.aux.get('cost', float('inf'))\n                    cost_candidate = cost_to_near + self._get_grid().get_movement_cost(near_vertex.position, new_vertex.position)\n                    if cost_candidate < best_cost:\n                        best_parent = near_vertex\n                        best_cost = cost_candidate\n\n            # Add new vertex to graph and connect to best parent\n            new_vertex.aux['cost'] = best_cost\n            self._graph.add_edge(best_parent, new_vertex)\n\n            # Rewiring step: try to improve cost of neighbors by connecting through new_vertex\n            for near_vertex in near_vertices:\n                if near_vertex == best_parent:\n                    continue\n                line_seq_rewire = self._get_grid().get_line_sequence(new_vertex.position, near_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_rewire):\n                    cost_new_vertex = new_vertex.aux.get('cost', float('inf'))\n                    cost_through_new = cost_new_vertex + self._get_grid().get_movement_cost(new_vertex.position, near_vertex.position)\n                    cost_current = near_vertex.aux.get('cost', float('inf'))\n                    if cost_through_new < cost_current:\n                        # Rewire edges\n                        # Remove old parent edge\n                        for p in list(near_vertex.parents):\n                            self._graph.remove_edge(p, near_vertex)\n                        self._graph.add_edge(new_vertex, near_vertex)\n                        near_vertex.aux['cost'] = cost_through_new\n\n            # Add the new_vertex in forest nodes for search\n            self._graph.root_vertices.append(new_vertex)\n\n            # Check if new_vertex can connect directly to goal vertex\n            if self._get_grid().get_distance(new_vertex.position, goal_vertex.position) <= self._max_dist_base:\n                goal_line_seq = self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    # Connect and update cost for goal vertex\n                    cost_to_new = new_vertex.aux.get('cost', float('inf'))\n                    cost_to_goal = cost_to_new + self._get_grid().get_movement_cost(new_vertex.position, goal_vertex.position)\n                    if cost_to_goal < goal_vertex.aux.get('cost', float('inf')):\n                        # Remove previous parents of goal if any\n                        for p in list(goal_vertex.parents):\n                            self._graph.remove_edge(p, goal_vertex)\n                        self._graph.add_edge(new_vertex, goal_vertex)\n                        goal_vertex.aux['cost'] = cost_to_goal\n\n                        # Extract and smooth path\n                        self._extract_and_smooth_path(goal_vertex)\n                        return\n\n            self.key_frame()\n\n\n\n    def _get_sample_with_goal_bias(self, goal_sample_rate: float, goal_position: Point) -> Point:\n        if (random.random() < goal_sample_rate):\n            return goal_position\n        else:\n            grid_size = self._get_grid().size\n            sample_x = random.uniform(0, (grid_size.width - 1))\n            sample_y = random.uniform(0, (grid_size.height - 1))\n            return Point(int(sample_x), int(sample_y))\n\n\n\n\n    def _get_new_vertex(self, nearest_vertex: Vertex, sample_point: Point, max_dist: float) -> Vertex:\n        direction_vector = Point((sample_point.x - nearest_vertex.position.x), (sample_point.y - nearest_vertex.position.y))\n        dist = math.hypot(direction_vector.x, direction_vector.y)\n        if (dist <= max_dist):\n            new_position = sample_point\n        else:\n            scale = (max_dist / dist)\n            new_x = int((nearest_vertex.position.x + (direction_vector.x * scale)))\n            new_y = int((nearest_vertex.position.y + (direction_vector.y * scale)))\n            new_position = Point(new_x, new_y)\n        new_vertex = Vertex(new_position, store_connectivity=True)\n        return new_vertex\n\n\n\n\n    def _extract_and_smooth_path(self, goal_vertex: Vertex) -> None:\n        path = []\n        current_vertex = goal_vertex\n        while current_vertex.parents:\n            path.append(current_vertex.position)\n            current_vertex = next(iter(current_vertex.parents))\n        path.append(current_vertex.position)\n        path.reverse()\n        smoothed_path = [path[0]]\n        idx = 0\n        while (idx < (len(path) - 1)):\n            furthest_reachable_idx = (idx + 1)\n            for j in range((len(path) - 1), idx, (- 1)):\n                line_seq = self._get_grid().get_line_sequence(path[idx], path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    furthest_reachable_idx = j\n                    break\n            smoothed_path.append(path[furthest_reachable_idx])\n            idx = furthest_reachable_idx\n        self._smoothed_path = smoothed_path\n",
          "objective": Infinity,
          "other_inf": null,
          "results": {}
     }
]