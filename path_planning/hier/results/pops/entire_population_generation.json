{
     "algorithm": "This algorithm implements an adaptive RRT*-inspired planner with goal biasing,\n    heuristic-guided sampling, and dynamic step size adjustment. It incorporates rewiring \n    to optimize path cost, uses a heuristic to guide sampling toward the goal to improve \n    efficiency and success rate, and applies shortcut smoothing during path extraction \n    to enhance path quality. Early stopping criteria include time limit and successful \n    connection detection, which improve robustness and reduce planning time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._max_dist_base = 12.0\n        self._iterations = 5000\n        self._goal_bias = 0.15  # probability of sampling the goal directly\n        self._rewire_radius = 20.0\n        self._time_limit = 10.0  # seconds\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        start_time = time.time()\n\n        for iteration in range(self._iterations):\n            current_time = time.time()\n            if current_time - start_time > self._time_limit:  # time limit check\n                break\n\n            # Adaptive sampling with goal bias\n            if self._sample_goal_bias():\n                q_rand = self._get_grid().goal.get_position()\n            else:\n                q_rand = self._get_heuristic_guided_sample()\n\n            q_near = self._graph.get_nearest_vertex(self._graph.root_vertices, q_rand)\n            max_dist = self._adaptive_max_dist(q_near.position, q_rand)\n\n            q_new = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            # Validate motion from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            new_vertex = Vertex(q_new, store_connectivity=True)\n            new_vertex.cost = q_near.cost + self._get_grid().get_movement_cost(q_near.position, q_new)\n\n            # Add new vertex and edge\n            self._graph.add_edge(q_near, new_vertex)\n\n            # Rewire nearby vertices for path improvement\n            neighbors = self._graph.get_vertices_within_radius(self._graph.root_vertices, new_vertex.position, self._rewire_radius)\n            for neighbor in neighbors:\n                if neighbor is new_vertex or neighbor is q_near:\n                    continue\n                line_to_neighbor = self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_to_neighbor):\n                    continue\n\n                new_cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, neighbor.position)\n                if new_cost < neighbor.cost:\n                    # Rewire edge\n                    parent_candidates = list(neighbor.parents)\n                    for p in parent_candidates:\n                        self._graph.remove_edge(p, neighbor)\n                    self._graph.add_edge(new_vertex, neighbor)\n                    neighbor.cost = new_cost\n\n            self.key_frame()\n\n            # Check if goal can be connected directly from new_vertex\n            goal_pos = self._get_grid().goal.get_position()\n            if Map.get_distance(new_vertex.position, goal_pos) <= self._max_dist_base:\n                line_to_goal = self._get_grid().get_line_sequence(new_vertex.position, goal_pos)\n                if self._get_grid().is_valid_line_sequence(line_to_goal):\n                    goal_vertex = self._graph.root_vertex_goal\n                    # Add edge to goal\n                    self._graph.add_edge(new_vertex, goal_vertex)\n                    goal_vertex.cost = new_vertex.cost + self._get_grid().get_movement_cost(new_vertex.position, goal_pos)\n                    self._extract_and_smooth_path()\n                    return\n\n\n\n    def _sample_goal_bias(self) -> bool:\n        return (random.random() < self._goal_bias)\n\n\n\n\n    def _get_heuristic_guided_sample(self) -> Point:\n        '\\n    Generates a sample point biased toward the goal using a heuristic.\\n    The heuristic can leverage the distance to the goal to bias sampling closer to it.\\n    '\n        grid = self._get_grid()\n        goal_pos = grid.goal.get_position()\n        agent_pos = grid.agent.position\n        map_size = grid.size\n        rand_x = random.uniform(0, map_size.width)\n        rand_y = random.uniform(0, map_size.height)\n        rand_point = Point(rand_x, rand_y)\n        alpha = 0.5\n        guided_x = ((alpha * goal_pos.x) + ((1 - alpha) * rand_point.x))\n        guided_y = ((alpha * goal_pos.y) + ((1 - alpha) * rand_point.y))\n        guided_point = Point(guided_x, guided_y)\n        if grid.is_agent_valid_pos(guided_point):\n            return guided_point\n        neighbors = grid.get_next_positions(agent_pos)\n        if neighbors:\n            return random.choice(neighbors)\n        else:\n            return agent_pos\n\n\n\n\n    def _adaptive_max_dist(self, q_near: Point, q_rand: Point) -> float:\n        dist = Map.get_distance(q_near, q_rand)\n        adaptive_factor = min(1.0, (dist / self._max_dist_base))\n        return (self._max_dist_base * adaptive_factor)\n\n\n\n\n    def _get_new_vertex(self, q_near: Point, q_rand: Point, max_dist: float) -> Point:\n        direction = Point((q_rand.x - q_near.x), (q_rand.y - q_near.y))\n        dist = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (dist == 0):\n            return q_near\n        scale = (min(max_dist, dist) / dist)\n        new_x = (q_near.x + (direction.x * scale))\n        new_y = (q_near.y + (direction.y * scale))\n        new_point = Point(new_x, new_y)\n        return new_point\n\n\n\n\n    def _extract_and_smooth_path(self) -> None:\n        path = []\n        current_vertex = self._graph.root_vertex_goal\n        while ((current_vertex is not None) and current_vertex.parents):\n            path.append(current_vertex.position)\n            current_vertex = next(iter(current_vertex.parents), None)\n        if (current_vertex is not None):\n            path.append(current_vertex.position)\n        path.reverse()\n        smoothed_path = []\n        if path:\n            smoothed_path.append(path[0])\n            last_index = 0\n            for i in range(1, len(path)):\n                line_seq = self._get_grid().get_line_sequence(smoothed_path[(- 1)], path[i])\n                if (not self._get_grid().is_valid_line_sequence(line_seq)):\n                    smoothed_path.append(path[(i - 1)])\n                    last_index = (i - 1)\n            smoothed_path.append(path[(- 1)])\n        self._path = smoothed_path\n        self.key_frame()\n",
     "objective": null,
     "other_inf": null
}
