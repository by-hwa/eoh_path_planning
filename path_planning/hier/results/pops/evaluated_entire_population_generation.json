Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0071,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
{
     "algorithm": "Improved path planning algorithm combining RRT* with goal biasing, adaptive step size,\n    and rewiring to improve path quality and success rate.\n\n    Key features:\n    - Goal-biased sampling to guide exploration towards the goal efficiently.\n    - Adaptive max_dist step size based on distance to goal and local obstacles.\n    - Rewiring of the graph to optimize path cost and produce shorter, smoother paths.\n    - Early stopping if solution found or after 10 seconds to limit planning time.\n    - Uses helper functions for modular design: sampling, extending, rewiring, and path extraction.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges\n        self._max_dist_base = 10  # Base max extension distance\n        self._goal_bias_prob = 0.2  # Probability of sampling goal directly\n        self._rewire_radius = 20.0  # Radius for rewiring neighbors\n        self._max_time = 10.0  # Maximum allowed planning time in seconds\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._max_time:\n                # Timeout: fail gracefully\n                break\n\n            # Sampling with goal bias\n            q_sample: Point = self._biased_random_sample()\n\n            # Nearest existing vertex in the tree\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            # Adaptive max_dist based on distance and environment\n            max_dist: float = self._adaptive_max_dist(q_near.position, q_sample)\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Insert q_new into the graph with cost update\n            self._graph.add_edge(q_near, q_new)\n\n            mov_cost = self._get_grid().get_movement_cost(q_near.position, q_new.position)\n            if mov_cost is None:\n                mov_cost = float('inf')\n            q_new.cost = (q_near.cost if q_near.cost is not None else float('inf')) + mov_cost\n\n            # Rewiring step to optimize path locally (RRT*)\n            neighbors: list[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start],\n                                                                            q_new.position,\n                                                                            self._rewire_radius)\n            for q_near_candidate in neighbors:\n                if q_near_candidate == q_near:\n                    continue\n                candidate_line = self._get_grid().get_line_sequence(q_near_candidate.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(candidate_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_near_candidate.position, q_new.position)\n                if mov_cost is None:\n                    continue\n                q_near_cost = q_near_candidate.cost if q_near_candidate.cost is not None else float('inf')\n                cost_through_candidate = q_near_cost + mov_cost\n                if cost_through_candidate < q_new.cost:\n                    # Rewire q_new to q_near_candidate\n                    self._graph.remove_edge(q_near, q_new)\n                    self._graph.add_edge(q_near_candidate, q_new)\n                    q_new.cost = cost_through_candidate\n                    q_near = q_near_candidate\n\n            # Also try rewiring neighbors through q_new for better paths\n            for neighbor in neighbors:\n                if neighbor == q_new:\n                    continue\n                rewiring_line = self._get_grid().get_line_sequence(q_new.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(rewiring_line):\n                    continue\n                mov_cost = self._get_grid().get_movement_cost(q_new.position, neighbor.position)\n                if mov_cost is None:\n                    continue\n                q_new_cost = q_new.cost if q_new.cost is not None else float('inf')\n                cost_through_q_new = q_new_cost + mov_cost\n                neighbor_cost = neighbor.cost if neighbor.cost is not None else float('inf')\n                if cost_through_q_new < neighbor_cost:\n                    # Rewire neighbor parent edges\n                    # Find current parents and remove edges\n                    for parent in list(neighbor.parents):\n                        self._graph.remove_edge(parent, neighbor)\n                    self._graph.add_edge(q_new, neighbor)\n                    neighbor.cost = cost_through_q_new\n\n            # If this new vertex is close enough to goal, attempt connection\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path_with_smoothing(q_new)\n                break\n\n            self.key_frame()\n\n    def _biased_random_sample(self) -> Point:\n        if (random.random() < self._goal_bias_prob):\n            return self._graph.root_vertex_goal.position\n        else:\n            grid_size = self._get_grid().size\n            while True:\n                sample_x = int(round(random.uniform(0, grid_size.width)))\n                sample_y = int(round(random.uniform(0, grid_size.height)))\n                sample = Point(sample_x, sample_y)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adaptive_max_dist(self, q_near_pos: Point, q_sample_pos: Point) -> float:\n        base_dist = self._max_dist_base\n        dist = Map.get_distance(q_near_pos, q_sample_pos)\n        goal_pos = self._graph.root_vertex_goal.position\n        dist_to_goal = Map.get_distance(q_near_pos, goal_pos)\n        if (dist_to_goal < (base_dist * 2)):\n            base_dist *= 0.5\n        obstacle_nearby = False\n        obstacle_safe_dist = base_dist\n        for obs in self._get_grid().obstacles:\n            obs_dist = Map.get_distance(q_near_pos, obs.position)\n            if (obs_dist <= (obstacle_safe_dist + obs.radius)):\n                obstacle_nearby = True\n                break\n        if obstacle_nearby:\n            base_dist *= 0.3\n        max_dist = min(base_dist, dist)\n        if (max_dist < 1e-05):\n            max_dist = 1.0\n        return max_dist\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        length = math.hypot(direction.x, direction.y)\n        if (length <= max_dist):\n            new_pos = q_sample\n        else:\n            scale = (max_dist / length)\n            new_x = q_near.position.x + (direction.x * scale)\n            new_y = q_near.position.y + (direction.y * scale)\n            new_pos = Point(new_x, new_y)\n\n        # Ensure position is integer coordinates before querying the grid\n        int_pos = Point(int(round(new_pos.x)), int(round(new_pos.y)))\n        new_vertex = Vertex(int_pos)\n        new_vertex.cost = float('inf')\n        return new_vertex\n\n    def _extract_path_with_smoothing(self, q_new: Vertex) -> None:\n        path = []\n        current_vertex = q_new\n        while (current_vertex is not None):\n            path.append(current_vertex.position)\n            if (len(current_vertex.parents) == 0):\n                break\n            current_vertex = min(current_vertex.parents, key=(lambda v: v.cost))\n        path.reverse()\n        smoothed_path = [path[0]]\n        i = 0\n        while (i < (len(path) - 1)):\n            j = (len(path) - 1)\n            while (j > (i + 1)):\n                line_seq = self._get_grid().get_line_sequence(path[i], path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    break\n                j -= 1\n            smoothed_path.append(path[j])\n            i = j\n        for point in smoothed_path:\n            self.move_agent(point)\n            self.key_frame()",
     "objective": 7941.59,
     "other_inf": null,
     "results": {
          "goal_found_perc": 96.67,
          "average_steps": 9.5,
          "average_distance": 10.11,
          "average_smoothness": 0.32,
          "average_clearance": 2.02,
          "average_time": 0.3711,
          "average_distance_from_goal": 0.25,
          "average_original_distance_from_goal": 8.42,
          "average memory": 66.88,
          "goal_found_perc_improvement": -0.68,
          "average_steps_improvement": -4.17,
          "average_distance_improvement": -4.98,
          "average_smoothness_improvement": -23.08,
          "average_clearance_improvement": 0.5,
          "average_time_improvement": -5126.76,
          "average_distance_from_goal_improvement": -25.0,
          "average_path_deviation": 0.47999999999999865,
          "average_memory_improvement": -79.69
     }
}
{
     "algorithm": "PathPlanning: An improved sample-based path planning algorithm inspired by RRT* with goal biasing, adaptive step size,\n    and rewiring for path optimization. The algorithm biases samples towards the goal to increase efficiency, adapts\n    the maximum extension distance to environment scale, and performs local rewiring to reduce path cost and improve \n    path smoothness. It includes shortcut path smoothing after a path is found and enforces a maximum runtime of 10 seconds \n    for robustness. This approach balances exploration and exploitation to achieve better success rates, faster planning, \n    and higher quality paths with fewer failures in cluttered environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize the sample-based graph with start and goal vertices\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0.0  # Initialize start vertex cost\n        self._graph = gen_forest(self._services, start_vertex, Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable removability for rewiring\n        # Adaptive max extension distance based on environment diagonal\n        self._max_dist = max(5, int(math.sqrt(self._get_grid().size.width ** 2 + self._get_grid().size.height ** 2) / 20))\n        self._goal_bias = 0.15  # Bias towards goal sampling probability\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 8000\n\n        goal_position: Point = self._get_grid().goal.position\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 10:  # Fail if planning takes too long\n                break\n\n            # Goal-biased random sampling\n            if random.random() < self._goal_bias:\n                q_sample = goal_position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                self.key_frame()\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Add q_new as vertex in graph\n            self._graph.add_edge(q_near, q_new)\n\n            # Rewire: find nearby vertices and try to update parent if better path found\n            radius = self._max_dist * 2\n            near_vertices = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n            for q_nearby in near_vertices:\n                if q_nearby == q_near:\n                    continue\n                new_line_seq = self._get_grid().get_line_sequence(q_new.position, q_nearby.position)\n                if self._get_grid().is_valid_line_sequence(new_line_seq):\n                    cost_through_new = q_new.cost + self._get_grid().get_distance(q_new.position, q_nearby.position)\n                    if cost_through_new < q_nearby.cost:\n                        # Remove old edge and add new edge for rewiring\n                        for parent_vertex in list(q_nearby.parents):\n                            self._graph.remove_edge(parent_vertex, q_nearby)\n                        self._graph.add_edge(q_new, q_nearby)\n                        q_nearby.cost = cost_through_new\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex and update cost\n                goal_vertex = Vertex(goal_position)\n                goal_vertex.cost = q_new.cost + self._get_grid().get_distance(q_new.position, goal_position)\n                self._graph.add_edge(q_new, goal_vertex)\n\n                # Extract and shortcut path\n                self._extract_path(q_new)\n\n                # Optional post-processing for smoothing path (call helper)\n                self._shortcut_path()\n\n                break\n\n            self.key_frame()\n\n    def _get_random_sample(self) -> Point:\n        width = self._get_grid().size.width\n        height = self._get_grid().size.height\n        while True:\n            x = random.randint(0, (width - 1))\n            y = random.randint(0, (height - 1))\n            sample_point = Point(x, y)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        direction = Point((q_sample.x - q_near.position.x), (q_sample.y - q_near.position.y))\n        dist = math.sqrt(((direction.x ** 2) + (direction.y ** 2)))\n        if (dist <= max_dist):\n            new_position = q_sample\n        else:\n            scale = (max_dist / dist)\n            new_x = int(round((q_near.position.x + (direction.x * scale))))\n            new_y = int(round((q_near.position.y + (direction.y * scale))))\n            new_position = Point(new_x, new_y)\n        new_vertex = Vertex(new_position)\n        # Initialize cost for q_near if None\n        if q_near.cost is None:\n            q_near.cost = 0.0\n        new_vertex.cost = (q_near.cost + self._get_grid().get_distance(q_near.position, new_position))\n        return new_vertex\n\n    def _extract_path(self, last_vertex: Vertex) -> None:\n        path = []\n        current = last_vertex\n        while (current is not None):\n            path.append(current.position)\n            if current.parents:\n                current = min(current.parents, key=(lambda p: p.cost))\n            else:\n                current = None\n        path.reverse()\n        self._path = path\n        for point in path:\n            self.move_agent(point)\n            self.key_frame()\n\n    def _shortcut_path(self) -> None:\n        if ((not hasattr(self, '_path')) or (not self._path) or (len(self._path) < 3)):\n            return\n        shortened_path = [self._path[0]]\n        current_index = 0\n        while (current_index < (len(self._path) - 1)):\n            next_index = (len(self._path) - 1)\n            for j in range((len(self._path) - 1), current_index, (- 1)):\n                line_seq = self._get_grid().get_line_sequence(self._path[current_index], self._path[j])\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    next_index = j\n                    break\n            shortened_path.append(self._path[next_index])\n            current_index = next_index\n        self._path = shortened_path\n        for point in self._path:\n            self.move_agent(point)\n            self.key_frame()",
     "objective": 3067.32,
     "other_inf": null,
     "results": {
          "goal_found_perc": 95.33,
          "average_steps": 21.66,
          "average_distance": 22.99,
          "average_smoothness": 0.47,
          "average_clearance": 2.13,
          "average_time": 0.1316,
          "average_distance_from_goal": 0.31,
          "average_original_distance_from_goal": 8.42,
          "average memory": 55.27,
          "goal_found_perc_improvement": -2.05,
          "average_steps_improvement": -139.87,
          "average_distance_improvement": -141.24,
          "average_smoothness_improvement": -80.77,
          "average_clearance_improvement": 5.45,
          "average_time_improvement": -1753.52,
          "average_distance_from_goal_improvement": -55.0,
          "average_path_deviation": 13.459999999999999,
          "average_memory_improvement": -48.5
     }
}
Astar{
     "goal_found_perc": 97.33,
     "average_steps": 9.14,
     "average_distance": 9.66,
     "average_smoothness": 0.26,
     "average_clearance": 2.0,
     "average_time": 0.0074,
     "average_distance_from_goal": 0.2,
     "average_original_distance_from_goal": 8.42,
     "average memory": 37.22
}
