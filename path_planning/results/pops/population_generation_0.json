[
     {
          "algorithm": "This is the A* algorithm, a classic pathfinding algorithm that uses heuristics to find the shortest path from the agent to the goal.",
          "code": "\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nfrom typing import Set, List, Tuple, Optional, Dict\n\nimport numpy as np\n\n\nfrom algorithms.algorithm import Algorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.gradient_list_map_display import GradientListMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point, Colour, BLUE, DynamicColour\nfrom structures.factory import gen_set, gen_heap\nfrom structures.heap import Heap\n\nfrom memory_profiler import profile\n\nclass AStar(Algorithm):\n    class InternalMemory:\n        priority_queue: Heap\n        visited: Set[Point]\n        back_pointer: Dict[Point, Optional[Point]]\n        g: Dict[Point, int]\n        h: Dict[Point, float]\n\n        def __init__(self, services: Services):\n            self.priority_queue = gen_heap(services)\n            self.visited = gen_set(services)\n            self.back_pointer = {}\n            self.g = {}\n            self.h = {}\n\n    mem: InternalMemory\n\n    pq_colour_max: DynamicColour\n    pq_colour_min: DynamicColour\n    visited_colour: DynamicColour\n\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        self.mem = AStar.InternalMemory(self._services)\n\n        self.pq_colour_max = self._services.state.views.add_colour(\"explored max\", BLUE)\n        self.pq_colour_min = self._services.state.views.add_colour(\"explored min\", Colour(0.27, 0.33, 0.35, 0.2))\n        self.visited_colour = self._services.state.views.add_colour(\"visited\", Colour(0.19, 0.19, 0.2, 0.8))\n\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self.mem.visited, self.visited_colour, z_index=50),\n                               GradientListMapDisplay(self._services, self.mem.priority_queue, min_colour=self.pq_colour_min,\n                                                  max_colour=self.pq_colour_max, z_index=49, inverted=True)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Read super description\n        \"\"\"\n        return super().set_display_info() + self.__map_displays\n\n    # noinspection PyUnusedLocal\n    # @profile\n    def _find_path_internal(self) -> None:\n        self._init_mem()\n\n        if self._expand():\n            self._follow_back_trace()\n\n    def _init_mem(self) -> None:\n        grid: Map = self._get_grid()\n\n        # push agent\n        self.mem.g[grid.agent.position] = 0\n        item: Tuple[float, Point] = (self.get_heuristic(grid.agent.position), grid.agent.position)\n        self.mem.priority_queue.push(item)\n        self.mem.back_pointer[grid.agent.position] = None\n\n    def _expand(self) -> bool:\n        grid: Map = self._get_grid()\n\n        while len(self.mem.priority_queue) > 0:\n            total_dist: float\n            next_node: Point\n            # peek and check if we need to terminate\n            total_dist, next_node = self.mem.priority_queue.pop()\n\n            if grid.is_goal_reached(next_node):\n                self.mem.priority_queue.push((total_dist, next_node))\n                return True\n\n            self.mem.visited.add(next_node)\n\n            for n, idx in grid.get_next_positions_with_move_index(next_node):\n                if n not in self.mem.visited:\n                    dist = grid.get_movement_cost_from_index(idx, n)\n                    if n not in self.mem.g or self.mem.g[next_node] + dist < self.mem.g[n]:\n                        # it does not matter if we have duplicates as we will not be looking at them\n                        # therefore it does not affect the priority\n                        self.mem.g[n] = self.mem.g[next_node] + dist\n                        item = (self.f(n), n)\n                        self.mem.priority_queue.push(item)\n                        self.mem.back_pointer[n] = next_node\n\n            self.key_frame()\n        return False\n\n    def f(self, x: Point) -> float:\n        g = self.mem.g[x]\n        h = self.get_heuristic(x)\n        ret = g + h\n        return ret\n\n    def _follow_back_trace(self):\n        grid: Map = self._get_grid()\n        \n        trace: List[Point] = self.get_back_trace(grid.goal)\n        trace.reverse()\n        for t in trace:\n            self.move_agent(t)\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def get_back_trace(self, goal: Goal) -> List[Point]:\n        \"\"\"\n        Follows the back pointer until it gets to the agent position\n        :return: The trace\n        \"\"\"\n        trace = []\n        pos = goal.position\n        while self.mem.back_pointer[pos] is not None:\n            trace.append(pos)\n            pos = self.mem.back_pointer[pos]\n        return trace\n\n    def get_heuristic(self, pos: Point) -> float:\n        \"\"\"\n        Returns the euclidean distance from the given position to the goal\n        It does memoization as well\n        :param goal: The goal\n        :param pos: The initial position\n        :return:\n        \"\"\"\n        self.mem.h.setdefault(pos, np.linalg.norm(np.array(pos) - np.array(self._get_grid().goal.position)))\n        return self.mem.h[pos]\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the RRT algorithm, a sample-based pathfinding algorithm that explores the space by randomly sampling points and connecting them to the nearest vertex.",
          "code": "\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nfrom simulator.services.services import Services\n\nfrom structures import Point\n\n\nclass RRT(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)    #connect the last sampled point that's close to goal vertex and connet point to goal vertex with edge\n        path: List[Vertex] = [goal_v]    \n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        #get animation of path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)   \n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()     #sample a random point and return it if it's in valid position\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample) \n            if q_near.position == q_sample:\n                continue    #restart the while loop right away if sample point same as nearest vertex point\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)    #get new vertex\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):    \n                continue    #restart the while loop right away if the straight line path from nearest vertex to new sample point is invalid \n            self._graph.add_edge(q_near, q_new)    #add edge between 2 points\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):    #if agent is in goal radius, then run _extract_path method \n                self._extract_path(q_new)\n                break\n\n            self.key_frame()    #add the new vertex and edge if the new sample point is not at goal yet\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the SPRM algorithm, a sample-based pathfinding algorithm that uses a cyclic graph to find a path from the agent to the goal.",
          "code": "\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\nfrom typing import List\n\nimport torch\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\n\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_cyclic_graph, CyclicGraph\n\n\nclass SPRM(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self):\n\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        for i, v in enumerate(self._graph.root_vertices):\n            U = self._near(v)\n            for u in U:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(u.position, v.position)):\n                    if v is not u:\n                        self._graph.add_edge(v, u)\n                        self._graph.add_edge(u, v)\n                    self.key_frame()\n                    if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n                        self._extract_path()\n                        return\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the RRT* algorithm, an optimized version of RRT that finds the shortest path by rewiring the tree as it grows.",
          "code": "\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\nfrom algorithms.configuration.maps.ros_map import RosMap\nfrom algorithms.configuration.maps.map import Map\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\n\nclass RRT_Star(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    # Helper Functions #\n    # -----------------#\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self, q_new):\n\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            #sends waypoint for ros extension\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        for i in range(iterations):\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)),max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    q_near.cost = None\n                    self._graph.remove_edge(q_parent, q_near)\n                    child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    q_near.cost = q_new.cost + child_parent_dist\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n",
          "objective": 0,
          "other_inf": null
     },
     {
          "algorithm": "This is the RRT-Connect algorithm, a sample-based pathfinding algorithm that connects two trees to find a path.",
          "code": "\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\nfrom typing import List\n\nimport torch\nimport numpy as np\n\nfrom memory_profiler import profile\n\nfrom algorithms.classic.sample_based.core.sample_based_algorithm import SampleBasedAlgorithm\nfrom algorithms.basic_testing import BasicTesting\nfrom simulator.services.services import Services\nfrom structures import Point\n\nfrom algorithms.classic.sample_based.core.vertex import Vertex\nfrom algorithms.classic.sample_based.core.graph import gen_forest, Forest\n\nn=0\n\nclass RRT_Connect(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n\n    # Helper Functions #\n    # -----------------#\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self):\n\n        # trace back\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    # Overridden Implementation #\n    # --------------------------#\n\n    #@profile\n    def _find_path_internal(self) -> None:\n\n        for i in range(self._iterations):\n            global n \n            n+=1\n\n            if n == 100:\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            # visualization code\n            self.key_frame()\n",
          "objective": 0,
          "other_inf": null
     }
]