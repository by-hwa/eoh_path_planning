{
     "algorithm": "\"\"\"\n    This algorithm implements an improved Rapidly-exploring Random Tree (RRT*) path planner,\n    which extends the original RRT by optimizing the paths found through rewiring nearby vertices.\n    It ensures asymptotic optimality and generally finds better solutions faster than standard RRT.\n    The approach samples random points, extends the tree towards them with a max step distance,\n    and rewires the tree locally by checking for shorter paths.\n    The search is bounded by a maximum execution time of 30 seconds to prevent infinite runtime.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable edge removal for rewiring optimization\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Find vertices in the graph within radius of q_new\n        near_vertices: List[Vertex] = []\n        all_vertices = self._graph.get_all_vertices()\n        for vertex in all_vertices:\n            if (vertex.position.to_tensor() - q_new.position.to_tensor()).norm() <= radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        # Cost heuristic: Euclidean distance if path is valid, else large number\n        dist = norm(from_v.position.to_tensor() - to_v.position.to_tensor()).item()\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(from_v.position, to_v.position)):\n            return float(\"inf\")\n        return dist\n\n    def _get_min_cost_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Among near vertices, select the one that yields minimum cost path to q_new and with valid connection\n        min_cost = float(\"inf\")\n        min_parent: Optional[Vertex] = None\n        for vertex in near_vertices:\n            candidate_cost = vertex.cost + self._cost(vertex, q_new)\n            if candidate_cost < min_cost:\n                min_cost = candidate_cost\n                min_parent = vertex\n        return min_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex, radius: float) -> None:\n        # Try to rewire neighbors through q_new if it improves their cost and path is valid\n        for vertex in near_vertices:\n            if vertex == q_new.parents[0]:\n                continue  # Skip actual parent vertex\n            cost_through_q_new = q_new.cost + self._cost(q_new, vertex)\n            if cost_through_q_new < vertex.cost:\n                # Check if path is valid before rewiring\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                    self._graph.remove_edge(vertex.parents[0], vertex)  # Remove old edge\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = cost_through_q_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = []\n        current = q_goal\n\n        # Trace back to start\n        while current is not None:\n            path.append(current)\n            if len(current.parents) > 0:\n                current = current.parents[0]\n            else:\n                break\n\n        path.reverse()\n\n        # Move the agent along the extracted path with animation key frames\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_time_seconds: float = 30.0\n        n_dim: int = self._get_grid().size.n_dim\n\n        iterations: int = 1000000  # Large number but will be bounded by time\n        start_time = time()\n\n        root_vertex: Vertex = self._graph.root_vertex_start\n        root_vertex.cost = 0.0  # cost to reach root is zero\n\n        for i in range(iterations):\n\n            elapsed_time = time() - start_time\n            if elapsed_time > max_time_seconds:\n                # Timeout: stop search and consider path not found.\n                break\n\n            # Goal biasing: with some probability sample the goal to speed convergence\n            if np.random.rand() < 0.1:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get nearby vertices for rewiring within radius\n            radius = min(50.0, max_dist * 5)  # Adaptive radius\n\n            near_vertices = self._get_near_vertices(q_new, radius)\n\n            # Choose the best parent among near vertices\n            min_parent = self._get_min_cost_parent(near_vertices, q_new)\n            if min_parent is None:\n                min_parent = q_near\n\n            # Add edge and update cost\n            self._graph.add_edge(min_parent, q_new)\n            q_new.cost = min_parent.cost + self._cost(min_parent, q_new)\n\n            # Rewire neighbors for optimization\n            self._rewire(near_vertices, q_new, radius)\n\n            # Check if goal reached (within goal radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex connected to q_new\n                goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThe algorithm implemented here is an improved sample-based planner inspired by RRT*.\nIt incorporates adaptive maximum extension distance and uses informed sampling to focus exploration towards\nthe goal after an initial solution is found, thus improving convergence speed.\nFurthermore, it enforces a 30-second maximum runtime to prevent excessive planning time.\nIt reuses the RRT* rewiring and path extraction logic but focuses sampling within an ellipsoidal region\nbetween start and goal to accelerate path finding.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member to track if initial solution found\n        self._solution_found: bool = False\n        # To store best cost found so far (initialized large)\n        self._best_cost: float = float('inf')\n        # Cache start and goal vertex for convenience\n        self._start_vertex: Vertex = self._graph.root_vertex_start\n        self._goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex.cost = float('inf')\n        # Prepare display info container\n        self._init_displays()\n    \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n    \n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n    \n    def _informed_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample within prolate hyperspheroid defined by start, goal, and current best cost.\n        If no solution yet (c_best == inf), sample uniformly.\n        \"\"\"\n        if c_best == float('inf'):\n            return self._get_random_sample()\n\n        # Compute center and coordinate transforms for ellipsoid sampling\n        start_np = np.array(start)\n        goal_np = np.array(goal)\n        c_min = float(c_min)\n        c_best = float(c_best)\n\n        center = (start_np + goal_np) / 2\n\n        # Unit vector along start to goal\n        direction = (goal_np - start_np)\n        norm_dir = np.linalg.norm(direction)\n        if norm_dir == 0:\n            return Point(*goal_np)\n\n        e1 = direction / norm_dir\n        # Create orthonormal basis using SVD or Gram-Schmidt for 2D\n        # In 2D, the orthonormal is just perpendicular vector\n        if e1.size == 2:\n            e2 = np.array([-e1[1], e1[0]])\n            basis = np.vstack((e1, e2)).T  # Columns are basis vectors\n        else:\n            # fallback to identity (should be 2D anyway)\n            basis = np.eye(len(e1))\n\n        # Radii of the ellipsoid along each axis\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n        # Sample random point inside unit ball in 2D\n        while True:\n            sample_unit = np.random.randn(2)\n            sample_unit /= np.linalg.norm(sample_unit)\n            if np.random.rand() <= 1.0:\n                break\n        # Uniform scale for 2D unit circle\n        scale = np.random.rand() ** 0.5\n        sample_ball = sample_unit * scale\n\n        # Stretch and rotate sample to ellipsoid\n        sample_ellipsoid = np.array([r1 * sample_ball[0], r2 * sample_ball[1]])\n        sample_world = center + basis @ sample_ellipsoid\n\n        # Clip to grid and make sure it is valid\n        sample_point = Point(*np.clip(sample_world, 0, self._get_grid().size.n_dim - 1).astype(int))\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback uniform sample if invalid\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Similar to RRT* extract path but moves agent with key frames\n        \"\"\"\n        path: List[Vertex] = []\n        current = q_new\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Pick first parent (RRT* is tree)\n            current = next(iter(current.parents), None)\n        path.reverse()\n\n        for v in path:\n            self.move_agent(v.position)\n            grid = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def _find_path_internal(self) -> None:\n\n        max_dist_init: float = 10.0\n        max_dist_min: float = 3.0\n        max_dist_decay: float = 0.9995  # decay max_dist slowly over iterations to more refined local exploration\n\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        c_min = self._heuristic_distance(self._start_vertex.position, self._goal_vertex.position)\n        c_best = float('inf')\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout reached, stop searching and treat as no path found\n                break\n\n            # Use informed sampling once a solution is found, else uniform random sampling\n            if self._solution_found:\n                q_sample = self._informed_sample(c_best, c_min, self._start_vertex.position, self._goal_vertex.position)\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max extension distance shrinking with iterations\n            max_dist = max(max_dist_min, max_dist_init * (max_dist_decay ** i))\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + self._heuristic_distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_candidate = q_near.cost + self._heuristic_distance(q_near.position, q_new.position)\n                    if cost_candidate < c_min_cost:\n                        q_min = q_near\n                        c_min_cost = cost_candidate\n\n            dist_parent_child = self._heuristic_distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + dist_parent_child\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_through_new = q_new.cost + self._heuristic_distance(q_new.position, q_near.position)\n                    if cost_through_new < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex is in goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update solution found status\n                cost_to_goal = q_new.cost + self._heuristic_distance(q_new.position, self._goal_vertex.position)\n                if cost_to_goal < c_best:\n                    c_best = cost_to_goal\n                    self._solution_found = True\n                    self._extract_path(q_new)\n                    # Break after first found path improves the solution\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm based on RRT with goal biasing and early stopping.\n    This implementation enhances the original RRT approach by:\n    - Introducing goal biasing: with a given probability, the sample is the goal, \n      which guides the tree growth faster towards the goal.\n    - Using a timer to enforce a max allowed planning time of 30 seconds to avoid long runs.\n    - Early stopping when the path to goal is found.\n    - Reusing existing helper functions and structure from the base RRT algorithm.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT-Connect with goal biasing and adaptive max extension distance for faster convergence.\n    This algorithm enhances the standard RRT-Connect by introducing:\n    - Goal biasing: samples the goal position with a fixed probability to direct growth towards the target.\n    - Adaptive step size: dynamically adjusts the maximum extension distance based on the distance to the goal,\n      allowing longer steps in open space and finer steps near obstacles or goal.\n    \n    Additionally, the algorithm terminates the search if it takes longer than 30 seconds to find a path.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.15  # 15% chance to sample goal directly\n        self._min_max_dist = 5\n        self._max_max_dist = 15\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        With probability self._goal_bias, return the goal point to bias tree growth toward the goal.\n        Otherwise, sample uniformly inside valid grid positions.\n        \"\"\"\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _adaptive_max_dist(self, from_point: Point) -> float:\n        \"\"\"\n        Adapt the max_dist based on distance to goal, capped between min and max.\n        Longer steps when far, shorter steps near goal.\n        \"\"\"\n        dist_to_goal = torch.norm(from_point.to_tensor() - self._get_grid().goal.position.to_tensor()).item()\n        # Map distance to [min_max_dist, max_max_dist] linearly, e.g. max max_dist at distances >= 50\n        max_allowed_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * min(dist_to_goal/50.0, 1.0)\n        return max_allowed_step\n\n    def _extend_with_adaptive_dist(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adaptive_dist = self._adaptive_max_dist(self._q_near.position)\n        self._q_new = self._get_new_vertex(self._q_near, q, adaptive_dist)\n        line_seq = self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend_with_adaptive_dist(root_vertex, q.position)\n            if S == 'reached':\n                break\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back mid to b\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = next(iter(path_mid_to_b[-1].parents))\n            path_mid_to_b.append(parent)\n\n        # trace a to mid\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = next(iter(path_a_to_mid[-1].parents))\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            # Check timeout\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30:\n                # Timeout reached, no path found\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_result = self._extend_with_adaptive_dist(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an improved, time-optimized variant inspired by the original RRT* approach.\n    The improvement is mainly achieved by incorporating informed sampling once an initial feasible path is found.\n    Informed RRT* (or Informed Sampling RRT*) restricts the sampling space to the ellipsoidal region that can possibly\n    improve the current best path, reducing unnecessary exploration outside that region, thus improving convergence speed.\n\n    Key improvements:\n    - After finding the first path to the goal, the sampler biases samples within an ellipsoidal subset\n      of the state space defined by the start, goal, and current best path cost, drastically pruning sampling.\n    - Time cutoff of 30 seconds is added to stop search and declare failure if no path is found before timeout.\n    - Retains rewiring and radius-based neighborhood search from RRT* for path cost optimization.\n\n    This algorithm reuses helper functions from the base class and integrates with the existing framework components.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._best_path_cost = float('inf')\n        self._best_goal_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _ellipsoidal_sample(self, start: Point, goal: Point, c_max: float) -> Point:\n        \"\"\"\n        Sample inside the prolate hyperspheroid (ellipsoid) with foci at start and goal, max cost c_max.\n        This improves convergence after first solution is found.\n        Falls back to uniform random if no informed region.\n        \"\"\"\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        start_np = start.to_tensor().numpy()\n        goal_np = goal.to_tensor().numpy()\n        foci_dist = np.linalg.norm(start_np - goal_np)\n\n        if foci_dist == 0 or c_max < foci_dist:\n            return self._get_random_sample()\n\n        # Compute the lengths of the ellipsoid axes\n        a1 = c_max / 2.0  # major axis half-length\n        minor_axis_len = math.sqrt(max(c_max ** 2 - foci_dist ** 2, 0)) / 2.0  # minor axis half-length(s)\n\n        # Sample random point in unit ball in dimension 2\n        while True:\n            # Uniform sampling within unit ball (2D)\n            theta = np.random.uniform(0, 2 * math.pi)\n            r = np.sqrt(np.random.uniform(0, 1))\n            x_ball = r * math.cos(theta)\n            y_ball = r * math.sin(theta)\n            # Scale to ellipsoid axes\n            sample_local = np.array([a1 * x_ball, minor_axis_len * y_ball])\n\n            # Find rotation matrix to align x-axis with vector from start to goal\n            direction = goal_np - start_np\n            norm_dir = np.linalg.norm(direction)\n            if norm_dir == 0:\n                # degenerate case fallback\n                return self._get_random_sample()\n            e1 = direction / norm_dir  # major axis unit vector\n            # 2D rotation matrix to rotate x-axis to e1\n            cos_angle = e1[0]\n            sin_angle = e1[1]\n            rot_mat = np.array([[cos_angle, -sin_angle], [sin_angle, cos_angle]])\n\n            sample_world = (rot_mat @ sample_local) + (start_np + goal_np) / 2.0\n\n            sample_point = Point(*sample_world.astype(int))\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        \"\"\"\n        Same as in RRT*, extract path from q_new to goal and move agent accordingly.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        start_position = self._get_grid().agent.position\n        goal_position = self._get_grid().goal.position\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout: treat as route not found and end\n                break\n\n            # Informed sampling after first solution found\n            if self._best_path_cost < float('inf'):\n                q_sample: Point = self._ellipsoidal_sample(start_position, goal_position, self._best_path_cost)\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: 'Vertex' = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: 'Vertex' = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision along edge\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                )\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex in goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Keep only better path\n                if q_new.cost < self._best_path_cost:\n                    self._best_path_cost = q_new.cost\n                    self._best_goal_vertex = q_new\n                    self._extract_path(q_new)\n                    # Continue searching for better solutions within time limit\n                    # (Can comment below break for full anytime behavior)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT, known as RRT-Connect. \n    Instead of growing a single tree from the start state randomly, it grows two trees:\n    one from the start and one from the goal, alternating their expansion.\n    Each iteration tries to extend one tree towards a random sample, then attempts to connect\n    the other tree to the newly extended vertex, potentially producing a faster path solution.\n    This bidirectional approach generally improves time efficiency in path planning \n    especially in complex spaces. Additionally, the search will abandon if it exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph_start = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph_start.edges_removable = False\n        \n        self._graph_goal = gen_forest(self._services, Vertex(self._get_grid().goal.position), Vertex(self._get_grid().agent.position), [])\n        self._graph_goal.edges_removable = False\n        \n        self.__map_displays = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Display both trees\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start), GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_extend(self, tree: Forest, q_target: Point, max_dist: float) -> Vertex:\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return q_near\n        \n        q_new: Vertex = self._get_new_vertex(q_near, q_target, max_dist)\n        \n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        tree.add_edge(q_near, q_new)\n        return q_new\n\n    def _extract_path(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Connects the path from root start to connect_vertex_start and from root goal to connect_vertex_goal,\n        then moves agent along path.\n        \"\"\"\n        # Build path from start tree\n        path_start: List[Vertex] = [connect_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Build path from goal tree\n        path_goal: List[Vertex] = [connect_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        full_path = path_start + path_goal  # connect paths (goal path is from connection vertex towards goal)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_time_seconds: float = 30.0\n\n        start_time = time()\n\n        # For alternating tree expansion: True => extend start tree first, False => goal tree first\n        extend_start_tree_next = True\n\n        for _ in range(100000):  # Large iteration count but constrained by max_time_seconds\n            # Check timeout\n            if time() - start_time > max_time_seconds:\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            if extend_start_tree_next:\n                q_new_start = self._try_extend(self._graph_start, q_sample, max_dist)\n                if q_new_start is None:\n                    extend_start_tree_next = not extend_start_tree_next\n                    self.key_frame()\n                    continue\n\n                q_new_goal = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n                if q_new_goal is not None:\n                    # Check connection line\n                    line_seq = self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # Connect edges between two trees\n                        self._graph_start.add_edge(q_new_start, q_new_goal)\n                        self._graph_goal.add_edge(q_new_goal, q_new_start)\n                        self._extract_path(q_new_start, q_new_goal)\n                        break\n            else:\n                q_new_goal = self._try_extend(self._graph_goal, q_sample, max_dist)\n                if q_new_goal is None:\n                    extend_start_tree_next = not extend_start_tree_next\n                    self.key_frame()\n                    continue\n\n                q_new_start = self._try_extend(self._graph_start, q_new_goal.position, max_dist)\n                if q_new_start is not None:\n                    line_seq = self._get_grid().get_line_sequence(q_new_goal.position, q_new_start.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        self._graph_goal.add_edge(q_new_goal, q_new_start)\n                        self._graph_start.add_edge(q_new_start, q_new_goal)\n                        self._extract_path(q_new_start, q_new_goal)\n                        break\n\n            extend_start_tree_next = not extend_start_tree_next\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved sampling-based path planner inspired by RRT* (Rapidly-exploring Random Tree Star).\n    Instead of classic A*, it incrementally builds a tree of collision-free configurations by sampling random points,\n    attempting to connect to the nearest existing vertex, and rewiring the tree to ensure near-optimal paths.\n    This approach is especially useful in high-dimensional or complex spaces where heuristic-guided grid search is intractable.\n    The algorithm terminates when it finds a path to the goal or after 30 seconds, whichever comes first.\n    Key improvements over grid-based A*: better efficiency in large continuous spaces, anytime improvement of the path,\n    and avoidance of exhaustive grid expansion.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # We will keep a graph structure as self._graph (inherited from SampleBasedAlgorithm assumed)\n        # Maintain sets for vertices and edges if needed, else rely on self._graph API\n        # Colors for displaying the tree and final path\n        self._tree_colour = self._services.state.views.add_colour(\"tree edges\", Colour(0.0, 0.7, 0.3, 0.5))\n        self._path_colour = self._services.state.views.add_colour(\"final path\", Colour(0.7, 0.1, 0.1, 1.0))\n        self._visited_vertices = gen_set(services)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        base_displays = super().set_display_info()\n        # Shows tree vertices\n        vertices_display = SolidIterableMapDisplay(self._services, self._visited_vertices, self._tree_colour, z_index=45)\n        return base_displays + [vertices_display]\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        # Initialize graph with start vertex\n        self._graph.clear()\n        start_vertex = self._graph.add_vertex(start_pos)\n        start_vertex.cost = 0.0\n        self._visited_vertices.add(start_pos)\n\n        max_iter = 10000  # upper bound on iterations to avoid infinite loops in pathological maps\n\n        goal_vertex: Optional = None\n\n        def dist(a: Point, b: Point) -> float:\n            return ((a[0]-b[0])**2 + (a[1]-b[1])**2) ** 0.5\n\n        def sample_free() -> Point:\n            # Sample random free point in the environment\n            attempts = 0\n            while True:\n                pos = self._graph.get_random_sample()\n                if not grid.is_occupied(pos):\n                    return pos\n                attempts += 1\n                # Prevent infinite loops\n                if attempts > 1000:\n                    return start_pos\n\n        def nearest_vertex(p: Point):\n            # Find vertex in the graph nearest to p\n            min_d = float('inf')\n            nearest = None\n            for v in self._graph.vertices():\n                d = dist(v.position, p)\n                if d < min_d:\n                    min_d = d\n                    nearest = v\n            return nearest\n\n        def steer(from_pos: Point, to_pos: Point, max_dist=1.0) -> Point:\n            # Returns a point towards to_pos from from_pos but no further than max_dist\n            vector = (to_pos[0]-from_pos[0], to_pos[1]-from_pos[1])\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            new_p = (from_pos[0] + vector[0]*scale, from_pos[1] + vector[1]*scale)\n            # Round to nearest grid point because we are on grid map\n            new_p_rounded = Point(round(new_p[0]), round(new_p[1]))\n            return new_p_rounded\n\n        def collision_free(p1: Point, p2: Point) -> bool:\n            # Check if path from p1 to p2 is free of obstacles\n            return grid.is_path_free(p1, p2)\n\n        def near_vertices(p: Point, radius=3.0):\n            # Return vertices within a radius of p\n            result = []\n            for v in self._graph.vertices():\n                if dist(v.position, p) <= radius:\n                    result.append(v)\n            return result\n\n        for i in range(max_iter):\n            if (time() - start_time) > 30.0:\n                # Timeout: stop searching\n                break\n\n            rand_sample = sample_free()\n            nearest = nearest_vertex(rand_sample)\n            new_pos = steer(nearest.position, rand_sample, max_dist=3.0)\n\n            if new_pos == nearest.position:\n                # No progress possible\n                continue\n\n            if not collision_free(nearest.position, new_pos):\n                continue\n\n            # Add new vertex and edge to graph\n            new_vertex = self._graph.add_vertex(new_pos)\n            # Cost to reach new_vertex via nearest\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_vertex.cost = new_cost\n            self._graph.add_edge(nearest, new_vertex)\n            self._visited_vertices.add(new_pos)\n\n            # Rewire nearby vertices if going through new_vertex is cheaper\n            neighbors = near_vertices(new_pos, radius=5.0)\n            for neighbor in neighbors:\n                if neighbor == nearest or neighbor == new_vertex:\n                    continue\n                if collision_free(new_vertex.position, neighbor.position):\n                    cost_through_new = new_vertex.cost + dist(new_vertex.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        # Rewire edge from neighbor's old parent to new_vertex\n                        old_parent = neighbor.parent\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.cost = cost_through_new\n\n            # Check if new_vertex is close enough to goal to attempt connection\n            if dist(new_vertex.position, goal_pos) <= 3.0:\n                if collision_free(new_vertex.position, goal_pos):\n                    goal_vertex = self._graph.add_vertex(goal_pos)\n                    goal_vertex.cost = new_vertex.cost + dist(new_vertex.position, goal_pos)\n                    self._graph.add_edge(new_vertex, goal_vertex)\n                    self._visited_vertices.add(goal_pos)\n                    break\n\n            self.key_frame()\n\n        # If path found, follow backtrace\n        if goal_vertex is not None:\n            path_positions = []\n            v = goal_vertex\n            while v is not None:\n                path_positions.append(v.position)\n                v = v.parent\n            path_positions.reverse()\n\n            for pos in path_positions:\n                self.move_agent(pos)\n                self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm is an improved sampling-based planner inspired by RRT*,\nenhanced by incorporating a heuristic bias towards the goal and informed sampling\nto accelerate convergence. We sample points either randomly or biased near the goal\nwith a defined probability to focus exploration, improving time efficiency.\nAlso, the rewiring radius adapts dynamically with the number of vertices for better optimization.\nA 30-second timeout exits the search if no path is found.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional members for informed sampling and timing\n        self._goal_bias_probability: float = 0.2  # Probability to sample near goal\n        self._timeout_seconds: float = 30.0       # Timeout in seconds for search\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        With some probability, sample near the goal within a small radius,\n        otherwise sample randomly in the entire environment.\n        \"\"\"\n        goal_pos = self._get_grid().goal.position\n        size = self._get_grid().size\n        bias_radius = 15  # radius near the goal to bias sampling\n\n        if random.random() < self._goal_bias_probability:\n            # Sample in a square bounding box around goal (clamp to map size)\n            lower_bounds = [max(0, goal_pos[i] - bias_radius) for i in range(goal_pos.n_dim)]\n            upper_bounds = [min(size[i]-1, goal_pos[i] + bias_radius) for i in range(goal_pos.n_dim)]\n            coords = [np.random.randint(low, high+1) for low, high in zip(lower_bounds, upper_bounds)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback to uniform random if biased sample invalid\n                return self._get_random_sample()\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._timeout_seconds:\n                # Timeout reached, stop trying and return (no path found)\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                log_card_v = torch.log(card_v)\n                radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent: Optional[Vertex] = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved PathPlanning algorithm inspired by RRT*, which enhances RRT by rewiring the tree for better paths.\n    It accelerates finding an optimized path by connecting new vertices not only to the nearest vertex but also\n    attempts to rewire neighbors within a radius to minimize the path cost. It prunes inefficient edges and \n    ensures efficient exploration. A timeout of 30 seconds is enforced to terminate long searches.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, \n                                 Vertex(self._get_grid().agent.position), \n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True     # Allow removing edges for rewiring\n        self._init_displays()\n        self._max_dist: float = 10.0\n        self._neighbor_radius: float = 15.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Find all vertices in graph within neighbor_radius of q_new\n        near_vertices: List[Vertex] = []\n        for v in self._graph.vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new.position.to_tensor()).item()\n            if dist <= self._neighbor_radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Cost from from_vertex to to_vertex is Euclidean distance\n        return torch.norm(to_vertex.position.to_tensor() - from_vertex.position.to_tensor()).item()\n\n    def _get_path_cost(self, vertex: Vertex) -> float:\n        # Compute cost from root to this vertex by summing edge costs\n        cost = 0.0\n        current = vertex\n        while len(current.parents) > 0:\n            parent = current.parents[0]\n            cost += self._cost(parent, current)\n            current = parent\n        return cost\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # For each neighbor, check if rewiring via q_new reduces cost and edge is valid\n        for v_near in near_vertices:\n            if v_near == q_new.parents[0]:\n                continue\n            # Current cost to neighbor\n            current_cost = self._get_path_cost(v_near)\n            # Cost if going through q_new\n            possible_cost = self._get_path_cost(q_new) + self._cost(q_new, v_near)\n            if possible_cost < current_cost:\n                # Check if line q_new->v_near is valid\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edge to v_near\n                    for parent in v_near.parents.copy():\n                        self._graph.remove_edge(parent, v_near)\n                    # Add new edge q_new->v_near\n                    self._graph.add_edge(q_new, v_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect to goal\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]  # Remove the root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.display_info if hasattr(self._graph, 'display_info') else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        for i in range(iterations):\n            if time.time() - start_time > 30.0:\n                # Timeout: no path found in 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices and choose parent with minimal cost to q_new\n            near_vertices = self._get_near_vertices(q_new)\n            min_cost = math.inf\n            best_parent = q_near\n            q_new_cost_est = self._get_path_cost(q_near) + self._cost(q_near, q_new)\n\n            for near_v in near_vertices:\n                line_seq = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_through_near = self._get_path_cost(near_v) + self._cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire connections to improve paths\n            if len(near_vertices) > 0:\n                self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT* focused on accelerating convergence \n    and reducing redundant computations to improve execution time in discrete grid environments.\n    Key improvements include:\n    - Adaptive sampling with goal bias to direct growth towards the goal more frequently.\n    - Early pruning of vertices with costs exceeding the best known solution to reduce rewiring overhead.\n    - Caching collision checks within each iteration to avoid repeated checks for the same edges.\n    - Time-bounded search: abort path search if it exceeds 30 seconds.\n    It still rewires the tree for optimal paths but applies heuristics to limit unnecessary computations \n    and direct the search more intelligently.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT-Connect, integrating a heuristic bias \n    towards the goal to accelerate convergence and reduce unnecessary exploration.\n\n    This algorithm, named PathPlanning, uses two trees grown from the start and goal positions,\n    respectively. It incorporates goal-biased sampling: with a certain probability, samples are \n    taken directly at the goal to speed up connection attempts. It also limits the number of iterations \n    dynamically by elapsed time, aborting the search if no path is found within 30 seconds.\n\n    By focusing sampling more often near the goal and pruning redundant full explorations, it aims to \n    reduce the total computation time compared to plain RRT-Connect, thus improving practical runtime performance.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% samples biased directly towards goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Returns a sample biased towards the goal with probability self._goal_sample_rate,\n        else a random valid position.\n        \"\"\"\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self) -> None:\n\n        # trace back from _q_new to root of start tree\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = next(iter(path_mid_to_b[-1].parents))\n            path_mid_to_b.append(parent)\n\n        # trace back from _extension_target to root of goal tree\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = next(iter(path_a_to_mid[-1].parents))\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # Adjust path direction if required\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        for i in range(self._iterations):\n\n            # Abort if runtime > 30 seconds\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # No path found within time limit\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nImproved path planning algorithm based on RRT*, an extension of RRT that optimizes the path by \nrewiring the tree to minimize costs and uses a radius neighborhood to try connecting new nodes \nto multiple nearby vertices. It attempts to find shorter paths faster by local optimization. \nThis implementation additionally terminates if runtime exceeds 30 seconds to avoid excessive delays.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"Return all vertices within radius from q_new.\"\"\"\n        vertices: List[Vertex] = []\n        all_vertices: List[Vertex] = self._graph.get_all_vertices()\n        q_new_tensor = q_new.position.to_tensor()\n        for v in all_vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor)\n            if dist <= radius:\n                vertices.append(v)\n        return vertices\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"Return path cost from root to vertex.\"\"\"\n        cost = 0.0\n        current = vertex\n        while len(current.parents) > 0:\n            parent = current.parents[0]\n            cost += torch.norm(current.position.to_tensor() - parent.position.to_tensor()).item()\n            current = parent\n        return cost\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"Choose the best parent from neighbors for q_new based on minimum cost.\"\"\"\n        min_cost = math.inf\n        best_parent = None\n        for v in neighbors:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = self._cost(v) + torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex, radius: float) -> None:\n        \"\"\"Try to optimize the path by rewiring nearby vertices to q_new if it reduces cost.\"\"\"\n        q_new_cost = self._cost(q_new)\n        q_new_tensor = q_new.position.to_tensor()\n        for v in neighbors:\n            if v == q_new:\n                continue\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor).item()\n            if dist > radius:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            current_cost = self._cost(v)\n            new_cost = q_new_cost + dist\n            if new_cost < current_cost:\n                # remove old edge parents if mutable graph\n                v.parents.clear()\n                self._graph.add_edge(q_new, v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        current = q_goal\n        while len(current.parents) != 0:\n            current = current.parents[0]\n            path.append(current)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._SampleBasedAlgorithm__map_displays if hasattr(self, \"_SampleBasedAlgorithm__map_displays\") else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        c: float = 1.0  # tuning parameter for neighborhood radius\n        start_time = time.time()\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout: treat route search as not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Radius for near neighbors (RRT* radius formula)\n            gamma_rrt_star = c * (math.log(len(self._graph.get_all_vertices()) + 1) / (len(self._graph.get_all_vertices()) + 1)) ** (1 / self._get_grid().size.n_dim)\n            radius = max_dist  # limit radius to max_dist to limit search space locally\n            radius = min(radius, gamma_rrt_star)\n\n            near_vertices = self._get_near_vertices(q_new, radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if no suitable parent found in neighborhood\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the nearby vertices if better path found via q_new\n            self._rewire(near_vertices, q_new, radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                # Check if line from q_new to goal is valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                else:\n                    self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT*, named \"Informed RRT*\".\n    It enhances the original RRT* by focusing the sampling within an ellipsoidal \n    informed set once a solution is found, which reduces unnecessary exploration \n    and speeds up convergence to an optimal path. Additionally, a timeout of 30 seconds \n    is implemented to terminate the search early if no path is found in that time frame.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of the SPRM sample-based planner.\n    Instead of building a cyclic graph and connecting all points within a fixed radius,\n    it uses a bidirectional incremental connection approach inspired by RRT-Connect to speed up path discovery.\n    Two vertex trees start from the agent and the goal, respectively, and grow towards random samples.\n    Whenever the two trees can connect via a collision-free path, the route is extracted and followed.\n    A 30-second timeout ensures the algorithm halts if no solution is found in time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # parameters for RRT-Connect style bidirectional growth\n        self._V_size = 200\n        self._max_extend_dist = 15\n        self._tree_agent: List[Vertex] = []\n        self._tree_goal: List[Vertex] = []\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _nearest(self, tree: List[Vertex], point: Point) -> Vertex:\n        # Find vertex in tree closest to point\n        min_dist = float('inf')\n        nearest_vertex = None\n        p_tensor = point.to_tensor()\n        for vertex in tree:\n            dist = torch.norm(vertex.position.to_tensor() - p_tensor).item()\n            if dist < min_dist:\n                min_dist = dist\n                nearest_vertex = vertex\n        return nearest_vertex\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        # From from_vertex, move towards to_point by up to max_dist\n        return self._get_new_vertex(from_vertex, to_point, max_dist)\n\n    def _connect_trees(self, V_from: Vertex, V_to: Vertex) -> bool:\n        # Attempt connection from V_from to V_to by checking line collision,\n        # and add edges if valid, updating connectivity\n        grid = self._get_grid()\n        line = grid.get_line_sequence(V_from.position, V_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n        self._graph.add_edge(V_from, V_to)\n        self._graph.add_edge(V_to, V_from)\n        # Update connectivity map for these vertices\n        # (assuming connectivity maintains shortest path or at least path presence)\n        # We can propagate connectivity updates here if needed\n        # For simplicity, we just add the edge; connectivity handled by CyclicGraph internals\n        return True\n\n    def _extract_path_from_connectivity(self, start: Vertex, goal: Vertex) -> List[Point]:\n        # Extract path following connectivity pointers from start to goal\n        path_vertices = [start]\n        current = start\n        while current is not goal:\n            if goal not in current.connectivity:\n                # No connection found - abort path extraction\n                return []\n            next_vertex = current.connectivity[goal]\n            if next_vertex == current:\n                # Avoid infinite loop if connectivity mismanaged\n                return []\n            path_vertices.append(next_vertex)\n            current = next_vertex\n        return [v.position for v in path_vertices]\n\n    def _extract_path(self, connect_vertex_agent: Vertex, connect_vertex_goal: Vertex) -> None:\n        # When two trees connect, we build path from agent to connection vertex,\n        # then from connection vertex in goal tree to goal.\n        # The goal tree connectivity is from goal backward, so path is reversed.\n        agent_root = self._graph.root_vertices[0]\n        goal_root = self._graph.root_vertices[1]\n\n        path_to_connect = self._extract_path_from_connectivity(agent_root, connect_vertex_agent)\n        path_from_connect = self._extract_path_from_connectivity(goal_root, connect_vertex_goal)\n\n        if not path_to_connect or not path_from_connect:\n            return  # Can't extract full path\n\n        path_from_connect.reverse()  # Because connectivity is towards root, reverse to go from connect to goal\n\n        full_path = path_to_connect + path_from_connect[1:]  # Avoid duplication of connect vertex\n\n        for p in full_path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize trees with root vertices\n        self._tree_agent = [agent_vertex]\n        self._tree_goal = [goal_vertex]\n        self._graph.edges_removable = True\n\n        start_time = time.time()\n        # Iterative growth with max iterations capped by V_size * 5 to avoid infinite loops\n        max_iterations = self._V_size * 5\n        for _ in range(max_iterations):\n            if time.time() - start_time > 30:\n                # Timeout reached; treat route as not found\n                return\n\n            # Sample a random valid point\n            q_rand = self._get_random_sample()\n\n            # --- Extend agent tree towards q_rand ---\n            nearest_agent = self._nearest(self._tree_agent, q_rand)\n            q_new_agent = self._steer(nearest_agent, q_rand, self._max_extend_dist)\n            line_agent = grid.get_line_sequence(nearest_agent.position, q_new_agent.position)\n            if grid.is_valid_line_sequence(line_agent) and q_new_agent.position != nearest_agent.position:\n                new_vertex_agent = Vertex(q_new_agent.position, store_connectivity=True)\n                self._graph.add_vertex(new_vertex_agent)\n                self._graph.add_edge(nearest_agent, new_vertex_agent)\n                self._graph.add_edge(new_vertex_agent, nearest_agent)\n                self._tree_agent.append(new_vertex_agent)\n                self.key_frame()\n\n                # Try connect new_agent_vertex to the goal tree\n                nearest_goal = self._nearest(self._tree_goal, new_vertex_agent.position)\n                if nearest_goal.position != new_vertex_agent.position:\n                    line_connect = grid.get_line_sequence(new_vertex_agent.position, nearest_goal.position)\n                    if grid.is_valid_line_sequence(line_connect):\n                        # Connect trees\n                        new_vertex_goal = Vertex(nearest_goal.position, store_connectivity=True)\n                        # No need to add nearest_goal again (already in tree_goal)\n                        self._graph.add_edge(new_vertex_agent, nearest_goal)\n                        self._graph.add_edge(nearest_goal, new_vertex_agent)\n                        self.key_frame()\n                        # Extract path and return\n                        self._extract_path(new_vertex_agent, nearest_goal)\n                        return\n\n            # --- Extend goal tree towards q_rand ---\n            nearest_goal = self._nearest(self._tree_goal, q_rand)\n            q_new_goal = self._steer(nearest_goal, q_rand, self._max_extend_dist)\n            line_goal = grid.get_line_sequence(nearest_goal.position, q_new_goal.position)\n            if grid.is_valid_line_sequence(line_goal) and q_new_goal.position != nearest_goal.position:\n                new_vertex_goal = Vertex(q_new_goal.position, store_connectivity=True)\n                self._graph.add_vertex(new_vertex_goal)\n                self._graph.add_edge(nearest_goal, new_vertex_goal)\n                self._graph.add_edge(new_vertex_goal, nearest_goal)\n                self._tree_goal.append(new_vertex_goal)\n                self.key_frame()\n\n                # Try connect new_goal_vertex to the agent tree\n                nearest_agent = self._nearest(self._tree_agent, new_vertex_goal.position)\n                if nearest_agent.position != new_vertex_goal.position:\n                    line_connect = grid.get_line_sequence(new_vertex_goal.position, nearest_agent.position)\n                    if grid.is_valid_line_sequence(line_connect):\n                        # Connect trees\n                        self._graph.add_edge(new_vertex_goal, nearest_agent)\n                        self._graph.add_edge(nearest_agent, new_vertex_goal)\n                        self.key_frame()\n                        # Extract path and return\n                        self._extract_path(nearest_agent, new_vertex_goal)\n                        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* variant with goal biasing and adaptive sampling radius for faster convergence.\nThe key improvements over standard RRT* are:\n- Goal bias: a certain fraction of samples are drawn directly from the goal region to guide growth towards the target.\n- Adaptive radius: dynamically adjusts the rewiring radius based on graph size to balance exploration and exploitation.\n- Early termination on timeout (30 seconds).\nThese modifications speed up path discovery and improve performance in complex environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _goal_bias: float\n    _max_dist: float\n    _max_iterations: int\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Added member variables for improved algorithm\n        self._goal_bias = 0.2         # 20% samples from goal region, biases growth towards goal\n        self._max_dist = 10.0         # Maximum extension distance for new vertices\n        self._max_iterations = 10000  # Maximum number of iterations\n        self._max_radius = 50.0       # Maximum radius for neighbor search during rewiring\n        self._lambda_rrt_star = 50.0  # Constant factor used in rewiring radius calculation (as in RRT*)\n        self._dimension = 2           # Dimensionality of the planning space (assumed 2D)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [EntitiesMapDisplay(self._services)]\n\n    def _get_random_sample(self) -> Point:\n        # With probability goal_bias, sample near or at the goal position to accelerate convergence\n        if np.random.rand() < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            # Small random offset around goal to expand exploration near goal region\n            offset = np.random.uniform(-2, 2, size=self._dimension)\n            goal_sample_array = goal_pos.to_tensor().numpy() + offset\n            goal_sample_array = np.clip(goal_sample_array, 0, self._get_grid().size - 1)\n            sample = Point(*goal_sample_array)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Otherwise, uniform random valid sample in the map\n        return super()._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Timeout after 30 seconds\n            if time.time() - start_time > 30.0:\n                # Fail to find path within time limit\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            ):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(\n                self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)),\n                self._max_radius,\n            )\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Choose best parent for q_new\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring for optimization\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                ):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        q_parent = next(iter(q_near.parents), None)\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        # Backtrack parent chain from goal to root\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        path.pop()  # Remove root duplicated\n        path.reverse()\n\n        # Move agent along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm is an improved variant of RRT-Connect, named Biased RRT*, combining the bidirectional growth strategy \nof RRT-Connect with heuristic sampling bias and cost optimization to improve time efficiency and path quality.\nThe key improvements over standard RRT-Connect are:\n- Sampling is biased towards the goal region with some probability to accelerate convergence.\n- Instead of fixed maximum distance steps, it uses incremental cost-based extension to better optimize the path.\n- Attempts rewiring in the trees to continuously improve path quality.\n- The search terminates after 30 seconds if no path is found, preventing excessive runtime.\n\nIt maintains the core concept of connecting two trees grown from start and goal, but uses heuristics and rewiring \nto speed up search and find paths faster.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges for optimization\n        self._init_displays()\n\n        self._max_dist = 12  # Slightly larger extension step\n        self._iterations = 15000  # Increased iterations, but bounded by time\n        self._goal_sample_rate = 0.1  # 10% goal-biased sampling\n\n    # Override displays to reuse existing display setup\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_path_cost(self, vertex: Vertex) -> float:\n        # Sum of edge costs to root; assume edge cost = distance(parent to vertex)\n        cost = 0.0\n        current = vertex\n        while current.parents:\n            parent = current.parents[0]\n            cost += self._distance(current.position, parent.position)\n            current = parent\n        return cost\n\n    def _get_near_vertices(self, root_vertex: Vertex, q_sample: Point, radius: float) -> List[Vertex]:\n        # Returns all vertices within radius of q_sample inside this tree\n        near_vertices = []\n        vertices_to_check = []\n        # BFS or DFS from root vertex to gather all vertices\n        # We assume Forest has method to get all vertices linked from root_vertex\n        vertices_to_check.append(root_vertex)\n        visited = set()\n        while vertices_to_check:\n            v = vertices_to_check.pop()\n            if v in visited:\n                continue\n            visited.add(v)\n            if self._distance(v.position, q_sample) <= radius:\n                near_vertices.append(v)\n            # Add children to check next\n            for edge_child in self._graph.adjacent(v):\n                if edge_child not in visited:\n                    vertices_to_check.append(edge_child)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent that yields minimal path cost to q_new and is collision free\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = self._get_path_cost(v) + self._distance(v.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to rewire near vertices through q_new if it results in lower cost path\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = self._get_path_cost(q_new) + self._distance(q_new.position, v.position)\n            cost_current = self._get_path_cost(v)\n            if cost_through_qnew < cost_current:\n                # Rewire: remove old parent edge, add new edge from q_new\n                # Note: Forest edges_removable=True allows this operation\n                for p in v.parents:\n                    self._graph.remove_edge(p, v)\n                    break\n                self._graph.add_edge(q_new, v)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        # Modified extend for cost-based parent selection and rewiring\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            return 'trapped'\n\n        near_radius = self._max_dist * 2.0  # radius for near vertices in rewiring\n        near_vertices = self._get_near_vertices(root_vertex, self._q_new.position, near_radius)\n        parent = self._choose_parent(near_vertices, self._q_new)\n\n        if parent is None:\n            # Fallback to nearest vertex if no better parent found\n            parent = self._q_near\n\n        self._graph.add_edge(parent, self._q_new)\n        self._rewire(near_vertices, self._q_new)\n\n        if self._q_new.position == q:\n            return 'reached'\n        else:\n            return 'advanced'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from connection point between start and goal trees\n\n        # From q_new back to start root\n        path_mid_to_start: List[Vertex] = [self._q_new]\n        while len(path_mid_to_start[-1].parents) != 0:\n            for parent in path_mid_to_start[-1].parents:\n                path_mid_to_start.append(parent)\n                break\n\n        # From extension target back to goal root\n        path_goal_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_goal_to_mid[-1].parents) != 0:\n            for parent in path_goal_to_mid[-1].parents:\n                path_goal_to_mid.append(parent)\n                break\n\n        path_goal_to_mid.reverse()\n        path = path_goal_to_mid + path_mid_to_start\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling towards goal position to improve search speed\n        if np.random.rand() < self._goal_sample_rate:\n            # sample goal position directly; if valid\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        # else random uniform sample\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Main path finding function with 30 sec timeout\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        for iteration in range(self._iterations):\n            # Check timeout after each iteration\n            if time() - start_time > 30.0:\n                # Failed to find path in 30 seconds\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            if self._extend(self._graph.root_vertices[0], q_rand) != 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved sample-based path planning algorithm inspired by RRT* (Rapidly-exploring Random Tree Star).\n    It incrementally builds a tree of feasible paths by sampling points in the free space and rewiring the tree to optimize \n    the path cost. Unlike the traditional A*, which relies on grid exploration, this approach uses sampling to improve \n    runtime in large or continuous spaces. We enforce a 30-second timeout to avoid long runtimes.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Sample-Based Path Planning algorithm using RRT* style rewiring and optimization.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: Optional[BasicTesting] = None) -> None:\n        super().__init__(services, testing)\n\n        # graph stores vertices for the sample-based method (vertex.position: Point, vertex.cost: float, vertex.parent: Optional[Vertex])\n        self._graph: Dict[Point, Vertex] = {}\n\n        # maximum distance to extend tree per iteration\n        self._max_extend_length = 10.0\n\n        # radius for rewiring neighbors\n        self._neighbor_radius = 15.0\n\n        # Store goal and start vertices\n        self._start_vertex: Optional[Vertex] = None\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Pre-initialize display list\n        self.__map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Initialize graph display once per planning\n        if not self.__map_displays:\n            self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        agent_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        # Initialize start vertex\n        self._start_vertex = Vertex(agent_pos)\n        self._start_vertex.cost = 0.0\n        self._start_vertex.parent = None\n\n        # Add start vertex to graph\n        self._graph.clear()\n        self._graph[agent_pos] = self._start_vertex\n\n        # Initialize goal vertex as placeholder, cost set to infinity initially\n        self._goal_vertex = Vertex(goal_pos)\n        self._goal_vertex.cost = float(\"inf\")\n        self._goal_vertex.parent = None\n\n        start_time = time.time()\n        time_limit = 30.0  # seconds\n\n        found_path = False\n\n        while True:\n            # Check timeout\n            if time.time() - start_time > time_limit:\n                # Timeout reached without path found\n                break\n\n            # Sample random free point in map\n            q_rand: Point = self._sample_free()\n\n            # Find nearest vertex in tree to q_rand\n            q_near: Vertex = self._nearest_vertex(q_rand)\n\n            # Steer from q_near towards q_rand to get q_new\n            q_new_pos: Point = self._steer(q_near.position, q_rand, self._max_extend_length)\n\n            if not grid.is_free(q_new_pos):\n                # Skip if q_new position is in obstacle\n                continue\n\n            # Check if path from q_near to q_new is collision free\n            if not self._collision_free(q_near.position, q_new_pos):\n                continue\n\n            # Create new vertex for q_new\n            q_new = Vertex(q_new_pos)\n\n            # Find neighbors within rewiring radius\n            neighbors = self._near_vertices(q_new_pos, self._neighbor_radius)\n\n            # Choose parent with minimum cost + cost to q_new\n            q_new_parent, q_new_cost = self._choose_parent(q_near, neighbors, q_new_pos)\n            q_new.parent = q_new_parent\n            q_new.cost = q_new_cost\n\n            # Add q_new to graph\n            self._graph[q_new_pos] = q_new\n\n            # Rewire neighbors to q_new if it improves their cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal and path from q_new to goal is free\n            if self._dist(q_new_pos, goal_pos) <= self._max_extend_length and self._collision_free(q_new_pos, goal_pos):\n                temp_goal_cost = q_new.cost + self._dist(q_new_pos, goal_pos)\n                if temp_goal_cost < self._goal_vertex.cost:\n                    # Update goal vertex parent and cost\n                    self._goal_vertex.parent = q_new\n                    self._goal_vertex.cost = temp_goal_cost\n                    self._goal_vertex.position = goal_pos\n                    self._graph[goal_pos] = self._goal_vertex\n                    found_path = True\n\n            self.key_frame()\n\n            # If we found a path, we can stop early or keep running to try and improve it\n            if found_path and (time.time() - start_time) > 0.5:\n                # Small delay after first path found then stop\n                break\n\n        if found_path:\n            self._move_agent_along_path()\n        # else, no path found within time limit; do nothing\n\n    # Helper methods below\n\n    def _sample_free(self) -> Point:\n        \"\"\"\n        Returns a random free point in the map.\n        Uses grid API or uniform sampling over map dimensions.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Try up to 100 times to find free point randomly\n        for _ in range(100):\n            x = self._services.state.rnd.uniform(0, grid.width - 1)\n            y = self._services.state.rnd.uniform(0, grid.height - 1)\n            sample_point = Point(int(x), int(y))\n            if grid.is_free(sample_point):\n                return sample_point\n        # fallback to agent position if no free sample found (unlikely)\n        return grid.agent.position\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Returns the vertex in the graph closest to given point.\n        \"\"\"\n        min_dist = float(\"inf\")\n        nearest = None\n        for v in self._graph.values():\n            dist = self._dist(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within radius distance of the point.\n        \"\"\"\n        neighbors = []\n        for v in self._graph.values():\n            if self._dist(v.position, point) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _steer(self, from_point: Point, to_point: Point, max_dist: float) -> Point:\n        \"\"\"\n        Returns a Point moved from from_point towards to_point by max_dist at most.\n        \"\"\"\n        vector = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = (vector[0] ** 2 + vector[1] ** 2) ** 0.5\n        if dist <= max_dist:\n            return to_point\n        else:\n            scale = max_dist / dist\n            new_x = int(from_point[0] + vector[0] * scale)\n            new_y = int(from_point[1] + vector[1] * scale)\n            return Point(new_x, new_y)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        \"\"\"\n        Check if path between from_point and to_point is free of obstacles using Bresenham line or similar.\n        \"\"\"\n        grid: Map = self._get_grid()\n        points = self._bresenham_line(from_point, to_point)\n        for p in points:\n            if not grid.is_free(p):\n                return False\n        return True\n\n    def _choose_parent(self, q_near: Vertex, neighbors: List[Vertex], q_new_pos: Point) -> Tuple[Vertex, float]:\n        \"\"\"\n        Chooses the best parent for q_new from neighbors minimizing total cost \n        (cost to neighbor + cost from neighbor to q_new).\n        \"\"\"\n        grid: Map = self._get_grid()\n        min_cost = q_near.cost + self._dist(q_near.position, q_new_pos)\n        best_parent = q_near\n        for neighbor in neighbors:\n            if neighbor == q_near:\n                continue\n            if not self._collision_free(neighbor.position, q_new_pos):\n                continue\n            cost = neighbor.cost + self._dist(neighbor.position, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent, min_cost\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, see if going through q_new improves cost; if yes, rewire tree.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parent:\n                continue\n            if not self._collision_free(q_new.position, neighbor.position):\n                continue\n            cost_through_qnew = q_new.cost + self._dist(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost:\n                neighbor.parent = q_new\n                neighbor.cost = cost_through_qnew\n\n    def _move_agent_along_path(self) -> None:\n        \"\"\"\n        Follow back from goal vertex to start and move agent along path.\n        \"\"\"\n        grid: Map = self._get_grid()\n        path: List[Point] = []\n        current = self._goal_vertex\n        while current.parent is not None:\n            path.append(current.position)\n            current = current.parent\n        path.append(self._start_vertex.position)\n        path.reverse()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between two Points.\n        \"\"\"\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def _bresenham_line(self, start: Point, end: Point) -> List[Point]:\n        \"\"\"\n        Uses Bresenham's line algorithm to get points between start and end (inclusive).\n        \"\"\"\n        points = []\n\n        x0, y0 = start\n        x1, y1 = end\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        x, y = x0, y0\n\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n\n        if dx > dy:\n            err = dx / 2.0\n            while x != x1:\n                points.append(Point(x, y))\n                err -= dy\n                if err < 0:\n                    y += sy\n                    err += dx\n                x += sx\n            points.append(Point(x, y))\n        else:\n            err = dy / 2.0\n            while y != y1:\n                points.append(Point(x, y))\n                err -= dx\n                if err < 0:\n                    x += sx\n                    err += dy\n                y += sy\n            points.append(Point(x, y))\n\n        return points ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is an improvement over the basic RRT* by integrating a heuristic-guided sampling approach inspired by Informed RRT*. \nAfter an initial path to the goal is found, the sampling region is confined to an ellipsoidal subset of the search space that can possibly yield a better path, \nreducing unnecessary exploration and improving convergence speed. Time limiting is enforced to abort if no path is found within 30 seconds.\nThe algorithm inherits from SampleBasedAlgorithm, reuses helper functions from RRT*, and modifies the sampling and iteration logic accordingly.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional member variables for improved sampling\n        self._best_cost: Optional[float] = None\n        # Precompute direct distance from start to goal for ellipsoid calculation\n        self._start_pos = self._graph.root_vertex_start.position\n        self._goal_pos = goal_vertex.position\n        self._c_best_init = torch.norm(self._start_pos.to_tensor() - self._goal_pos.to_tensor()).item()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.display_info if hasattr(self._graph, 'display_info') else super().set_display_info()\n\n    def _get_random_sample_informed(self) -> Point:\n        \"\"\"\n        Sample inside an ellipsoidal informed subset once a path exists\n        If no path found yet, sample uniformly.\n        \"\"\"\n\n        size = self._get_grid().size\n        n_dim = size.n_dim\n\n        if self._best_cost is None:\n            # No solution found yet: uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, size, n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample from ellipsoid defined by start, goal, and best_cost\n            c_min = self._c_best_init\n            c_max = self._best_cost\n\n            center = Point.from_tensor((self._start_pos.to_tensor() + self._goal_pos.to_tensor()) / 2)\n            a1 = (self._goal_pos.to_tensor() - self._start_pos.to_tensor()) / torch.norm(self._goal_pos.to_tensor() - self._start_pos.to_tensor())\n            # Create an orthonormal basis (for 2D case) - extend for higher dims if necessary\n            if n_dim == 2:\n                a2 = torch.tensor([-a1[1], a1[0]])\n                U = torch.stack([a1, a2], dim=1)\n            else:\n                # For higher dims, create identity basis (fallback)\n                U = torch.eye(n_dim)\n\n            # radii of ellipsoid\n            l1 = c_max / 2\n            # Other axes radii\n            if n_dim > 1:\n                l2 = (c_max**2 - c_min**2)**0.5 / 2\n            else:\n                l2 = 0\n\n            L_diag = torch.diag(torch.tensor([l1] + [l2]*(n_dim - 1), dtype=torch.float32))\n\n            for _ in range(100):  # Attempt sampling to find a valid point\n                # Sample from unit n-ball\n                x_ball = torch.randn(n_dim)\n                norm_x = torch.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball_unit = x_ball / norm_x\n                # Sample radius inside unit ball uniformly\n                r = np.random.uniform(0, 1) ** (1/n_dim)\n                x_rand_ball = r * x_ball_unit\n                # Map to ellipsoid\n                x_rand = torch.matmul(U, torch.matmul(L_diag, x_rand_ball)) + center.to_tensor()\n\n                # Project to nearest integer grid point\n                x_rand_int = x_rand.round().long()\n                x_rand_int_clamped = torch.clamp(x_rand_int, min=0, max=size - 1)\n                sample = Point.from_tensor(x_rand_int_clamped)\n\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n            # If no valid sample found after attempts, fallback to uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, size, n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Same as in RRT_Star; reused with no modification\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Traverse parents to root\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        # Remove duplicate root vertex and reverse path\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        path_found = False\n\n        for i in range(iterations):\n\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Timeout: path not found within 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample_informed()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose minimum cost parent\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring nearby vertices\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and extract path\n                self._best_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_pos.to_tensor()).item()\n                self._extract_path(q_new)\n                path_found = True\n                break\n\n            self.key_frame()\n\n        if not path_found:\n            # If no path found within time or iterations, optionally notify or handle here\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT* (Rapidly-exploring Random Tree Star) inspired algorithm for faster path planning.\n    This algorithm incrementally builds a tree by sampling points, connects new vertices considering optimal\n    rewiring to reduce path cost, and prunes unnecessary branches. It biases sampling towards the goal to\n    improve convergence speed, rewires vertices within a radius to optimize paths, and stops searching after\n    30 seconds if no path is found. This improves over basic RRT by seeking lower cost paths and faster convergence.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_sample_rate: float = 0.1) -> Point:\n        \"\"\"\n        With some probability, sample the goal point to bias tree growth towards goal.\n        Otherwise, sample uniformly at random in valid environment positions.\n        \"\"\"\n        if np.random.random() < goal_sample_rate:\n            # Bias towards goal\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _find_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find all vertices within 'radius' of q_new.position in the graph.\n        \"\"\"\n        near_vertices: List[Vertex] = []\n        vertices_to_search = self._graph.all_vertices()\n        for vertex in vertices_to_search:\n            if self._distance(vertex.position, q_new.position) <= radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent for q_new among the near_vertices that minimizes cost to q_new\n        while ensuring the line path is valid.\n        \"\"\"\n        if not near_vertices:\n            return None\n\n        min_cost = math.inf\n        best_parent = None\n\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + self._distance(q_near.position, q_new.position)\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                best_parent = q_near\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For all near vertices, check if rewiring through q_new would lower cost.\n        If yes and line path is valid, rewire to q_new.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new.parent:\n                continue  # skip parent vertex\n            \n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n\n            new_cost = q_new.cost + self._distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Rewire q_near to have q_new as parent\n                if q_near.parents:\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))  # get one parent (tree structure expected)\n            path.append(parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overrides #\n    # --------- #\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_iterations: int = 10000\n        goal_radius: float = self._get_grid().goal.radius if hasattr(self._get_grid().goal, \"radius\") else 1.0\n        dimension = self._get_grid().size.n_dim\n\n        # Initialize costs for root vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        start_time = time.time()\n        for i in range(max_iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:  # timeout after 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=0.2)  # bias sampling by 20% towards goal\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # If the path to new vertex invalid, skip\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near vertices within a radius for rewiring and parent selection\n            # Radius chosen based on space dimension and log of iterations (RRT* style)\n            radius = max_dist * 2.0  # can be tuned or adaptive, kept fixed here for simplicity\n\n            near_vertices: List[Vertex] = self._find_near_vertices(q_new, radius)\n\n            # Choose parent with lowest cost connection\n            parent: Optional[Vertex] = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                # fallback: connect to nearest vertex if no better parent found\n                parent = q_near\n\n            # Set q_new cost and parent\n            q_new.cost = parent.cost + self._distance(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire near vertices if better cost found through q_new\n            self._rewire(near_vertices, q_new)\n\n            # Check if q_new is within goal radius (using Euclidean distance)\n            if self._distance(q_new.position, self._get_grid().goal.position) <= goal_radius \\\n               and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal to complete path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                # Validate that path from q_new to goal is collision free\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Create visualization keyframe for each iteration\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved path planning algorithm based on RRT* with enhancements to improve \n    time efficiency. The key ideas include:\n    - Incorporating a goal bias sampling strategy to speed up convergence towards the goal by sampling the goal \n      position with a certain probability.\n    - Early stopping condition using a timeout of 30 seconds to abort the search if no path is found within the time limit.\n    - Reuse of graph radius calculation for rewiring but with a slightly reduced max radius to limit unnecessary nearby connections.\n    - Maintaining the laziness of rewiring, only rewiring when a better path is found, preserving the optimized paths.\n    The algorithm inherits SampleBasedAlgorithm and overrides _find_path_internal and set_display_info methods.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Add any new member variables here if needed\n        self._goal_bias = 0.1  # Probability to sample the goal directly for faster convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Samples the goal position with probability self._goal_bias,\n        otherwise returns a random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10.0\n        iterations: int = 10000\n        max_radius: float = 40.0  # Reduced max radius to prune rewiring computations slightly\n        lambda_rrt_star: float = 40.0\n        dimension: int = 2\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Check elapsed time for early stopping if >30 seconds\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Abort search - no path found in time limit\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    # Rewire only if improvement is made\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        q_near.cost = None\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Algorithm Description:\n    This is an improved RRT-Connect based path planning algorithm named PathPlanning.\n    It introduces goal biasing to efficiently direct tree growth towards the goal, reducing random samples.\n    It also uses bidirectional tree growing but adds a time-based termination condition (30 seconds) to ensure timely response.\n    By periodically biasing samples toward the goal and limiting elapsed search time, it improves pathfinding speed while preserving completeness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.2  # 20% samples towards goal for faster convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Return a random sample point with goal biasing:\n        With probability _goal_bias, return the goal position as sample.\n        Otherwise, return a uniform random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout, path not found within time limit\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_status = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_status != 'trapped':\n                self._extension_target = self._q_new\n                connect_status = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_status == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            # Visualization key frame for animation/debugging\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation uses the RRT* (Rapidly-exploring Random Tree Star) algorithm, which is a sample-based \n    path planning algorithm that iteratively builds and optimizes a tree rooted at the start position to find \n    an efficient, collision-free path to the goal. RRT* randomly samples points in the space, connects new samples \n    to the nearest tree vertex if feasible, and rewires the tree to reduce path costs. This approach improves \n    performance and path quality over classic discrete grid search like A*. A 30-second timeout is added to \n    terminate search if path not found timely.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Dict[Point, Vertex]\n    _q_new: Optional[Vertex]\n    _q_near: Optional[Vertex]\n    _q_nearest: Optional[Vertex]\n    _q_parent: Optional[Vertex]\n    _goal_vertex: Optional[Vertex]\n\n    max_search_time: float\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph as a dictionary mapping position to Vertex\n        self._graph = {}\n        self._q_new = None\n        self._q_near = None\n        self._q_nearest = None\n        self._q_parent = None\n        self._goal_vertex = None\n\n        self.max_search_time = 30.0  # seconds timeout\n\n        # Initialize displays list\n        self.__map_displays = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Show the graph of explored paths if generated\n        if not self.__map_displays:\n            self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Implements RRT* algorithm with improvements in rewiring and cost optimization.\n        Terminates search if path to goal is found or timeout of 30 seconds is reached.\n        After path is found, follows and moves the agent along the path.\n        \"\"\"\n        grid: Map = self._get_grid()\n        self._init_graph(grid.agent.position)\n\n        start_time = time()\n        found_path = False\n\n        while True:\n            if (time() - start_time) > self.max_search_time:\n                # Timeout: Route not found\n                break\n\n            q_rand_point = self._get_random_sample()\n            self._q_nearest = self._nearest_vertex(q_rand_point)\n\n            q_new_pos, valid = self._steer(self._q_nearest.position, q_rand_point)\n            if not valid:\n                self.key_frame()\n                continue\n\n            if self._collision_free(self._q_nearest.position, q_new_pos):\n                self._q_new = Vertex(q_new_pos)\n                self._q_new.cost = float('inf')\n                neighbors = self._near_vertices(self._q_new.position)\n\n                # Choose parent with minimum cost + distance\n                min_cost = self._q_nearest.cost + self._cost(self._q_nearest.position, self._q_new.position)\n                self._q_parent = self._q_nearest\n                for q_near in neighbors:\n                    if self._collision_free(q_near.position, self._q_new.position):\n                        cost_through_qnear = q_near.cost + self._cost(q_near.position, self._q_new.position)\n                        if cost_through_qnear < min_cost:\n                            min_cost = cost_through_qnear\n                            self._q_parent = q_near\n\n                # Attach new node\n                self._q_new.cost = min_cost\n                self._q_new.parent = self._q_parent\n                self._graph[self._q_new.position] = self._q_new\n\n                # Rewire neighbors if we improve their cost\n                for q_near in neighbors:\n                    if q_near == self._q_parent:\n                        continue\n                    if self._collision_free(self._q_new.position, q_near.position):\n                        cost_to_neighbor = self._q_new.cost + self._cost(self._q_new.position, q_near.position)\n                        if cost_to_neighbor < q_near.cost:\n                            q_near.parent = self._q_new\n                            q_near.cost = cost_to_neighbor\n\n                self.key_frame()\n\n                # Check if goal reached (distance threshold)\n                if self._distance(self._q_new.position, grid.goal.position) < grid.get_movement_cost_from_index(0, grid.goal.position):\n                    self._goal_vertex = Vertex(grid.goal.position)\n                    self._goal_vertex.parent = self._q_new\n                    self._goal_vertex.cost = self._q_new.cost + self._cost(self._q_new.position, grid.goal.position)\n                    self._graph[self._goal_vertex.position] = self._goal_vertex\n                    found_path = True\n                    break\n\n        if found_path:\n            self._follow_path()\n        else:\n            # no path found within time limit\n            pass\n\n    def _init_graph(self, start_pos: Point) -> None:\n        \"\"\"Initialize the graph with the start vertex.\"\"\"\n        start_vertex = Vertex(start_pos)\n        start_vertex.cost = 0.0\n        start_vertex.parent = None\n        self._graph = {start_pos: start_vertex}\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random free position from the map.\n        Uses the map's random_sample API if available, else samples uniformly.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for _ in range(100):  # try 100 times max\n            sample = grid.random_sample()\n            if sample is not None and not grid.is_obstacle(sample):\n                return sample\n        # fallback: return goal if no random sample found avoid infinite loop\n        return grid.goal.position\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"Return the vertex in graph closest to the point.\"\"\"\n        nearest = None\n        min_dist = float('inf')\n        for v in self._graph.values():\n            dist = self._distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _near_vertices(self, point: Point, radius: float = 5.0) -> List[Vertex]:\n        \"\"\"Return graph vertices within radius distance from point.\"\"\"\n        neighbors = []\n        for v in self._graph.values():\n            if self._distance(v.position, point) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _steer(self, from_point: Point, to_point: Point, max_extend_length: float = 3.0) -> (Point, bool):\n        \"\"\"\n        Returns a new point in the direction from from_point to to_point \n        at distance no greater than max_extend_length.\n        Returns (new_point, is_valid) tuple.\n        \"\"\"\n        from_np = self._to_np(from_point)\n        to_np = self._to_np(to_point)\n        direction = to_np - from_np\n        dist = np.linalg.norm(direction)\n        if dist == 0:\n            return from_point, False\n        length = min(max_extend_length, dist)\n        direction = direction / dist\n        new_pos_np = from_np + direction * length\n        new_pos = self._to_point(new_pos_np)\n        return new_pos, True\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        \"\"\"\n        Checks if path from from_point to to_point is free of obstacles.\n        Uses map API for collision checking as necessary.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Sample intermediate points along the line and check collision\n        from_np = self._to_np(from_point)\n        to_np = self._to_np(to_point)\n        dist = np.linalg.norm(to_np - from_np)\n        steps = int(dist / 0.5) + 1\n        for i in range(steps + 1):\n            interm = from_np + (to_np - from_np) * (i / steps)\n            interm_point = self._to_point(interm)\n            if grid.is_obstacle(interm_point):\n                return False\n        return True\n\n    def _cost(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Returns the cost of moving from p1 to p2, \n        incorporating map's movement cost if available.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Use map's movement cost function if exists for the segment index 0\n        return grid.get_movement_cost_from_index(0, p2) + np.linalg.norm(np.array(p2) - np.array(p1)) * 0.001\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"Euclidean distance between two points.\"\"\"\n        return np.linalg.norm(np.array(p1) - np.array(p2))\n\n    def _to_np(self, point: Point) -> \"np.ndarray\":\n        return np.array(point)\n\n    def _to_point(self, arr: \"np.ndarray\") -> Point:\n        return Point(int(round(arr[0])), int(round(arr[1])))\n\n    def _follow_path(self) -> None:\n        \"\"\"Follow path from goal back to start, moving the agent step by step.\"\"\"\n        if self._goal_vertex is None:\n            return\n        grid: Map = self._get_grid()\n        path = []\n        curr = self._goal_vertex\n        while curr is not None:\n            path.append(curr.position)\n            curr = curr.parent\n        path.reverse()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, type(grid)):  # check if map is RosMap if needed\n                try:\n                    grid.publish_wp(grid.agent.position)\n                except Exception:\n                    pass\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm based on the RRT* (Rapidly-exploring Random Tree Star) approach,\n    which is a sample-based algorithm designed to efficiently explore large continuous spaces.\n    This algorithm incrementally builds a tree by randomly sampling points in the space, connecting them to\n    the nearest existing tree vertex if valid, and rewiring the tree to find lower-cost paths. It improves\n    upon standard RRT by optimizing the path through rewiring, thus improving path quality over time.\n    To ensure responsiveness, the algorithm terminates if no path is found within 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: List[Vertex] = []  # The tree vertices\n        self._goal_vertex: Optional[Vertex] = None\n\n        self._max_distance: float = 5.0  # max step size for extending the tree\n        self._goal_sample_rate: float = 0.1  # probability of sampling the goal point directly\n        self._search_radius: float = 10.0  # radius for rewiring neighbors\n\n        # Display colors for visualization\n        self._vertex_colour = self._services.state.views.add_colour(\"vertex colour\", Colour(0.2, 0.6, 0.9, 0.7))\n        self._path_colour = self._services.state.views.add_colour(\"path colour\", Colour(0.9, 0.2, 0.2, 0.9))\n\n        self._map_displays: List[MapDisplay] = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self._map_displays = [SolidIterableMapDisplay(self._services, (v.point for v in self._graph), self._vertex_colour, z_index=60)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        self._graph = [Vertex(start)]\n        self._goal_vertex = None\n\n        start_time = time()\n        max_duration = 30.0  # seconds\n\n        while (time() - start_time) < max_duration:\n            # Sample a random point in the map or the goal with probability goal_sample_rate\n            rnd_point = self._sample_free_point(goal, grid)\n\n            nearest_vertex = self._nearest_vertex(rnd_point)\n            new_point = self._steer(nearest_vertex.point, rnd_point, self._max_distance)\n\n            if not grid.is_location_valid(new_point):\n                continue\n\n            if not grid.is_path_free(nearest_vertex.point, new_point):\n                continue\n\n            new_vertex = Vertex(new_point)\n            # Choose parent with minimal cost within search radius\n            neighbors = self._near_vertices(new_vertex.point)\n            min_cost = nearest_vertex.cost + self._distance(nearest_vertex.point, new_vertex.point)\n            min_parent = nearest_vertex\n\n            for neighbor in neighbors:\n                if grid.is_path_free(neighbor.point, new_vertex.point):\n                    cost = neighbor.cost + self._distance(neighbor.point, new_vertex.point)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = neighbor\n\n            new_vertex.parent = min_parent\n            new_vertex.cost = min_cost\n            self._graph.append(new_vertex)\n\n            # Rewire neighbors if this new vertex offers a lower cost path\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if grid.is_path_free(new_vertex.point, neighbor.point):\n                    cost_through_new = new_vertex.cost + self._distance(new_vertex.point, neighbor.point)\n                    if cost_through_new < neighbor.cost:\n                        neighbor.parent = new_vertex\n                        neighbor.cost = cost_through_new\n\n            self.key_frame()\n\n            # Check if goal can be connected directly within max_distance\n            if self._distance(new_vertex.point, goal) <= self._max_distance and grid.is_path_free(new_vertex.point, goal):\n                goal_vertex = Vertex(goal, new_vertex)\n                goal_vertex.cost = new_vertex.cost + self._distance(new_vertex.point, goal)\n                self._graph.append(goal_vertex)\n                self._goal_vertex = goal_vertex\n                break\n\n        if self._goal_vertex is not None:\n            self._follow_back_trace()\n        else:\n            # Mark algorithm done without path found\n            self.key_frame()\n\n    def _sample_free_point(self, goal: Point, grid: Map) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            return goal\n        else:\n            # Sample uniformly from the map bounds\n            map_bounds = grid.get_bounds()  # expected to return (min_x, max_x, min_y, max_y)\n            x = random.uniform(map_bounds[0], map_bounds[1])\n            y = random.uniform(map_bounds[2], map_bounds[3])\n            sampled_point = Point(int(round(x)), int(round(y)))\n            return sampled_point\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        best_vertex = self._graph[0]\n        best_dist = self._distance(point, best_vertex.point)\n        for vertex in self._graph[1:]:\n            dist = self._distance(point, vertex.point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = vertex\n        return best_vertex\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        neighbors = []\n        r = self._search_radius\n        for vertex in self._graph:\n            if self._distance(point, vertex.point) <= r:\n                neighbors.append(vertex)\n        return neighbors\n\n    def _steer(self, from_p: Point, to_p: Point, max_dist: float) -> Point:\n        from_x, from_y = from_p\n        to_x, to_y = to_p\n        dist = self._distance(from_p, to_p)\n        if dist <= max_dist:\n            return to_p\n        else:\n            theta = math.atan2(to_y - from_y, to_x - from_x)\n            new_x = int(round(from_x + max_dist * math.cos(theta)))\n            new_y = int(round(from_y + max_dist * math.sin(theta)))\n            return Point(new_x, new_y)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])\n\n    def _follow_back_trace(self) -> None:\n        grid: Map = self._get_grid()\n\n        # Trace back from goal vertex to start vertex\n        trace: List[Point] = []\n        current = self._goal_vertex\n        while current is not None:\n            trace.append(current.point)\n            current = current.parent\n        trace.reverse()\n\n        # Move agent along the found path\n        for step in trace:\n            self.move_agent(step)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning algorithm based on RRT but enhancing efficiency using a bidirectional search \n    strategy (Bidirectional RRT). Instead of growing a single tree from start to goal, this algorithm grows two trees:\n    one from the start and one from the goal. In each iteration, a random sample is generated and used to extend \n    both trees towards each other when possible. Once the two trees connect, the algorithm extracts and traces the \n    path. This approach typically reduces the search time for a path compared to the vanilla RRT. \n\n    Additionally, this implementation includes a 30-second timeout check to stop searching if no path is found \n    within this duration.\n\n    It inherits all useful helper functions from the RRT structure and preserves API and display integration.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_start.edges_removable = False\n        \n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_goal.edges_removable = False\n\n        # For display, unify displays from both forests:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start),\n                              GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Provide displays from both trees plus parent displays\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse from RRT: step towards q_sample from q_near by max_dist limit\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Reuse random valid sample getter from RRT\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_connect_trees(self, q_new_start: Vertex) -> bool:\n        # Attempt to connect the new vertex from start tree to the nearest vertex in goal tree.\n        q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n        if q_near_goal.position == q_new_start.position:\n            return True  # Already connected points\n\n        if not self._get_grid().is_valid_line_sequence(\n            self._get_grid().get_line_sequence(q_new_start.position, q_near_goal.position)\n        ):\n            return False\n        \n        self._graph_start.add_edge(q_new_start, q_near_goal)   # Connect start tree to goal tree vertex\n\n        return self._get_grid().is_agent_in_goal_radius(agent_pos=q_near_goal.position)\n\n    def _extract_path_bidirectional(self, q_connect_start: Vertex, q_connect_goal: Vertex) -> None:\n        # Extract path from start root to q_connect_start\n        path_start: List[Vertex] = [q_connect_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Extract path from q_connect_goal to goal root\n        path_goal: List[Vertex] = [q_connect_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # Concatenate paths (start to goal)\n        full_path = path_start + path_goal\n\n        # Animate agent movement along path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        start_time = time.time()\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Timeout reached; no path found\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Extend start tree towards q_sample\n            q_near_start = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            if q_near_start.position == q_sample:\n                continue\n\n            q_new_start = self._get_new_vertex(q_near_start, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)):\n                continue\n            self._graph_start.add_edge(q_near_start, q_new_start)\n\n            # Attempt to connect start tree to goal tree\n            if self._try_connect_trees(q_new_start):\n                q_connect_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n                self._extract_path_bidirectional(q_new_start, q_connect_goal)\n                break\n\n            self.key_frame()\n\n            # Swap roles to grow goal tree towards a new sample (from goal tree's perspective)\n            q_sample_goal = self._get_random_sample()\n            q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample_goal)\n            if q_near_goal.position == q_sample_goal:\n                continue\n\n            q_new_goal = self._get_new_vertex(q_near_goal, q_sample_goal, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)):\n                continue\n            self._graph_goal.add_edge(q_near_goal, q_new_goal)\n\n            # Attempt to connect goal tree to start tree\n            q_near_start_check = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_new_goal.position)\n            if q_near_start_check.position != q_new_goal.position:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_goal.position, q_near_start_check.position)):\n                    self._graph_goal.add_edge(q_new_goal, q_near_start_check)\n                    if self._get_grid().is_agent_in_goal_radius(agent_pos=q_near_start_check.position):\n                        self._extract_path_bidirectional(q_near_start_check, q_new_goal)\n                        break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on the Rapidly-exploring Random Tree (RRT*) method.\nThis sample-based approach incrementally builds a tree of feasible paths in the configuration\nspace by sampling random points, connecting them to the nearest existing vertex, and rewiring\nto optimize path cost. It is asymptotically optimal, often faster than grid-based A* in large or\ncomplex spaces. The implementation includes a 30-second timeout to prevent excessive runtime.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph: List[Vertex] = []\n        self._radius_neighbour: float = 3.0  # radius for rewiring neighbors\n        self._max_samples: int = 10000\n        self._goal_tolerance: float = 1.0  # distance to goal to consider path found\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Colours for display\n        self._vertex_colour = self._services.state.views.add_colour(\"rrt vertices\", Colour(0.0, 0.7, 0.0, 0.8))\n        self._edge_colour = self._services.state.views.add_colour(\"rrt edges\", Colour(0.0, 0.5, 0.5, 0.7))\n        self.__map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Use solid points for vertices and lines for edges (if available)\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph, vertex_colour=self._vertex_colour,\n                                              edge_colour=self._edge_colour, z_index=50)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        self._init_rrt_star()\n\n        grid: Map = self._get_grid()\n        start_time = time.time()\n\n        for i in range(self._max_samples):\n            # timeout check\n            if time.time() - start_time > 30.0:\n                # time exceeded, consider no path found\n                self.key_frame()\n                return\n\n            x_rand = self._get_random_sample()\n            v_near = self._nearest_vertex(x_rand)\n            if v_near is None:\n                continue\n\n            x_new = self._steer(v_near.point, x_rand)\n\n            if not grid.is_valid_position(x_new):\n                continue\n\n            if self._collision_free(v_near.point, x_new):\n                v_new = Vertex(x_new, v_near)\n                v_new.cost = v_near.cost + self._distance(v_near.point, x_new)\n\n                # find neighbors for potential rewiring\n                neighbors = self._near_vertices(x_new, self._radius_neighbour)\n\n                # choose parent with lowest cost\n                v_best = v_near\n                c_best = v_new.cost\n\n                for v_nei in neighbors:\n                    if self._collision_free(v_nei.point, x_new):\n                        c_new = v_nei.cost + self._distance(v_nei.point, x_new)\n                        if c_new < c_best:\n                            v_best = v_nei\n                            c_best = c_new\n\n                # attach new vertex to best parent\n                v_new.parent = v_best\n                v_new.cost = c_best\n                self._graph.append(v_new)\n\n                # rewire neighbors to new vertex if it improves cost\n                for v_nei in neighbors:\n                    if v_nei == v_best:\n                        continue\n                    if self._collision_free(v_new.point, v_nei.point):\n                        c_nei = v_nei.cost\n                        c_new_to_nei = v_new.cost + self._distance(v_new.point, v_nei.point)\n                        if c_new_to_nei < c_nei:\n                            v_nei.parent = v_new\n                            v_nei.cost = c_new_to_nei\n\n                # Check if close to goal\n                if self._distance(v_new.point, grid.goal.position) <= self._goal_tolerance:\n                    if self._goal_vertex is None or v_new.cost + self._distance(v_new.point, grid.goal.position) < self._goal_vertex.cost:\n                        self._goal_vertex = v_new\n\n            if (i % 50) == 0:\n                self.key_frame()\n\n        # Path found if goal vertex is set\n        if self._goal_vertex is not None:\n            self._follow_back_trace(self._goal_vertex.point)\n        else:\n            # No path found; optionally key_frame for visualization\n            self.key_frame()\n\n    def _init_rrt_star(self) -> None:\n        self._graph = []\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position, None)\n        start_vertex.cost = 0.0\n        self._graph.append(start_vertex)\n        self._goal_vertex = None\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniform random sample within the map boundaries.\"\"\"\n        grid = self._get_grid()\n        min_x, max_x, min_y, max_y = grid.get_bounds()  # Assume this returns the limits (x_min, x_max, y_min, y_max)\n        while True:\n            x = np.random.uniform(min_x, max_x)\n            y = np.random.uniform(min_y, max_y)\n            sample = Point(int(round(x)), int(round(y)))\n            if grid.is_valid_position(sample):\n                return sample\n\n    def _nearest_vertex(self, point: Point) -> Optional[Vertex]:\n        if not self._graph:\n            return None\n        dist_list = [(self._distance(v.point, point), v) for v in self._graph]\n        dist_list.sort(key=lambda x: x[0])\n        return dist_list[0][1]\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        arr1 = np.array(p1)\n        arr2 = np.array(p2)\n        return float(np.linalg.norm(arr1 - arr2))\n\n    def _steer(self, from_p: Point, to_p: Point, max_len: float = 5.0) -> Point:\n        \"\"\"Return a new point moved from from_p toward to_p by at most max_len.\"\"\"\n        from_arr = np.array(from_p, dtype=float)\n        to_arr = np.array(to_p, dtype=float)\n        direction = to_arr - from_arr\n        dist = np.linalg.norm(direction)\n        if dist == 0:\n            return from_p\n        direction /= dist\n        length = min(max_len, dist)\n        new_point = from_arr + direction * length\n        new_point_int = Point(int(round(new_point[0])), int(round(new_point[1])))\n        return new_point_int\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        \"\"\"Return list of vertices within radius of the given point.\"\"\"\n        near = []\n        for v in self._graph:\n            if self._distance(v.point, point) <= radius:\n                near.append(v)\n        return near\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Check if path between p1 and p2 is collision free using the grid's API.\"\"\"\n        grid = self._get_grid()\n        # Use Bresenham line or similar discrete line traversal between p1 and p2\n        x1, y1 = p1\n        x2, y2 = p2\n\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        x, y = x1, y1\n\n        n = 1 + dx + dy\n        x_inc = 1 if x2 > x1 else -1\n        y_inc = 1 if y2 > y1 else -1\n        error = dx - dy\n        dx *= 2\n        dy *= 2\n\n        for _ in range(n):\n            pt = Point(x, y)\n            if not grid.is_valid_position(pt):\n                return False\n            if error > 0:\n                x += x_inc\n                error -= dy\n            else:\n                y += y_inc\n                error += dx\n\n        return True\n\n    def _follow_back_trace(self, end_point: Point) -> None:\n        grid: Map = self._get_grid()\n        # reconstruct path from end_point to start\n        path: List[Point] = []\n        vertex = None\n        for v in self._graph:\n            if v.point == end_point:\n                vertex = v\n                break\n        if vertex is None:\n            return\n        while vertex.parent is not None:\n            path.append(vertex.point)\n            vertex = vertex.parent\n        path.append(vertex.point)  # start vertex\n        path.reverse()\n\n        for t in path:\n            self.move_agent(t)\n            self.key_frame(ignore_key_frame_skip=True)\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Description:\n    This algorithm implements an improved RRT-based planner, inspired by the original RRT approach.\n    It integrates two key improvements to enhance runtime efficiency:\n    1) Goal biasing: A fixed probability to sample the goal directly each iteration, accelerating convergence.\n    2) Parent rewiring: After adding a new vertex, it attempts to rewire nearby vertices to this new node if it yields\n       a shorter and valid path, similar to RRT*, improving path quality on-the-fly.\n    Additionally, the search is bounded to 30 seconds, after which it aborts and treats the path as unfound.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Needed for rewiring edges in RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        \"\"\"Same as original RRT method: moves from q_near toward q_sample up to max_dist.\"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_sample_rate=0.1) -> Point:\n        \"\"\"\n        Samples a random position with goal biasing.\n        With probability goal_sample_rate, returns the goal position.\n        Otherwise, samples uniformly from valid positions.\n        \"\"\"\n        goal_pos = self._get_grid().goal.position\n        if np.random.random() < goal_sample_rate and self._get_grid().is_agent_valid_pos(goal_pos):\n            return goal_pos\n\n        attempts = 0\n        max_attempts = 1000\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # Fallback to goal if no free sample found (unlikely)\n        return goal_pos\n\n    def _find_nearby_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"Find vertices in graph within radius of q_new.position.\"\"\"\n        nearby = []\n        for v in self._graph.vertices:\n            if torch.norm(v.position.to_tensor() - q_new.position.to_tensor()) <= radius:\n                nearby.append(v)\n        return nearby\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent for q_new among q_near_candidates by minimum cost from root\n        with valid edge from candidate to q_new.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in q_near_candidates:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = self._graph.get_cost_from_root(q_near) + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        For each vertex in nearby_vertices, attempts to rewire its parent to q_new\n        if the path through q_new improves cost and the edge is valid.\n        \"\"\"\n        for q_near in nearby_vertices:\n            if q_near == q_new.parents[0] if q_new.parents else None:\n                continue  # skip current parent\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            current_cost = self._graph.get_cost_from_root(q_near)\n            new_cost = self._graph.get_cost_from_root(q_new) + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            if new_cost < current_cost:\n                # Perform rewiring: remove old edge(s) and add new edge from q_new to q_near\n                self._graph.remove_parent(q_near)\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extracts and moves agent along path from start to goal by following parent chain.\n        Similar to original.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Follow parents until root\n        while len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]  # There should be only one parent\n            path.append(parent)\n\n        path.pop()  # Remove the root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10\n        max_iterations: int = 20000\n        goal_radius = self._get_grid().goal.radius\n\n        start_time = time.time()\n\n        while True:\n            if time.time() - start_time > 30.0:\n                # Timeout, treat as no path found\n                break\n\n            if max_iterations <= 0:\n                break\n            max_iterations -= 1\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=0.1)\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            # If line invalid, skip\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # RRT* style: find nearby within radius r = gamma*(log(n)/n)^{1/d}\n            n_vertices = len(self._graph.vertices) + 1\n            gamma_rrt_star = 50.0  # tuning parameter\n            dimension = self._get_grid().size.n_dim\n            r = min(max_dist, gamma_rrt_star * ((np.log(n_vertices) / n_vertices) ** (1/dimension)))\n\n            nearby_vertices = self._find_nearby_vertices(q_new, r)\n            parent_candidates = nearby_vertices if len(nearby_vertices) > 0 else [q_near]\n\n            best_parent = self._choose_parent(parent_candidates, q_new)\n            if best_parent is None:\n                # If no suitable parent found, skip\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(q_new, nearby_vertices)\n\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n            if dist_to_goal <= goal_radius:\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star).\n    This algorithm improves the basic RRT by rewiring the tree to find shorter paths progressively,\n    thus optimizing the path cost over time. It also implements a timeout of 30 seconds to stop the search\n    if no path is found within that time. The algorithm maintains a graph similar to RRT but after adding\n    a new vertex, it checks nearby vertices for better parent connections (rewiring step),\n    resulting in more efficient paths and faster convergence compared to basic RRT.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_iterations: int = 10000\n        search_start_time = time.time()\n        radius = 15.0  # Radius for neighborhood rewiring\n\n        def vertex_cost(vertex: Vertex) -> float:\n            # Compute cost from root to this vertex by summing up edge distances along parents\n            cost = 0.0\n            cur = vertex\n            while len(cur.parents) > 0:\n                parent = next(iter(cur.parents))\n                cost += (cur.position.to_tensor() - parent.position.to_tensor()).norm().item()\n                cur = parent\n            return cost\n\n        def find_nearest_vertex(vertices: List[Vertex], point: Point) -> Vertex:\n            return self._graph.get_nearest_vertex(vertices, point)\n\n        def near_vertices(q_new: Vertex) -> List[Vertex]:\n            # Find vertices within radius of q_new\n            near_list = []\n            for v in self._graph.vertices:\n                dist = (v.position.to_tensor() - q_new.position.to_tensor()).norm().item()\n                if dist <= radius:\n                    near_list.append(v)\n            return near_list\n\n        def rewire(q_new: Vertex, near_list: List[Vertex]) -> None:\n            for q_near in near_list:\n                if q_near == q_new:\n                    continue\n                # Check if path from q_new to q_near is possible and offers lower cost\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_through_qnew = vertex_cost(q_new) + (q_new.position.to_tensor() - q_near.position.to_tensor()).norm().item()\n                    if cost_through_qnew < vertex_cost(q_near):\n                        # Remove existing edges from q_near parents\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                        # Add edge from q_new to q_near (rewiring)\n                        self._graph.add_edge(q_new, q_near)\n\n        def choose_parent(q_near_list: List[Vertex], q_new_position: Point) -> Optional[Vertex]:\n            min_cost = inf\n            best_parent = None\n            for q_near in q_near_list:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost = vertex_cost(q_near) + (q_near.position.to_tensor() - q_new_position.to_tensor()).norm().item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = q_near\n            return best_parent\n\n        def extract_path(q_goal: Vertex) -> None:\n            path: List[Vertex] = [q_goal]\n\n            while len(path[-1].parents) != 0:\n                parent = next(iter(path[-1].parents))\n                path.append(parent)\n\n            path.reverse()\n\n            for p in path:\n                self.move_agent(p.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        for _ in range(max_iterations):\n            # Check timeout of 30 seconds\n            if time.time() - search_start_time > 30.0:\n                # Timeout reached, treat as not found and return\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = find_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Prevent adding vertex outside the valid map\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            near_list = near_vertices(q_new)\n            best_parent = choose_parent(near_list, q_new.position)\n            if best_parent is None:\n                # If no suitable parent found, fallback to q_near\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            rewire(q_new, near_list)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect last vertex to goal directly if possible\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    extract_path(goal_vertex)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an optimized sampling-based planner inspired by RRT* (Rapidly-exploring Random Tree Star).\n    Unlike A*, which operates on a discrete grid, this method efficiently explores the space by incrementally building a tree\n    of collision-free paths through random sampling. It improves over standard RRT by rewiring nearby vertices to optimize path cost,\n    resulting in faster convergence toward an optimal path. It also enforces a 30-seconds timeout to bound planning time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    max_iterations: int\n    search_timeout: float\n    _graph: 'Forest'  # Assuming a graph structure representing the tree, defined elsewhere\n    _q_new: Optional[Point]  # New sampled node\n    _goal_reached_vertex: Optional['Vertex']\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self.max_iterations = 10000  # Max iterations for sampling\n        self.search_timeout = 30.0  # Max search time in seconds\n        self._graph = self._initialize_graph()\n        self._q_new = None\n        self._goal_reached_vertex = None\n        self._init_displays()\n\n    def _initialize_graph(self) -> 'Forest':\n        grid = self._get_grid()\n        root = grid.agent.position\n        # Assuming Forest class has an add_vertex method that accepts Point and cost (0 here)\n        forest = Forest(self._services)\n        forest.add_vertex(root, cost=0.0, parent=None)\n        return forest\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Add graph display from SampleBasedAlgorithm plus additional coloring if needed\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        goal_position = grid.goal.position\n        reached = False\n\n        for iteration in range(self.max_iterations):\n            if time.time() - start_time > self.search_timeout:\n                # Timeout reached; treat as no path found and exit\n                break\n\n            q_rand = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex(q_rand)\n            q_new = self._steer(q_nearest.position, q_rand, max_extend_length=grid.get_max_step_size())\n            if not grid.is_obstacle_free(q_nearest.position, q_new):\n                continue\n\n            cost_to_q_new = q_nearest.cost + grid.get_movement_cost(q_nearest.position, q_new)\n            neighbors = self._graph.get_near_vertices(q_new, radius=self._get_near_radius())\n\n            q_min_parent, min_cost = q_nearest, cost_to_q_new\n            # Choose best parent for q_new from neighbors\n            for q_near in neighbors:\n                if grid.is_obstacle_free(q_near.position, q_new):\n                    cost_candidate = q_near.cost + grid.get_movement_cost(q_near.position, q_new)\n                    if cost_candidate < min_cost:\n                        q_min_parent = q_near\n                        min_cost = cost_candidate\n\n            # Add q_new to graph with best parent\n            self._graph.add_vertex(q_new, cost=min_cost, parent=q_min_parent)\n            self._q_new = q_new\n\n            # Rewire neighbors to q_new if it improves cost\n            for q_near in neighbors:\n                if q_near == q_min_parent:\n                    continue\n                if grid.is_obstacle_free(q_new, q_near.position):\n                    cost_through_q_new = min_cost + grid.get_movement_cost(q_new, q_near.position)\n                    if cost_through_q_new < q_near.cost:\n                        self._graph.rewire_vertex(q_near, new_parent_position=q_new, new_cost=cost_through_q_new)\n\n            self.key_frame()\n\n            # Check if goal can be connected directly from q_new\n            if grid.is_obstacle_free(q_new, goal_position):\n                goal_cost = min_cost + grid.get_movement_cost(q_new, goal_position)\n                self._graph.add_vertex(goal_position, cost=goal_cost, parent=self._graph.find_vertex_by_position(q_new))\n                self._goal_reached_vertex = self._graph.find_vertex_by_position(goal_position)\n                reached = True\n                break\n\n        if reached:\n            path = self._get_path_from_goal()\n            path.reverse()\n            for point in path:\n                self.move_agent(point)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found; optionally can log or handle failure here\n            pass\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Generates a random sample point within the map bounds.\n        If a bias towards goal is desired, it could be implemented here.\n        \"\"\"\n        grid = self._get_grid()\n        # Assuming grid provides boundaries: x_min, x_max, y_min, y_max (2D)\n        x_min, x_max, y_min, y_max = grid.get_sampling_bounds()\n        import random\n        # 10% goal bias to speed convergence\n        if random.random() < 0.1:\n            return grid.goal.position\n        else:\n            xr = random.uniform(x_min, x_max)\n            yr = random.uniform(y_min, y_max)\n            return Point(xr, yr)\n\n    def _steer(self, from_point: Point, to_point: Point, max_extend_length: float) -> Point:\n        \"\"\"\n        Returns a new point moved from from_point towards to_point by maximum max_extend_length.\n        \"\"\"\n        vec = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = math.hypot(vec[0], vec[1])\n        if dist <= max_extend_length:\n            return to_point\n        else:\n            scale = max_extend_length / dist\n            new_x = from_point[0] + vec[0] * scale\n            new_y = from_point[1] + vec[1] * scale\n            return Point(new_x, new_y)\n\n    def _get_near_radius(self) -> float:\n        \"\"\"\n        Returns the radius to search for near neighbors for rewiring.\n        Typically depends on log of iteration number and free space dimensionality.\n        For simplicity, return a fixed radius or adapt if iteration count available.\n        \"\"\"\n        grid = self._get_grid()\n        # Could be tuned based on environment size; here using a default fixed radius\n        return 5.0\n\n    def _get_path_from_goal(self) -> List[Point]:\n        \"\"\"\n        Reconstruct the path from the goal vertex back to the root.\n        \"\"\"\n        path: List[Point] = []\n        vertex = self._goal_reached_vertex\n        while vertex is not None:\n            path.append(vertex.position)\n            vertex = vertex.parent\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an enhanced path planner called Informed RRT* (based on RRT*) \nwhich improves convergence speed by biasing samples toward the informed subset (an ellipsoidal region) \nonce a path to the goal is found. It thereby focuses the search on regions more likely to improve \nthe solution, reducing unnecessary exploration and improving runtime. It also enforces \na 30-seconds timeout to stop the search if no path is found.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Maintain best solution vertex found\n        self._best_goal_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipsoid(self, c_best: float, c_min: float, x_center: torch.Tensor,\n                             C: torch.Tensor) -> Point:\n        \"\"\"\n        Sample a random point uniformly from an ellipsoid defined by cost c_best,\n        minimum path cost c_min, transformation matrix C and center x_center.\n        Ref: Informed RRT* sampling\n        \"\"\"\n        dim = x_center.shape[0]\n        while True:\n            # Sample from unit n-ball\n            x_ball = torch.randn(dim)\n            x_ball /= torch.norm(x_ball)\n            r = torch.rand(1).item() ** (1/dim)  # Uniform radius distribution in n-dim ball\n            x_ball = x_ball * r\n            \n            # Scaling matrix for ellipsoid\n            L = torch.diag(torch.tensor([c_best/2] + [sqrt(c_best**2 - c_min**2)/2]*(dim-1)))\n            # Map sample from unit ball to ellipsoid\n            x_rand = torch.matmul(C, torch.matmul(L, x_ball)) + x_center\n\n            # Round and convert to Point and check validity\n            sample_point = Point.from_tensor(x_rand)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        c_best = float('inf')  # best solution cost so far\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        goal_vertex = Vertex(goal_pos)\n\n        # Precompute constants for informed sampling\n        c_min = torch.norm(start_pos.to_tensor() - goal_pos.to_tensor()).item()\n        x_center = ((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n        # Rotation matrix from unit vector in x to the vector from start to goal\n        a1 = (goal_pos.to_tensor() - start_pos.to_tensor())\n        unit_a1 = a1 / torch.norm(a1)\n        # Construct orthonormal basis C using Householder transform\n        eye = torch.eye(dimension)\n        v = unit_a1 - eye[:,0]\n        if torch.norm(v) < 1e-10:\n            C = eye\n        else:\n            v = v / torch.norm(v)\n            C = eye - 2 * torch.outer(v, v)\n        \n        for i in range(iterations):\n            # Check timeout\n            if time.time() - start_time > 30:\n                # Timeout no path found\n                break\n\n            # Select informed sample if solution found, else uniform random sample\n            if c_best < float('inf'):\n                q_sample = self._sample_in_ellipsoid(c_best, c_min, x_center, C)\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision for path from q_nearest to q_new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            q_new.cost = c_min_cost\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire tree\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reaches goal region with improved cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Calculate total cost through q_new to goal vertex\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor())\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < c_best:\n                    c_best = total_cost\n                    # Update best goal vertex and add edge from q_new to goal\n                    if self._best_goal_vertex is not None:\n                        # Remove previous edge if it exists\n                        for parent in self._best_goal_vertex.parents:\n                            self._graph.remove_edge(parent, self._best_goal_vertex)\n                    goal_vertex.cost = c_best\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    # Update center and rotation matrix again for sampling:\n                    x_center = ((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n                    # Already computed above, no change needed within same iteration\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT* with optimizations for faster convergence and pruning:\n    - Uses informed sampling (sampling within an ellipse defined by current best cost to goal) to focus exploration.\n    - Implements early stopping once cost thresholds or goal condition met.\n    - Limits rewiring radius dynamically based on the number of vertices.\n    - Stops planning after 30 seconds if no path found to prevent long waits.\n    This approach reduces exploration time by focusing the sampling around the best path found so far,\n    hence improving time efficiency compared to vanilla RRT*.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional members for informed sampling\n        self._best_cost = float('inf')\n        self._path_found = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample within an ellipse defined by start, goal, and current path cost c_best.\n        If no path found yet (c_best == inf), fallback to uniform random sampling.\n        \"\"\"\n        if c_best == float('inf'):\n            # No solution found yet, sample globally random\n            return self._get_random_sample()\n\n        # Convert Points to tensors\n        start_t = start.to_tensor()\n        goal_t = goal.to_tensor()\n\n        c_min = torch.norm(goal_t - start_t).item()\n        if c_best < c_min:\n            # Numerical stability fallback\n            c_best = c_min + 1e-6\n\n        # Define ellipse parameters\n        center = (start_t + goal_t) / 2\n        a1 = (goal_t - start_t) / c_min  # unit vector along start->goal\n\n        # Define rotation matrix to align with x-axis\n        # We want to rotate sampled point in standard ellipse coordinates back to world coords\n        # For 2D, rotation matrix:\n        # R = [a1, a2], where a2 is orthogonal vector to a1\n        # a1: unit vector start->goal\n        # a2: perpendicular vector\n\n        # perpendicular vector in 2D\n        a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n\n        # ellipse radii\n        r1 = c_best / 2\n        try:\n            r2_val = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n        except ValueError:\n            r2_val = 0.0\n        r2 = r2_val\n\n        # Sample random point in unit circle\n        while True:\n            # Sample from unit disk using polar coordinates\n            t = 2 * math.pi * np.random.random()\n            u = np.random.random() + np.random.random()\n            r = 2 - u if u > 1 else u  # triangular distribution for uniformity\n            \n            x_ball = r * math.cos(t)\n            y_ball = r * math.sin(t)\n\n            if x_ball ** 2 + y_ball ** 2 > 1:\n                continue\n\n            # Scale by ellipse radii\n            sample_ellipse = torch.tensor([x_ball * r1, y_ball * r2])\n\n            # Rotate and translate back to world coords\n            sample_world = center + sample_ellipse[0] * a1 + sample_ellipse[1] * a2\n\n            # Round and convert to Point (integral grid coordinates)\n            sample_coords = torch.round(sample_world).to(torch.int64)\n            sample_point = Point(*sample_coords.tolist())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Timeout exceeded, stop search\n                break\n\n            # Informed sampling: sample smarter in ellipse based on best cost found\n            q_sample: Point = self._informed_sample(start_vertex.position, goal_pos, self._best_cost)\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose minimum cost parent\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices to new vertex if it improves cost\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost if better\n                goal_dist = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor())\n                total_cost = q_new.cost + goal_dist\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    self._path_found = True\n                    self._extract_path(q_new)\n                break\n\n            # Update best cost if new vertex is closer to goal with valid path\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            possible_cost = q_new.cost + dist_to_goal\n            if possible_cost < self._best_cost:\n                self._best_cost = possible_cost\n\n            self.key_frame()\n\n        if not self._path_found:\n            # No path found: can optionally log or mark failure\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved version of the RRT algorithm, \ncalled RRT-Connect. It grows two trees simultaneously: one from the start \nand one from the goal, trying to connect them in each iteration, which improves \nthe convergence speed and reduces planning time compared to the basic RRT. \n\nThe search terminates either when a connecting path is found or when the time \nlimit of 30 seconds is exceeded. Path extraction then follows the connected trees \nto form a complete route from start to goal.\n\"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planner that incrementally builds a tree of feasible configurations. \nIt enhances the basic RRT by rewiring the tree to improve path quality, reducing total path cost and search time. \nA time limit of 30 seconds is imposed to stop the search if no path is found, improving practical runtime. \nCore improvements include: nearest vertex search based on path cost, rewiring within a neighborhood radius, and path cost tracking.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow edges removal for rewiring in RRT*\n        self._max_dist = 10.0\n        self._iterations = 10000\n        self._rewire_radius = 15.0  # radius within which to search for rewiring candidates\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Returns vertices within radius of q_new.position\n        near: List[Vertex] = []\n        for vertex in self._graph.get_all_vertices():\n            if torch.norm(q_new.position.to_tensor() - vertex.position.to_tensor()) <= radius:\n                near.append(vertex)\n        return near\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Calculate cost from root to this vertex by summing edge distances up the parents chain\n        cost = 0.0\n        current = vertex\n        while current.parents:\n            # parents list may contain multiple but we only track single parent in this tree, use first\n            parent = current.parents[0]\n            cost += torch.norm(current.position.to_tensor() - parent.position.to_tensor()).item()\n            current = parent\n        return cost\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent from candidates minimizing total cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in q_near_candidates:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                continue\n            cost = self._cost(near_v) + torch.norm(q_new.position.to_tensor() - near_v.position.to_tensor()).item()\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = near_v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        cost_q_new = self._cost(q_new)\n        for near_v in near_vertices:\n            if near_v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, near_v.position)):\n                continue\n            cost_through_q_new = cost_q_new + torch.norm(q_new.position.to_tensor() - near_v.position.to_tensor()).item()\n            cost_near_v = self._cost(near_v)\n            if cost_through_q_new < cost_near_v:\n                # Rewire near_v parent to q_new\n                self._graph.remove_edge_parents(near_v)  # Remove current parent edges to near_v\n                self._graph.add_edge(q_new, near_v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        while len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]\n            path.append(parent)\n\n        path.pop()  # Remove last duplicate start vertex\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        goal_vertex = Vertex(goal_pos)\n\n        # Add root vertices to tree if not already added\n        if not self._graph.root_vertex_start:\n            self._graph.root_vertex_start = Vertex(self._get_grid().agent.position)\n        if not self._graph.root_vertex_goal:\n            self._graph.root_vertex_goal = goal_vertex\n\n        for _ in range(self._iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:  # time limit exceeded\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near_candidates: List[Vertex] = self._graph.get_all_vertices()\n            if not q_near_candidates:\n                continue\n\n            # Find nearest vertex in terms of Euclidean distance for initial expansion\n            q_near = min(q_near_candidates, key=lambda v: torch.norm(v.position.to_tensor() - q_sample.to_tensor()).item())\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                continue\n\n            self._graph.add_edge(parent_vertex, q_new)\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex if reachable\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved sample-based path planning algorithm inspired by RRT*.\n    It incrementally builds a tree rooted at the agent's start position and rewires vertices to ensure \n    asymptotic optimality, improving path quality over time compared to classic RRT.\n    The algorithm stops either upon finding a feasible path to the goal or after 30 seconds timeout.\n    Key improvements over basic A* include probabilistic sampling for exploring large continuous spaces, \n    efficient local rewiring for path cost improvement, and lazy collision checking.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: Forest = Forest()\n        self._start_vertex: Optional[Vertex] = None\n        self._goal_vertex: Optional[Vertex] = None\n        self._goal_reached: bool = False\n        self._max_runtime_seconds: float = 30.0\n\n        # Display elements initialized in _init_displays() which will be called later\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self._graph.vertices, \n                                                      colour=Point(0, 1, 0, 0.5), z_index=50)]\n        \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        self._start_vertex = self._graph.add_vertex(start_pos)\n        self._goal_vertex = None\n        self._goal_reached = False\n\n        start_time = time.time()\n\n        # Number of iterations to attempt sampling (or until timeout / goal reached)\n        max_iterations = 10000\n\n        for i in range(max_iterations):\n            # Check timeout\n            if time.time() - start_time > self._max_runtime_seconds:\n                # Timeout exceeded -> stop search and treat route as not found\n                break\n            \n            sample_point = self._get_random_sample()\n            nearest_vertex = self._graph.get_nearest_vertex(sample_point)\n\n            new_point = self._steer(nearest_vertex.position, sample_point)\n            if not grid.is_traversable(new_point):\n                continue\n            if not grid.check_line_of_sight(nearest_vertex.position, new_point):\n                # Obstacle in path between nearest_vertex and new_point\n                continue\n            \n            # Add new vertex but first connect with best parent within neighborhood radius\n            new_vertex = self._graph.add_vertex(new_point)\n            radius = self._calc_neighborhood_radius(len(self._graph.vertices))\n            neighbors = self._graph.get_vertices_within_radius(new_point, radius)\n\n            # Initialize best parent as nearest vertex and cost as cost to reach it\n            best_parent = nearest_vertex\n            best_cost = nearest_vertex.cost + self._distance(nearest_vertex.position, new_point)\n\n            for neighbor in neighbors:\n                # Check if path is collision free and if vertex is cheaper to reach through neighbor\n                if grid.check_line_of_sight(neighbor.position, new_point):\n                    cost_through_neighbor = neighbor.cost + self._distance(neighbor.position, new_point)\n                    if cost_through_neighbor < best_cost:\n                        best_parent = neighbor\n                        best_cost = cost_through_neighbor\n            \n            # Connect new vertex to best parent\n            self._graph.add_edge(best_parent, new_vertex)\n            new_vertex.cost = best_cost\n            new_vertex.parent = best_parent\n\n            # Rewire neighbors to the new vertex if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                if grid.check_line_of_sight(new_point, neighbor.position):\n                    cost_through_new = new_vertex.cost + self._distance(new_point, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        # Rewire neighbor\n                        old_parent = neighbor.parent\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.cost = cost_through_new\n                        neighbor.parent = new_vertex\n            \n            self.key_frame()\n\n            # Check if goal is within radius and can be connected with no collision\n            if self._distance(new_point, goal_pos) <= radius and grid.check_line_of_sight(new_point, goal_pos):\n                # Add goal vertex and connect it\n                self._goal_vertex = self._graph.add_vertex(goal_pos)\n                self._graph.add_edge(new_vertex, self._goal_vertex)\n                self._goal_vertex.cost = new_vertex.cost + self._distance(new_point, goal_pos)\n                self._goal_vertex.parent = new_vertex\n                self._goal_reached = True\n                break\n\n        if self._goal_reached:\n            path = self._extract_path(self._goal_vertex)\n            self._follow_back_trace(path)\n        # else no path found or timeout -> no movement occurs\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random point in the free space of the map.\n        Incorporates goal biasing with 10% chance to sample goal directly.\n        \"\"\"\n        from numpy.random import uniform\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        # 10% goal biasing\n        if uniform(0, 1) < 0.1:\n            return goal_pos\n\n        width = grid.width()\n        height = grid.height()\n\n        while True:\n            x = uniform(0, width)\n            y = uniform(0, height)\n            point = Point(x, y)\n            if grid.is_traversable(point):\n                return point\n\n    def _steer(self, from_point: Point, to_point: Point, max_step: float = 1.0) -> Point:\n        \"\"\"\n        Returns a new point moved from from_point towards to_point by at most max_step distance.\n        \"\"\"\n        vec = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = (vec[0] ** 2 + vec[1] ** 2) ** 0.5\n        if dist <= max_step:\n            return to_point\n        scale = max_step / dist\n        new_x = from_point[0] + vec[0] * scale\n        new_y = from_point[1] + vec[1] * scale\n        return Point(new_x, new_y)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between two points\n        \"\"\"\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5\n\n    def _calc_neighborhood_radius(self, num_vertices: int) -> float:\n        \"\"\"\n        Radius for neighborhood search using RRT* heuristic.\n        \"\"\"\n        map_area = self._get_grid().width() * self._get_grid().height()\n        gamma_rrt_star = 30.0  # tuning parameter, typical values 20-50\n        radius = min(\n            10.0,\n            gamma_rrt_star * ((map_area / (3.14159 * num_vertices)) ** 0.5)\n        )\n        return radius\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Extracts the path from start to goal by following parent links.\n        \"\"\"\n        path: List[Point] = []\n        current = goal_vertex\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n        return path\n\n    def _follow_back_trace(self, path: List[Point]) -> None:\n        \"\"\"\n        Moves the agent step by step along the path points.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, Map) and hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT with goal biasing and adaptive sampling radius.\n    This algorithm incorporates a goal bias to sample the goal position with a certain probability to \n    speed up convergence towards the goal. It also adapts the maximum extension distance dynamically \n    based on progress. The implementation includes a 30-second timeout to prevent long-running searches.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n        # Parameters for improved sampling\n        self._goal_sample_rate = 0.15    # Probability to sample the goal (goal bias)\n        self._max_dist_min = 3.0          # Minimum max step\n        self._max_dist_max = 15.0         # Maximum max step\n        self._max_dist = 10.0             # Initial max step\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample_goal_bias(self) -> Point:\n        \"\"\"\n        Sample randomly with a bias towards the goal\n        \"\"\"\n        import numpy as np\n        if np.random.random() < self._goal_sample_rate:\n            # Sample goal point directly\n            return self._get_grid().goal.position\n        else:\n            # Otherwise uniform random sample in valid position\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adapt_max_dist(self, newly_added: bool, iteration: int) -> None:\n        \"\"\"\n        Adapt the max_dist based on progress and iteration count.\n        If new node was added, increase max_dist slowly to encourage exploration.\n        If no node added for a long time, decrease to focus on local refinements.\n        \"\"\"\n        if newly_added:\n            # Increase max_dist but cap at max_dist_max\n            self._max_dist = min(self._max_dist + 0.5, self._max_dist_max)\n        else:\n            # Decrease max_dist slowly but not below min threshold\n            if iteration % 100 == 0:\n                self._max_dist = max(self._max_dist - 0.5, self._max_dist_min)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # Always take the first parent (tree structure)\n            path.append(path[-1].parents[0])\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations: int = 10000\n        start_time = time.time()\n        last_added = False\n\n        for i in range(max_iterations):\n            # Timeout if running for more than 30 seconds\n            if (time.time() - start_time) > 30.0:\n                # No path found within time limit\n                break\n\n            q_sample: Point = self._get_random_sample_goal_bias()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self._adapt_max_dist(newly_added=False, iteration=i)\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n            self._adapt_max_dist(newly_added=True, iteration=i)\n            last_added = True\n\n        # If here, path not found within max_iterations or timeout; no action needed (fail quietly) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved RRT-based planner inspired by the baseline RRT.\nIt adds goal biasing during sampling to accelerate convergence towards the goal,\nand uses a rewiring step similar to RRT* to improve path quality and reduce total cost\nby connecting new nodes through lower-cost parents when possible.\nAdditionally, it imposes a 30-second timeout on the path search to prevent excessive computation.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring for improved paths\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_sample_rate: float = 0.2) -> Point:\n        \"\"\"\n        Samples randomly in the map with a probability of goal_sample_rate to sample the goal directly.\n        This biases the tree growth towards the goal for faster convergence.\n        \"\"\"\n        grid = self._get_grid()\n        if np.random.random() < goal_sample_rate:\n            return grid.goal.position\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within given radius of q_new.position.\n        \"\"\"\n        near_vertices: List[Vertex] = []\n        q_new_tensor = q_new.position.to_tensor()\n        for v in self._graph.vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor)\n            if dist <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex, max_dist: float) -> Vertex:\n        \"\"\"\n        Chooses best parent from the list of near vertices for q_new based on cost.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n\n        for q_near in near_vertices:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                best_parent = q_near\n\n        if best_parent is None:\n            # fallback to single nearest vertex if no near vertices are connected validly\n            best_parent = self._graph.get_nearest_vertex(self._graph.vertices, q_new.position)\n\n        # Set cost and parent accordingly\n        q_new.cost = min_cost if best_parent is not None else 0.0\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire near vertices to q_new if cost can be improved.\n        \"\"\"\n        grid = self._get_grid()\n        pos_new_tensor = q_new.position.to_tensor()\n        for q_near in near_vertices:\n            if q_near == q_new.parents[0] if q_new.parents else None:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_near.position.to_tensor() - pos_new_tensor)\n            if cost_through_new < q_near.cost:\n                # Remove old edge(s) - assume one parent in typical tree structure\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect last sampled point close to goal vertex to goal vertex\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # go through parents, only single parent assumed (tree)\n            parent = path[-1].parents[0]\n            path.append(parent)\n\n        del path[-1]  # remove root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 10000\n        goal_sample_rate: float = 0.2\n        rewire_radius: float = 15.0\n\n        start_time = time.time()\n        grid = self._get_grid()\n\n        for iteration in range(iterations):\n            if (time.time() - start_time) > 30.0:\n                # Timeout, path search failed\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find nearby vertices for parent selection & rewiring\n            near_vertices: List[Vertex] = self._near_vertices(q_new, rewire_radius)\n\n            best_parent: Vertex = self._choose_parent(near_vertices, q_new, max_dist)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewiring near vertices to improve path cost\n            self._rewire(q_new, near_vertices)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This implementation is an improved sample-based path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star). \nIt incrementally grows a search tree by randomly sampling points in the map, connecting them to the nearest vertex \nin the tree while rewiring connections to ensure near-optimal paths. This approach significantly improves time \nefficiency over exhaustive A* on grids by avoiding full grid expansion, and it utilizes heuristic sampling \nand rewiring to optimize the path quality. The implementation also stops searching if no solution is found \nwithin 30 seconds, treating it as not found to maintain responsiveness in complex maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Sample-based planner inspired by RRT* algorithm for improved performance over A* in large/complex maps.\n    It grows a tree of vertices by sampling and locally optimizing the path by rewiring neighbors.\n    Stops after 30 seconds if no path found.\n    \"\"\"\n    _graph: Set[Vertex]\n    _vertex_map: Dict[Point, Vertex]\n    _max_distance: float\n    _goal_radius: float\n    _goal_vertex: Optional[Vertex]\n    _map: Map\n    _pq_colour_max: DynamicColour\n    _pq_colour_min: DynamicColour\n    _visited_colour: DynamicColour\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        self._graph = set()\n        self._vertex_map = {}\n        self._goal_vertex = None\n        self._max_distance = 5.0  # max step length for a new edge; can be tuned\n        self._goal_radius = 2.0   # radius to consider goal reached\n\n        self._map = self._get_grid()\n\n        self._pq_colour_max = self._services.state.views.add_colour(\"rrt star max\", BLUE)\n        self._pq_colour_min = self._services.state.views.add_colour(\"rrt star min\", Colour(0.3, 0.4, 0.5, 0.3))\n        self._visited_colour = self._services.state.views.add_colour(\"rrt star visited\", Colour(0.2, 0.55, 0.3, 0.8))\n\n        self.__map_displays = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.monotonic()\n        start_point = self._map.agent.position\n        goal_point = self._map.goal.position\n\n        root_vertex = Vertex(start_point)\n        self._graph.add(root_vertex)\n        self._vertex_map[start_point] = root_vertex\n\n        found_goal = False\n\n        # Set initial pause for keyframe visualization\n        self.key_frame()\n\n        while True:\n            current_time = time.monotonic()\n            if current_time - start_time > 30.0:\n                # Timeout no path found\n                break\n\n            q_rand = self._get_random_sample()\n\n            q_nearest = self._nearest_vertex(q_rand)\n            q_new_point = self._steer(q_nearest.point, q_rand, self._max_distance)\n            if not self._map.is_valid_position(q_new_point):\n                # Invalid position (e.g. obstacle)\n                continue\n            if self._map.is_collision_between(q_nearest.point, q_new_point):\n                # Path blocked by obstacle, skip\n                continue\n\n            q_new = Vertex(q_new_point)\n            q_new.parent = q_nearest\n            q_new.cost = q_nearest.cost + self._map.get_movement_cost(q_nearest.point, q_new_point)\n            self._graph.add(q_new)\n            self._vertex_map[q_new_point] = q_new\n\n            # Rewire neighbors within radius to reduce costs\n            radius = self._get_neighbour_radius(len(self._graph))\n            neighbors = self._near_vertices(q_new_point, radius)\n\n            for q_neighbor in neighbors:\n                if q_neighbor == q_nearest:\n                    continue\n                if self._map.is_collision_between(q_neighbor.point, q_new_point):\n                    continue\n                new_cost = q_new.cost + self._map.get_movement_cost(q_new_point, q_neighbor.point)\n                if new_cost < q_neighbor.cost:\n                    # Rewire\n                    if q_neighbor.parent is not None:\n                        q_neighbor.parent.children.discard(q_neighbor)\n                    q_neighbor.parent = q_new\n                    q_neighbor.cost = new_cost\n                    q_new.children.add(q_neighbor)\n\n            q_nearest.children.add(q_new)\n\n            self.key_frame()\n\n            # Check if goal is reached (within radius)\n            if self._distance(q_new_point, goal_point) <= self._goal_radius:\n                if not self._map.is_collision_between(q_new_point, goal_point):\n                    found_goal = True\n                    self._goal_vertex = Vertex(goal_point)\n                    self._goal_vertex.parent = q_new\n                    self._goal_vertex.cost = q_new.cost + self._map.get_movement_cost(q_new_point, goal_point)\n                    self._graph.add(self._goal_vertex)\n                    self._vertex_map[goal_point] = self._goal_vertex\n                    q_new.children.add(self._goal_vertex)\n                    break\n\n        if found_goal:\n            path = self._extract_path(self._goal_vertex)\n            for p in path:\n                self.move_agent(p)\n                if isinstance(self._map, RosMap):\n                    self._map.publish_wp(self._map.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        # else no path found, do nothing\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling with goal probability 0.1 to improve goal-directed growth\n        goal_point = self._map.goal.position\n        if np.random.rand() < 0.1:\n            return goal_point\n        else:\n            xmin, ymin = self._map.get_min_bounds()\n            xmax, ymax = self._map.get_max_bounds()\n            return Point(np.random.uniform(xmin, xmax), np.random.uniform(ymin, ymax))\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        # Linear search for nearest vertex in the tree - can be optimized\n        nearest_v = None\n        min_dist = float('inf')\n        for v in self._graph:\n            d = self._distance(v.point, point)\n            if d < min_dist:\n                min_dist = d\n                nearest_v = v\n        assert nearest_v is not None\n        return nearest_v\n\n    def _steer(self, from_point: Point, to_point: Point, max_length: float) -> Point:\n        dist = self._distance(from_point, to_point)\n        if dist <= max_length:\n            return to_point\n        else:\n            direction = np.array(to_point) - np.array(from_point)\n            direction_norm = direction / dist\n            new_point_arr = np.array(from_point) + direction_norm * max_length\n            return Point(float(new_point_arr[0]), float(new_point_arr[1]))\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(np.linalg.norm(np.array(p1) - np.array(p2)))\n\n    def _get_neighbour_radius(self, num_vertices: int) -> float:\n        # Radius strategy per RRT* theoretical guarantees: gamma * (log(n)/n)^(1/d)\n        # Here d = 2 for 2D space, gamma chosen as 20 for practical tuning\n        if num_vertices <= 1:\n            return self._max_distance\n        gamma = 20.0\n        r = gamma * (np.log(num_vertices) / num_vertices) ** 0.5\n        return max(r, self._max_distance)\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        neighbors = []\n        radius_sq = radius * radius\n        point_np = np.array(point)\n        for v in self._graph:\n            if np.sum((np.array(v.point) - point_np) ** 2) <= radius_sq:\n                neighbors.append(v)\n        return neighbors\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        path = []\n        current = goal_vertex\n        while current is not None:\n            path.append(current.point)\n            current = current.parent\n        path.reverse()\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This is an improved sample-based path planning algorithm inspired by RRT-Connect but enhanced by incorporating heuristics that bias sampling towards the goal region, \nresulting in faster convergence. Instead of purely random sampling, this approach uses goal-biased sampling to reduce unnecessary exploration.\nAdditionally, a timeout has been added to terminate the search after 30 seconds if no path is found.\nThis algorithm preserves the bidirectional tree growth and connection strategy of RRT-Connect but improves efficiency by focusing growth in promising areas.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% goal bias sampling\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_goal_biased_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # Return the goal position directly for biased sampling\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n\n            # Timeout check - end search if > 30 seconds\n            curr_time = time.time()\n            if curr_time - start_time > 30:\n                # No path found within allowed time\n                break\n\n            q_rand: Point = self._get_goal_biased_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on Rapidly-exploring Random Tree (RRT*) that\n    incrementally builds a tree of feasible paths by sampling the space and rewiring \n    connections for asymptotic optimality.\n    The algorithm balances exploration and exploitation by connecting new samples with \n    the best parent to reduce path cost, while rewiring nearby nodes to improve existing paths.\n    This sample-based approach can perform better in large, high-dimensional, or complex\n    discrete grid environments by avoiding exhaustive search and improving path quality over time.\n    The search is time-limited to 30 seconds to prevent excessive runtime without success.\n    \"\"\"",
     "code": "self.g = {}\n            self.h = {}\n\n    mem: InternalMemory\n\n    pq_colour_max: DynamicColour\n    pq_colour_min: DynamicColour\n    visited_colour: DynamicColour\n\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        self.mem = AStar.InternalMemory(self._services)\n\n        self.pq_colour_max = self._services.state.views.add_colour(\"explored max\", BLUE)\n        self.pq_colour_min = self._services.state.views.add_colour(\"explored min\", Colour(0.27, 0.33, 0.35, 0.2))\n        self.visited_colour = self._services.state.views.add_colour(\"visited\", Colour(0.19, 0.19, 0.2, 0.8))\n\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self.mem.visited, self.visited_colour, z_index=50),\n                               GradientListMapDisplay(self._services, self.mem.priority_queue, min_colour=self.pq_colour_min,\n                                                  max_colour=self.pq_colour_max, z_index=49, inverted=True)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Read super description\n        \"\"\"\n        return super().set_display_info() + self.__map_displays\n\n    # noinspection PyUnusedLocal\n    # @profile\n    def _find_path_internal(self) -> None:\n        self._init_mem()\n\n        if self._expand():\n            self._follow_back_trace()\n\n    def _init_mem(self) -> None:\n        grid: Map = self._get_grid()\n\n        # push agent\n        self.mem.g[grid.agent.position] = 0\n        item: Tuple[float, Point] = (self.get_heuristic(grid.agent.position), grid.agent.position)\n        self.mem.priority_queue.push(item)\n        self.mem.back_pointer[grid.agent.position] = None\n\n    def _expand(self) -> bool:\n        grid: Map = self._get_grid()\n\n        while len(self.mem.priority_queue) > 0:\n            total_dist: float\n            next_node: Point\n            # peek and check if we need to terminate\n            total_dist, next_node = self.mem.priority_queue.pop()\n\n            if grid.is_goal_reached(next_node):\n                self.mem.priority_queue.push((total_dist, next_node))\n                return True\n\n            self.mem.visited.add(next_node)\n\n            for n, idx in grid.get_next_positions_with_move_index(next_node):\n                if n not in self.mem.visited:\n                    dist = grid.get_movement_cost_from_index(idx, n)\n                    if n not in self.mem.g or self.mem.g[next_node] + dist < self.mem.g[n]:\n                        # it does not matter if we have duplicates as we will not be looking at them\n                        # therefore it does not affect the priority\n                        self.mem.g[n] = self.mem.g[next_node] + dist\n                        item = (self.f(n), n)\n                        self.mem.priority_queue.push(item)\n                        self.mem.back_pointer[n] = next_node\n\n            self.key_frame()\n        return False\n\n    def f(self, x: Point) -> float:\n        g = self.mem.g[x]\n        h = self.get_heuristic(x)\n        ret = g + h\n        return ret\n\n    def _follow_back_trace(self):\n        grid: Map = self._get_grid()\n        \n        trace: List[Point] = self.get_back_trace(grid.goal)\n        trace.reverse()\n        for t in trace:\n            self.move_agent(t)\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def get_back_trace(self, goal: Goal) -> List[Point]:\n        \"\"\"\n        Follows the back pointer until it gets to the agent position\n        :return: The trace\n        \"\"\"\n        trace = []\n        pos = goal.position\n        while self.mem.back_pointer[pos] is not None:\n            trace.append(pos)\n            pos = self.mem.back_pointer[pos]\n        return trace\n\n    def get_heuristic(self, pos: Point) -> float:\n        \"\"\"\n        Returns the euclidean distance from the given position to the goal\n        It does memoization as well\n        :param goal: The goal\n        :param pos: The initial position\n        :return:\n        \"\"\"\n        self.mem.h.setdefault(pos, np.linalg.norm(np.array(pos) - np.array(self._get_grid().goal.position)))\n        return self.mem.h[pos]\n\nPlease help us create a new algorithm with improved time by modifying the provided algorithm. \nIdentify the backbone idea in the provided algorithms.\nThe class you generate must inherit from `SampleBasedAlgorithm`, which itself inherits from `Algorithm`.\n\nYou must conform to this interface structure and override the required abstract methods, including:\n- `set_display_info(self) -> List[MapDisplay]`\n- `_find_path_internal(self) -> None`\n\n\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\n\n### Constraints:\n- Please write a brief description of the algorithm you generated.\n- The description must be inside a brace and placed at the very top of the code.\n- Implement it in Python.\n- You do not need to declare the imports, as they are already provided in the codebase.\n- Your class must be named `PathPlanning`.\n- It must inherit from `SampleBasedAlgorithm` which inherits 'Algorithm'.(you can utilize the existing methods from `SampleBasedAlgorithm` and `Algorithm`).\n- You must reuse existing helper functions where applicable. If necessary, you may define and use new helper functions to support the implementation.\n- It should work with existing components: `Forest`, `Point`, `Vertex`, etc.\n- The `__init__` method must not be modified. However, you are allowed to add new member variables within it (no structural changes or logic modifications).\n- When referencing multiple algorithms, don't forget to declare variables in __init__.\n- The core logic of the path planning algorithm must be implemented inside the `_find_path_internal` function. You may call any helper functions from within `_find_path_internal`.\n- Analyze the usage patterns and conventions from the provided codebase (e.g., class structure, function calls, and service access), and ensure your code follows the same patterns.\n- All variables or objects used in the code must be explicitly declared before use. Do not use undeclared variables, even if they appear to be implied from context.\n- If the reference code uses specific variable declarations (e.g., `self._graph`, `self._q_new`, 'self._get_random_sample', etc.), ensure these are preserved and correctly initialized before being used.\n- Always verify that any newly introduced variables are properly initialized and assigned in a contextually valid location.\n- Do not assume the existence of any variables that are not shown in the provided reference code. If a variable is required, define it explicitly and ensure it is logically scoped.\n- After code generation, you must review the code to ensure it is syntactically correct, logically coherent, and executable within the expected environment.\n- Add code to treat a route search as not found if it takes more than 30 seconds to find the route.(in function `_find_path_internal`)\n\n### You may freely define new helper functions if necessary\n- If your approach benefits from additional utility methods (e.g., cost estimation, region sampling, custom distance functions), feel free to create and use them.\n\n### The `_find_path_internal` function is the main function executed for path planning.\n\n\n### Constraints:\n- Please write a brief description of the algorithm you generated.\n- The description must be inside a brace and placed at the very top of the code.\n- Implement it in Python.\n- You do not need to declare the imports, as they are already provided in the codebase.\n- Your class must be named `PathPlanning`.\n- It must inherit from `SampleBasedAlgorithm` which inherits 'Algorithm'.(you can utilize the existing methods from `SampleBasedAlgorithm` and `Algorithm`).\n- You must reuse existing helper functions where applicable. If necessary, you may define and use new helper functions to support the implementation.\n- It should work with existing components: `Forest`, `Point`, `Vertex`, etc.\n- The `__init__` method must not be modified. However, you are allowed to add new member variables within it (no structural changes or logic modifications).\n- When referencing multiple algorithms, don't forget to declare variables in __init__.\n- The core logic of the path planning algorithm must be implemented inside the `_find_path_internal` function. You may call any helper functions from within `_find_path_internal`.\n- Analyze the usage patterns and conventions from the provided codebase (e.g., class structure, function calls, and service access), and ensure your code follows the same patterns.\n- All variables or objects used in the code must be explicitly declared before use. Do not use undeclared variables, even if they appear to be implied from context.\n- If the reference code uses specific variable declarations (e.g., `self._graph`, `self._q_new`, 'self._get_random_sample', etc.), ensure these are preserved and correctly initialized before being used.\n- Always verify that any newly introduced variables are properly initialized and assigned in a contextually valid location.\n- Do not assume the existence of any variables that are not shown in the provided reference code. If a variable is required, define it explicitly and ensure it is logically scoped.\n- After code generation, you must review the code to ensure it is syntactically correct, logically coherent, and executable within the expected environment.\n- Add code to treat a route search as not found if it takes more than 30 seconds to find the route.(in function `_find_path_internal`)\n\n### You may freely define new helper functions if necessary\n- If your approach benefits from additional utility methods (e.g., cost estimation, region sampling, custom distance functions), feel free to create and use them.\n\n### The `_find_path_internal` function is the main function executed for path planning.\n\n\nDo not give additional explanations. ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved sample-based path planning algorithm \n    inspired by RRT* (Rapidly-exploring Random Tree Star). \n\n    Unlike classic A* which operates on a grid, this algorithm incrementally builds a tree in continuous space, \n    using random sampling to explore the map efficiently and improve the path cost over time.\n\n    It samples random points, tries to connect them to the nearest existing tree vertices, rewires \n    nearby vertices to maintain optimal cost paths, and stops once it finds a path to the goal or time exceeds 30s.\n\n    This approach reduces pathfinding time especially in high-dimensional or large spaces compared to exhaustive search.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = set()  # type: Set[Vertex]\n        self._vertices = {}  # type: Dict[Point, Vertex]\n        self._q_new: Optional[Vertex] = None\n        self._radius: float = 5.0  # Radius for rewiring (can be tuned based on map scale)\n        self._goal_vertex: Optional[Vertex] = None\n        self._max_iter: int = 10000\n        self._map = self._get_grid()\n\n        # Initialize display list\n        self._display_graph = GraphMapDisplay(self._services, self._graph)\n        self._map_displays = [self._display_graph]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._init_graph()\n\n        found_path = False\n        iter_count = 0\n\n        while iter_count < self._max_iter:\n            iter_count += 1\n            if (time.time() - start_time) > 30.0:\n                # Timeout condition: no path found within 30s\n                break\n\n            x_sample = self._get_random_sample()\n\n            nearest_vertex = self._nearest_vertex(x_sample)\n            x_new = self._steer(nearest_vertex.position, x_sample)\n\n            if not self._map.is_walkable(x_new):\n                # Ignore sample in obstacles or invalid\n                continue\n\n            if self._collision_free(nearest_vertex.position, x_new):\n                new_vertex = Vertex(x_new)\n                new_vertex.parent = nearest_vertex\n                new_vertex.cost = nearest_vertex.cost + self._distance(nearest_vertex.position, x_new)\n\n                neighbors = self._near_vertices(new_vertex.position)\n\n                min_cost = new_vertex.cost\n                min_parent = nearest_vertex\n\n                # Choose best parent from neighbors for new vertex to optimize path cost\n                for neighbor in neighbors:\n                    if self._collision_free(neighbor.position, new_vertex.position):\n                        cost_through_neighbor = neighbor.cost + self._distance(neighbor.position, new_vertex.position)\n                        if cost_through_neighbor < min_cost:\n                            min_cost = cost_through_neighbor\n                            min_parent = neighbor\n\n                new_vertex.parent = min_parent\n                new_vertex.cost = min_cost\n\n                self._graph.add(new_vertex)\n                self._vertices[new_vertex.position] = new_vertex\n\n                # Rewire neighbors to new vertex if it improves their cost\n                for neighbor in neighbors:\n                    if neighbor == min_parent:\n                        continue\n                    if self._collision_free(new_vertex.position, neighbor.position):\n                        cost_through_new = new_vertex.cost + self._distance(new_vertex.position, neighbor.position)\n                        if cost_through_new < neighbor.cost:\n                            neighbor.parent = new_vertex\n                            neighbor.cost = cost_through_new\n\n                # Check if new vertex connects to goal\n                if self._map.is_goal_reached(new_vertex.position):\n                    self._goal_vertex = new_vertex\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        if found_path:\n            path_points = self._build_path(self._goal_vertex)\n            # Move agent along the path\n            for pt in path_points:\n                self.move_agent(pt)\n                if isinstance(self._map, RosMap):\n                    self._map.publish_wp(self._map.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n    def _init_graph(self) -> None:\n        self._graph.clear()\n        self._vertices.clear()\n\n        start_pos = self._map.agent.position\n        start_vertex = Vertex(start_pos)\n        start_vertex.parent = None\n        start_vertex.cost = 0.0\n\n        self._graph.add(start_vertex)\n        self._vertices[start_pos] = start_vertex\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random point within the map's bounds.\n        With some probability, sample the goal to bias exploration.\n        \"\"\"\n        goal_pos = self._map.goal.position\n\n        # Probability to sample goal to help directed search\n        goal_sample_prob = 0.1\n\n        import random\n        if random.random() < goal_sample_prob:\n            return goal_pos\n\n        xmin, ymin = self._map.bounds_min\n        xmax, ymax = self._map.bounds_max\n\n        while True:\n            x = random.uniform(xmin, xmax)\n            y = random.uniform(ymin, ymax)\n            pt = (x, y)\n            if self._map.is_walkable(pt):\n                return pt\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Find the nearest vertex in the tree to the given point by Euclidean distance.\n        \"\"\"\n        nearest = None\n        nearest_dist = math.inf\n        for vertex in self._graph:\n            dist = self._distance(vertex.position, point)\n            if dist < nearest_dist:\n                nearest_dist = dist\n                nearest = vertex\n        return nearest\n\n    def _steer(self, from_pt: Point, to_pt: Point, max_dist: float = 1.0) -> Point:\n        \"\"\"\n        Move from 'from_pt' towards 'to_pt' by at most max_dist.\n        \"\"\"\n        from_arr = np.array(from_pt)\n        to_arr = np.array(to_pt)\n        direction = to_arr - from_arr\n        length = np.linalg.norm(direction)\n        if length <= max_dist:\n            return to_pt\n        direction = direction / length\n        new_point = from_arr + direction * max_dist\n        return tuple(new_point)\n\n    def _collision_free(self, from_pt: Point, to_pt: Point) -> bool:\n        \"\"\"\n        Check if path between from_pt and to_pt is free of obstacles.\n        Uses map's line collision checking capability or samples line with fine discretization.\n        \"\"\"\n        # We use the map's method if it exists, else fallback to manual checking\n        if hasattr(self._map, \"line_collision_free\"):\n            return self._map.line_collision_free(from_pt, to_pt)\n\n        # fallback manual collision checking with steps\n        steps = int(math.ceil(self._distance(from_pt, to_pt) / 0.1))\n        if steps == 0:\n            steps = 1\n        for i in range(steps + 1):\n            interp = np.array(from_pt) + (np.array(to_pt) - np.array(from_pt)) * (i / steps)\n            pt = tuple(interp)\n            if not self._map.is_walkable(pt):\n                return False\n        return True\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(np.linalg.norm(np.array(p1) - np.array(p2)))\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"\n        Find all vertices in the graph within self._radius distance of the point.\n        \"\"\"\n        near = []\n        for vertex in self._graph:\n            if self._distance(vertex.position, point) <= self._radius:\n                near.append(vertex)\n        return near\n\n    def _build_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Traverse parents from goal vertex back to start vertex to build path.\n        Returns path from start to goal.\n        \"\"\"\n        path = []\n        v = goal_vertex\n        while v is not None:\n            path.append(v.position)\n            v = v.parent\n        path.reverse()\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star).\n    This sample-based algorithm incrementally builds a tree rooted at the agent's start position,\n    samples random points in the environment, and attempts to connect them to the existing tree to\n    find an optimized path avoiding obstacles. It improves over basic RRT by rewiring the tree locally\n    to shorten paths, thus approximating the optimal path asymptotically. The algorithm terminates\n    once it finds a path to the goal or after 30 seconds timeout.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: Dict[Point, List[Point]] = {}  # adjacency list for tree graph\n        self._cost: Dict[Point, float] = {}  # cost from start to node\n        self._parent: Dict[Point, Optional[Point]] = {}  # parent pointer for path reconstruction\n\n        self._vertex_set: Set[Point] = gen_set(self._services)  # all vertices in the tree\n\n        # Display components\n        self.__map_displays: List[MapDisplay] = []\n\n    def _init_displays(self) -> None:\n        # Display vertices in the tree\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self._vertex_set,\n                                                      colour=self._services.state.views.add_colour(\"tree vertices\", Point(0.2, 0.7, 0.3, 0.8)),\n                                                      z_index=55)]\n        # call super to add parent displays if needed\n        super()._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        grid: Map = self._get_grid()\n        start: Point = grid.agent.position\n        goal: Point = grid.goal.position\n\n        # Initialize graph\n        self._graph.clear()\n        self._cost.clear()\n        self._parent.clear()\n        self._vertex_set.clear()\n\n        # Add start vertex\n        self._add_vertex(start, cost=0.0, parent=None)\n\n        max_iterations = 10000\n        radius = 10.0  # radius for neighbor searching to rewire (tune as needed)\n\n        found_goal = False\n\n        for _ in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 30.0:\n                # Treat as no path found due to timeout\n                return\n\n            # Sample random point in the map\n            q_rand: Point = self._get_random_sample()\n\n            # Find nearest vertex in tree\n            q_nearest: Point = self._nearest_vertex(q_rand)\n\n            # Steer from q_nearest toward q_rand with step size limit\n            q_new: Point = self._steer(q_nearest, q_rand, max_distance=5.0)\n\n            # Check collision for edge q_nearest -> q_new\n            if not self._collision_free(q_nearest, q_new):\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for potential rewiring\n            neighbors: List[Point] = self._near_vertices(q_new, radius)\n\n            # Choose best parent for q_new from neighbors (including q_nearest)\n            q_min, c_min = self._choose_parent(q_new, neighbors)\n\n            if q_min is None:\n                # No valid parent found; skip iteration\n                self.key_frame()\n                continue\n\n            self._add_vertex(q_new, cost=c_min, parent=q_min)\n\n            # Rewire neighbors if new connection is better\n            self._rewire(q_new, neighbors)\n\n            self.key_frame()\n\n            # Check if goal can be connected directly\n            if self._distance(q_new, goal) < 5.0 and self._collision_free(q_new, goal):\n                # Add goal to graph\n                self._add_vertex(goal, cost=self._cost[q_new] + self._distance(q_new, goal), parent=q_new)\n                found_goal = True\n                break\n\n        if found_goal:\n            self._follow_back_trace(goal)\n        # else we end with no path found\n\n    # ----- Helper methods -----\n\n    def _add_vertex(self, vertex: Point, cost: float, parent: Optional[Point]) -> None:\n        self._vertex_set.add(vertex)\n        self._cost[vertex] = cost\n        self._parent[vertex] = parent\n        self._graph.setdefault(vertex, [])\n        if parent is not None:\n            self._graph.setdefault(parent, []).append(vertex)\n\n    def _nearest_vertex(self, q_rand: Point) -> Point:\n        # Find vertex in self._vertex_set with minimum Euclidean distance to q_rand\n        best_vertex = None\n        min_dist = float('inf')\n        for v in self._vertex_set:\n            dist = self._distance(v, q_rand)\n            if dist < min_dist:\n                min_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _steer(self, from_point: Point, to_point: Point, max_distance: float) -> Point:\n        # Move from from_point towards to_point by max_distance, or less if closer\n        vec = np.array(to_point) - np.array(from_point)\n        dist = np.linalg.norm(vec)\n        if dist <= max_distance:\n            return to_point\n        else:\n            direction = vec / dist\n            new_point_np = np.array(from_point) + direction * max_distance\n            return Point(int(round(new_point_np[0])), int(round(new_point_np[1])))\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        # Check if path between p1 and p2 is free of obstacles using the map API\n        grid: Map = self._get_grid()\n        # Using line interpolation to check cells between p1 and p2\n        return grid.is_path_valid(p1, p2)\n\n    def _near_vertices(self, q_new: Point, radius: float) -> List[Point]:\n        # Return all vertices within radius of q_new\n        neighbors = []\n        for v in self._vertex_set:\n            if self._distance(v, q_new) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _choose_parent(self, q_new: Point, neighbors: List[Point]) -> Tuple[Optional[Point], float]:\n        # Choose the neighbor with minimal cost + cost to q_new among neighbors that can connect collision-free\n        min_cost = float('inf')\n        best_neighbor = None\n        grid: Map = self._get_grid()\n\n        for q_near in neighbors:\n            if not self._collision_free(q_near, q_new):\n                continue\n            cost = self._cost[q_near] + self._distance(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_neighbor = q_near\n\n        return best_neighbor, min_cost\n\n    def _rewire(self, q_new: Point, neighbors: List[Point]) -> None:\n        # Attempt to rewire neighbors to go through q_new if cheaper path found\n        grid: Map = self._get_grid()\n\n        for q_near in neighbors:\n            if q_near == self._parent.get(q_new, None):\n                continue  # Skip current parent\n            if not self._collision_free(q_new, q_near):\n                continue\n            new_cost = self._cost[q_new] + self._distance(q_new, q_near)\n            if new_cost < self._cost.get(q_near, float('inf')):\n                # Rewire q_near to q_new\n                old_parent = self._parent[q_near]\n                if old_parent is not None:\n                    if q_near in self._graph.get(old_parent, []):\n                        self._graph[old_parent].remove(q_near)\n                self._parent[q_near] = q_new\n                self._cost[q_near] = new_cost\n                self._graph.setdefault(q_new, []).append(q_near)\n                # Propagate cost updates downstream recursively\n                self._propagate_cost_update(q_near)\n\n    def _propagate_cost_update(self, vertex: Point) -> None:\n        # Recursively update children costs after rewiring\n        for child in self._graph.get(vertex, []):\n            new_cost = self._cost[vertex] + self._distance(vertex, child)\n            if new_cost < self._cost.get(child, float('inf')):\n                self._cost[child] = new_cost\n                self._propagate_cost_update(child)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return np.linalg.norm(np.array(p1) - np.array(p2))\n\n    def _follow_back_trace(self, goal: Point) -> None:\n        # Reconstruct path from goal to start and move agent along it\n        grid: Map = self._get_grid()\n        path: List[Point] = []\n\n        pos = goal\n        while pos is not None:\n            path.append(pos)\n            pos = self._parent.get(pos, None)\n\n        path.reverse()\n\n        for point in path:\n            self.move_agent(point)\n            if isinstance(grid, Map) and hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved sample-based path planning method inspired by RRT*,\n    which incrementally builds a tree of feasible paths in the continuous state space. \n    By sampling random points and rewiring the tree to maintain minimum cost paths to nodes, \n    it improves efficiency and path optimality over classical methods like A* on discrete grids.\n    \n    To improve time performance, it incorporates a timeout mechanism that halts the search \n    after 30 seconds if no path is found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        # Initialize the graph as a list of vertices (since we do not have Forest code explicitly)\n        self._graph: List[Vertex] = []\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Parameters for RRT* inspired approach\n        self._max_samples = 10000  # Max samples before timing out\n        self._neighborhood_radius = 5.0  # Radius to look around for rewiring\n\n        # Display initialization\n        self._map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Assuming GraphMapDisplay can be constructed with services and graph; else adjust accordingly.\n        from simulator.views.map.display.entities_map_display import EntitiesMapDisplay\n        from simulator.views.map.display.map_display import MapDisplay\n        \n        # Initialize map displays if empty\n        if not self._map_displays:\n            try:\n                from simulator.views.map.display.graph_map_display import GraphMapDisplay\n                self._map_displays = [GraphMapDisplay(self._services, self._graph)]\n            except ImportError:\n                # fallback if GraphMapDisplay unavailable\n                self._map_displays = []\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        self._graph.clear()\n        self._goal_vertex = None\n\n        # Insert start vertex\n        start_vertex = Vertex(start_pos, parent=None, cost=0.0)\n        self._graph.append(start_vertex)\n\n        start_time = time.time()\n        found_path = False\n\n        for _ in range(self._max_samples):\n            if time.time() - start_time > 30:\n                # Timeout: stop search without finding path\n                found_path = False\n                break\n\n            q_rand = self._get_random_sample()\n            q_near = self._nearest_vertex(q_rand)\n            q_new = self._steer(q_near, q_rand)\n\n            if not self._is_collision_free(q_near.point, q_new):\n                self.key_frame()\n                continue\n\n            # Initialize new vertex cost\n            new_cost = q_near.cost + self._cost(q_near.point, q_new)\n\n            # Find nearby vertices for rewiring\n            neighbors = self._near_vertices(q_new)\n\n            min_cost = new_cost\n            min_parent = q_near\n\n            # Choose the best parent for q_new\n            for neighbor in neighbors:\n                if self._is_collision_free(neighbor.point, q_new):\n                    cost = neighbor.cost + self._cost(neighbor.point, q_new)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = neighbor\n\n            q_new_vertex = Vertex(q_new, parent=min_parent, cost=min_cost)\n            self._graph.append(q_new_vertex)\n\n            # Rewire neighbors where q_new offers a lower cost path\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if self._is_collision_free(q_new, neighbor.point):\n                    cost_through_q_new = q_new_vertex.cost + self._cost(q_new, neighbor.point)\n                    if cost_through_q_new < neighbor.cost:\n                        neighbor.parent = q_new_vertex\n                        neighbor.cost = cost_through_q_new\n\n            # Check if goal can be connected directly to q_new\n            if self._distance(q_new, goal_pos) <= self._neighborhood_radius:\n                if self._is_collision_free(q_new, goal_pos):\n                    self._goal_vertex = Vertex(goal_pos, parent=q_new_vertex,\n                                              cost=q_new_vertex.cost + self._cost(q_new, goal_pos))\n                    self._graph.append(self._goal_vertex)\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        if found_path and self._goal_vertex is not None:\n            path = self._construct_path(self._goal_vertex)\n            for point in path:\n                self.move_agent(point)\n                if isinstance(grid, type(grid)):\n                    grid.publish_wp(grid.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        # else fail silently (no path found)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random free point from the map space\n        \"\"\"\n        grid: Map = self._get_grid()\n        width, height = grid.width, grid.height\n\n        import random\n\n        while True:\n            x = random.uniform(0, width - 1)\n            y = random.uniform(0, height - 1)\n            point = Point(int(round(x)), int(round(y)))\n            if not grid.is_obstacle(point):\n                return point\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Find vertex in graph closest to given point (Euclidean distance)\n        \"\"\"\n        nearest = None\n        min_dist = float('inf')\n        for vertex in self._graph:\n            dist = self._distance(vertex.point, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = vertex\n        return nearest\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, extend_length: float = 5.0) -> Point:\n        \"\"\"\n        Move from from_vertex.point towards to_point by max extend_length.\n        Return new point.\n        \"\"\"\n        from_point = from_vertex.point\n        dist = self._distance(from_point, to_point)\n        if dist <= extend_length:\n            return to_point\n        else:\n            direction = ((to_point[0] - from_point[0]) / dist, (to_point[1] - from_point[1]) / dist)\n            new_x = from_point[0] + direction[0] * extend_length\n            new_y = from_point[1] + direction[1] * extend_length\n            return Point(int(round(new_x)), int(round(new_y)))\n\n    def _is_collision_free(self, p1: Point, p2: Point) -> bool:\n        \"\"\"\n        Check collision-free path between p1 and p2 on the map by Bresenham's line algorithm.\n        \"\"\"\n        grid: Map = self._get_grid()\n        points = self._bresenham_line(p1, p2)\n        for pt in points:\n            if grid.is_obstacle(pt):\n                return False\n        return True\n\n    def _cost(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Cost function (Euclidean distance)\n        \"\"\"\n        return self._distance(p1, p2)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between points p1 and p2\n        \"\"\"\n        import math\n        return math.hypot(p1[0] - p2[0], p1[1] - p2[1])\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"\n        Return list of vertices in the graph within neighborhood radius of point.\n        \"\"\"\n        neighbors = []\n        for vertex in self._graph:\n            if self._distance(vertex.point, point) <= self._neighborhood_radius:\n                neighbors.append(vertex)\n        return neighbors\n\n    def _construct_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Construct path from start to goal by following parent links.\n        \"\"\"\n        path = []\n        node = goal_vertex\n        while node is not None:\n            path.append(node.point)\n            node = node.parent\n        path.reverse()\n        return path\n\n    def _init_displays(self) -> None:\n        # Initialize display info for this sample-based planner\n        self._map_displays = []\n        try:\n            from simulator.views.map.display.graph_map_display import GraphMapDisplay\n            self._map_displays.append(GraphMapDisplay(self._services, self._graph))\n        except ImportError:\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm improves upon RRT-Connect by incorporating informed sampling to focus exploration on\n    an ellipsoidal region bounded by the start and goal and the best current path cost. This reduces \n    unnecessary sampling in regions unlikely to improve the solution, thereby improving convergence time.\n    Additionally, the algorithm tracks elapsed time and aborts search if no path is found within 30 seconds.\n    The algorithm still uses a bi-directional tree connection approach inspired by RRT-Connect, but leverages\n    heuristic sampling from the informed set.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _time_limit: float\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._time_limit = 30.0  # seconds\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_informed(self, start: Point, goal: Point, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Samples a random point inside an ellipsoidal informed set defined by start, goal, and \n        current best path cost c_best. If c_best is None or infinite, fall back to uniform sampling.\n        \"\"\"\n        if c_best is None or math.isinf(c_best):\n            # Uniform random sample - fallback\n            return self._get_random_sample()\n        \n        # Distance between start and goal\n        c_min = start.distance(goal)\n        if c_min == 0:\n            # Start and goal coincide; return start\n            return start\n        \n        # Define ellipsoid axes lengths\n        a1 = c_best / 2.0  # major axis length semi\n        b = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best**2 - c_min**2 > 0 else 0.0  # minor axis semi\n        \n        # Sample unit ball in n-dim (here n=2 or general n_dim)\n        n_dim = self._get_grid().size.n_dim\n        \n        # sample random point in unit n-ball (uniform)\n        while True:\n            sample_unit = np.random.normal(0, 1, n_dim)\n            norm = np.linalg.norm(sample_unit)\n            if norm > 0:\n                sample_unit = sample_unit / norm\n                break\n        radius = np.random.uniform(0,1) ** (1/n_dim)  # scaled radius for uniform ball\n        sample_ball = sample_unit * radius\n        \n        # Rotation to align ellipse major axis with start->goal vector\n        start_to_goal = (goal.to_tensor() - start.to_tensor()).numpy()  # numpy array\n        start_to_goal_norm = np.linalg.norm(start_to_goal)\n        e1 = start_to_goal / start_to_goal_norm\n        \n        # Construct rotation matrix that maps x-axis unit vector to e1\n        # We assume 2D or n-D general with first axis aligned to start->goal vector\n        # Create orthonormal basis with e1 and others via Gram-Schmidt\n        U = np.zeros((n_dim, n_dim))\n        U[:, 0] = e1\n        \n        # Build orthonormal complement for n_dim > 1\n        if n_dim > 1:\n            # Using Gram-Schmidt for rest of basis vectors\n            basis = np.eye(n_dim)\n            count = 1\n            for i in range(n_dim):\n                v = basis[:, i]\n                # make orthogonal to e1\n                v = v - np.dot(v, e1) * e1\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    U[:, count] = v / norm_v\n                    count += 1\n                if count >= n_dim:\n                    break\n        else:\n            # 1D case, trivial\n            pass\n        \n        # Scale matrix (diagonal) with ellipse radii\n        L = np.diag([a1] + [b] * (n_dim - 1))\n        \n        # Map sample_ball to ellipse\n        mapped = np.dot(U, np.dot(L, sample_ball)) + (start.to_tensor() + goal.to_tensor()) / 2.0\n        sample_point = Point.from_tensor(torch.tensor(mapped))\n        \n        # validate sample inside map and collision free\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback uniform if invalid\n            return self._get_random_sample()\n\n    def _calculate_path_cost(self, vertices_path: List[Vertex]) -> float:\n        \"\"\"\n        Calculate the cost of a path as the sum of Euclidean distances between consecutive vertices.\n        \"\"\"\n        total_cost = 0.0\n        for i in range(1, len(vertices_path)):\n            p1 = vertices_path[i - 1].position\n            p2 = vertices_path[i].position\n            total_cost += p1.distance(p2)\n        return total_cost\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract path from the two trees and move the agent along the found path.\n        \"\"\"\n        # trace back mid to goal side\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = path_mid_to_b[-1].parents[0]\n            path_mid_to_b.append(parent)\n\n        # trace back start to mid side\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = path_a_to_mid[-1].parents[0]\n            path_a_to_mid.append(parent)\n        path_a_to_mid.reverse()\n        \n        path = path_a_to_mid + path_mid_to_b\n        \n        # If graph root vertices order inverted, reverse path\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n        \n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        best_path_cost: Optional[float] = math.inf\n        best_path_found: bool = False\n\n        for _ in range(self._iterations):\n            # Check time limit\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit:\n                # Exceeded time limit; stop search (no path found)\n                break\n\n            # Sample informed, using best_path_cost known so far\n            q_rand: Point = self._sample_informed(self._graph.root_vertices[0].position,\n                                                  self._graph.root_vertices[-1].position,\n                                                  best_path_cost)\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    # Extract path vertices\n                    # Compute cost of combined path for informed sampling\n                    path_mid_to_b: List[Vertex] = [self._q_new]\n                    while len(path_mid_to_b[-1].parents) != 0:\n                        path_mid_to_b.append(path_mid_to_b[-1].parents[0])\n                    path_a_to_mid: List[Vertex] = [self._extension_target]\n                    while len(path_a_to_mid[-1].parents) != 0:\n                        path_a_to_mid.append(path_a_to_mid[-1].parents[0])\n                    path_a_to_mid.reverse()\n                    combined_path = path_a_to_mid + path_mid_to_b\n                    \n                    path_cost = self._calculate_path_cost(combined_path)\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path_found = True\n                        self._extract_path()\n                        break\n                    \n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved RRT* variant called Bidirectional RRT*. \n    It grows two trees simultaneously: one from the start and one from the goal. \n    By attempting to connect the two trees during expansion, it can find a feasible path faster. \n    It preserves the rewiring optimization of RRT* to improve path costs iteratively.\n    Additionally, a 30-second timeout is used to stop search if no path is found in time. \n    This approach generally achieves faster convergence to a solution compared to single-tree RRT*.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Two forests: start -> goal and goal -> start\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._init_displays_bidirectional()\n\n    def _init_displays_bidirectional(self) -> None:\n        map_displays = [EntitiesMapDisplay(self._services),\n                        SolidIterableMapDisplay(self._services)]\n        # Add graph displays for both forests\n        if hasattr(self, '_graph_start') and hasattr(self, '_graph_goal'):\n            from algorithms.classic.sample_based.core.graph import GraphMapDisplay\n            map_displays.append(GraphMapDisplay(self._services, self._graph_start))\n            map_displays.append(GraphMapDisplay(self._services, self._graph_goal))\n        self.__map_displays = map_displays\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex_from(self, forest: Forest, q_sample: Point) -> Vertex:\n        return forest.get_nearest_vertex([forest.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius_from(self, forest: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return forest.get_vertices_within_radius([forest.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _rewire(self, forest: Forest, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, q_near.position))\n            cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if near_new_collision_free and cost_new_to_near < q_near.cost:\n                # Remove old edge\n                q_parent = None\n                for parent in q_near.parents:\n                    q_parent = parent\n                    break\n                if q_parent is not None:\n                    forest.remove_edge(q_parent, q_near)\n                # Add new edge and update cost\n                child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                q_near.cost = q_new.cost + child_parent_dist\n                forest.add_edge(q_new, q_near)\n\n    def _extract_bidirectional_path(self, q_connect_start: Vertex, q_connect_goal: Vertex) -> None:\n        # Build path from start root to q_connect_start\n        path_start: List[Vertex] = [q_connect_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Build path from q_connect_goal to goal root\n        path_goal: List[Vertex] = [q_connect_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # Concatenate paths (start->connect + connect->goal)\n        full_path = path_start + path_goal\n\n        # Move agent through path, with keyframes and waypoint publishing as before\n        for v in full_path:\n            self.move_agent(v.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp') and callable(grid.publish_wp):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self, q_new_start: Vertex, forest_goal: Forest, radius: float) -> Tuple[bool, Vertex, Vertex]:\n        # Attempt to connect q_new_start to nearest vertices in the goal tree within radius\n        Q_near_goal = self._get_vertices_within_radius_from(forest_goal, q_new_start, radius)\n\n        q_connect_goal = None\n        c_min = float('inf')\n\n        for q_goal in Q_near_goal:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_start.position, q_goal.position)):\n                continue\n            cost = q_new_start.cost + torch.norm(q_new_start.position.to_tensor() - q_goal.position.to_tensor()) + q_goal.cost\n            if cost < c_min:\n                c_min = cost\n                q_connect_goal = q_goal\n\n        if q_connect_goal is not None:\n            return True, q_new_start, q_connect_goal\n        return False, None, None\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time()\n\n        for i in range(iterations):\n            if time() - start_time > 30:\n                # Timeout: path not found in 30 seconds\n                break\n\n            # Alternate samples between trees to balance growth\n            if i % 2 == 0:\n                forest_a = self._graph_start\n                forest_b = self._graph_goal\n            else:\n                forest_a = self._graph_goal\n                forest_b = self._graph_start\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex_from(forest_a, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(forest_a.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius_from(forest_a, q_new, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            forest_a.add_edge(q_min, q_new)\n\n            self._rewire(forest_a, q_new, Q_near)\n\n            # Try to connect the two trees\n            connected, q_tree_a_connect, q_tree_b_connect = self._try_connect_trees(q_new, forest_b, radius)\n\n            if connected:\n                # Build and extract path from start to goal via q_tree_a_connect and q_tree_b_connect\n                if forest_a == self._graph_start:\n                    self._extract_bidirectional_path(q_tree_a_connect, q_tree_b_connect)\n                else:\n                    self._extract_bidirectional_path(q_tree_b_connect, q_tree_a_connect)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved RRT-inspired algorithm named PathPlanning.\n    It incorporates goal-bias sampling and a rewiring step inspired by RRT* to improve path quality and speed up convergence.\n    The algorithm balances exploration and exploitation by sampling the goal with a fixed probability and attempts to rewire nearby vertices to reduce path costs.\n    The search stops either when a path is found to the goal or when 30 seconds have elapsed.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring (remove edges)\n        self._init_displays()\n        # Parameters for algorithm tuning\n        self.max_dist: float = 10.0\n        self.iterations: int = 10000\n        self.goal_sample_rate: float = 0.1  # 10% of samples are the goal (goal bias)\n        self.rewire_radius: float = 15.0  # radius for rewiring nearby vertices\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse from RRT: Create new vertex in direction from q_near to q_sample with max_dist step limit\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_norm = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_norm)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # With probability self.goal_sample_rate, return goal position (goal bias)\n        if np.random.rand() < self.goal_sample_rate:\n            return self._get_grid().goal.position\n        # Otherwise random sample in valid position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Find vertices in the graph within a distance rewiring radius to q_new\n        near_vertices: List[Vertex] = []\n        q_new_tensor = q_new.position.to_tensor()\n        for vertex in self._graph.vertices:\n            dist = torch.norm(vertex.position.to_tensor() - q_new_tensor)\n            if dist <= self.rewire_radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Among near vertices, choose the parent that yields lowest cost path to q_new\n        # Cost is approximated as distance from start (root) vertex to parent + distance parent->q_new\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost_to_vertex = self._graph.get_cost_to_root(vertex)\n            edge_cost = torch.norm(vertex.position.to_tensor() - q_new.position.to_tensor()).item()\n            total_cost = cost_to_vertex + edge_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to rewire the near vertices if going through q_new reduces cost\n        cost_q_new = self._graph.get_cost_to_root(q_new)\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            cost_vertex = self._graph.get_cost_to_root(vertex)\n            edge_cost = torch.norm(q_new.position.to_tensor() - vertex.position.to_tensor()).item()\n            new_cost = cost_q_new + edge_cost\n            if new_cost < cost_vertex:\n                # Rewire vertex: remove edge from old parent and add edge from q_new\n                self._graph.remove_edge(vertex.parents[0], vertex)\n                self._graph.add_edge(q_new, vertex)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        if not self._graph.has_vertex(goal_v):\n            self._graph.add_vertex(goal_v)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Traverse parents back to root, forming path\n        while len(path[-1].parents) != 0:\n            path.append(path[-1].parents[0])\n\n        path.pop()  # remove root duplicate\n        path.reverse()\n\n        # Animate agent moving along the final path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Override display info, add graph display\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        root_vertex = self._graph.root_vertex_start\n\n        for i in range(self.iterations):\n            # Check for time limit exceeded\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Time exceeded, no path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self.max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get near vertices for rewiring and parent selection\n            near_vertices = self._near_vertices(q_new)\n            # Choose best parent from near vertices or q_near if none better\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire near vertices for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            # Visualize addition\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of the SPRM sample-based planner.\n    It combines the cyclic graph approach with a prioritized edge connection strategy \n    guided by heuristic distances (Euclidean distance) towards the goal.\n    Instead of connecting all vertices within a fixed radius, it only expands from vertices \n    likely to lead towards the goal, reducing unnecessary edge checks.\n    It uses an incremental sampling and connection process until a path is found or 30 seconds elapse.\n    This approach reduces the number of collision checks and speeds up pathfinding while maintaining completeness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        # Initialize samples and graph similarly to SPRM\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic_dist(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        v1 = p1.to_tensor()\n        v2 = p2.to_tensor()\n        return torch.norm(v1 - v2).item()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # Priority queue by heuristic distance from vertex to goal\n        # Using a simple list because heapq doesn't support decrease-key easily without extra complexity\n        open_set: List[Vertex] = [agent]\n        visited = set()\n        # Store cost from start to each vertex\n        cost_from_start = {agent: 0}\n        # Store the best connection towards the goal for each vertex\n        # Actually, connectivity in Vertex stores best next vertex towards goal as per SPRM usage.\n\n        while open_set:\n            # Check timeout\n            if time.time() - start_time > 30:\n                # No path found within time limit\n                return\n\n            # Sort open_set by f = g + heuristic (cost_from_start + heuristic_dist)\n            open_set.sort(key=lambda vertex: cost_from_start.get(vertex, math.inf) + self._heuristic_dist(vertex.position, goal.position))\n\n            current_vertex = open_set.pop(0)\n            visited.add(current_vertex)\n\n            # Try to connect current_vertex to nearby vertices that are closer to the goal\n            nearby_vertices = self._graph.get_vertices_within_radius(self._graph.vertices, current_vertex.position, self._max_radius)\n            for neighbor in nearby_vertices:\n                if neighbor is current_vertex:\n                    continue\n                # Only consider neighbor if not visited to limit expansion\n                if neighbor in visited:\n                    continue\n\n                # Only connect if line is valid (no collision)\n                line_seq = self._get_grid().get_line_sequence(current_vertex.position, neighbor.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    new_cost = cost_from_start[current_vertex] + torch.norm(current_vertex.position.to_tensor() - neighbor.position.to_tensor()).item()\n                    if neighbor not in cost_from_start or new_cost < cost_from_start[neighbor]:\n                        # Add/update edge both ways since cyclic graph\n                        self._graph.add_edge(current_vertex, neighbor)\n                        self._graph.add_edge(neighbor, current_vertex)\n                        cost_from_start[neighbor] = new_cost\n                        # Connectivity toward goal in SPRM is stored in current_vertex.connectivity[goal]\n                        # We'll maintain connectivity on the fly:\n                        # Connect current_vertex -> neighbor towards goal if neighbor is closer\n                        if neighbor not in current_vertex.connectivity or \\\n                           cost_from_start[neighbor] + self._heuristic_dist(neighbor.position, goal.position) < \\\n                           cost_from_start.get(current_vertex.connectivity.get(goal, None), math.inf) + \\\n                           (self._heuristic_dist(current_vertex.connectivity.get(goal, goal).position, goal.position) if current_vertex.connectivity.get(goal, None) else math.inf):\n                            current_vertex.connectivity[goal] = neighbor\n\n                        if current_vertex not in neighbor.connectivity or \\\n                           cost_from_start[current_vertex] + self._heuristic_dist(current_vertex.position, goal.position) < \\\n                           cost_from_start.get(neighbor.connectivity.get(goal, None), math.inf) + \\\n                           (self._heuristic_dist(neighbor.connectivity.get(goal, goal).position, goal.position) if neighbor.connectivity.get(goal, None) else math.inf):\n                            neighbor.connectivity[goal] = current_vertex\n\n                        if neighbor not in open_set:\n                            open_set.append(neighbor)\n\n                        self.key_frame()\n\n            # Check if path exists by connectivity from agent to goal\n            if goal in agent.connectivity:\n                self._extract_path()\n                return\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            next_vertex = current_vertex.connectivity.get(goal, None)\n            if next_vertex is None:\n                # Path broken, stop\n                break\n            current_vertex = next_vertex\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* with informed sampling to speed up convergence.\n    This algorithm integrates the Informed RRT* idea: after finding an initial solution, it samples \n    within an ellipsoidal subset of the search space that only contains paths better than the current best path.\n    This reduces wasted samples outside promising regions and accelerates path improvement.\n    The implementation also respects a 30-second timeout to terminate early if no path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # New member variable to hold current best solution cost (inf if none)\n        self._best_cost = float('inf')\n        self._best_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, c_best: float, c_min: float, x_center: torch.Tensor, C: torch.Tensor) -> Point:\n        \"\"\"\n        Samples a random point from an ellipsoidal subset defined by the current best cost c_best and minimum cost c_min.\n        The ellipsoid is defined in workspace coordinates, with center x_center and rotation matrix C.\n        \"\"\"\n        dim = 2\n        while True:\n            # Sample unit ball random point uniformly\n            rand_dir = torch.randn(dim)\n            rand_dir = rand_dir / torch.norm(rand_dir)\n            rand_radius = torch.pow(torch.rand(1), 1/dim)[0]\n            sample_unit_ball = rand_radius * rand_dir\n\n            # Radii of ellipsoid axes\n            r1 = c_best / 2\n            r2 = torch.sqrt(c_best**2 - c_min**2) / 2\n\n            # Sample point in ellipsoid coordinate frame\n            L = torch.diag(torch.tensor([r1, r2]))\n            sample_ellipsoid = x_center + C @ L @ sample_unit_ball\n\n            # Convert to Point and check validity\n            sample_coords = sample_ellipsoid.numpy()\n            sample_point = Point(int(round(sample_coords[0])), int(round(sample_coords[1])))\n\n            grid_size = self._get_grid().size.n_dim\n            # Check bounds\n            if any(sample_coords < 0) or any(sample_coords >= self._get_grid().size):\n                continue\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Override to use informed sampling after a first solution found.\n        Before first solution, uniform random samples are used.\n        \"\"\"\n        if self._best_cost == float('inf'):\n            # No solution yet, uniform sample\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling\n            start = self._graph.root_vertex_start.position.to_tensor()\n            goal = self._graph.root_vertex_goal.position.to_tensor()\n            c_min = torch.norm(goal - start)\n            c_best = self._best_cost\n\n            x_center = (start + goal) / 2\n            a1 = (goal - start) / torch.norm(goal - start)\n            # Construct rotation matrix C: 2D case\n            id1 = torch.tensor([1.0, 0.0])\n            v = a1 - id1\n            if torch.norm(v) < 1e-6:\n                C = torch.eye(2)\n            else:\n                a1 = a1.unsqueeze(1)  # column vector\n                ortho = torch.tensor([[0.0, -1.0], [1.0, 0.0]])\n                b1 = ortho @ a1\n                C = torch.cat([a1, b1], dim=1)\n\n            # Sample inside ellipsoid\n            return self._informed_sample(c_best, c_min, x_center, C)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Override to update best solution and move agent accordingly.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            # pick first parent to go backward\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]  # remove root start vertex duplicated\n        path.reverse()\n\n        # Move agent along path\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time()\n\n        for i in range(iterations):\n            if time() - start_time > 30.0:\n                # Timed out, fail gracefully\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)),max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring neighbors\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost & vertex if better path found\n                if q_new.cost < self._best_cost:\n                    self._best_cost = q_new.cost\n                    self._best_vertex = q_new\n                    self._extract_path(q_new)\n                    # Continue searching for better paths in time limit\n\n            self.key_frame()\n\n        # If best path found within iterations and time, move agent along best path if not moved yet\n        if self._best_vertex is not None:\n            self._extract_path(self._best_vertex) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT*, enhancing the original RRT by rewiring the tree to reduce path costs dynamically.\n    This algorithm not only randomly samples points and connects them similar to RRT but also attempts to find better parent nodes within a specified radius,\n    rewiring the tree to achieve shorter, more optimal paths over time, improving time efficiency by avoiding poor extensions.\n    It stops and treats no path found if it takes longer than 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _max_iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring for RRT*\n        self._max_dist = 15.0\n        self._max_iterations = 10000\n        self._rewire_radius = 30.0\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    # Override _get_new_vertex to return the new vertex point limited by max_dist (reuse from RRT pattern)\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Get all vertices within radius of q_new.position for rewiring.\n        \"\"\"\n        vertices_in_radius = []\n        q_new_pos_tensor = q_new.position.to_tensor()\n        # Search among all vertices in the graph.\n        all_vertices = list(self._graph.vertices.values())\n        for vertex in all_vertices:\n            dist = torch.norm(vertex.position.to_tensor() - q_new_pos_tensor)\n            if dist <= radius:\n                vertices_in_radius.append(vertex)\n        return vertices_in_radius\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        From candidate near vertices, find the best parent that results in minimal cost to q_new.\n        Cost is defined as cost from root to parent + distance(parent, q_new).\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        q_new_pos = q_new.position\n        grid = self._get_grid()\n\n        for q_near in q_near_vertices:\n            # Make sure path between q_near and q_new is valid\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new_pos)):\n                continue\n\n            # Compute cost to q_new through q_near\n            cost_to_near = self._graph.get_cost(q_near)\n            dist = torch.norm(q_new_pos.to_tensor() - q_near.position.to_tensor()).item()\n            total_cost = cost_to_near + dist\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = q_near\n\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        For each vertex in near_vertices, check if going through q_new results in lower cost.\n        If yes and path is valid, rewire by changing parent to q_new.\n        \"\"\"\n        grid = self._get_grid()\n        q_new_cost = self._graph.get_cost(q_new)\n        q_new_pos = q_new.position\n\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n\n            # Check if path from q_new to q_near is valid\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new_pos, q_near.position)):\n                continue\n\n            current_cost = self._graph.get_cost(q_near)\n            dist = torch.norm(q_near.position.to_tensor() - q_new_pos.to_tensor()).item()\n            new_cost = q_new_cost + dist\n\n            if new_cost < current_cost:\n                # Rewire edge: remove old edges connecting q_near to parents, and add new edge from q_new to q_near\n                self._graph.remove_all_parents_edges(q_near)\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_end: Vertex) -> None:\n        \"\"\"\n        Extract path from start to goal treating q_end as goal-connected vertex and move agent along it.\n        \"\"\"\n        # Create temporary goal vertex at goal position to finalize path with clean end vertex\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_end, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Move up parents to reconstruct path\n        current_vertex = goal_v\n        while len(current_vertex.parents) != 0:\n            parent = next(iter(current_vertex.parents))\n            path.append(parent)\n            current_vertex = parent\n\n        path.pop()  # remove start vertex duplicate\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        root_vertices = [self._graph.root_vertex_start]\n\n        for iteration in range(self._max_iterations):\n            if time.time() - start_time > 30:\n                # Timeout exceeded: treat route as not found, terminate\n                if self.testing is not None:\n                    self.testing.algorithm_done()\n                return\n\n            q_sample: Point = self._graph.root_vertex_goal.position\n            # Bias sampling towards goal with 10% probability to speed convergence\n            if np.random.rand() < 0.1:\n                q_sample = self._graph.root_vertex_goal.position\n            else:\n                # Sample random valid point\n                while True:\n                    rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n                    sample = Point(*rand_pos)\n                    if grid.is_agent_valid_pos(sample):\n                        q_sample = sample\n                        break\n\n            q_near: Vertex = self._graph.get_nearest_vertex(root_vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            # Check validity of line from q_near to q_new\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get near vertices for rewire consideration, including q_near to ensure connection attempt\n            near_vertices = self._near_vertices(q_new, self._rewire_radius)\n\n            # Choose best parent among near vertices that connects validly with minimal cost\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No valid parent found, skip\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire nearby vertices if possible to improve path costs\n            self._rewire(q_new, near_vertices)\n\n            # Check if q_new is in goal region; if yes, extract the path and finish\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant of the RRT-Connect path planning algorithm called Informed RRT-Connect.\nIt enhances runtime efficiency by focusing the sampling on an elliptical subset of the search space (\"informed set\")\nonce an initial solution is found, reducing unnecessary exploration. \nIt also incorporates a 30-second timeout to abort the search if no path is found within this duration.\nThe main innovation lies in biased sampling towards promising regions inspired by the informed RRT* approach,\nwhile retaining the bi-directional tree growth and connection attempts from RRT-Connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _timeout_seconds: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._timeout_seconds = 30\n        # For informed sampling\n        self._best_cost = float('inf')\n        self._found_path = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n    \n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n    \n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples a point inside an ellipsoid defined by the start and goal positions, focusing on the subset\n        of the search space that might yield a better path than the current best found cost.\n        If no path is found yet, defaults to uniform random sampling.\n        \"\"\"\n        if not self._found_path:\n            # Uniform sampling as no solution has been found yet\n            return self._get_random_sample()\n        \n        start_pos = self._graph.root_vertices[0].position\n        goal_pos = self._graph.root_vertices[-1].position\n        \n        c_min = self._distance(start_pos, goal_pos)\n        c_best = self._best_cost\n        \n        if c_best == float('inf'):\n            # fallback\n            return self._get_random_sample()\n        \n        center = Point(\n            *( (start_pos.to_tensor() + goal_pos.to_tensor()) / 2 ).tolist()\n        )\n        \n        diff = goal_pos.to_tensor() - start_pos.to_tensor()\n        e1 = diff / torch.norm(diff)\n\n        # Construct orthonormal basis (rotation matrix C)\n        dim = len(start_pos.to_tensor())\n        I = torch.eye(dim)\n        U = e1.unsqueeze(1)\n        # Gram-Schmidt to orthonormalize - here we choose identity basis minus e1 column\n        if dim == 2:\n            e2 = torch.tensor([-e1[1], e1[0]])\n            C = torch.stack([e1, e2], dim=1)\n        else:\n            # Higher dim: use QR decomposition for orthonormal basis\n            Q, _ = torch.linalg.qr(torch.cat([e1.unsqueeze(1), I[:,1:]], dim=1))\n            C = Q\n\n        # Radii of the ellipsoid\n        r1 = c_best / 2\n        r_rest = sqrt(c_best**2 - c_min**2) / 2 if c_best**2 > c_min**2 else 0.0\n\n        radii = torch.tensor([r1] + [r_rest]*(dim-1))\n\n        # Sample uniformly in unit n-ball\n        while True:\n            x = torch.randn(dim)\n            x /= torch.norm(x)\n            u = torch.rand(1).item() ** (1/dim)\n            sample_unit_ball = u * x\n            # Scale by radii\n            sample = radii * sample_unit_ball\n            # Map to ellipsoid\n            sample_ellipsoid = C @ sample + center.to_tensor()\n\n            sample_point = Point.from_tensor(sample_ellipsoid)\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        line_seq = self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from mid to goal-tree root\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back path from mid to start-tree root\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # Depending on root order, reverse path if necessary\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        for i in range(self._iterations):\n            # Check timeout condition (30 seconds)\n            if time.time() - self._start_time > self._timeout_seconds:\n                # Timed out - treat as no path found\n                break\n\n            # Use informed sampling if path was found, else use uniform random\n            q_rand: Point = self._informed_sample()\n\n            if self._extend(self._graph.root_vertices[0], q_rand) != 'trapped':\n                self._extension_target = self._q_new\n                dist_start_to_new = self._distance(self._graph.root_vertices[0].position, self._q_new.position)\n                dist_new_to_goal = self._distance(self._q_new.position, self._graph.root_vertices[-1].position)\n                current_cost = dist_start_to_new + dist_new_to_goal\n\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._found_path = True\n                    if current_cost < self._best_cost:\n                        self._best_cost = current_cost\n                    self._extract_path()\n                    break\n\n                # Update best cost on partial solution progress\n                if current_cost < self._best_cost:\n                    self._best_cost = current_cost\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved sample-based path planning algorithm inspired by SPRM,\n    enhancing efficiency by incrementally building a Rapidly-exploring Random Graph (RRG).\n    The algorithm uses incremental sampling with radius-based neighbor connections \n    coupled with rewiring to optimize paths dynamically.\n    This approach reduces redundant edge checking by connecting new samples to existing\n    nearby vertices within a radius that shrinks as the graph grows, similar to an \n    RRT* paradigm but adapted to a cyclic graph structure, increasing time efficiency.\n    A timeout of 30 seconds is enforced to terminate searches that take too long.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _start_time: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300  # slightly larger sample size for better coverage\n        self._max_radius = 20.0  # initial max connection radius\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # allow edges to be rewired / removed for optimization\n        self._init_displays()\n        self._start_time = 0.0\n\n    def _near(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, radius)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        vec = p1.to_tensor() - p2.to_tensor()\n        return float(torch.norm(vec))\n\n    def _choose_parent(self, vertex_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        \"\"\"\n        Chooses the best parent from neighbors minimizing the cost to vertex_new\n        Cost here is approximated as Euclidean distance from agent vertex plus distance from that neighbor to new vertex.\n        \"\"\"\n        agent_vertex = self._graph.root_vertices[0]\n        min_cost = math.inf\n        best_parent = None\n        for u in neighbors:\n            if vertex_new is u:\n                continue\n            # check connectivity from agent to u\n            if agent_vertex in u.connectivity:\n                # cost: distance agent->u + u->new\n                try:\n                    cost_u = u.cost_to_root if hasattr(u, \"cost_to_root\") else self._distance(agent_vertex.position, u.position)\n                except Exception:\n                    cost_u = self._distance(agent_vertex.position, u.position)\n                cost = cost_u + self._distance(u.position, vertex_new.position)\n                if cost < min_cost:\n                    # check if path between u and vertex_new is obstacle free\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(u.position, vertex_new.position)):\n                        min_cost = cost\n                        best_parent = u\n        if best_parent is None:\n            # fallback: connect directly to agent vertex if possible\n            agent_vertex = self._graph.root_vertices[0]\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(agent_vertex.position, vertex_new.position)):\n                best_parent = agent_vertex\n            # else no connection found\n        return best_parent\n\n    def _rewire(self, vertex_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire neighbors through vertex_new if it provides a lower cost path.\n        \"\"\"\n        agent_vertex = self._graph.root_vertices[0]\n        for u in neighbors:\n            if u is vertex_new:\n                continue\n            # Check current cost_u\n            if agent_vertex in u.connectivity:\n                try:\n                    current_cost_u = u.cost_to_root if hasattr(u, \"cost_to_root\") else self._distance(agent_vertex.position, u.position)\n                except Exception:\n                    current_cost_u = self._distance(agent_vertex.position, u.position)\n                new_cost = vertex_new.cost_to_root + self._distance(vertex_new.position, u.position) if hasattr(vertex_new, \"cost_to_root\") else math.inf\n                if new_cost < current_cost_u:\n                    # check path from vertex_new to u is clear\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex_new.position, u.position)):\n                        # remove old edges from original parent\n                        for parent in list(u.connectivity.keys()):\n                            if u in parent.connectivity:\n                                if u.connectivity[parent] == u:\n                                    pass\n                        # rewire: remove old edge and add new one through vertex_new\n                        self._graph.add_edge(vertex_new, u)\n                        self._graph.add_edge(u, vertex_new)\n                        # Optionally remove old edges? But we keep cyclic graph structure\n                        # Update costs for u and downstream vertices could be done for precise cost values\n                        u.cost_to_root = new_cost\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Extract path using connectivity to goal\n        current_vertex = agent\n        path = []\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # no path exists\n                return\n            next_vertex = current_vertex.connectivity[goal]\n            if next_vertex in path:\n                # loop detected: break to avoid infinite loop\n                break\n            path.append(next_vertex)\n            current_vertex = next_vertex\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize cost to root for agent vertex\n        agent_vertex.cost_to_root = 0.0\n\n        # Vertices list includes roots and samples\n        all_vertices = self._graph.vertices\n\n        # Incremental graph building with rewiring, stops when path found or timeout reached\n        for i in range(len(all_vertices)):\n            if time.time() - self._start_time > 30.0:\n                # Timeout: treat as not found\n                return\n\n            vertex_new = all_vertices[i]\n\n            # Compute radius dynamically shrinking as the graph grows (per RRG / RRT* theory)\n            gamma_rrt_star = 2.0 * (1.5 ** (1/2))  # simplified constant for 2D (can tune or generalize)\n            radius = min(self._max_radius, gamma_rrt_star * ((math.log(len(all_vertices)+1) / (len(all_vertices)+1)) ** 0.5))\n            neighbors = self._near(vertex_new, radius)\n\n            # Choose best parent to connect new vertex minimizing cost\n            parent = self._choose_parent(vertex_new, neighbors)\n            if parent is not None:\n                self._graph.add_edge(parent, vertex_new)\n                self._graph.add_edge(vertex_new, parent)\n                # Update cost to root for new vertex\n                try:\n                    parent_cost = parent.cost_to_root if hasattr(parent, \"cost_to_root\") else self._distance(agent_vertex.position, parent.position)\n                except Exception:\n                    parent_cost = self._distance(agent_vertex.position, parent.position)\n                vertex_new.cost_to_root = parent_cost + self._distance(parent.position, vertex_new.position)\n\n                # Rewire neighboring vertices if better path found through vertex_new\n                self._rewire(vertex_new, neighbors)\n\n            self.key_frame()\n\n            # Check if goal is reachable now\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return\n\n        # If loop ends without creating path, do not move agent ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved Path Planning algorithm inspired by RRT*. This algorithm incorporates heuristics with goal biasing \nto accelerate convergence and reduces unnecessary rewiring by limiting rewiring only when beneficial.\nIt also uses an adaptive sampling strategy focusing samples nearer to the goal region increasingly over \ntime, and employs a timeout check to terminate search if it exceeds 30 seconds. The approach balances \nexploration and exploitation, improves efficiency on large maps, and maintains path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: \"Forest\"\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self, goal_bias_ratio: float) -> Point:\n        \"\"\"\n        Sample with goal biasing to speed convergence.\n        \"\"\"\n        size = self._get_grid().size\n        if np.random.random() < goal_bias_ratio:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, size, size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 40\n        lambda_rrt_star: float = 40\n        iterations: int = 10000\n        dimension = 2\n        time_limit_seconds = 30.0\n\n        start_time = time.perf_counter()\n\n        for i in range(iterations):\n            current_time = time.perf_counter()\n            if current_time - start_time > time_limit_seconds:\n                # Timeout reached, path not found\n                break\n\n            # Increase goal bias ratio as iterations increase to focus search\n            goal_bias_ratio = min(0.2 + 0.8 * (i / iterations), 0.9)\n            q_sample: Point = self._get_random_sample(goal_bias_ratio)\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Validate path segment\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimal cost plus distance to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Limited rewiring: Only rewire neighbors that improve cost significantly (> 1% improvement)\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost * 0.99:\n                    q_parent = None\n                    if len(q_near.parents) > 0:\n                        q_parent = next(iter(q_near.parents))\n                        self._graph.remove_edge(q_parent, q_near)\n                    else:\n                        # should not happen, but skip rewiring if no parent is found\n                        continue\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm inspired by RRT but enhanced with goal biasing and early stopping.\n    Instead of purely random sampling, this algorithm occasionally samples the goal position to guide \n    exploration towards the goal faster. It also includes a time limit of 30 seconds to treat failure \n    in case no path is found within that duration. This improves the average planning time and success rate.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(self._services, \n                                 Vertex(self._get_grid().agent.position), \n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        # Probability of sampling the goal directly (goal bias)\n        self._goal_sample_rate = 0.2\n        # Maximum distance for extending tree edges\n        self._max_dist = 10.0\n        # Max iterations allowed (safety cap)\n        self._max_iterations = 10000\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # With probability goal_sample_rate, return goal position to bias tree growth\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        # Otherwise uniform random sample within valid positions\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._max_iterations):\n            # If time exceeded 30 seconds, abort search\n            if time.time() - start_time > 30.0:\n                # Mark algorithm done with no path found\n                if self.testing is not None:\n                    self.testing.algorithm_done()\n                return\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved Rapidly-exploring Random Tree (RRT) variant with goal biasing and early stopping.\n    Instead of purely random sampling, it samples the goal position with a certain probability to guide the search towards the goal and reduce exploration time.\n    Also adds a timeout mechanism to stop search attempts after 30 seconds. \n    The sample extension distance is dynamically optimized to balance exploration and refinement.\n    The algorithm also uses the existing helper methods for vertex generation and path extraction.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nPathPlanning implements an improved sample-based path planning algorithm inspired by RRT-Connect.\nIt adds informed sampling that biases the random samples towards the ellipsoidal region between\nstart and goal to reduce exploration space, improving convergence time. It also includes a 30-second\ntimeout to treat search as not found if exceeded. The method retains the bidirectional growth and connection\nstrategy of RRT-Connect but uses the informed sampling technique to accelerate path discovery.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        self._max_dist = 10\n        self._iterations = 10000\n        \n        # Added member: store start and goal point tensors for informed sampling\n        self._start_point = self._get_grid().agent.position\n        self._goal_point = self._get_grid().goal.position\n        self._start_tensor = self._start_point.to_tensor()\n        self._goal_tensor = self._goal_point.to_tensor()\n        self._c_best = float('inf')  # best path cost found so far (initialized to infinity)\n        \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _informed_sample(self) -> Point:\n        \"\"\"\n        Samples a point from the informed sampling ellipsoid defined by the current best path cost.\n        If no path found yet (c_best = inf), samples uniformly.\n        Ellipsoid is defined by start and goal with the major axis = c_best.\n        \"\"\"\n        if self._c_best == float('inf'):\n            # No solution found yet, sample uniformly\n            return self._get_random_sample()\n        \n        # Calculate center, unit vector from start to goal, and the axes lengths\n        c_min = self._distance(self._start_point, self._goal_point)  # minimal path length (Euclidean)\n        if c_min == 0:\n            # Start and goal coincident\n            return self._start_point\n        \n        center_tensor = (self._start_tensor + self._goal_tensor) / 2\n        \n        # Rotation matrix from ellipsoid frame to world frame\n        a1 = (self._goal_tensor - self._start_tensor) / c_min  # unit vector along major axis\n        \n        # Following a method to generate random point in unit n-ball and transform to ellipsoid\n        # For arbitrary dimension:\n        n_dim = self._start_tensor.shape[0]\n        \n        # lengths of ellipsoid axes\n        r1 = self._c_best / 2  # major axis length semi-major axis\n        # for other axes, calculate sqrt(r1^2 - c_min^2/4) which is minor axes radius\n        if r1*r1 - (c_min*c_min)/4 < 0:\n            r2 = 0\n        else:\n            r2 = math.sqrt(r1*r1 - (c_min*c_min)/4)\n        \n        # Construct orthonormal basis for ellipsoid\n        # Use Gram-Schmidt to find matrix C s.t. C e1 = a1\n        # Start with identity basis vectors e_i\n        # First basis vector = a1 (already unit length)\n        basis = [a1]\n        # Generate the remaining n-1 orthonormal vectors to complete the basis\n        \n        def unit_vector(v):\n            norm = torch.norm(v)\n            return v / norm if norm > 0 else v\n        \n        # Using torch for convenience\n        def gram_schmidt(vectors):\n            ortho = []\n            for v in vectors:\n                w = v.clone()\n                for u in ortho:\n                    w = w - torch.dot(w, u) * u\n                w_norm = torch.norm(w)\n                if w_norm > 1e-10:\n                    ortho.append(w / w_norm)\n            return ortho\n        \n        # Generate initial arbitrary set of basis vectors (standard basis)\n        e = [torch.eye(n_dim)[i] for i in range(n_dim)]\n        # Replace first vector with a1\n        e[0] = a1\n        C = gram_schmidt(e)\n        C = torch.stack(C)  # shape (n_dim, n_dim)\n\n        # Sample random point in unit n-ball using normal distribution method\n        rand_dir = torch.randn(n_dim)\n        rand_dir = rand_dir / torch.norm(rand_dir)\n        rand_radius = torch.pow(torch.rand(1), 1/dimensionality) if (dimensionality:=n_dim) else 1.0\n        rand_point_unit_ball = rand_dir * rand_radius\n\n        # Scale point by ellipsoid axes lengths\n        # Axis lengths vector:\n        r = torch.tensor([r1] + [r2]*(n_dim-1))\n        ellipsoid_point = r * rand_point_unit_ball\n        \n        # Map through C rotation matrix\n        mapped_point = center_tensor + torch.matmul(C.t(), ellipsoid_point)\n        mapped_point_int = Point.from_tensor(mapped_point.round())\n\n        # If point outside valid map or invalid pos, fallback to random uniform sampling\n        if self._get_grid().is_agent_valid_pos(mapped_point_int):\n            return mapped_point_int\n        else:\n            return self._get_random_sample()\n\n    # Retain _extend, _connect, _get_nearest_vertex, _get_new_vertex, _extract_path, _get_random_sample from RRT_Connect, with minor reuse\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _update_c_best(self, path_length: float) -> None:\n        if path_length < self._c_best:\n            self._c_best = path_length\n\n    def _compute_path_length(self, path: List[Vertex]) -> float:\n        length = 0.0\n        for i in range(1, len(path)):\n            length += self._distance(path[i-1].position, path[i].position)\n        return length\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            # Terminate if time exceeded 30 seconds\n            elapsed = time.time() - start_time\n            if elapsed > 30:\n                # Consider path not found, stop searching\n                break\n\n            # Sample from informed region if path found, else uniform\n            q_rand: Point = self._informed_sample()\n\n            # Attempt extension from tree A to q_rand\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n\n                # Attempt to connect tree B to q_new\n                connect_res = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_res == 'reached':\n                    # Extract path\n                    self._extract_path()\n                    # Update best path cost\n                    # Extract current path vertices for length calculation\n                    path_mid_to_b: List[Vertex] = [self._q_new]\n                    while len(path_mid_to_b[-1].parents) != 0:\n                        for parent in path_mid_to_b[-1].parents:\n                            path_mid_to_b.append(parent)\n                            break\n                    path_a_to_mid: List[Vertex] = [self._extension_target]\n                    while len(path_a_to_mid[-1].parents) != 0:\n                        for parent in path_a_to_mid[-1].parents:\n                            path_a_to_mid.append(parent)\n                            break\n                    path_a_to_mid.reverse()\n                    full_path = path_a_to_mid + path_mid_to_b\n                    if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n                        full_path.reverse()\n                    path_len = self._compute_path_length(full_path)\n                    self._update_c_best(path_len)\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an improved sample-based planner inspired by SPRM but incorporating the RRT* (Rapidly-exploring Random Tree*)\n    technique to improve time efficiency and path quality. It incrementally grows a tree rooted at the agent's start,\n    connecting new samples by optimizing local paths and rewiring nearby vertices to reduce overall path cost.\n    The algorithm uses informed sampling within a radius around the goal to bias exploration and stops once a feasible path is found or 30 seconds elapsed.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._max_radius = 15\n        self._V_size = 300  # increase for better sampling density\n        self._goal_sample_rate = 0.15  # probability of sampling the goal to speed up convergence\n\n        self._graph: CyclicGraph = None\n        # Initialize vertices with start and goal vertices plus empty initially (for RRT*)\n        agent_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph([agent_vertex, goal_vertex], [], edges_removable=True)\n\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        With some probability, return the goal position (goal biasing).\n        Else, sample uniformly valid random point from the map.\n        \"\"\"\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _closest_vertex(self, vertex_list: List[Vertex], point: Point) -> Vertex:\n        \"\"\"\n        Find the vertex in vertex_list closest to point.\n        \"\"\"\n        min_dist = math.inf\n        closest_vertex = None\n        for v in vertex_list:\n            dist = self._distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                closest_vertex = v\n        return closest_vertex\n\n    def _near(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Get all vertices within radius of vertex.position.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Same as SPRM: move from q_near towards q_sample by at most max_dist.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _choose_parent(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent from nearby vertices for q_new based on minimal cost to q_new.\n        Cost is approximated by path length.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = math.inf\n        best_parent = None\n        for v in nearby_vertices:\n            if grid.is_valid_line_sequence(grid.get_line_sequence(v.position, q_new.position)):\n                cost = v.cost + self._distance(v.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        For each vertex in nearby_vertices, check if going through q_new reduces cost.\n        If yes and line is valid, update parent and cost.\n        \"\"\"\n        grid = self._get_grid()\n        for v in nearby_vertices:\n            if v is q_new:\n                continue\n            if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                new_cost = q_new.cost + self._distance(q_new.position, v.position)\n                if new_cost < v.cost:\n                    # Reconnect vertex v with q_new\n                    if v.parent is not None:\n                        self._graph.remove_edge(v.parent, v)\n                    v.parent = q_new\n                    v.cost = new_cost\n                    self._graph.add_edge(q_new, v)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract path from goal to start by following parent links.\n        Then move the agent along this path.\n        \"\"\"\n        goal_vertex = self._graph.root_vertices[1]\n        path = []\n        v = goal_vertex\n        if v.parent is None:\n            # No path found\n            return\n        while v is not None:\n            path.append(v)\n            v = v.parent\n        path.reverse()\n        grid = self._get_grid()\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n        max_extend_length = self._max_radius\n        radius = 20.0  # radius for near neighbors in rewiring\n        agent_vertex.cost = 0.0\n        agent_vertex.parent = None\n\n        start_time = time.time()\n\n        for i in range(self._V_size):\n            if time.time() - start_time > 30:\n                # Timeout, no path found\n                return\n\n            q_sample_point = self._get_random_sample()\n            q_nearest = self._closest_vertex(self._graph.vertices, q_sample_point)\n            q_new = self._get_new_vertex(q_nearest, q_sample_point, max_extend_length)\n            \n            # Validate new vertex position\n            if not grid.is_agent_valid_pos(q_new.position):\n                continue\n\n            line_seq = grid.get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Prepare new vertex with cost and parent candidates\n            q_new.cost = math.inf\n            q_new.parent = None\n\n            nearby_vertices = self._near(q_new, radius)\n\n            # Choose the best parent\n            best_parent = self._choose_parent(q_new, nearby_vertices)\n            if best_parent is None:\n                # Fallback: connect to nearest if valid\n                best_parent = q_nearest\n                q_new.cost = best_parent.cost + self._distance(best_parent.position, q_new.position)\n                q_new.parent = best_parent\n            else:\n                q_new.cost = best_parent.cost + self._distance(best_parent.position, q_new.position)\n                q_new.parent = best_parent\n\n            # Add q_new vertex and edge from parent to q_new\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(q_new.parent, q_new)\n\n            # Rewire nearby vertices to possibly improve paths\n            self._rewire(q_new, nearby_vertices)\n\n            self.key_frame()\n\n            # Check if can connect to goal to improve path\n            if self._distance(q_new.position, goal_vertex.position) <= max_extend_length:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    if goal_vertex.parent is None or q_new.cost + self._distance(q_new.position, goal_vertex.position) < goal_vertex.cost:\n                        # Connect goal to q_new\n                        if goal_vertex.parent is not None:\n                            self._graph.remove_edge(goal_vertex.parent, goal_vertex)\n                        goal_vertex.parent = q_new\n                        goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                        self._graph.add_edge(q_new, goal_vertex)\n\n                        # Extract the path and move the agent accordingly\n                        self._extract_path()\n                        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved sample-based path planning algorithm inspired by SPRM with enhancements:\n    - Uses a radius-based incremental connection approach to limit edge checks and reduce unnecessary edge additions.\n    - Introduces a priority queue (min-heap) to expand vertices with the shortest estimated cost first, akin to an informed sampling-based search.\n    - Incorporates a heuristic distance estimate to the goal to prioritize exploration toward goal direction.\n    - Stops search after 30 seconds if no path found.\n    - This algorithm attempts to significantly reduce search time while maintaining probabilistic completeness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _heuristic(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance heuristic\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _extract_path(self, parents: Dict[Vertex, Vertex]) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        path = []\n        current_vertex = goal\n        while current_vertex is not agent:\n            path.append(current_vertex)\n            current_vertex = parents[current_vertex]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # Priority queue element: (f_score, g_score, vertex)\n        # f_score = g_score + heuristic estimate to goal\n        open_set: List[Tuple[float, float, Vertex]] = []\n        heapq.heappush(open_set, (self._heuristic(agent.position, goal.position), 0.0, agent))\n\n        # Maps for tracking costs and path\n        g_scores: Dict[Vertex, float] = {agent: 0.0}\n        parents: Dict[Vertex, Vertex] = {}\n\n        # We will connect edges on the fly if feasible to reduce combinatorial checks\n        visited = set()\n\n        while open_set:\n            # Time-out check - stop if more than 30 seconds elapsed\n            if time.time() - start_time > 30.0:\n                # Timeout: treat as no path found, break without moving agent\n                return\n\n            f_score, g_score_current, current_vertex = heapq.heappop(open_set)\n\n            # If goal reached\n            if current_vertex is goal:\n                self._extract_path(parents)\n                return\n\n            if current_vertex in visited:\n                continue\n            visited.add(current_vertex)\n\n            # Get neighbors within radius\n            near_vertices: List[Vertex] = self._graph.get_vertices_within_radius(self._graph.root_vertices, current_vertex.position, self._max_radius)\n\n            for neighbor in near_vertices:\n                if neighbor is current_vertex:\n                    continue\n                if neighbor in visited:\n                    continue\n\n                # Check if edge is valid (collision-free)\n                line_seq = self._get_grid().get_line_sequence(current_vertex.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                tentative_g_score = g_score_current + torch.norm(current_vertex.position.to_tensor() - neighbor.position.to_tensor()).item()\n\n                prev_g_score = g_scores.get(neighbor, float('inf'))\n                if tentative_g_score < prev_g_score:\n                    # We found a better path to neighbor\n                    parents[neighbor] = current_vertex\n                    g_scores[neighbor] = tentative_g_score\n                    f_score_neighbor = tentative_g_score + self._heuristic(neighbor.position, goal.position)\n                    heapq.heappush(open_set, (f_score_neighbor, tentative_g_score, neighbor))\n\n                    # Add edges bi-directionally in graph for visualization/debug if not present\n                    if neighbor not in current_vertex.connectivity:\n                        self._graph.add_edge(current_vertex, neighbor)\n                    if current_vertex not in neighbor.connectivity:\n                        self._graph.add_edge(neighbor, current_vertex)\n\n                    self.key_frame()\n\n        # If exit loop without finding goal, no path found (silent fail) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* with goal biasing and early stopping.\n    This algorithm enhances the original RRT* by adding:\n    - Goal bias sampling to more frequently sample towards the goal and thus converge faster.\n    - An adaptive rewiring radius that shrinks with graph size to reduce unnecessary rewires.\n    - A time limit of 30 seconds to avoid excessive computation time.\n    - Early goal connection attempts to speed up finding a feasible path.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variables\n        self._goal_bias = 0.2  # probability to sample the goal directly to bias sampling\n        self._max_time_seconds = 30.0  # max runtime for the search in seconds\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Uses existing display info from SampleBasedAlgorithm and can add more if needed\n        return super().set_display_info()\n\n    def _get_biased_random_sample(self) -> Point:\n        \"\"\"\n        Returns a random sample with goal bias.\n        With probability goal_bias, sample the goal position directly.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return Point(*self._get_grid().goal.position.data)  # goal point\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_radius: float = 40.0  # slightly smaller max radius for rewiring than original\n        lambda_rrt_star: float = 40.0\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > self._max_time_seconds:\n                # Time exceeded, no path found, finish algorithm gracefully.\n                self.key_frame()  # to mark end state\n                break\n\n            q_sample: Point = self._get_biased_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check free path from nearest to new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1/dimension)) if card_v > 1 else max_radius, max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Choose best parent from neighbors\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            # Attach new vertex to best parent\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path is found through q_new\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            # Early attempt to connect directly to goal\n            goal_v = Vertex(self._get_grid().goal.position)\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n                if q_new.cost + dist_to_goal < float('inf'):\n                    goal_v.cost = q_new.cost + dist_to_goal\n                    self._graph.add_edge(q_new, goal_v)\n                    # Extract and follow path:\n                    self._extract_path(goal_v)\n                    break\n\n            # If agent is already within a radius of goal, extract path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n    def _extract_path(self, q_goal_vertex: Vertex) -> None:\n        \"\"\"\n        Extracts path from start to goal and commands the agent to follow it.\n        \"\"\"\n        path: List[Vertex] = [q_goal_vertex]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.reverse()\n        # Remove the start vertex if it appears twice\n        if len(path) > 1 and path[0].position == self._get_grid().agent.position:\n            path = path[1:]\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved RRT-Connect variant named PathPlanning.\n    It optimizes exploration by biasing random samples towards the goal region with certain probability,\n    thus accelerating convergence. It also performs a pruning step to keep the graph compact, \n    removing vertices that are too close to others to reduce redundant exploration.\n    Additionally, the search respects a 30-second timeout to prevent excessive run time.\n    The backbone idea is to maintain two trees grown from start and goal, extending and connecting them efficiently.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n    _time_limit_sec: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        self._graph = gen_forest(self._services, Vertex(start_pos), Vertex(goal_pos), [])\n        self._graph.edges_removable = True  # Allow pruning/removing edges to improve efficiency\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.20  # 20% of the time, bias sample towards goal\n        self._time_limit_sec = 30.0  # 30 seconds timeout\n        self._init_displays()\n\n    def _bias_sample(self) -> Point:\n        \"\"\"Sample point with probability to bias towards goal, otherwise uniform random.\"\"\"\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._graph.root_vertex_goal.position\n        else:\n            return self._get_random_sample()\n\n    def _prune_near_vertices(self, vertex: Vertex, radius: float = 5.0) -> None:\n        \"\"\"\n        Remove vertices that are close to the newly added vertex to reduce redundancy.\n        This helps keep the graph simpler and speeds up nearest vertex queries.\n        \"\"\"\n        to_remove = []\n        for v in list(self._graph.vertices):\n            if v is vertex:\n                continue\n            dist_vec = (v.position.to_tensor() - vertex.position.to_tensor())\n            dist = dist_vec.norm().item()\n            if dist < radius:\n                # Remove from graph if possible\n                if self._graph.edges_removable:\n                    to_remove.append(v)\n        for v in to_remove:\n            self._graph.remove_vertex(v)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            self._prune_near_vertices(self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from mid to goal tree root\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back path from mid to start tree root\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # If root_vertices[0] is goal root, reverse the path\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        # Move agent along the constructed path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = self._graph.random_sample_point()\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist_norm = torch.norm(dir)\n        if dist_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        for _ in range(self._iterations):\n            current_time = time()\n            if current_time - start_time > self._time_limit_sec:\n                # Timeout: treat as path not found\n                break\n\n            q_rand: Point = self._bias_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT called RRT-Connect. It simultaneously grows two trees: one from the start and the other from the goal.\nIn each iteration, it samples a random point and attempts to extend the start tree toward it, then tries to connect the goal tree to the newly added vertex.\nThis bidirectional growth typically reduces search time and improves efficiency.\nIt maintains the original interface and utilities, and adds a 30-second timeout to stop the search if no path is found in that duration.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _timeout_seconds: int\n\n    def __init__(self, services: Services, testing: Optional[BasicTesting] = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_start.edges_removable = False\n\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_goal.edges_removable = False\n\n        self._max_dist = 10\n        self._timeout_seconds = 30\n\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Combine displays from both graphs if needed\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start),\n                              GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_extend(self, tree: Forest, q_target: Point) -> Optional[Vertex]:\n        \"\"\"\n        Attempt to extend tree toward q_target by one step (max_dist).\n        Returns the newly added vertex or None if extension not possible.\n        \"\"\"\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return None\n        q_new: Vertex = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n            return None\n\n        tree.add_edge(q_near, q_new)\n        return q_new\n\n    def _connect(self, tree: Forest, q_target: Point) -> Optional[Vertex]:\n        \"\"\"\n        Tries to extend the tree in a loop until cannot grow closer to q_target.\n        Returns the last vertex added if connection was successful, else None.\n        \"\"\"\n        q_new = None\n        while True:\n            extended_vertex = self._try_extend(tree, q_target)\n            if extended_vertex is None:\n                break\n            q_new = extended_vertex\n            # If reached target position, connect successful\n            if q_new.position == q_target or self._is_point_equal(q_new.position, q_target):\n                return q_new\n        return q_new\n\n    def _is_point_equal(self, p1: Point, p2: Point) -> bool:\n        # Equality with tolerance for floating point points\n        return (p1 - p2).to_tensor().norm().item() < 1e-6\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start tree and goal tree by joining\n        the vertices at connection points, then move agent along it.\n        \"\"\"\n\n        path_start: List[Vertex] = [connection_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            path_start.append(path_start[-1].parents[0])\n        path_start.reverse()\n\n        path_goal: List[Vertex] = [connection_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            path_goal.append(path_goal[-1].parents[0])\n\n        full_path = path_start + path_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        start_time = time.time()\n\n        for i in range(10000):  # max iterations, can terminate earlier\n\n            # Timeout check\n            if time.time() - start_time > self._timeout_seconds:\n                # Route search timed out: No path found\n                # Optionally, could call key_frame to mark end state\n                break\n\n            # Alternate sampling between start tree and goal tree growth\n            # Sample random position biased towards goal with some probability to improve speed\n            if np.random.rand() < 0.05:\n                # With small probability, pick goal position as sample (goal bias)\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            # Extend start tree toward q_sample\n            q_new_start = self._try_extend(self._graph_start, q_sample)\n            if q_new_start is None:\n                self.key_frame()\n                continue\n\n            # Try to connect goal tree to q_new_start\n            q_new_goal = self._connect(self._graph_goal, q_new_start.position)\n\n            self.key_frame()\n\n            if q_new_goal is not None and self._is_point_equal(q_new_goal.position, q_new_start.position):\n\n                # Connected both trees, extract path and finish\n                self._extract_path(q_new_start, q_new_goal)\n                break\n\n            # Swap trees for next iteration (bidirectional)\n            self._graph_start, self._graph_goal = self._graph_goal, self._graph_start\n            self.__map_displays[0], self.__map_displays[1] = self.__map_displays[1], self.__map_displays[0] ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm builds upon the RRT* baseline with improvements targeting time efficiency and \n    smarter sampling to reduce unnecessary explorations. It incorporates:\n    - A goal bias sampling strategy: samples the goal position occasionally to guide the tree growth.\n    - Early pruning of vertices with costs exceeding the current best path cost for faster rewiring.\n    - Time limit enforcement to stop searching if path is not found within 30 seconds.\n    - A caching mechanism of valid edges to avoid repeated expensive collision checks.\n    - Maintains RRT* rewiring and near radius adaptation.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._best_goal_vertex: Optional[Vertex] = None\n        self._cached_valid_lines = set()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _valid_edge_cached(self, q1: Point, q2: Point) -> bool:\n        key = (q1, q2)\n        if key in self._cached_valid_lines:\n            return True\n        valid = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q1, q2))\n        if valid:\n            self._cached_valid_lines.add(key)\n        return valid\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        goal_sample_rate = 0.1  # 10% samples target directly the goal\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Stop search after 30 seconds if no path found\n                break\n\n            # Sampling with goal bias:\n            if np.random.rand() < goal_sample_rate:\n                q_sample: Point = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Skip if not collision free (use caching)\n            if not self._valid_edge_cached(q_nearest.position, q_new.position):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            dist_qmin_qnew = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            c_min = q_nearest.cost + dist_qmin_qnew\n\n            # Pruning: Only consider near vertices with lower cost than best known path to goal if any\n            cost_threshold = self._best_goal_vertex.cost if self._best_goal_vertex is not None else None\n\n            for q_near in Q_near:\n                if cost_threshold is not None and q_near.cost >= cost_threshold:  # prune high cost vertices\n                    continue\n                if not self._valid_edge_cached(q_near.position, q_new.position):\n                    continue\n                dist = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                cost = q_near.cost + dist\n                if cost < c_min:\n                    q_min = q_near\n                    c_min = cost\n\n            dist_min_to_new = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_min_to_new\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if cost_threshold is not None and q_near.cost >= cost_threshold:\n                    continue\n                if not self._valid_edge_cached(q_new.position, q_near.position):\n                    continue\n                dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                cost = q_new.cost + dist\n                if cost < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is None:\n                        continue\n                    q_near.cost = None\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reaches goal\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best goal vertex if better\n                goal_v: Vertex = Vertex(self._get_grid().goal.position)\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n                goal_v.cost = q_new.cost + dist_to_goal\n                self._graph.add_edge(q_new, goal_v)\n\n                if (self._best_goal_vertex is None) or (goal_v.cost < self._best_goal_vertex.cost):\n                    self._best_goal_vertex = goal_v\n\n                # Extract and move on the best path found so far:\n                self._extract_path(self._best_goal_vertex)\n                break\n\n            self.key_frame()\n\n        # If no path found within time or iterations, no movement happens and function ends\n\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reused from RRT_Star, adjusted to utilize self._best_goal_vertex correctly\n        path: List[Vertex] = [q_new]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by SPRM, implementing an RRT* (Rapidly-exploring Random Tree Star) style \n    approach to improve time efficiency and path optimality. It incrementally builds a tree rooted at the agent's position \n    by sampling random points, connecting them to the nearest neighbor, and rewiring connections to reduce path cost.\n    The graph is constructed with dynamically adjustable edges and edge rewiring to optimize the path. \n    A 30-second timeout is enforced to abort the search if no valid path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_dist: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Parameters, slightly tuned for RRT* behavior\n        self._V_size = 200\n        self._max_radius = 20.0\n        self._max_dist = 15.0\n\n        # Initialize sample set including root vertices (agent and goal)\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        # Root vertices: start(agent) and goal\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph = CyclicGraph()\n        self._graph.add_vertex(start_vertex)\n        self._graph.add_vertex(goal_vertex)\n        self._graph.root_vertices = [start_vertex, goal_vertex]\n\n        # Add sampled vertices\n        for v in V:\n            self._graph.add_vertex(v)\n\n        self._graph.edges_removable = True  # enable edge rewiring/removal for optimization\n        self._init_displays()\n\n    def _get_nearest_vertex(self, q_rand: Point) -> Vertex:\n        best_v: Optional[Vertex] = None\n        best_dist = float('inf')\n        q_rand_t = q_rand.to_tensor()\n        for vertex in self._graph.vertices:\n            dist = torch.norm(vertex.position.to_tensor() - q_rand_t).item()\n            if dist < best_dist:\n                best_dist = dist\n                best_v = vertex\n        return best_v\n\n    def _near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Return vertices within radius _max_radius\n        q_new_pos = q_new.position\n        return self._graph.get_vertices_within_radius(self._graph.vertices, q_new_pos, self._max_radius)\n\n    def _steer(self, q_near: Vertex, q_rand: Point) -> Vertex:\n        # Reuse _get_new_vertex logic from SPRM but as helper here\n        dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= self._max_dist:\n            return Vertex(q_rand)\n        else:\n            dir_normalized = dir_vec / dist\n            q_new_point = Point.from_tensor(q_near.position.to_tensor() + self._max_dist * dir_normalized)\n            return Vertex(q_new_point)\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Simple Euclidean distance as edge cost\n        return torch.norm(from_vertex.position.to_tensor() - to_vertex.position.to_tensor()).item()\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        # Choose nearest vertex in near_vertices that connects to q_new with minimum cost if collision-free\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for v in near_vertices:\n            if grid.is_valid_line_sequence(grid.get_line_sequence(v.position, q_new.position)):\n                cost = self._cost(v, q_new)\n                # Add cost of path from root to v if exists\n                if v in self._graph.root_vertices[0].connectivity:\n                    path_cost = 0\n                    current = v\n                    while current is not self._graph.root_vertices[0]:\n                        parent = current.connectivity.get(self._graph.root_vertices[0], None)\n                        if parent is None:\n                            break\n                        path_cost += self._cost(parent, current)\n                        current = parent\n                    cost += path_cost\n\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v is q_new:\n                continue\n            if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                cost_through_new = self._cost(q_new, v)\n                current_parent = None\n                # Detect current parent of v connecting to root agent if exists\n                for p in self._graph.vertices:\n                    if v in p.connectivity.values():\n                        current_parent = p\n                        break\n\n                if current_parent is None or cost_through_new < self._cost(current_parent, v):\n                    # Remove old edge and add new edge to rewire\n                    if current_parent is not None:\n                        self._graph.remove_edge(current_parent, v)\n                    self._graph.add_edge(q_new, v)\n                    self._graph.add_edge(v, q_new)\n                    self.key_frame()\n\n    def _extract_path(self) -> None:\n        goal = self._graph.root_vertices[1]\n        agent = self._graph.root_vertices[0]\n\n        if goal not in agent.connectivity:\n            return  # no path found\n\n        current_vertex = agent\n        path: List[Vertex] = list()\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity.get(goal, None)\n            if current_vertex is None:\n                break\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph_display()  # draw latest graph display\n\n    def _graph_display(self) -> List[MapDisplay]:\n        # Lazy init or reuse existing map display for graph\n        if hasattr(self, \"_graph_displays\") and self._graph_displays:\n            return self._graph_displays\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self._graph_displays = [GraphMapDisplay(self._services, self._graph)]\n        return self._graph_displays\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        start_time = time.time()\n        for i in range(self._V_size):\n            if time.time() - start_time > 30:\n                # Timeout stop condition\n                break\n\n            q_rand = self._get_random_sample()\n            q_nearest = self._get_nearest_vertex(q_rand)\n            q_new = self._steer(q_nearest, q_rand)\n\n            if grid.is_agent_valid_pos(q_new.position) and grid.is_valid_line_sequence(grid.get_line_sequence(q_nearest.position, q_new.position)):\n                near_vertices = self._near_vertices(q_new)\n                parent = self._choose_parent(q_new, near_vertices)\n                if parent is None:\n                    parent = q_nearest  # fallback\n\n                # Add q_new to graph and connect to parent\n                self._graph.add_vertex(q_new)\n                self._graph.add_edge(parent, q_new)\n                self._graph.add_edge(q_new, parent)\n                self.key_frame()\n\n                # Rewire connections around q_new for improved path\n                self._rewire(q_new, near_vertices)\n\n                # Check if goal is connectable from q_new\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.add_edge(goal_vertex, q_new)\n                    self.key_frame()\n                    if goal_vertex in agent_vertex.connectivity:\n                        self._extract_path()\n                        return\n\n        # If timeout or no path found, no movement done. ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT* combining Adaptive Sampling and early goal biasing to speed up convergence.\nIt incorporates goal bias sampling to increase the chances of connecting to the goal early.\nAdditionally, it uses an adaptive neighborhood radius for rewiring that shrinks as the tree grows, reducing unnecessary\nre-computation and speeding up the search process.\nThe algorithm also terminates if the search time exceeds 30 seconds to avoid excessive runtime.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member for goal bias probability and adaptive radius parameter\n        self._goal_bias_prob: float = 0.1          # 10% samples are from goal region to bias growth towards goal\n        self._lambda_rrt_star_base: float = 50     # Base parameter for radius calculation\n        self._max_radius: float = 50                # Maximum radius to limit rewiring neighborhood\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        # With some probability, sample directly at the goal to bias towards the goal\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        # Otherwise sample uniformly as usual\n        return super()._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        max_dist: float = 10\n        iterations: int = 10000\n        dimension = 2\n\n        for i in range(iterations):\n\n            # Check timeout to stop if search takes too long\n            if (time.time() - start_time) > 30.0:\n                # Timeout reached: stop search with no path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n\n            # Adaptive radius: decrease radius as tree grows, faster rewiring for smaller tree\n            shrink_factor = max(1.0 - (card_v / iterations), 0.1)\n            lambda_rrt_star_adaptive = self._lambda_rrt_star_base * shrink_factor\n\n            radius = min(lambda_rrt_star_adaptive * ((log_card_v / card_v) ** (1 / dimension)), self._max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            dist_near_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            c_min = q_nearest.cost + dist_near_new\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        q_near.cost = None\n                        self._graph.remove_edge(q_parent, q_near)\n                        child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        q_near.cost = q_new.cost + child_parent_dist\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT-Connect inspired path planner leveraging heuristic-guided sampling \n    and adaptive extension steps to speed up pathfinding. \n    The algorithm integrates goal biasing and dynamic max extension distance \n    to reduce unnecessary exploration and connect trees faster. \n    Time limit of 30 seconds is enforced to terminate search if no path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, \n                                 Vertex(self._get_grid().agent.position), \n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias_ratio = 0.2    # Probability to sample goal directly\n        self._min_max_dist = 3         # Minimum extension distance to avoid too small steps\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._SampleBasedAlgorithm__map_displays\n\n    def _sample_with_goal_bias(self) -> Point:\n        # With probability goal_bias_ratio, sample the goal to focus tree grow towards goal\n        if np.random.rand() < self._goal_bias_ratio:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _get_dynamic_max_dist(self, q_near: Vertex, q_sample: Point) -> float:\n        # Adapt extension distance dynamically based on distance to sample point\n        dist = torch.norm(q_sample.to_tensor() - q_near.position.to_tensor()).item()\n        # Clamp between min_max_dist and self._max_dist\n        return max(self._min_max_dist, min(self._max_dist, dist))\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        max_dist_dynamic = self._get_dynamic_max_dist(self._q_near, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, max_dist_dynamic)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30:\n                # Timeout reached, give up search\n                break\n\n            q_rand: Point = self._sample_with_goal_bias()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved sample-based path planner inspired by RRT, called RRT-Connect variant. \nIt grows two trees simultaneously: one from the start and one from the goal trying to connect them.\nThis bidirectional growth helps reduce search time significantly. \nAdditionally, it uses goal biasing to sample the goal with higher probability, and a 30-second time cutoff to ensure timely termination.\nIt preserves the general structure of RRT but adds these enhancements to improve efficiency.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved version of RRT* by incorporating goal bias sampling \nand early rewiring optimizations. It limits the maximum allowed runtime to 30 seconds for \npractical responsiveness. Goal biasing increases the chance of sampling near the goal, \nexpediting convergence. Early rewiring reduces unnecessary computation by skipping \nrewiring vertices that would clearly not improve costs. These improvements aim to reduce \nthe average planning time compared to standard RRT* without compromising path optimality.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Goal bias [0..1], probability to sample goal directly to speed convergence\n        self._goal_sample_rate: float = 0.1\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling introduced for faster convergence\n        if np.random.rand() < self._goal_sample_rate:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        return super()._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Overriding _extract_path to move agent along final found path\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Enforce max runtime of 30 seconds\n            if time.time() - start_time > 30.0:\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(line_seq)\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Optimized rewiring: skip vertices where cost difference is insignificant to reduce computations\n            for q_near in Q_near:\n                # Prevent rewiring to itself and ignore if cost improvement is too small\n                if q_near == q_min:\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near + 1e-6 >= q_near.cost:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                # Perform rewiring\n                q_parent = None\n                for parent in q_near.parents:\n                    q_parent = parent\n                    break\n                if q_parent is not None:\n                    self._graph.remove_edge(q_parent, q_near)\n                q_near.cost = cost_new_to_near\n                self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm, named 'PathPlanning', is an improved sample-based path planner inspired by SPRM.\n    It integrates heuristics and incremental connection strategies similar to RRT* to accelerate \n    path discovery. Instead of building a full cyclic graph upfront, it incrementally grows a tree \n    from the agent towards the goal using guided sampling and rewiring for path cost optimization. \n    The algorithm maintains a fixed maximum radius for neighbor search and valid edge checking.\n    A 30-second timeout is enforced to abort overly long searches.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300  # Increased sample size for better connectivity\n        self._max_radius = 20.0  # Slightly larger radius for neighborhood search\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        # Initialize graph with agent and goal roots and sampled vertices\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize cost and parent dictionaries for RRT*-like rewiring\n        cost = {v: float('inf') for v in self._graph.vertices}\n        parent = {v: None for v in self._graph.vertices}\n        cost[agent_vertex] = 0.0\n\n        # Vertices will be maintained in the graph's vertices list\n        # Active vertices to expand from; start with agent root\n        active_vertices: List[Vertex] = [agent_vertex]\n        \n        while True:\n            # Check timeout\n            if time.time() - start_time > 30.0:\n                # Timeout reached, no path found\n                return\n            \n            # Sample new point with goal biasing (10% towards goal)\n            if torch.rand(1).item() < 0.1:\n                q_sample = goal_vertex.position\n            else:\n                q_sample = self._get_random_sample()\n            \n            # Find nearest vertex to sample in current graph\n            q_near = self._nearest_vertex(q_sample)\n            \n            # Steer towards sample, limiting step to max_radius\n            q_new = self._steer(q_near.position, q_sample, self._max_radius)\n            if not self._get_grid().is_agent_valid_pos(q_new):\n                continue\n            \n            q_new_vertex = Vertex(q_new, store_connectivity=True)\n\n            # Check collision-free path from q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Add q_new to graph if not present\n            if q_new_vertex not in self._graph.vertices:\n                self._graph.add_vertex(q_new_vertex)\n\n            # Find neighbors within radius for rewiring\n            neighbors = self._graph.get_vertices_within_radius(self._graph.vertices, q_new, self._max_radius)\n\n            # Initialize minimum cost and best parent for q_new\n            min_cost = cost.get(q_near, float('inf')) + self._distance(q_near.position, q_new)\n            best_parent = q_near\n\n            # Check if any neighbor offers cheaper path to q_new\n            for neighbor in neighbors:\n                if neighbor == q_near:\n                    continue\n                line_seq_n = self._get_grid().get_line_sequence(neighbor.position, q_new)\n                if self._get_grid().is_valid_line_sequence(line_seq_n):\n                    neighbor_cost = cost.get(neighbor, float('inf')) + self._distance(neighbor.position, q_new)\n                    if neighbor_cost < min_cost:\n                        min_cost = neighbor_cost\n                        best_parent = neighbor\n\n            # Connect q_new to best parent\n            self._graph.add_edge(best_parent, q_new_vertex)\n            self._graph.add_edge(q_new_vertex, best_parent)\n            cost[q_new_vertex] = min_cost\n            parent[q_new_vertex] = best_parent\n\n            # Rewire neighbors if going through q_new reduces cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                edge_cost = self._distance(q_new, neighbor.position)\n                if cost[q_new_vertex] + edge_cost < cost.get(neighbor, float('inf')):\n                    line_seq_n = self._get_grid().get_line_sequence(q_new, neighbor.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq_n):\n                        # Remove old parent edge to neighbor\n                        old_parent = parent.get(neighbor, None)\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                            self._graph.remove_edge(neighbor, old_parent)\n                        # Add new edge from q_new to neighbor\n                        self._graph.add_edge(q_new_vertex, neighbor)\n                        self._graph.add_edge(neighbor, q_new_vertex)\n                        cost[neighbor] = cost[q_new_vertex] + edge_cost\n                        parent[neighbor] = q_new_vertex\n            \n            self.key_frame()\n\n            # Check if goal close enough to q_new and connected\n            dist_to_goal = self._distance(q_new, goal_vertex.position)\n            if dist_to_goal <= self._max_radius:\n                # Check collision free connection to goal\n                line_seq_goal = self._get_grid().get_line_sequence(q_new, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    # Add edge q_new <-> goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n                    self._graph.add_edge(goal_vertex, q_new_vertex)\n                    cost[goal_vertex] = cost[q_new_vertex] + dist_to_goal\n                    parent[goal_vertex] = q_new_vertex\n                    self._extract_path_rrt(parent, goal_vertex)\n                    return\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        min_dist = float('inf')\n        nearest = None\n        for v in self._graph.vertices:\n            dist = self._distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _steer(self, from_point: Point, to_point: Point, max_dist: float) -> Point:\n        from_tensor = from_point.to_tensor()\n        to_tensor = to_point.to_tensor()\n        direction = to_tensor - from_tensor\n        length = torch.norm(direction)\n        if length <= max_dist:\n            return to_point\n        direction_normalized = direction / length\n        new_tensor = from_tensor + max_dist * direction_normalized\n        return Point.from_tensor(new_tensor)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _extract_path_rrt(self, parent: dict, goal_vertex: Vertex) -> None:\n        current_vertex = goal_vertex\n        path = []\n        while current_vertex is not None and current_vertex != self._graph.root_vertices[0]:\n            path.append(current_vertex)\n            current_vertex = parent.get(current_vertex, None)\n\n        path.reverse()\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of RRT*, called 'Informed RRT*'.\n    It builds upon RRT* by incorporating a heuristic: after the first feasible path \n    to the goal is found, it limits sampling to an ellipsoidal subset of the search \n    space that could potentially improve the current best path cost. This focused \n    sampling reduces unnecessary exploration and accelerates convergence to an optimal \n    or near-optimal path.\n    Additionally, a 30-second timeout is enforced to abort the search if no solution \n    is found within this timeframe.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # We keep track of best cost found so far for informed sampling\n        self._best_cost: float = float('inf')\n        self._goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex.cost = float('inf')\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Samples points inside the prolate hyperspheroid defined by start, goal and c_best,\n        to focus sampling in the informed subset of the space.\n        If c_best is infinite (no solution yet), fallback to uniform random sampling.\n        \"\"\"\n\n        if math.isinf(c_best):\n            return self._get_random_sample()\n\n        start_np = start.to_tensor().numpy()\n        goal_np = goal.to_tensor().numpy()\n\n        center = (start_np + goal_np) / 2.0\n        diff = goal_np - start_np\n        dim = len(diff)\n        c_min = max(c_min, 1e-6)  # avoid divide by zero\n\n        # Rotation matrix - aligns x-axis with the line from start to goal\n        def unit_vector(vec):\n            norm = np.linalg.norm(vec)\n            if norm < 1e-10:\n                return vec\n            return vec / norm\n\n        a1 = unit_vector(diff)\n        I = np.eye(dim)\n        M = np.outer(a1, np.array([1] + [0]*(dim - 1)))\n        U, _, Vt = np.linalg.svd(M, full_matrices=True)\n        C = np.dot(U, Vt)  # rotation matrix\n\n        # Ellipsoid radii\n        a = c_best / 2.0  # major axis\n        b = math.sqrt(c_best**2 - c_min**2) / 2.0  # minor axes radius\n        r = np.array([a] + [b]*(dim - 1))\n\n        while True:\n            # Sample random point in unit n-ball\n            x_ball = np.random.normal(0, 1, dim)\n            x_ball /= np.linalg.norm(x_ball) + 1e-15  # normalize\n            radius = np.random.uniform(0, 1)**(1/dim)\n            x_ball *= radius\n\n            # Scale to ellipse\n            x_ellipse = r * x_ball\n            # Rotate and translate to ellipsoid frame\n            x_sample = np.dot(C, x_ellipse) + center\n\n            sample_pt = Point(*np.round(x_sample).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _extract_path(self, q_new):\n        goal_v: Vertex = self._goal_vertex\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n\n        # Clear old connections of goal before adding new edges from fresh extraction\n        old_parents = list(goal_v.parents)\n        for parent in old_parents:\n            self._graph.remove_edge(parent, goal_v)\n\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        start_vertex = self._graph.root_vertex_start\n        self._goal_vertex.cost = float('inf')\n\n        start_time = time.time()\n        iterations: int = 100000  # potentially high limit, bounded by time\n\n        best_path_found: bool = False\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30:\n                # Timeout after 30 seconds, no path found\n                break\n\n            if best_path_found:\n                # Informed sampling within ellipse using best cost found so far\n                c_best = self._best_cost\n                c_min = torch.norm(start_vertex.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n                q_sample: Point = self._informed_sample(c_best, c_min, start_vertex.position, self._goal_vertex.position)\n            else:\n                # Uniform sampling before first solution found\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if it improves cost through q_new\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal radius and update best cost if path found\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < self._best_cost:\n                    self._best_cost = q_new.cost\n                    best_path_found = True\n                    self._extract_path(q_new)\n                    # Do not break immediately to continue optimizing path using informed sampling\n                    # But if time limit reached, will exit loop naturally\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning algorithm based on RRT* (Rapidly-exploring Random Tree Star).\n    This algorithm improves upon the basic RRT by incorporating rewiring of the tree to maintain \n    near-optimal paths and reducing path cost over time. It incorporates a radius-based neighbor search \n    to connect new vertices to the best parent, and rewires existing neighbors if the new path offers \n    improvement. To improve time efficiency, the search is terminated if no solution is found within \n    30 seconds.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This implementation improves on the RRT-Connect by incorporating a goal biasing strategy during sampling and adaptive maximum extension length to speed up convergence. \"\\\n\"Additionally, it uses time-based termination to stop the search if no path is found within 30 seconds. This reduces unnecessary computation, \"\\\n\"particularly in cluttered maps. Goal biasing increases the chance of extending towards the goal position, focusing the tree growth. \"\\\n\"The adaptive max distance shortens the extension length as the trees near each other, improving fine path quality and reducing overshoot.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n    _min_max_dist: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        self._max_dist = 15.0     # increased base max extension length for faster exploration\n        self._min_max_dist = 3.0  # minimum max_dist when close to goal/tree\n        self._iterations = 10000\n        self._goal_bias = 0.1     # 10% of samples biased towards goal\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_goal_biased_sample(self) -> Point:\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _adaptive_max_dist(self, q_near: Vertex, q_target: Point) -> float:\n        dist = self._distance(q_near.position, q_target)\n        # Decrease max_dist as trees extend closer, but never below min_max_dist\n        return max(self._min_max_dist, min(self._max_dist, dist))\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adaptive_dist = self._adaptive_max_dist(self._q_near, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, adaptive_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from q_new to root of one tree\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = path_mid_to_b[-1].parents[0]\n            path_mid_to_b.append(parent)\n\n        # trace back path from extension_target to root of other tree\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = path_a_to_mid[-1].parents[0]\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n        # Reverse if root_vertices order is swapped\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            if (time.time() - start_time) > 30.0:\n                # Time limit exceeded, stop search as failed\n                break\n\n            q_rand = self._get_goal_biased_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm improves the SPRM by incorporating a heuristic-guided sampling strategy inspired by RRT*,\n    focusing sampling around the current path to the goal to speed up convergence,\n    and employing a rewiring step to reduce path costs progressively.\n    The cyclic graph structure is maintained, but edges are adjusted dynamically for efficiency.\n    A time cutoff (30 seconds) is enforced to abort if no path is found within the limit.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        # Initial random vertices sampled from valid positions\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow rewiring (removal/add edges)\n        self._init_displays()\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Samples around the straight-line path between agent and goal to bias exploration.\n        This reduces random sampling overhead and improves convergence speed.\n        \"\"\"\n        grid = self._get_grid()\n        agent_pos = grid.agent.position.to_tensor()\n        goal_pos = grid.goal.position.to_tensor()\n        alpha = torch.rand(1).item()  # interpolation factor between 0 and 1\n\n        # Interpolate along the line agent->goal with some random noise perpendicular\n        base_point = agent_pos + alpha * (goal_pos - agent_pos)\n\n        # Add perpendicular noise with magnitude up to max_radius/2 in each dimension\n        noise = (torch.rand_like(base_point) - 0.5) * self._max_radius\n        candidate_point_tensor = base_point + noise\n\n        # Clamp to grid bounds\n        for d in range(grid.size.n_dim):\n            candidate_point_tensor[d] = torch.clamp(candidate_point_tensor[d], 0, grid.size[d] - 1)\n\n        candidate_point = Point.from_tensor(candidate_point_tensor)\n\n        if grid.is_agent_valid_pos(candidate_point):\n            return candidate_point\n        else:\n            # Fallback: use uniform random sample if biased sample invalid\n            return self._get_random_sample()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / torch.norm(dir)\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _cost(self, v_from: Vertex, v_to: Vertex) -> float:\n        # Euclidean distance between vertices as cost\n        return torch.norm(v_from.position.to_tensor() - v_to.position.to_tensor()).item()\n\n    def _best_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent to minimize cost-to-come + cost edge\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if grid.is_valid_line_sequence(grid.get_line_sequence(neighbor.position, q_new.position)):\n                cost = neighbor.cost + self._cost(neighbor, q_new)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Rewire neighbors to q_new if it reduces their cost.\n        \"\"\"\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, neighbor.position)):\n                new_cost = q_new.cost + self._cost(q_new, neighbor)\n                if new_cost < neighbor.cost:\n                    # Remove old edge from old parent if exists\n                    for p in list(neighbor.connectivity):\n                        if neighbor in p.connectivity and neighbor.connectivity[p] == neighbor:\n                            p.connectivity.pop(neighbor, None)\n\n                    # Connect q_new -> neighbor\n                    q_new.connectivity[neighbor] = neighbor\n                    neighbor.cost = new_cost\n                    neighbor.parent = q_new\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Build path by backtracking parents from goal to agent\n        path = []\n\n        current_vertex = goal\n        while current_vertex is not agent:\n            path.append(current_vertex)\n            if hasattr(current_vertex, 'parent'):\n                current_vertex = current_vertex.parent\n            else:\n                # No parent means no path; break to avoid infinite loop\n                break\n\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize costs and parents\n        for v in self._graph.vertices:\n            v.cost = float('inf')\n            v.parent = None\n        agent_vertex.cost = 0\n        agent_vertex.parent = None\n\n        # Build edges initially for initial vertices close to roots\n        for v in self._graph.vertices:\n            neighbors = self._near(v)\n            for u in neighbors:\n                if v is not u:\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(u.position, v.position)):\n                        self._graph.add_edge(v, u)\n                        self._graph.add_edge(u, v)\n            self.key_frame()\n\n        # Main improvement loop: biased sampling + rewiring\n        while True:\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout exceeded, path not found\n                return\n\n            q_sample_point = self._heuristic_sample()\n            q_near_candidates = self._graph.get_vertices_within_radius(self._graph.vertices, q_sample_point, self._max_radius)\n\n            # Find nearest vertex precisely\n            if not q_near_candidates:\n                continue\n\n            q_near = min(q_near_candidates,\n                         key=lambda v: torch.norm(v.position.to_tensor() - q_sample_point.to_tensor()))\n\n            q_new = self._get_new_vertex(q_near, q_sample_point, self._max_radius)\n            if not grid.is_agent_valid_pos(q_new.position):\n                continue\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            neighbors = self._near(q_new)\n\n            best_parent = self._best_parent(q_new, neighbors)\n            if best_parent is None:\n                best_parent = q_near\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n            q_new.parent = best_parent\n\n            # Add q_new to graph\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.add_edge(q_new, best_parent)\n\n            # Rewire neighbors through q_new to reduce cost\n            self._rewire(q_new, neighbors)\n\n            self.key_frame()\n\n            # Check if goal can be connected through q_new\n            if torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()) <= self._max_radius:\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    cost_goal_new = q_new.cost + self._cost(q_new, goal_vertex)\n                    if cost_goal_new < goal_vertex.cost:\n                        # Connect goal to q_new\n                        self._graph.add_edge(q_new, goal_vertex)\n                        self._graph.add_edge(goal_vertex, q_new)\n                        goal_vertex.cost = cost_goal_new\n                        goal_vertex.parent = q_new\n\n                        self._extract_path()\n                        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved PathPlanning algorithm based on RRT* with goal biasing and informed sampling to reduce \n    exploration of irrelevant areas and to speed up convergence. The algorithm maintains RRT*'s \n    rewiring optimization but prioritizes samples near the goal region after an initial solution \n    is found, aiming to refine and shorten the path faster.\n\n    Key improvements:\n    - Goal biasing: periodically sample the goal directly to focus tree growth towards the goal.\n    - Informed sampling: once a feasible path is found, samples are drawn from an ellipsoidal \n      informed subset of the search space constrained by the current best path cost.\n    - Early termination if no solution found within 30 seconds.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved Rapidly-exploring Random Tree (RRT) variant called RRT-Connect.\n    Unlike the basic RRT which grows a single tree, RRT-Connect grows two trees simultaneously:\n    one from the start and one from the goal. Each iteration attempts to extend one tree \n    towards a random sample and then tries to connect the other tree to this new node, \n    resulting in faster convergence by aggressively connecting the two trees. \n    The algorithm quits if a path is found or after 30 seconds timeout.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nAn improved path planning algorithm based on RRT, called RRT-Connect.\nThis algorithm grows two trees simultaneously: one from the start and one from the goal.\nIn each iteration, it samples a random valid point, extends the start tree towards it,\nthen attempts to connect the goal tree to the newly added vertex. If the two trees connect,\nthe path is found by merging both trees. This bidirectional approach often significantly\nimproves the planning time. The search is terminated if the solution is found or if it\nexceeds a 30-second timeout.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize two graphs (forests), one from start and one from goal\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # We display both graphs for visualization\n        self.__map_displays = [\n            GraphMapDisplay(self._services, self._graph_start),\n            GraphMapDisplay(self._services, self._graph_goal),\n        ]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"Reuse from RRT: move towards sample with max_dist limit\"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _try_extend(self, graph: Forest, q_target: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Try to extend the graph towards the target point.\n        Returns the newly added vertex or None if extension not possible.\n        \"\"\"\n        q_near: Vertex = graph.get_nearest_vertex([graph.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return None\n        q_new: Vertex = self._get_new_vertex(q_near, q_target, max_dist)\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        graph.add_edge(q_near, q_new)\n        return q_new\n\n    def _connect_trees(self, graph_from: Forest, graph_to: Forest, vertex_connect: Vertex, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempt to connect graph_to to the vertex_connect in graph_from tree.\n        Returns the connecting vertex in graph_to if successful, else None.\n        \"\"\"\n        q_new: Vertex = self._try_extend(graph_to, vertex_connect.position, max_dist)\n        # Keep trying until unable to extend closer or connection made\n        while q_new is not None:\n            if q_new.position == vertex_connect.position:\n                return q_new\n            # If extension leads nearer, continue extending towards vertex_connect\n            q_new = self._try_extend(graph_to, vertex_connect.position, max_dist)\n        return None\n\n    def _extract_path(self, vertex_start: Vertex, vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract and move agent along the combined path from start tree vertex to goal tree vertex.\n        \"\"\"\n        path_start = [vertex_start]\n        while len(path_start[-1].parents) != 0:\n            parent = path_start[-1].parents[0]\n            path_start.append(parent)\n        path_start.reverse()\n\n        path_goal = [vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            parent = path_goal[-1].parents[0]\n            path_goal.append(parent)\n\n        full_path_vertices = path_start + path_goal\n\n        for vertex in full_path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        start_time: float = time.time()\n        timeout_seconds: float = 30.0\n\n        # Quick check if start is already in goal radius\n        if self._get_grid().is_agent_in_goal_radius(agent_pos=self._graph_start.root_vertex_start.position):\n            self._extract_path(self._graph_start.root_vertex_start, self._graph_goal.root_vertex_start)\n            return\n\n        for i in range(10000):\n            # Timeout check\n            if time.time() - start_time > timeout_seconds:\n                # No path found within time limit\n                break\n\n            # Sample random valid point\n            q_sample: Point = None\n            attempts = 0\n            while attempts < 100:\n                possible_sample = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sampled_point = Point(*possible_sample)\n                if self._get_grid().is_agent_valid_pos(sampled_point):\n                    q_sample = sampled_point\n                    break\n                attempts += 1\n            if q_sample is None:\n                continue\n\n            # Extend start tree towards sample\n            q_new_start: Vertex = self._try_extend(self._graph_start, q_sample, max_dist)\n            if q_new_start is None:\n                continue\n\n            # Try to connect goal tree to newly added start tree vertex\n            q_new_goal: Vertex = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n            while q_new_goal is not None and q_new_goal.position != q_new_start.position:\n                q_new_goal = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n\n            if q_new_goal is not None and q_new_goal.position == q_new_start.position:\n                # Trees connected; extract path\n                self._extract_path(q_new_start, q_new_goal)\n                return\n\n            # Swap roles of trees to balance growth (bi-directional RRT)\n            self._graph_start, self._graph_goal = self._graph_goal, self._graph_start\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved and optimized variant of the RRT-Connect path planner.\n    It enhances performance and time efficiency by employing a goal-biased sampling strategy,\n    which biases sample generation towards the goal with a tunable probability, reducing\n    unnecessary exploration. Additionally, it incorporates an early termination condition \n    based on a 30-second timeout, ensuring the search does not run indefinitely. The core \n    structure remains similar to RRT-Connect, extending and connecting two trees, but with \n    strategic sampling to improve convergence speed and path find time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.2  # 20% of the samples are directly toward the goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_goal_biased_sample(self) -> Point:\n        \"\"\"\n        Returns a sample biased towards the goal or random with goal_bias probability.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # Trace back path starting from last added vertices in both trees\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n        \n        # Reverse path if start is root_vertex_goal to maintain order start->goal\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for _ in range(self._iterations):\n            if (time.time() - start_time) > 30.0:  # Timeout after 30 seconds\n                break\n\n            q_rand: Point = self._get_goal_biased_sample()\n\n            if self._extend(self._graph.root_vertices[0], q_rand) != 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This algorithm named PathPlanning improves the time efficiency of the sample-based path planning approach \"\n    \"inspired by the SPRM algorithm. It adopts an incremental RRT* inspired strategy to build a tree of vertices \"\n    \"connecting the start to the goal via randomly sampled points. It uses a search radius to find neighbors and \"\n    \"adds new best connections, rather than rechecking all pairs cyclically, reducing redundant collision checks. \"\n    \"Also, a rewiring step is included to shorten paths dynamically improving solution quality. The search limits \"\n    \"to 30 seconds, stopping if no path is found. Once a path is found, it is extracted and the agent moves along it.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300      # Increased sample size for better coverage\n        self._max_radius = 20.0 # Increased radius for neighbor checking\n        from algorithms.classic.sample_based.core.vertex import Vertex\n\n        # Initialize vertices with random samples plus start and goal\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Instead of cyclic graph, we initialize an empty graph and will build connections incrementally\n        from algorithms.classic.sample_based.core.graph import CyclicGraph\n        self._graph = CyclicGraph(self._services, start_vertex, goal_vertex, V)\n        self._graph.edges_removable = True  # Allow rewiring\n\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import time\n        from algorithms.classic.sample_based.core.vertex import Vertex\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Tree vertices: start vertex initially\n        tree_vertices: List[Vertex] = [start_vertex]\n\n        # We store costs to reach vertices; start cost is 0\n        start_vertex.cost = 0.0\n\n        # Add all vertices (samples + start + goal) to set of unexplored (but not yet connected)\n        unconnected_vertices = set(self._graph.vertices)\n        unconnected_vertices.discard(start_vertex)  # start is the root of tree\n\n        def distance(v1: Vertex, v2: Vertex) -> float:\n            diff = v1.position.to_tensor() - v2.position.to_tensor()\n            return float(torch.norm(diff).item())\n\n        def near_vertices(vertex: Vertex, radius: float) -> List[Vertex]:\n            return self._graph.get_vertices_within_radius(tree_vertices, vertex.position, radius)\n\n        def is_line_valid(p1: Point, p2: Point) -> bool:\n            seq = self._get_grid().get_line_sequence(p1, p2)\n            return self._get_grid().is_valid_line_sequence(seq)\n\n        def choose_parent(q_new: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n            best_parent = None\n            best_cost = float('inf')\n            for q_near in neighbors:\n                if is_line_valid(q_near.position, q_new.position):\n                    tentative_cost = q_near.cost + distance(q_near, q_new)\n                    if tentative_cost < best_cost:\n                        best_cost = tentative_cost\n                        best_parent = q_near\n            return best_parent\n\n        def rewire(q_new: Vertex, neighbors: List[Vertex]) -> None:\n            for q_near in neighbors:\n                if q_near is q_new:\n                    continue\n                if is_line_valid(q_new.position, q_near.position):\n                    new_cost = q_new.cost + distance(q_new, q_near)\n                    if new_cost < q_near.cost:\n                        # Remove old edge parent->q_near and add new q_new->q_near\n                        # Find old parent edge and remove\n                        for p in q_near.connectivity.values():\n                            if q_near in p.connectivity:\n                                if q_near in p.connectivity:\n                                    p.connectivity.pop(q_near, None)\n                        # But given graph structure, instead we just update connectivity from q_new\n                        q_near.cost = new_cost\n                        q_new.connectivity[q_near] = q_near\n                        q_near.connectivity[goal_vertex] = goal_vertex  # maintain connectivity dict shape, dummy\n                        # We also update q_near's connectivity dictionary: this algorithm keeps connectivity to goal\n                        # To keep consistent with existing SPRM style connectivity dict, we keep path to goal fixed\n                        # but here we only maintain connectivity for path extraction\n                        # This is a naive update but enough for display and functionality in this context\n\n        while (time.time() - start_time) < 30.0:\n            q_rand = self._get_random_sample()\n            q_rand_vertex = Vertex(q_rand, store_connectivity=True)\n\n            # Find nearest vertex in tree\n            min_dist = float('inf')\n            q_nearest = None\n            for v in tree_vertices:\n                d = distance(v, q_rand_vertex)\n                if d < min_dist:\n                    min_dist = d\n                    q_nearest = v\n\n            # Steer towards q_rand using max radius\n            def steer(q_from: Vertex, q_to: Point, max_dist: float) -> Vertex:\n                dir = q_to.to_tensor() - q_from.position.to_tensor()\n                length = torch.norm(dir)\n                if length <= max_dist:\n                    return Vertex(q_to, store_connectivity=True)\n                dir_normalized = dir / length\n                new_pos = Point.from_tensor(q_from.position.to_tensor() + max_dist * dir_normalized)\n                return Vertex(new_pos, store_connectivity=True)\n\n            q_new = steer(q_nearest, q_rand, self._max_radius)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            if not is_line_valid(q_nearest.position, q_new.position):\n                continue\n\n            # Find neighbors in tree within radius\n            neighbors = near_vertices(q_new, self._max_radius)\n\n            # Choose best parent from neighbors\n            best_parent = choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # If no valid parent, skip this iteration\n                continue\n\n            # Add q_new to tree\n            q_new.cost = best_parent.cost + distance(best_parent, q_new)\n            tree_vertices.append(q_new)\n            self._graph.vertices.append(q_new)\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.add_edge(q_new, best_parent)\n\n            # Rewire neighbors through q_new if it improves path cost\n            rewire(q_new, neighbors)\n\n            self.key_frame()\n\n            # Check if q_new can connect directly to goal\n            if is_line_valid(q_new.position, goal_vertex.position):\n                tentative_goal_cost = q_new.cost + distance(q_new, goal_vertex)\n                if tentative_goal_cost < getattr(goal_vertex, \"cost\", float('inf')):\n                    # Connect goal to tree\n                    goal_vertex.cost = tentative_goal_cost\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._graph.add_edge(goal_vertex, q_new)\n                    tree_vertices.append(goal_vertex)\n\n                    # Build connectivity for path extraction (store parents)\n                    # We rebuild a connectivity dict for path extraction: for each vertex store parent\n                    parent_map = {}\n\n                    def build_parent_map():\n                        for vertex in tree_vertices:\n                            vertex.connectivity.clear()\n                        for vertex in tree_vertices:\n                            # Add edge from parent to child\n                            for other in tree_vertices:\n                                if vertex is other:\n                                    continue\n                                # We do a check based on cost to assign parent links\n                                # A child has parent if cost difference equals edge dist\n                                diff = vertex.cost - other.cost\n                                edge_dist = distance(vertex, other)\n                                if abs(diff - edge_dist) < 1e-5:\n                                    vertex.connectivity[other] = other\n\n                    build_parent_map()\n\n                    # Extract the path from start to goal using helper\n                    self._extract_path_tree(start_vertex, goal_vertex, parent_map)\n                    return\n\n        # If time exceeded or no path found, do nothing (route not found)\n        return\n\n    def _extract_path_tree(self, start_vertex: 'Vertex', goal_vertex: 'Vertex', parent_map: dict) -> None:\n        # Build path backwards from goal to start using stored connectivity (parents)\n        path = []\n        current_vertex = goal_vertex\n\n        # Because the above connectivity dict stores child->parent edges by cost difference reasoning,\n        # we reconstruct path by repeatedly finding parent with cost less by edge distance.\n\n        while current_vertex != start_vertex:\n            parents = [v for v in current_vertex.connectivity if v.cost < current_vertex.cost]\n            if not parents:\n                # no path found\n                return\n            # Choose parent with minimal cost difference (should be 1 step)\n            parent = min(parents, key=lambda v: current_vertex.cost - v.cost)\n            path.append(current_vertex)\n            current_vertex = parent\n        path.reverse()\n\n        # Move agent along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm improves upon the SPRM approach by implementing an RRT* (Rapidly-exploring Random Tree Star) inspired method to achieve faster convergence and better path quality.\nIt incrementally builds a tree rooted at the agent's position, sampling random valid points, connecting them optimally within a neighborhood, and rewiring existing vertices to minimize path cost.\nIt terminates once a feasible path to the goal is found or 30 seconds have elapsed, whichever comes first.\nIt retains sample-based graph construction but improves edge selection and path quality through rewiring.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 20.0  # Slightly larger radius for rewiring and connectivity\n        # Initialize empty vertices list (starts with agent)\n        agent_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        # Initially only root vertices; no pre-sampled set\n        self._graph = CyclicGraph([agent_vertex, goal_vertex], edges_removable=True)\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _nearest(self, vertex_list: List[Vertex], point: Point) -> Vertex:\n        nearest_vertex = None\n        min_dist = float(\"inf\")\n        for v in vertex_list:\n            dist = self._distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_vertex = v\n        return nearest_vertex\n\n    def _near(self, vertices: List[Vertex], point: Point, radius: float) -> List[Vertex]:\n        near_vertices = []\n        for v in vertices:\n            if self._distance(v.position, point) <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _steer(self, q_near: Vertex, q_rand: Point, max_dist: float) -> Vertex:\n        delta = q_rand.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(delta).item()\n        if dist <= max_dist:\n            return Vertex(q_rand)\n        else:\n            direction = delta / dist\n            new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction)\n            return Vertex(new_pos)\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Calculates cost from root (agent) to vertex by summing costs along connectivity edges (shortest known path)\n        cost = 0.0\n        parent = vertex._parent if hasattr(vertex, '_parent') else None\n        current = vertex\n        while parent is not None:\n            cost += self._distance(current.position, parent.position)\n            current = parent\n            parent = getattr(current, '_parent', None)\n        return cost\n\n    def _extract_path(self) -> None:\n        goal_vertex = self._graph.root_vertices[1]  # goal\n        agent_vertex = self._graph.root_vertices[0]  # agent\n\n        # Reconstruct path backwards by parent references\n        path_vertices = []\n        current_vertex = goal_vertex\n        while current_vertex is not agent_vertex:\n            path_vertices.append(current_vertex)\n            current_vertex = getattr(current_vertex, '_parent', None)\n            if current_vertex is None:\n                # no parent means no path found\n                return\n        path_vertices.reverse()\n\n        for vertex in path_vertices:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize tree with just the start vertex\n        vertices: List[Vertex] = [agent_vertex]\n        # Set _parent attribute to None for root vertices\n        agent_vertex._parent = None\n        goal_vertex._parent = None\n\n        max_extend_dist = self._max_radius  # max step length per extend\n\n        while True:\n            if time.time() - start_time > 30.0:\n                # Timeout: no path found\n                return\n\n            # Sample random valid point\n            q_rand = self._get_random_sample()\n            # Find nearest vertex in tree\n            q_near = self._nearest(vertices, q_rand)\n            # Steer toward q_rand from q_near by max_extend_dist\n            q_new = self._steer(q_near, q_rand, max_extend_dist)\n\n            # Collision check line q_near to q_new\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self.key_frame()\n                continue\n\n            # Choose parent with minimal cost in neighbors within radius (including q_near)\n            near_vertices = self._near(vertices, q_new.position, self._max_radius)\n            min_cost = self._cost(q_near) + self._distance(q_near.position, q_new.position)\n            min_parent = q_near\n            for v in near_vertices:\n                # Check if edge v->q_new is collision-free\n                line_check = self._get_grid().get_line_sequence(v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_check):\n                    cost = self._cost(v) + self._distance(v.position, q_new.position)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = v\n\n            # Assign optimal parent\n            q_new._parent = min_parent\n\n            # Add q_new and edges to graph and vertices\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(min_parent, q_new)\n            self._graph.add_edge(q_new, min_parent)\n            vertices.append(q_new)\n\n            # Rewire neighbors to q_new if it reduces cost\n            for v in near_vertices:\n                if v is min_parent:\n                    continue\n                line_check = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_check):\n                    cost_through_qnew = min_cost + self._distance(q_new.position, v.position)\n                    current_cost = self._cost(v)\n                    if cost_through_qnew < current_cost:\n                        # Remove old edge parent->v and add parent to q_new\n                        old_parent = getattr(v, '_parent', None)\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, v)\n                            self._graph.remove_edge(v, old_parent)\n                        v._parent = q_new\n                        self._graph.add_edge(q_new, v)\n                        self._graph.add_edge(v, q_new)\n\n            self.key_frame()\n\n            # Check if q_new can connect to goal\n            line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n            if self._get_grid().is_valid_line_sequence(line_to_goal):\n                # Connect q_new to goal and assign parent to q_new for goal\n                goal_vertex._parent = q_new\n                self._graph.add_edge(q_new, goal_vertex)\n                self._graph.add_edge(goal_vertex, q_new)\n                vertices.append(goal_vertex)\n\n                # Extract and move agent along the path\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* with informed sampling and an early stopping mechanism.\n    The main improvement lies in focusing sampling within the current best-cost ellipsoidal search space (Informed RRT*)\n    after an initial solution is found to accelerate convergence to an optimal path.\n    Rewiring is kept for optimality, and a 30-second timeout is enforced for timely termination.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved RRT-Connect variant which integrates a heuristic bias \n    toward the goal to speed up convergence and a timeout mechanism to terminate \n    long searches exceeding 30 seconds. The heuristic sampling occasionally biases \n    samples directly toward the goal rather than purely random exploration, increasing \n    efficiency in finding a connection path. It preserves the bidirectional tree \n    expansion concept and the extend/connect procedures to maintain quick path \n    construction while respecting environment constraints.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.15  # 15% of samples biased toward goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        # With probability _goal_sample_rate, sample the goal directly to bias growth\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            # Terminate if time exceeds 30 seconds\n            if time.time() - start_time > 30.0:\n                # Could add a handle for failure state here if needed\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planning method inspired by the RRT* algorithm, \n    which extends the base RRT by rewiring the tree to improve path quality incrementally. \n    It maintains a tree of vertices, samples random points biased towards the goal more frequently, \n    connects new vertices to the lowest cost parent within a neighborhood, and rewires the neighbors \n    to optimize the path. A timeout of 30 seconds is enforced to stop the search if no path is found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _neighbor_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable edge removals for rewiring\n        self._max_dist = 10.0\n        self._neighbor_radius = 20.0  # Radius for rewiring neighbors\n        self._init_displays()\n\n    # Helper Functions #\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            q_new_pos = q_sample\n        else:\n            dir_normalized = dir / dist\n            q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias: with 20% probability sample goal directly\n        if np.random.rand() < 0.2:\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Find vertices in the graph within neighbor_radius (euclidean) of q_new.position\n        vertices = self._graph.vertices_list()\n        near_vertices: List[Vertex] = []\n        pos_new_tensor = q_new.position.to_tensor()\n        neighbor_radius_sq = self._neighbor_radius * self._neighbor_radius\n        for v in vertices:\n            dist_sq = torch.sum((v.position.to_tensor() - pos_new_tensor)**2)\n            if dist_sq <= neighbor_radius_sq:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the neighbor that provides the lowest cost to q_new (cost from root)\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = self._graph.get_vertex_cost(v) + torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        return best_parent if best_parent is not None else self._graph.root_vertex_start\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # For each near vertex, check if the path to it via q_new is better; if yes, rewire\n        cost_q_new = self._graph.get_vertex_cost(q_new)\n        pos_q_new_tensor = q_new.position.to_tensor()\n        for v in near_vertices:\n            if v == q_new.parents[0] if len(q_new.parents) > 0 else None:\n                continue  # Skip the parent itself\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_v_current = self._graph.get_vertex_cost(v)\n            new_cost = cost_q_new + torch.norm(v.position.to_tensor() - pos_q_new_tensor).item()\n            if new_cost < cost_v_current:\n                # Remove old edges of v to parents\n                for p in list(v.parents):\n                    self._graph.remove_edge(p, v)\n                # Add new edge from q_new to v\n                self._graph.add_edge(q_new, v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while path[-1] != self._graph.root_vertex_start and len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]  # Always one parent since this is a tree\n            path.append(parent)\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_iterations = 10000\n\n        for i in range(max_iterations):\n            if (time.time() - start_time) > 30.0:\n                # Timeout: treat as path not found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new)\n            chosen_parent = self._choose_parent(near_vertices, q_new)\n            self._graph.add_edge(chosen_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                q_goal = Vertex(self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_goal.position)):\n                    self._graph.add_edge(q_new, q_goal)\n                    self._extract_path(q_goal)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This is an improved variant of the RRT* algorithm, named Informed RRT*.\nIt enhances the original RRT* by focusing the sampling within the subset of the space that can potentially lead to better solutions.\nIt uses an elliptical informed sampling domain computed based on the current best solution cost, reducing the exploration of irrelevant space.\nAdditionally, the algorithm terminates if the search exceeds 30 seconds without finding a path.\nThe backbone remains the incremental tree building, rewiring process, and cost optimization of RRT* with focussed sampling to improve convergence speed.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize best_path_cost with infinity, update as better paths are found\n        self.best_path_cost = float('inf')\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    # Helper: Elliptical informed sampling around start and goal\n    def _get_informed_sample(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Samples uniformly from an ellipse with foci at start and goal and major axis length c_best.\n        If no current best solution, fallback to uniform sampling.\n        \"\"\"\n        if c_best == float('inf'):\n            return self._get_random_sample()\n\n        c_min = torch.norm(goal.to_tensor() - start.to_tensor()).item()\n        if c_min < 1e-6:\n            return start\n\n        # Sample in unit circle\n        while True:\n            # Sample point inside unit circle\n            theta = 2 * math.pi * np.random.rand()\n            r = math.sqrt(np.random.rand())\n            x_ball = r * math.cos(theta)\n            y_ball = r * math.sin(theta)\n\n            # Construct ellipse parameters\n            a = c_best / 2.0  # semi-major axis\n            b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0  # semi-minor axis\n\n            # Map (x_ball, y_ball) in unit circle to ellipse\n            # Rotate ellipse to align with line from start to goal\n            delta = goal.to_tensor() - start.to_tensor()\n            angle = math.atan2(delta[1].item(), delta[0].item())\n\n            x_ellipse = a * x_ball\n            y_ellipse = b * y_ball\n\n            # Rotate back\n            x_rot = x_ellipse * math.cos(angle) - y_ellipse * math.sin(angle)\n            y_rot = x_ellipse * math.sin(angle) + y_ellipse * math.cos(angle)\n\n            sample_point = Point(start[0] + x_rot, start[1] + y_rot)\n\n            # Round and clamp for grid\n            sample_coords = np.array([round(sample_point[0]), round(sample_point[1])], dtype=int)\n\n            # Check bounds and validity\n            size = self._get_grid().size\n            if 0 <= sample_coords[0] < size[0] and 0 <= sample_coords[1] < size[1]:\n                candidate = Point(*sample_coords)\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_vertex = self._graph.root_vertex_start\n        goal_point = self._get_grid().goal.position\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Check timeout: terminate search if >30 seconds\n            if time.time() - start_time > 30.0:\n                # Optionally notify no path found - here just breaks\n                break\n\n            # Use informed sampling if better path found, else uniform random sampling\n            q_sample: Point = self._get_informed_sample(start_vertex.position, goal_point, self.best_path_cost)\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbours\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    self._graph.add_edge(q_new, q_near)\n\n            # Update best path cost if closer to goal\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_point.to_tensor())\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost + dist_to_goal < self.best_path_cost:\n                    self.best_path_cost = q_new.cost + dist_to_goal\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, improves upon the SPRM sample-based pathfinding method by incorporating key ideas from RRT* (Rapidly-exploring Random Tree Star):\n- It incrementally builds a tree rooted at the agent's position by sampling points in the environment.\n- It re-wires the tree locally to connect new samples through the lowest-cost paths found,\n  aiming to minimize path cost and converging towards an optimal solution.\n- To improve efficiency, the search stops if no path is found within 30 seconds.\nThis approach enhances the SPRM's simple cyclic graph by focusing on optimal path growth and reducing redundant checks,\nthus improving time efficiency in typical grid scenarios.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: 'Graph'   # type: ignore  # we will treat self._graph as the tree graph structure\n    _V_size: int\n    _max_radius: float\n    _max_step: float\n    _costs: dict  # maps Vertex to float cost from start\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300               # Increase samples for better exploration\n        self._max_radius = 20            # Radius for near vertices rewiring\n        self._max_step = 10              # Max step size for new vertex extension\n        self._vertices: List[Vertex] = []  # Store vertices for search and rewiring\n        self._costs = dict()             # Track cost-to-come for each vertex\n        start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        # Init graph as tree with start and goal vertices; initially disconnected except start vertex in graph\n        from algorithms.classic.sample_based.core.graph import CyclicGraph\n        self._graph = CyclicGraph(self._services, [start_vertex, goal_vertex], [])\n        self._costs[start_vertex] = 0.0\n        self._vertices.append(start_vertex)\n        self._vertices.append(goal_vertex)\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        def dist(p1: Point, p2: Point) -> float:\n            return float((p1.to_tensor() - p2.to_tensor()).norm())\n\n        def near_vertices(new_v: Vertex) -> List[Vertex]:\n            res = []\n            for v in self._vertices:\n                if dist(v.position, new_v.position) <= self._max_radius:\n                    res.append(v)\n            return res\n\n        def choose_parent(q_near_list: List[Vertex], q_new_pos: Point) -> Optional[Vertex]:\n            min_cost = float('inf')\n            best_parent = None\n            for q_near in q_near_list:\n                line = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n                if self._get_grid().is_valid_line_sequence(line):\n                    cost = self._costs[q_near] + dist(q_near.position, q_new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = q_near\n            return best_parent\n\n        def rewire(q_new: Vertex, near_vs: List[Vertex], current_cost: float) -> None:\n            for q_near in near_vs:\n                if q_near is q_new:\n                    continue\n                line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line):\n                    new_cost = current_cost + dist(q_new.position, q_near.position)\n                    if new_cost < self._costs.get(q_near, float('inf')):\n                        # Remove old parent edge to q_near and add new one from q_new\n                        for p, connections in q_near.connectivity.items():\n                            if p == q_near:\n                                continue\n                        # In this framework we update connectivity:\n                        # As the graph stores connectivity, we must:\n                        # Remove all edges incoming to q_near, then add edge from q_new to q_near.\n                        # But as connectivity maps target vertex -> next vertex, we update q_near.connectivity accordingly.\n                        # We should find q_near's parent (vertex that connects to q_near)\n                        parent_candidates = []\n                        for v in self._vertices:\n                            if q_near in v.connectivity:\n                                parent_candidates.append(v)\n                        for parent in parent_candidates:\n                            # Remove old edge from parent to q_near\n                            if q_near in parent.connectivity:\n                                del parent.connectivity[q_near]\n                                # Also remove reciprocal edge for undirected structure if present\n                                if parent in q_near.connectivity:\n                                    del q_near.connectivity[parent]\n                        # Add new edge from q_new to q_near both ways for bidirectional connectivity\n                        self._graph.add_edge(q_new, q_near)\n                        self._graph.add_edge(q_near, q_new)\n                        self._costs[q_near] = new_cost\n                        self.key_frame()\n\n        def extend(q_near: Vertex, q_rand: Point) -> Optional[Vertex]:\n            dir_vec = q_rand.to_tensor() - q_near.position.to_tensor()\n            norm = dir_vec.norm()\n            if norm == 0:\n                return None\n            if norm <= self._max_step:\n                q_new_pos = q_rand\n            else:\n                dir_unit = dir_vec / norm\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_step * dir_unit)\n            q_new_vertex = Vertex(q_new_pos, store_connectivity=True)\n            line_to_new = self._get_grid().get_line_sequence(q_near.position, q_new_pos)\n            if self._get_grid().is_valid_line_sequence(line_to_new):\n                return q_new_vertex\n            return None\n\n        # Start sampling loop\n        goal_reached = False\n        while True:\n            if (time.time() - start_time) > 30:\n                # Timeout reached - terminate search as not found\n                return\n\n            q_rand_pos = self._get_random_sample()  # Reuse existing sampling method\n            # Find nearest vertex in tree\n            nearest_vertex = min(self._vertices, key=lambda v: dist(v.position, q_rand_pos))\n            q_new = extend(nearest_vertex, q_rand_pos)\n            if q_new is None:\n                continue\n\n            # Find near vertices for choosing parent and rewiring\n            near_vs = near_vertices(q_new)\n            chosen_parent = choose_parent(near_vs, q_new.position)\n            if chosen_parent is None:\n                continue\n\n            # Add q_new to graph and vertices list\n            self._graph.add_vertex(q_new)\n            self._vertices.append(q_new)\n            # Add edge from chosen parent to q_new and vice versa\n            self._graph.add_edge(chosen_parent, q_new)\n            self._graph.add_edge(q_new, chosen_parent)\n\n            # Update cost\n            self._costs[q_new] = self._costs[chosen_parent] + dist(chosen_parent.position, q_new.position)\n\n            # Rewire near vertices through q_new if improves cost\n            rewire(q_new, near_vs, self._costs[q_new])\n\n            # Check if we can connect q_new directly to goal\n            line_to_goal = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n            if self._get_grid().is_valid_line_sequence(line_to_goal):\n                self._graph.add_edge(q_new, goal_vertex)\n                self._graph.add_edge(goal_vertex, q_new)\n                self._costs[goal_vertex] = self._costs[q_new] + dist(q_new.position, goal_vertex.position)\n                goal_reached = True\n                self.key_frame()\n                break  # path found\n\n            self.key_frame()\n\n        if goal_reached:\n            self._extract_path()\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract the best path from start to goal based on cost and graph connectivity.\n        \"\"\"\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Reconstruct path by backtracking from goal to start using minimum cost parents\n        path = []\n        current = goal_vertex\n        # Build reverse connectivity map: child->parent with minimum cost\n        parent_map = dict()\n        for v in self._vertices:\n            for c in v.connectivity:\n                # Normalize to only keep edges in tree direction with decreasing cost\n                if self._costs.get(c, float('inf')) > self._costs.get(v, float('inf')):\n                    parent_map[c] = v\n\n        while current is not start_vertex:\n            path.append(current)\n            if current not in parent_map:\n                # No path found (should not happen if graph is consistent)\n                return\n            current = parent_map[current]\n        path.append(start_vertex)\n        path.reverse()\n\n        for vertex in path[1:]:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved RRT* variant that accelerates the convergence and time efficiency \n    by introducing informed sampling once a solution to the goal is found, focusing sampling within an \n    ellipsoid enclosing start and goal to reduce unnecessary exploration. It also terminates search early \n    if elapsed time exceeds 30 seconds. The rewiring and cost update steps are retained for path optimality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # No structural changes, but can add new members\n        self._found_solution = False\n        self._best_goal_vertex: Vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_ellipsoid_sample(self, c_best: float, start: Point, goal: Point) -> Point:\n        \"\"\" \n        Sample inside an ellipsoid defined by start, goal, and best cost c_best to focus search.\n        Reference: Informed RRT* sampling \n        \"\"\"\n        if c_best == float('inf'):\n            # No solution yet, sample randomly in free space\n            return self._get_random_sample()\n\n        start_np = start.to_tensor().numpy()\n        goal_np = goal.to_tensor().numpy()\n\n        c_min = np.linalg.norm(goal_np - start_np)\n        if c_min == 0:\n            # Start and goal are the same\n            return start\n\n        # Compute rotation matrix from ellipsoid frame\n        a1 = (goal_np - start_np) / c_min\n        I = np.identity(len(start_np))\n        M = np.outer(a1, np.array([1] + [0]*(len(start_np)-1)))\n        U, _, Vt = np.linalg.svd(M, full_matrices=True)\n        C = U @ np.diag([1.0]*len(start_np)) @ Vt\n\n        # Sample random point in unit n-ball\n        while True:\n            x_ball = np.random.normal(0, 1, size=len(start_np))\n            norm_x = np.linalg.norm(x_ball)\n            if norm_x <= 1:\n                x_ball /= norm_x\n                break\n        r = np.random.rand() ** (1/len(start_np))\n        x_ball *= r\n\n        # Define radii of ellipsoid axes\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n        radii = np.array([r1] + [r2]*(len(start_np)-1))\n        sample_ellipsoid = C @ (radii * x_ball) + (start_np + goal_np) / 2.0\n\n        # Round and convert to Point within map bounds\n        sample_coords = np.clip(np.round(sample_ellipsoid), 0, self._get_grid().size.n - 1).astype(int)\n        sample_point = Point(*sample_coords)\n\n        # Validate sample position; if invalid, fallback to uniform random sample\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new):\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start = self._get_grid().agent.position\n        goal = self._get_grid().goal.position\n\n        c_best = float('inf')  # Best path cost found so far\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Timeout, stop search without path found\n                break\n\n            if self._found_solution:\n                q_sample: Point = self._get_ellipsoid_sample(c_best, start, goal)\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring nearby vertices if beneficial\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._found_solution = True\n                if q_new.cost < c_best:\n                    c_best = q_new.cost\n                    self._best_goal_vertex = q_new\n                    self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"Description\": \"Bidirectional RRT* inspired algorithm with incremental rewiring to improve path quality and speed up convergence compared to RRT-Connect. It incrementally rewires vertices to optimize paths and uses a balanced growth strategy. Also terminates if no path found within 30 seconds.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._rewire_radius = 15.0  # Radius for rewiring around new nodes for optimization\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_near_vertices(self, root_vertex: Vertex, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Return vertices near q_new within radius from the subgraph rooted at root_vertex\n        \"\"\"\n        near_vertices: List[Vertex] = []\n\n        candidates = self._graph.get_all_vertices([root_vertex])\n        for v in candidates:\n            dist = torch.norm(v.position.to_tensor() - q_new.position.to_tensor())\n            if dist <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, root_vertex: Vertex, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Choose best parent for q_new from near_vertices minimizing cost to q_new.\n        \"\"\"\n        min_cost = float(\"inf\")\n        best_parent: Optional[Vertex] = None\n        for v in near_vertices:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                cost = v.cost + torch.norm(v.position.to_tensor() - q_new.position.to_tensor()).item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        if best_parent is not None:\n            q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, root_vertex: Vertex, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Rewire near vertices to q_new if it offers a cheaper cost path.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                new_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n                if new_cost < v.cost:\n                    # Remove v's current parent edge (if removable)\n                    for p in v.parents:\n                        self._graph.remove_edge(p, v)\n                    self._graph.add_edge(q_new, v)\n                    v.cost = new_cost\n\n    def _extend_rrt_star(self, root_vertex: Vertex, q_sample: Point) -> Optional[Vertex]:\n        \"\"\"\n        RRT* style extend with rewiring. Returns the newly added vertex or None if trapped.\n        \"\"\"\n        q_near: Vertex = self._get_nearest_vertex(root_vertex, q_sample)\n        q_new_candidate: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n        if not self._get_grid().is_valid_line_sequence(\n            self._get_grid().get_line_sequence(q_near.position, q_new_candidate.position)\n        ):\n            return None\n\n        near_vertices = self._get_near_vertices(root_vertex, q_new_candidate, self._rewire_radius)\n        best_parent = self._choose_parent(root_vertex, q_new_candidate, near_vertices)\n        if best_parent is None:\n            # fallback to q_near if no better parent found\n            best_parent = q_near\n            q_new_candidate.cost = best_parent.cost + torch.norm(best_parent.position.to_tensor() - q_new_candidate.position.to_tensor()).item()\n        else:\n            # Already set cost in choose_parent\n            pass\n\n        q_new = Vertex(q_new_candidate.position)\n        q_new.cost = q_new_candidate.cost\n        self._graph.add_edge(best_parent, q_new)\n\n        # Rewire near vertices with q_new as potential parent\n        self._rewire(root_vertex, q_new, near_vertices)\n\n        return q_new\n\n    def _extract_path(self, connecting_vertex: Vertex) -> None:\n        \"\"\"\n        Extract the final path from start to goal through connecting_vertex and move the agent along the path.\n        \"\"\"\n        path: List[Vertex] = []\n\n        # Trace back to start root vertex\n        curr = connecting_vertex\n        while len(curr.parents) != 0:\n            path.append(curr)\n            curr = curr.parents[0]  # single parent path assumption\n        path.append(curr)  # add root vertex\n        path.reverse()\n\n        # Also trace forward from connecting_vertex to goal root vertex\n        # If connecting_vertex belongs originally to the start tree, we trace forward to goal:\n        # Otherwise reverse the graph roots to ensure.\n        curr = connecting_vertex\n        forward_path: List[Vertex] = []\n        while True:\n            children = self._graph.get_children(curr)\n            if not children:\n                break\n            # Assume single child to goal path (tree structure)\n            curr = children[0]\n            forward_path.append(curr)\n        full_path = path + forward_path\n\n        # Move agent step by step on the path with keyframe induction\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Implements a bidirectional RRT* inspired approach with incremental rewiring.\n        Balanced growth from both start and goal trees, terminating if no path found within 30 seconds.\n        \"\"\"\n        start_time = time.time()\n\n        root_start = self._graph.root_vertices[0]  # start tree root\n        root_goal = self._graph.root_vertices[1]  # goal tree root\n\n        # Initialize costs for root vertices\n        root_start.cost = 0.0\n        root_goal.cost = 0.0\n\n        path_found = False\n\n        for i in range(self._iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:\n                # Timeout > 30 seconds, stop search\n                break\n\n            # Sample random valid point\n            q_rand = self._get_random_sample()\n\n            # Extend start tree towards random sample\n            q_new_start: Optional[Vertex] = self._extend_rrt_star(root_start, q_rand)\n            if q_new_start is None:\n                self._graph.reverse_root_vertices()\n                root_start, root_goal = self._graph.root_vertices[0], self._graph.root_vertices[1]\n                self.key_frame()\n                continue\n\n            # Try to connect goal tree to the new vertex added in start tree\n            q_new_goal: Optional[Vertex] = self._extend_rrt_star(root_goal, q_new_start.position)\n            if q_new_goal is not None and q_new_goal.position == q_new_start.position:\n                # Path found by connection of two trees\n                self._extract_path(q_new_start)\n                path_found = True\n                break\n\n            # Swap trees for balanced exploration\n            self._graph.reverse_root_vertices()\n            root_start, root_goal = self._graph.root_vertices[0], self._graph.root_vertices[1]\n\n            self.key_frame()\n\n        if not path_found:\n            # No path found, optionally handle no path (e.g. stop or notify)\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved RRT variant incorporating goal biasing and rewiring (inspired by RRT*),\n    which improves path quality and convergence speed. \n    Goal biasing periodically samples the goal to direct exploration faster towards it.\n    Rewiring attempts to connect new vertices to existing nearby vertices if it reduces path cost,\n    thus optimizing the path incrementally.\n    Additionally, the algorithm enforces a 30-second timeout for path search termination.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable edges for rewiring\n        self._init_displays()\n\n        self._rewire_radius = 15.0  # radius in grid units to search for nearby vertices to rewire for optimal connections\n        self._goal_sample_freq = 0.1  # probability to sample goal position to bias tree growth\n        self._max_dist = 10.0  # max distance to extend tree at each iteration\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir_vec)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / norm_dir\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_freq:\n            return self._get_grid().goal.position  # goal bias sampling\n        \n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within self._rewire_radius of q_new position.\n        \"\"\"\n        near_vertices = []\n        for vertex in self._graph.vertices:\n            if torch.norm(vertex.position.to_tensor() - q_new.position.to_tensor()) <= self._rewire_radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _cost(self, q_start: Vertex, q_end: Vertex) -> float:\n        \"\"\"\n        Computes cost as Euclidean distance between two vertices.\n        \"\"\"\n        return torch.norm(q_start.position.to_tensor() - q_end.position.to_tensor()).item()\n\n    def _choose_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the parent with minimum cost to q_new from near vertices if path is valid.\n        \"\"\"\n        min_cost = math.inf\n        best_parent = None\n        for vertex in q_near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost = vertex.cost + self._cost(vertex, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, q_near_vertices: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        Attempts to rewire near vertices to q_new if it improves their cost and path is valid.\n        \"\"\"\n        for vertex in q_near_vertices:\n            if vertex == q_new.parent:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = q_new.cost + self._cost(q_new, vertex)\n            if new_cost < vertex.cost:\n                # Rewire vertex by changing its parent to q_new\n                if len(vertex.parents) > 0:\n                    old_parent = vertex.parents[0]\n                    self._graph.remove_edge(old_parent, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        goal_v.cost = q_new.cost + self._cost(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]\n            path.append(parent)\n\n        # remove duplicate root start vertex at end\n        if path[-1] == self._graph.root_vertex_start:\n            path.pop()\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    # Override of SampleBasedAlgorithm abstract method\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_iterations = 10000\n\n        for _ in range(max_iterations):\n            current_time = time()\n            if current_time - start_time > 30:\n                # Timeout after 30 seconds: no path found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices = self._near_vertices(q_new)\n            best_parent = self._choose_parent(near_vertices + [q_near], q_new)\n            if best_parent is None:\n                # No valid parent found, discard q_new\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = best_parent.cost + self._cost(best_parent, q_new)\n\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved sample-based path planning method called Informed RRT*.\n    It extends RRT* by focusing sampling in an informed ellipsoidal region around the \n    current best path, which significantly reduces unnecessary exploration and improves \n    time efficiency. The informed sampling uses the start and goal positions and the \n    current best path cost to define the sampling ellipse. The implementation reuses helper \n    functions from the base class and incorporates a 30-second timeout to stop search if \n    a route is not found within that time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._best_cost: Optional[float] = None\n        self._goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipse(self, c_best: float, c_min: float, x_center: Point, C: torch.Tensor) -> Point:\n        \"\"\"Sample a point in an ellipsoidal informed subset of the search space.\"\"\"\n        dimension = 2\n        while True:\n            # Sample unit ball point\n            x_ball = torch.randn(dimension)\n            x_ball /= torch.norm(x_ball)\n            r = torch.rand(1).item() ** (1 / dimension)\n            x_ball *= r\n\n            # Scale by ellipse radii\n            L = torch.diag(torch.tensor([c_best / 2, math.sqrt(c_best**2 - c_min**2) / 2], dtype=torch.float32))\n            x_rand_tensor = torch.mv(C @ L, x_ball) + x_center.to_tensor()\n            x_rand = Point.from_tensor(x_rand_tensor.round().clamp(0, self._get_grid().size[0] - 1))\n\n            if self._get_grid().is_agent_valid_pos(x_rand):\n                return x_rand\n\n    def _rotation_to_world(self, start: Point, goal: Point) -> torch.Tensor:\n        \"\"\"Compute rotation matrix to align ellipse axes with start-goal.\"\"\"\n        direction = (goal.to_tensor() - start.to_tensor()).float()\n        e1 = direction / torch.norm(direction)\n        e2 = torch.tensor([-e1[1], e1[0]])\n        return torch.stack((e1, e2), dim=0)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reuse existing path extraction logic from reference implementation.\n        path: List[Vertex] = [self._goal_vertex]\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n        self._goal_vertex.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, self._goal_vertex)\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._goal_vertex\n\n        # c_min is the straight-line distance start->goal\n        c_min = torch.norm(start_vertex.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n        self._best_cost = None\n        self._graph.size = 1  # initialized with root vertex\n\n        while True:\n            # Timeout check\n            if time.time() - start_time > 30:\n                # Did not find a route within 30 seconds\n                return\n\n            # Decide sample according to whether a better path is found\n            if self._best_cost is None:\n                # No best path found, uniform random sample\n                q_sample: Point = self._get_random_sample()\n            else:\n                # Informed sampling\n                x_center = Point(*((start_vertex.position.to_tensor() + goal_vertex.position.to_tensor()) / 2).round().tolist())\n                C = self._rotation_to_world(start_vertex.position, goal_vertex.position)\n                q_sample = self._sample_in_ellipse(self._best_cost, c_min, x_center, C)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_local = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_local:\n                    q_min = q_near\n                    c_min_local = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    q_near.cost = q_new.cost + child_parent_dist\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost if found better path\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if self._best_cost is None or total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    self._extract_path(q_new)\n                    break\n\n            self._graph.size += 1\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm improves upon the SPRM sample-based method by implementing a rapidly-exploring random tree (RRT)-like approach\n    combined with a heuristic to bias sampling towards the goal, thereby accelerating convergence.\n    Instead of building a large fixed cyclic graph upfront, it incrementally grows a tree from the agent's position,\n    connecting new vertices only if collision-free. It uses goal-bias sampling to improve convergence speed.\n    The search stops either when a path to the goal is found or 30 seconds elapse, ensuring timely termination.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _goal_bias_prob: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300  # Increased samples for denser exploration\n        self._max_radius = 15\n        self._goal_bias_prob = 0.2  # 20% goal bias\n        self._graph = None  # Will be initialized in _find_path_internal\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        RRT style random sampling with goal bias.\n        \"\"\"\n        if torch.rand(1).item() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Returns vertices within radius used for rewiring attempts (like RRT*)\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        \"\"\"\n        Same as provided helper: move towards sample up to max_dist\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # Path disconnected (shouldn't happen if found)\n                break\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        grid = self._get_grid()\n        agent_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        # Initialize graph with just agent and goal as roots (disconnected)\n        V: List[Vertex] = [agent_vertex]\n        self._graph = CyclicGraph(self._services, [agent_vertex, goal_vertex], V)\n        self._graph.edges_removable = True\n        self._init_displays()\n\n        max_edge_len = self._max_radius\n        reached_goal = False\n\n        # For fast nearest neighbor search in this example, we brute force\n        for i in range(self._V_size):\n            if time() - start_time > 30:\n                # Timeout - give up\n                break\n\n            q_sample = self._get_random_sample()\n            # Find nearest vertex in current tree\n            nearest_vertex = min(self._graph.vertices, key=lambda v: torch.norm(v.position.to_tensor() - q_sample.to_tensor()))\n            q_new = self._get_new_vertex(nearest_vertex, q_sample, max_edge_len)\n\n            if not grid.is_agent_valid_pos(q_new.position):\n                continue\n\n            line_seq = grid.get_line_sequence(nearest_vertex.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            new_vertex = q_new\n            # Add new vertex and edge\n            self._graph.add_vertex(new_vertex)\n            self._graph.add_edge(nearest_vertex, new_vertex)\n            self._graph.add_edge(new_vertex, nearest_vertex)\n\n            # Rewire nearby vertices for shorter paths (RRT* concept)\n            nearby_vertices = self._near(new_vertex)\n            for near_vertex in nearby_vertices:\n                if near_vertex is new_vertex:\n                    continue\n                line_seq_rewire = grid.get_line_sequence(new_vertex.position, near_vertex.position)\n                if not grid.is_valid_line_sequence(line_seq_rewire):\n                    continue\n                # If connecting near_vertex to new_vertex shortens path to root agent, update edges accordingly\n                cost_current = torch.norm(near_vertex.position.to_tensor() - agent_vertex.position.to_tensor())\n                cost_new = torch.norm(new_vertex.position.to_tensor() - agent_vertex.position.to_tensor()) + \\\n                           torch.norm(near_vertex.position.to_tensor() - new_vertex.position.to_tensor())\n                if cost_new + 1e-5 < cost_current:\n                    self._graph.remove_edge(near_vertex, nearest_vertex)\n                    self._graph.add_edge(new_vertex, near_vertex)\n                    self._graph.add_edge(near_vertex, new_vertex)\n                    self.key_frame()\n\n            self.key_frame()\n\n            # Try connecting new vertex directly to goal if close enough and path feasible\n            dist_to_goal = torch.norm(new_vertex.position.to_tensor() - goal_vertex.position.to_tensor())\n            if dist_to_goal <= max_edge_len:\n                line_seq_to_goal = grid.get_line_sequence(new_vertex.position, goal_vertex.position)\n                if grid.is_valid_line_sequence(line_seq_to_goal):\n                    # Add edges between new vertex and goal\n                    self._graph.add_edge(new_vertex, goal_vertex)\n                    self._graph.add_edge(goal_vertex, new_vertex)\n                    # Mark connectivity for path extraction\n                    reached_goal = True\n                    break\n\n        if reached_goal:\n            self._extract_path()\n        # else no path found within time limit - do nothing and end ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nEnhanced Informed RRT* algorithm to improve convergence speed and efficiency.\nThis algorithm improves upon the standard RRT* by using informed sampling:\n- Once a feasible path to the goal is found, sampling is restricted within an ellipsoidal\n  subset of the search space (based on the best found path cost) to focus sampling towards\n  promising areas.\n- Early pruning and faster rewiring reduce unnecessary computations.\n- A 30-second timeout is enforced to abort if no path is found quickly.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self.best_cost: Optional[float] = None\n        self.best_vertex: Optional[Vertex] = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipsoid(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Samples inside an ellipsoid defined by the current best path cost.\n        The ellipsoid is oriented along the line between start and goal.\n        \"\"\"\n        # Distance between start and goal\n        c_min = torch.norm(start.to_tensor() - goal.to_tensor()).item()\n        if c_best is None or c_best == float('inf'):\n            # No path found yet, sample uniformly\n            return self._get_random_sample()\n\n        # Define parameters of the ellipsoid\n        center_np = ((start.to_tensor() + goal.to_tensor()) / 2).numpy()\n        # unit vector from start to goal\n        direction = (goal.to_tensor() - start.to_tensor())\n        norm_direction = torch.norm(direction).item()\n        if norm_direction == 0:\n            return start\n        unit_vector = (direction / norm_direction).numpy()\n\n        # Ellipsoid axes lengths\n        a1 = c_best / 2.0   # Major axis length\n        a2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0  # Minor axes length\n\n        # Sample random point in unit ball\n        while True:\n            x_ball = np.random.normal(0, 1, 2)\n            x_ball = x_ball / np.linalg.norm(x_ball)\n            r = np.random.rand() ** 0.5  # sqrt for uniform sampling in ball\n            sample_unit = r * x_ball\n\n            # Transform unit ball sample to ellipsoid sample\n            # Rotation matrix to align x axis to unit_vector\n            angle = math.atan2(unit_vector[1], unit_vector[0])\n            rotation = np.array([[math.cos(angle), -math.sin(angle)],\n                                 [math.sin(angle),  math.cos(angle)]])\n            # Scale axes lengths\n            sample_ellipsoid = rotation @ (sample_unit * np.array([a1, a2])) + center_np\n\n            sample_point = Point(int(round(sample_ellipsoid[0])), int(round(sample_ellipsoid[1])))\n\n            # Validate position within map and pass collision checks\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_dist: float = 10.0\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension: int = 2\n        iterations: int = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout: stop search and return (no path found)\n                break\n\n            if (self.best_cost is None) or (self.best_cost == float('inf')):\n                # No solution found yet: uniform sampling\n                q_sample: Point = self._get_random_sample()\n            else:\n                # Informed sampling inside ellipsoid\n                q_sample = self._sample_in_ellipsoid(start_vertex.position, goal_vertex.position, self.best_cost)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check path collision between nearest and new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Find best parent for q_new based on cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_line = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(near_new_line)\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices if better path through q_new found\n            for q_near in Q_near:\n                near_new_line = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(near_new_line)\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent: Optional[Vertex] = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is inside goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and vertex if better path found\n                goal_dist = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n                path_cost = q_new.cost + goal_dist.item()\n                if (self.best_cost is None) or (path_cost < self.best_cost):\n                    self.best_cost = path_cost\n                    self.best_vertex = q_new\n\n                # Extract path and move\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT-Connect with the following enhancements:\n    - Uses bidirectional RRT with heuristically informed sampling to bias samples toward the goal, improving convergence speed.\n    - Uses goal biasing with a probability to sample the goal directly, reducing random exploration time.\n    - Employs a rewiring strategy like RRT* to optimize paths during tree growth.\n    - Stops searching if the runtime exceeds 30 seconds, treating no path found.\n    - Retains backbone structure of extending and connecting dual trees but adds path cost checks and parent rewiring for smoother paths.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring (RRT* feature)\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.15  # Probability to sample goal directly to speed convergence\n        self._rewire_radius = 15  # Radius for rewire (optimize) step\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        q_new: Vertex = self._get_new_vertex(q_near, q, self._max_dist)\n\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return 'trapped'\n\n        cost_new = q_near.cost + self._distance(q_near.position, q_new.position)\n        # Find vertices in rewire radius and pick the best parent\n        near_vertices = self._graph.get_near_vertices(q_new, self._rewire_radius)\n\n        best_parent = q_near\n        best_cost = cost_new\n\n        for vertex in near_vertices:\n            line_seq_near = self._get_grid().get_line_sequence(vertex.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq_near):\n                cost_thru_vertex = vertex.cost + self._distance(vertex.position, q_new.position)\n                if cost_thru_vertex < best_cost:\n                    best_cost = cost_thru_vertex\n                    best_parent = vertex\n\n        q_new.cost = best_cost\n        q_new.parents = []\n        self._graph.add_edge(best_parent, q_new)\n\n        # Rewire other vertices in the neighborhood if it improves their cost\n        for vertex in near_vertices:\n            if vertex is q_new or vertex is best_parent:\n                continue\n            line_seq_check = self._get_grid().get_line_sequence(q_new.position, vertex.position)\n            if self._get_grid().is_valid_line_sequence(line_seq_check):\n                cost_thru_qnew = q_new.cost + self._distance(q_new.position, vertex.position)\n                if cost_thru_qnew < vertex.cost:\n                    # Rewire connection\n                    self._graph.remove_edge(vertex.parents[0], vertex)\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = cost_thru_qnew\n\n        if q_new.position == q:\n            self._q_new = q_new\n            return 'reached'\n        else:\n            self._q_new = q_new\n            return 'advanced'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        state = 'advanced'\n        while state == 'advanced':\n            state = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return state\n\n    def _extract_path(self) -> None:\n        # Trace from q_new back to start\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = path_mid_to_b[-1].parents[0]\n            path_mid_to_b.append(parent)\n\n        # Trace from extension target back to other root\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = path_a_to_mid[-1].parents[0]\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        p = random.random()\n        # Goal biasing to speed convergence\n        if p < self._goal_sample_rate:\n            goal_pos: Point = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / dist\n        new_pos_tensor = q_near.position.to_tensor() + max_dist * dir_normalized\n        new_pos = Point.from_tensor(new_pos_tensor)\n        return Vertex(new_pos)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n\n            # Timeout check - 30 seconds max\n            if time.time() - start_time > 30.0:\n                # Failed to find path in time\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    return\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm inspired by SPRM, called \"Incremental SPRM with heuristic pruning\".\n    This algorithm speeds up the search by:\n    - Limiting connection attempts only between samples and nearby vertices within a smaller radius,\n      updated incrementally to maintain a sparse yet connected graph.\n    - Incorporating a heuristic to prioritize connection towards the goal direction.\n    - Using batch sampling and incremental graph expansion rather than connecting all vertices at once.\n    - Early stopping if no better connectivity is possible.\n    - Imposes a 30-second timeout to prevent excessively long search.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 12  # Reduced radius for faster connection checks\n        # Initialize vertices randomly sampled in free space\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic_towards_goal(self, from_p: Point, to_p: Point) -> float:\n        \"\"\"Euclidean distance heuristic towards the goal.\"\"\"\n        v = to_p.to_tensor() - from_p.to_tensor()\n        return torch.norm(v).item()\n\n    def _near(self, vertex: Vertex, radius: float = None) -> List[Vertex]:\n        r = radius if radius is not None else self._max_radius\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, r)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = []\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # path not found\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _connect_with_pruning(self, v: Vertex) -> bool:\n        # Attempt connections primarily towards vertices closer to the goal\n        neighbors = self._near(v)\n        goal_pos = self._graph.root_vertices[1].position\n        # Sort neighbors by heuristic cost (distance to goal) ascending so we try more promising first\n        neighbors.sort(key=lambda vert: self._heuristic_towards_goal(vert.position, goal_pos))\n        connected_any = False\n        for u in neighbors:\n            if u is v:\n                continue\n            # Only add edge if line valid and not already connected\n            if u not in v.connectivity:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(u.position, v.position)):\n                    self._graph.add_edge(v, u)\n                    self._graph.add_edge(u, v)\n                    self.key_frame()\n                    connected_any = True\n                    # If goal is reachable from agent, shortcut immediately\n                    if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n                        return True\n        return False\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Incremental approach: sample and connect in batches with pruning\n        batch_size = max(20, self._V_size // 10)  # e.g. 20 samples per batch\n        vertices_unprocessed = set(self._graph.vertices)\n        processed_vertices = set()\n\n        # Ensure root vertices are processed first\n        vertices_queue = [self._graph.root_vertices[0], self._graph.root_vertices[1]]\n        processed_vertices.update(vertices_queue)\n        vertices_unprocessed.difference_update(processed_vertices)\n\n        # Add their connections initially\n        for v in vertices_queue:\n            self._connect_with_pruning(v)\n\n        # Then process rest incrementally\n        while vertices_unprocessed:\n            if time.time() - start_time > 30.0:\n                # Timeout exceeded - treat as path not found\n                return\n\n            batch = []\n            # Get next batch of vertices to process\n            for _ in range(min(batch_size, len(vertices_unprocessed))):\n                v = vertices_unprocessed.pop()\n                batch.append(v)\n            any_new_connection = False\n            for v in batch:\n                did_connect_goal = self._connect_with_pruning(v)\n                processed_vertices.add(v)\n                if did_connect_goal:\n                    self._extract_path()\n                    return\n                any_new_connection = any_new_connection or did_connect_goal\n\n            # If no new connections to goal after full batch processed, try expanding radius slightly for next rounds\n            if not any_new_connection and self._max_radius < 25:\n                self._max_radius += 1  # slowly increase attempting radius to add connectivity\n\n        # Final check if goal connected to agent\n        if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n            self._extract_path() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved version of RRT known as RRT-Connect.\nIt grows two trees simultaneously: one from the start and one from the goal.\nThe trees attempt to connect towards each other by extending towards sampled points.\nThis bidirectional approach reduces the search time significantly compared to basic RRT.\nAdditionally, the algorithm enforces a 30-second timeout to stop searching when taking too long.\nThe path extraction merges the two trees' paths once they connect.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Two separate forests, one from start, one from goal\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_goal.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Show both graphs' displays if needed or reuse parent's displays\n        displays = super().set_display_info()\n        # Optionally add a second display for the goal tree if needed;\n        # but per constraints, keep it simple and just use parent's display\n        return displays\n\n    def _get_random_sample(self) -> Point:\n        # Reuse helper copied from RRT\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Reuse helper copied from RRT\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        length = torch.norm(dir)\n        if length <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / length\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _try_extend(self, tree: Forest, q_target: Point, max_dist: float) -> Optional[Vertex]:\n        # Extend tree towards q_target.\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return None  # no extension needed\n\n        q_new: Vertex = self._get_new_vertex(q_near, q_target, max_dist)\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n            return None\n        tree.add_edge(q_near, q_new)\n        self.key_frame()\n        return q_new\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        # Reconstruct path from start tree root to connection vertex\n        path_start: List[Vertex] = []\n        v = connection_vertex_start\n        while True:\n            path_start.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n        path_start.reverse()\n\n        # Reconstruct path from goal tree root to connection vertex\n        path_goal: List[Vertex] = []\n        v = connection_vertex_goal\n        while True:\n            path_goal.append(v)\n            if len(v.parents) == 0:\n                break\n            v = next(iter(v.parents))\n\n        # Full path is start path + reversed goal path (excluding connection vertex duplicate)\n        full_path = path_start + path_goal[1:]\n\n        # Animate path movement\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_time_seconds: float = 30.0\n        start_time = time.time()\n\n        for i in range(10000):\n            # Check timeout\n            if time.time() - start_time > max_time_seconds:\n                # Path search timeout, break with no result\n                break\n\n            # Sample random point\n            q_sample: Point = self._get_random_sample()\n\n            # Extend start tree towards q_sample\n            q_new_start: Optional[Vertex] = self._try_extend(self._graph_start, q_sample, max_dist)\n            if q_new_start is None:\n                continue\n\n            # Extend goal tree towards q_new_start.position (connect attempt)\n            q_new_goal: Optional[Vertex] = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n            if q_new_goal is None:\n                continue\n\n            # Attempt to connect further from start tree towards last extension in goal tree\n            q_connect_goal_pos = q_new_goal.position\n            while True:\n                q_new_start_extended = self._try_extend(self._graph_start, q_connect_goal_pos, max_dist)\n                if q_new_start_extended is None or q_new_start_extended.position == q_connect_goal_pos:\n                    break\n                q_new_start = q_new_start_extended\n\n                # Try to connect the goal tree again closer to new vertex\n                q_new_goal = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n                if q_new_goal is None or q_new_goal.position == q_new_start.position:\n                    break\n\n            # Check if trees connected (distance small enough)\n            dist = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor())\n            if dist <= max_dist:\n                # Add final connection edge to graph_start for path extraction\n                self._graph_start.add_edge(q_new_start, Vertex(q_new_goal.position))\n                self._extract_path(q_new_start, q_new_goal)\n                return\n\n        # No path found within time or iteration limits; do nothing ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved sample-based path planning inspired by SPRM but incorporates RRT* \n(Rapidly-exploring Random Tree Star) concepts to improve path quality and time efficiency. \nKey improvements:\n- Incrementally builds a tree rooted at the agent, rewiring vertices to shorten paths,\n- Uses a radius-based neighborhood check for rewiring,\n- Limits search time to 30 seconds,\n- Extracts the shortest found path to the goal.\n\nThis leverages the existing graph and vertex structures and sampling helpers from SPRM but \nmodifies the connection and path optimization strategy for faster convergence and better path quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_extend_length: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 20.0\n        self._max_extend_length = 10.0\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow rewiring/removal for RRT*\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"Return vertices within max_radius of given vertex.\"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir).item()\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        else:\n            dir_normalized = dir / dist\n            q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            return Vertex(q_new)\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"Calculate cost to reach this vertex from the agent through connectivity.\"\"\"\n        # Cost is sum of edge distances from root (agent)\n        cost = 0.0\n        current = vertex\n        while True:\n            pred = self._get_parent(current)\n            if pred is None:\n                break\n            cost += torch.dist(current.position.to_tensor(), pred.position.to_tensor()).item()\n            current = pred\n        return cost\n\n    def _get_parent(self, vertex: Vertex) -> Vertex or None:\n        \"\"\"Get the parent vertex chained to this vertex in the tree (nearest neighbor leading to it).\n        Connectivity stores shortest paths. For rewiring, parent is the connection with lowest cost.\"\"\"\n        if not vertex.connectivity:\n            return None\n        # Find the parent vertex as the one that leads along shortest path to agent\n        # The agent vertex is root_vertices[0]\n        agent_vertex = self._graph.root_vertices[0]\n        min_parent = None\n        min_cost = math.inf\n        for v in vertex.connectivity:\n            # connectivity[v] is the vertex to go to from vertex towards v,\n            # But we want the parent that leads from which vertex to this vertex,\n            # So check if vertex is in connectivity of v\n            if vertex in v.connectivity:\n                # Cost from agent to v plus distance from v to vertex\n                pred_cost = self._cost(v) + torch.dist(vertex.position.to_tensor(), v.position.to_tensor()).item()\n                if pred_cost < min_cost:\n                    min_cost = pred_cost\n                    min_parent = v\n        if min_parent is None:\n            # fallback: if vertex directly connected to agent\n            if agent_vertex in vertex.connectivity:\n                return agent_vertex\n            return None\n        return min_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, check if path going through q_new improves cost,\n        if yes, rewire edge from neighbor's parent to q_new.\n        \"\"\"\n        for q_near in neighbors:\n            if q_near == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            cost_q_new = self._cost(q_new)\n            dist_qnew_qnear = torch.dist(q_new.position.to_tensor(), q_near.position.to_tensor()).item()\n            new_cost = cost_q_new + dist_qnew_qnear\n            current_cost = self._cost(q_near)\n            if new_cost < current_cost:\n                # Rewire edges\n                # Remove old parent edge of q_near if any\n                old_parent = self._get_parent(q_near)\n                if old_parent is not None:\n                    if q_near in old_parent.connectivity:\n                        del old_parent.connectivity[q_near]\n                    if old_parent in q_near.connectivity:\n                        del q_near.connectivity[old_parent]\n                # Add new edges between q_new and q_near\n                self._graph.add_edge(q_new, q_near)\n                self._graph.add_edge(q_near, q_new)\n                self.key_frame()\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Reconstruct path from agent to goal by stepping through connectivity\n        path = []\n        current_vertex = goal\n        # Backtrack: find parent chain towards agent\n        while current_vertex is not agent:\n            parent = self._get_parent(current_vertex)\n            if parent is None:\n                # No path found\n                return\n            path.append(current_vertex)\n            current_vertex = parent\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n        V = [agent_vertex] + self._graph.vertices + [goal_vertex]\n\n        # Initialize tree rooted at agent with no edges\n        self._graph.root_vertices[0].connectivity.clear()\n        self._graph.root_vertices[1].connectivity.clear()\n        for v in self._graph.vertices:\n            v.connectivity.clear()\n\n        # Add agent vertex root\n        tree_vertices = [agent_vertex]\n\n        while True:\n            current_time = time.time()\n            if current_time - start_time > 30.0:\n                # Timeout: no route found\n                return\n\n            q_rand_pos = self._get_random_sample()\n            # Find nearest vertex in tree to q_rand\n            nearest_vertex = None\n            min_dist = math.inf\n            for v in tree_vertices:\n                dist = torch.dist(v.position.to_tensor(), q_rand_pos.to_tensor()).item()\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_vertex = v\n\n            q_new = self._get_new_vertex(nearest_vertex, q_rand_pos, self._max_extend_length)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            # Check if edge from nearest_vertex to q_new is valid\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)):\n                continue\n\n            new_vertex = Vertex(q_new.position, store_connectivity=True)\n            # Find neighbors within radius\n            neighbors = self._near(new_vertex)\n\n            # Choose parent with minimum cost connection from neighbors\n            min_cost = math.inf\n            min_vertex = None\n            for q_near in neighbors:\n                if q_near == new_vertex:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, new_vertex.position)):\n                    continue\n                cost = self._cost(q_near) + torch.dist(q_near.position.to_tensor(), new_vertex.position.to_tensor()).item()\n                if cost < min_cost:\n                    min_cost = cost\n                    min_vertex = q_near\n\n            if min_vertex is None:\n                min_vertex = nearest_vertex  # fallback to nearest vertex\n\n            # Add new_vertex and edge to parent\n            self._graph.vertices.append(new_vertex)\n            tree_vertices.append(new_vertex)\n            self._graph.add_edge(min_vertex, new_vertex)\n            self._graph.add_edge(new_vertex, min_vertex)\n            self.key_frame()\n\n            # Rewire neighbors to new_vertex if it improves cost\n            self._rewire(new_vertex, neighbors)\n\n            # Check if goal can be connected and path extracted\n            dist_goal_new = torch.dist(goal_vertex.position.to_tensor(), new_vertex.position.to_tensor()).item()\n            if dist_goal_new <= self._max_extend_length:\n                # Check if connecting new_vertex to goal is valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, goal_vertex.position)):\n                    self._graph.add_edge(new_vertex, goal_vertex)\n                    self._graph.add_edge(goal_vertex, new_vertex)\n                    self.key_frame()\n                    # Extract shortest path\n                    self._extract_path()\n                    return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved sample-based roadmap path planning algorithm inspired by SPRM with enhanced efficiency.\n    Instead of blindly connecting vertices within a max radius, this approach incrementally extends \n    the roadmap using a prioritized nearest neighbor search with rewiring (RRT* style idea) to reduce \n    redundant connections and improve path quality. It limits attempts by time (30 seconds timeout) \n    and tries to connect new samples only to the closest vertices, not all neighbors, thus improving speed.\n    Once the goal is reachable, the path is extracted and the agent moves along it.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _near(self, vertex: Vertex, radius: float = None) -> List[Vertex]:\n        radius = radius if radius is not None else self._max_radius\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new, store_connectivity=True)\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        if goal not in agent.connectivity:\n            return\n\n        current_vertex = agent\n        path = [current_vertex]\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path[1:]:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # To improve speed, iteratively sample and connect only to closest vertex then attempt rewiring\n        for iteration in range(self._V_size):\n            # timeout check\n            if time.time() - start_time > 30.0:\n                # timeout expired\n                return\n\n            q_rand_point = self._get_random_sample()\n            # Find closest vertex in graph to q_rand_point\n            all_vertices = list(self._graph.vertices)\n            min_dist = float('inf')\n            q_nearest: Optional[Vertex] = None\n            q_rand_tensor = q_rand_point.to_tensor()\n            for v in all_vertices:\n                dist = torch.norm(v.position.to_tensor() - q_rand_tensor).item()\n                if dist < min_dist:\n                    min_dist = dist\n                    q_nearest = v\n\n            if q_nearest is None:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_rand_point, self._max_radius)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            # Check collision for edge\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Add new vertex and edge to graph\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(q_nearest, q_new)\n            self._graph.add_edge(q_new, q_nearest)\n            self.key_frame()\n\n            # Rewire nearby vertices for potential better paths (like RRT*)\n            neighbors = self._near(q_new, self._max_radius)\n            # Find best parent to minimize cost (distance from agent)\n            best_parent = q_nearest\n            best_cost = self._cost_to_vertex(agent, q_nearest) + torch.norm(q_new.position.to_tensor() - q_nearest.position.to_tensor()).item()\n            for vertex in neighbors:\n                if vertex == q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                    cost = self._cost_to_vertex(agent, vertex) + torch.norm(q_new.position.to_tensor() - vertex.position.to_tensor()).item()\n                    if cost < best_cost:\n                        best_cost = cost\n                        best_parent = vertex\n\n            if best_parent != q_nearest:\n                # Remove old edge\n                self._graph.remove_edge(q_nearest, q_new)\n                self._graph.remove_edge(q_new, q_nearest)\n                # Add edge to better parent\n                self._graph.add_edge(best_parent, q_new)\n                self._graph.add_edge(q_new, best_parent)\n                self.key_frame()\n\n            # Attempt rewiring neighbors through q_new if it improves cost\n            for vertex in neighbors:\n                if vertex == q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                    current_cost = self._cost_to_vertex(agent, vertex)\n                    new_cost = best_cost + torch.norm(vertex.position.to_tensor() - q_new.position.to_tensor()).item()\n                    if new_cost < current_cost:\n                        parent_of_vertex = self._get_parent_to_vertex(agent, vertex)\n                        if parent_of_vertex is not None:\n                            self._graph.remove_edge(parent_of_vertex, vertex)\n                            self._graph.remove_edge(vertex, parent_of_vertex)\n                        self._graph.add_edge(q_new, vertex)\n                        self._graph.add_edge(vertex, q_new)\n                        self.key_frame()\n\n            # Check if goal reachable from agent\n            if goal in agent.connectivity:\n                self._extract_path()\n                return\n\n    def _cost_to_vertex(self, start_vertex: Vertex, end_vertex: Vertex) -> float:\n        \"\"\"\n        Computes the path cost from start_vertex to end_vertex by traversing connectivity.\n        Returns float('inf') if no path exists.\n        Uses BFS to find shortest path length in edges weighted by Euclidean distance.\n        \"\"\"\n        from collections import deque\n        queue = deque()\n        visited = set()\n        cost_map = {start_vertex: 0.0}\n\n        queue.append(start_vertex)\n        visited.add(start_vertex)\n\n        while queue:\n            current = queue.popleft()\n            if current == end_vertex:\n                return cost_map[current]\n\n            for neighbor in current.connectivity:\n                if neighbor not in visited:\n                    edge_cost = torch.norm(current.position.to_tensor() - neighbor.position.to_tensor()).item()\n                    total_cost = cost_map[current] + edge_cost\n                    if neighbor not in cost_map or total_cost < cost_map[neighbor]:\n                        cost_map[neighbor] = total_cost\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n\n        return float('inf')\n\n    def _get_parent_to_vertex(self, start_vertex: Vertex, target_vertex: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Finds the immediate parent vertex from start_vertex's connectivity chain to target_vertex.\n        Returns None if no parent found or target_vertex is start_vertex.\n        \"\"\"\n        if start_vertex == target_vertex:\n            return None\n\n        from collections import deque\n        queue = deque()\n        visited = set()\n        parent_map = {}\n\n        queue.append(start_vertex)\n        visited.add(start_vertex)\n\n        while queue:\n            current = queue.popleft()\n            for neighbor in current.connectivity:\n                if neighbor not in visited:\n                    parent_map[neighbor] = current\n                    if neighbor == target_vertex:\n                        return current\n                    queue.append(neighbor)\n                    visited.add(neighbor)\n        return None ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved version of the classical RRT called RRT-Connect.\nIt grows two trees simultaneously: one rooted at the start and another rooted at the goal.\nIn each iteration, it samples a random valid point and extends the start tree towards it.\nIf successful, it then tries to connect the goal tree towards the newly added vertex from the start tree.\nIf the two trees can be connected via a valid path segment, it extracts and returns the path.\nThis bidirectional approach typically reduces planning time compared to unidirectional RRT.\nAdditionally, the algorithm imposes a 30-second timeout to treat no-path-found cases.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize two forests: one from start, one from goal\n        self._graph_start = gen_forest(self._services,\n                                       Vertex(self._get_grid().agent.position),\n                                       Vertex(self._get_grid().goal.position),\n                                       [])\n        self._graph_goal = gen_forest(self._services,\n                                      Vertex(self._get_grid().goal.position),\n                                      Vertex(self._get_grid().agent.position),\n                                      [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n\n        self.__map_displays_start: List[MapDisplay] = []\n        self.__map_displays_goal: List[MapDisplay] = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Showing both trees separately by creating separate displays for each graph\n        from algorithms.classic.sample_based.core.graph_display import GraphMapDisplay\n        self.__map_displays_start = [GraphMapDisplay(self._services, self._graph_start)]\n        self.__map_displays_goal = [GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays_start + self.__map_displays_goal\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Optional[Vertex]:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir == 0:\n            return None\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extend(self, graph: Forest, q_target: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Attempt to extend the graph towards q_target by max_dist, returns new vertex if extension successful,\n        else None. This corresponds to the 'Extend' operation in RRT-Connect.\n        \"\"\"\n\n        q_near: Vertex = graph.get_nearest_vertex([graph.root_vertex_start], q_target)\n\n        if q_near.position == q_target:\n            return None\n\n        q_new: Optional[Vertex] = self._get_new_vertex(q_near, q_target, max_dist)\n        if q_new is None:\n            return None\n\n        # Validate path between q_near and q_new\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        graph.add_edge(q_near, q_new)\n        return q_new\n\n    def _connect(self, graph: Forest, q_target: Point, max_dist: float) -> bool:\n        \"\"\"\n        Repeatedly extend the graph towards q_target until unable to extend further or q_target reached.\n        Returns True if q_target reached, False otherwise.\n        \"\"\"\n\n        while True:\n            q_new = self._extend(graph, q_target, max_dist)\n            if q_new is None:\n                return False\n            if q_new.position == q_target:\n                return True\n\n    def _extract_bidirectional_path(self, connecting_vertex_start: Vertex, \n                                    connecting_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract the path connecting the start tree and goal tree at respective vertices,\n        then move the agent along the path.\n        \"\"\"\n\n        # Extract path from start root to connecting_vertex_start\n        path_start: List[Vertex] = [connecting_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            parent = next(iter(path_start[-1].parents))\n            path_start.append(parent)\n        path_start.reverse()\n\n        # Extract path from connecting_vertex_goal to goal root\n        path_goal: List[Vertex] = [connecting_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            parent = next(iter(path_goal[-1].parents))\n            path_goal.append(parent)\n\n        # Concatenate full path (excluding duplicate connecting vertex)\n        full_path: List[Vertex] = path_start + path_goal[1:]\n\n        # Animate path traversal\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_duration_seconds: float = 30.0\n        start_time = time.time()\n\n        # We'll alternate extending trees: start tree then goal tree\n        for iteration in range(10000):\n            \n            if time.time() - start_time > max_duration_seconds:\n                # Timeout reached; treat path as not found\n                break\n\n            # Sample random valid point\n            q_sample = self._get_random_sample()\n\n            # 1) Extend start tree towards q_sample\n            q_new_start = self._extend(self._graph_start, q_sample, max_dist)\n            if q_new_start is None:\n                self.key_frame()\n                continue\n\n            self.key_frame()\n\n            # 2) Try to connect goal tree towards q_new_start\n            reached = self._connect(self._graph_goal, q_new_start.position, max_dist)\n            self.key_frame()\n\n            if reached:\n                # Find the vertex in goal tree nearest to q_new_start\n                q_new_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n\n                # Extract and animate full path\n                self._extract_bidirectional_path(q_new_start, q_new_goal)\n                return\n\n            # Swap roles of trees for next iteration\n            self._graph_start, self._graph_goal = self._graph_goal, self._graph_start\n            self.__map_displays_start, self.__map_displays_goal = self.__map_displays_goal, self.__map_displays_start\n\n        # If exit the loop without returning, no path found within timeout ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant of the RRT* algorithm integrating goal bias sampling and adaptive rewiring radius to improve convergence speed and reduce unnecessary rewiring operations.\n- Goal bias sampling increases the chance of sampling near the goal, accelerating path discovery.\n- Adaptive radius computation reduces the rewiring radius as the tree grows to focus optimization locally.\n- Time constraint of 30 seconds is enforced to terminate if no path is found.\n- Uses existing helper functions for consistency and leverages torch for cost computations.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services, testing=None) -> None:\n        super().__init__(services, testing)\n        # Additional parameter to control goal biasing\n        self._goal_bias_prob: float = 0.1  # 10% of samples towards goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        dimension: int = 2\n        lambda_rrt_star: float = 50\n\n        # Predeclare reused variables\n        grid: Map = self._get_grid()\n        start_time = time.time()\n\n        for i in range(iterations):\n            # Timeout check to abort search after 30 seconds\n            cur_time = time.time()\n            if cur_time - start_time > 30.0:\n                break\n\n            # Goal-biased random sampling: with prob p sample goal, else random valid\n            if np.random.rand() < self._goal_bias_prob:\n                q_sample: Point = grid.goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision for the edge from q_nearest to q_new, skip if invalid\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Adaptive radius calculation based on current graph size to localize rewiring\n            card_v = torch.tensor(float(self._graph.size)) + 1e-6  # add small epsilon to avoid zero division\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with lowest cost to connect q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_line = grid.get_line_sequence(q_near.position, q_new.position)\n                near_new_collision_free = grid.is_valid_line_sequence(near_new_line)\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            # Connect q_new to the best parent q_min\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors only if they can be reached with lower cost from q_new\n            # Skip rewiring if q_new cost is not significantly better to avoid redundant rewiring\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                near_new_line = grid.get_line_sequence(q_new.position, q_near.position)\n                near_new_collision_free = grid.is_valid_line_sequence(near_new_line)\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near + 1e-5 < q_near.cost:\n                    # Remove old edge\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        # Update cost and add new edge\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is within goal radius to extract final path\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved path planner inspired by RRT* with the following enhancements for better time performance:\n    - Incorporates a goal biasing technique to sample the goal position with a certain probability, accelerating convergence to the goal.\n    - Uses a dynamic max distance step size that adapts based on progress.\n    - Implements early stopping when the path cost stops improving significantly over a window of iterations.\n    - Includes a strict time-out of 30 seconds to terminate if no path is found.\n    This yields a faster but still asymptotically optimal planner leveraging the base RRT* backbone.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Start vertex and goal vertex initialization reused from base\n        self._goal_sample_rate: float = 0.1  # 10% goal sampling bias\n        self._improvement_window: int = 50   # Iterations to measure cost improvement\n        self._last_best_cost: float = float('inf')\n        self._no_improve_iters: int = 0\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import torch\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension: int = 2\n\n        start_time = time()\n\n        for i in range(iterations):\n            # Time budget check: stop if > 30 seconds\n            if time() - start_time > 30:\n                # Treat as no path found and exit\n                break\n\n            # Goal biasing sampling\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample: Point = self._get_grid().goal.position\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min: Vertex = q_nearest\n            c_min: float = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor()).item()\n\n            # Choose best parent for q_new\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor()).item()\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire tree around q_new\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    # Remove old edge first\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if agent is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Extract path from q_new to goal\n                self._extract_path(q_new)\n                return\n\n            # Stop if no cost improvement over the last improvement window iterations\n            if q_new.cost < self._last_best_cost - 1e-3:\n                self._last_best_cost = q_new.cost\n                self._no_improve_iters = 0\n            else:\n                self._no_improve_iters += 1\n                if self._no_improve_iters >= self._improvement_window:\n                    # Early stop - No improvement recently\n                    break\n\n            self.key_frame()\n\n        # If finished without path found or time exceeded, do nothing (fail gracefully)\n        # Optionally could move agent to closest node or stay put\n\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor()).item()\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.pop()  # Remove last redundant vertex\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm improves upon SPRM by incorporating a radius-based incremental growth\n    typical to RRT* (Rapidly-exploring Random Tree Star) style methods. It samples points and tries\n    to connect them to the existing graph minimizing path cost through rewiring while maintaining a\n    maximum connection radius. This rewiring reduces overall cost and thus leads to faster convergence\n    towards the goal with a better path quality and fewer collision checks.\n    The search stops if the goal is connected or if a 30-second timeout is reached (treat as failure).\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Parameters kept as in SPRM for direct comparability\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = CyclicGraph(\n            vertices=[Vertex(self._get_grid().agent.position, store_connectivity=True),\n                      Vertex(self._get_grid().goal.position, store_connectivity=True)] + V\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges for optimization\n        self._init_displays()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _vertex_cost(self, vertex: Vertex) -> float:\n        \"\"\"Compute cost to reach this vertex from root agent vertex (0th vertex).\"\"\"\n        # Uses the connectivity dict cost; assume it stores final cost\n        # If no path known, return large cost\n        INF = float('inf')\n        agent_vertex = self._graph.root_vertices[0]\n        if vertex == agent_vertex:\n            return 0.0\n        # Find minimum cost from parents connected to this vertex\n        min_cost = INF\n        # Reverse connectivity not directly stored, so iterate all vertices connectivity\n        for v in self._graph.vertices:\n            if vertex in v.connectivity:\n                cost_v_u = v.connectivity[vertex]\n                cost_v = self._vertex_cost(v) if hasattr(v, 'cost') is False else v.cost\n                total_cost = cost_v + cost_v_u\n                if total_cost < min_cost:\n                    min_cost = total_cost\n        return min_cost\n\n    def _update_vertex_costs(self) -> None:\n        \"\"\"Update costs for all vertices using BFS from agent vertex, store in vertex.cost.\"\"\"\n        from collections import deque\n        agent_vertex = self._graph.root_vertices[0]\n        for v in self._graph.vertices:\n            v.cost = float('inf')\n        agent_vertex.cost = 0.0\n        queue = deque([agent_vertex])\n        while queue:\n            current = queue.popleft()\n            for neighbor in current.connectivity:\n                new_cost = current.cost + current.connectivity[neighbor]\n                if new_cost < neighbor.cost:\n                    neighbor.cost = new_cost\n                    queue.append(neighbor)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        agent_vertex: Vertex = self._graph.root_vertices[0]\n        goal_vertex: Vertex = self._graph.root_vertices[1]\n\n        # Initialize agent cost\n        agent_vertex.cost = 0.0\n\n        # Insert agent and goal already in graph vertices, others are the random samples\n\n        vertices = self._graph.vertices\n\n        # RRT*-style incremental growth with rewiring\n        for i in range(1, len(vertices)):\n            current_time = time.time()\n            if current_time - start_time > 30.0:\n                # Fail if timeout exceed 30s\n                return\n\n            q_new = vertices[i]\n            U = self._near(q_new)\n\n            # Find best parent with lowest cost + edge cost\n            min_cost = float('inf')\n            best_parent = None\n            for u in U:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(u.position, q_new.position)):\n                    edge_cost = torch.norm(q_new.position.to_tensor() - u.position.to_tensor()).item()\n                    cost = u.cost + edge_cost if hasattr(u, 'cost') else float('inf')\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = u\n            if best_parent is None:\n                # No valid parent connection\n                continue\n\n            # Connect q_new to best parent\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.add_edge(q_new, best_parent)\n            q_new.cost = min_cost\n\n            # Rewire: check if q_new can improve connection to neighbors\n            for u in U:\n                if u is not best_parent and u != q_new:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, u.position)):\n                        edge_cost = torch.norm(u.position.to_tensor() - q_new.position.to_tensor()).item()\n                        new_cost = q_new.cost + edge_cost\n                        if hasattr(u, 'cost') is False:\n                            u.cost = float('inf')\n                        if new_cost < u.cost:\n                            # Remove old edges from parents to u\n                            parents = [v for v in self._graph.vertices if u in v.connectivity]\n                            for p in parents:\n                                self._graph.remove_edge(p, u)\n                            # Add new edge from q_new to u\n                            self._graph.add_edge(q_new, u)\n                            self._graph.add_edge(u, q_new)\n                            u.cost = new_cost\n\n            self.key_frame()\n            # Check connection to goal\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return\n\n        # After all vertices processed, if no path found, no movement occurs (fail silently)\n\n    def _extract_path(self) -> None:\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n        path = list()\n\n        current_vertex = agent\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # Path incomplete due to partial connectivity\n                return\n            current_vertex = current_vertex.connectivity[goal] if False else None\n            # Instead reconstruct by choosing the neighbor with minimal cost towards goal\n            # We reconstruct path by following min cost edges (greedy)\n            min_cost_vertex = None\n            min_cost = float('inf')\n            for nxt in current_vertex.connectivity:\n                if hasattr(nxt, 'cost') and nxt.cost < min_cost:\n                    min_cost = nxt.cost\n                    min_cost_vertex = nxt\n            if min_cost_vertex is None:\n                break\n            path.append(min_cost_vertex)\n            current_vertex = min_cost_vertex\n            if current_vertex == goal:\n                break\n\n        # Alternative robust approach: reconstruct by following the connectivity to goal in SPRM style\n        # Because connectivity structure stores shortest connectivity to goal vertex\n        current = agent\n        path = []\n        while current is not goal:\n            if goal not in current.connectivity:\n                return\n            current = current.connectivity[goal]\n            path.append(current)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.get_displays() if hasattr(self._graph, \"get_displays\") else super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-Based Planner combining SPRM backbone with heuristic-guided connection to\n    speed up goal-directed search. Instead of blindly connecting only near root vertices,\n    this algorithm selectively extends the graph by sampling and connecting vertices not only near the agent,\n    but also near the goal, and attempts to connect new vertices towards the goal using a biased sampling\n    strategy. It uses a max iteration/time cutoff and the approximate cost-to-go heuristic (Euclidean distance)\n    to guide edges addition, thus improving convergence time. The path extraction follows connectivity from agent to goal.\n    If no path is found within 30 seconds, it terminates as no route found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _max_iter: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._max_iter = 5000\n\n        # Initialize vertices with random samples distributed both near agent and goal to bias exploration\n        V: List[Vertex] = list()\n        agent_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        # Half samples near agent, half near goal, with some uniform randomness for diversity\n        for i in range(self._V_size):\n            if i % 2 == 0:\n                q_rand = self._biased_sample_around(agent_pos, radius=self._max_radius*2)\n            else:\n                q_rand = self._biased_sample_around(goal_pos, radius=self._max_radius*2)\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = CyclicGraph()\n        # Add root vertices (agent and goal)\n        agent_v = Vertex(agent_pos, store_connectivity=True)\n        goal_v = Vertex(goal_pos, store_connectivity=True)\n        self._graph.root_vertices = [agent_v, goal_v]\n\n        for v in V:\n            self._graph.add_vertex(v)\n\n        self._init_displays()\n\n    def _biased_sample_around(self, center: Point, radius: float) -> Point:\n        \"\"\"\n        Sample a valid point within a ball of given radius around center, biased towards valid positions.\n        \"\"\"\n        attempts = 0\n        while attempts < 100:\n            offsets = [torch.randint(-int(radius), int(radius)+1, (1,)).item() for _ in range(self._get_grid().size.n_dim)]\n            candidate_coords = [max(0, min(self._get_grid().size[i]-1, center[i] + offsets[i])) for i in range(self._get_grid().size.n_dim)]\n            candidate = Point(*candidate_coords)\n            if self._get_grid().is_agent_valid_pos(candidate):\n                return candidate\n            attempts += 1\n        # fallback: random valid anywhere\n        return self._get_random_sample()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir / norm\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point, store_connectivity=True)\n\n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _extract_path(self):\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        # Follow connectivity dictionary built dynamically from agent towards goal\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # No path can be reconstructed\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.get_displays() if hasattr(self._graph, 'get_displays') else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        iteration = 0\n        while iteration < self._max_iter:\n            iteration += 1\n\n            # Time cutoff check\n            if time.time() - start_time > 30:\n                # Consider no path found\n                return\n\n            # Sample a target biased to goal with probability 0.3 else random sample near agent\n            if torch.rand(1).item() < 0.3:\n                q_sample = self._biased_sample_around(goal.position, radius=self._max_radius*3)\n            else:\n                q_sample = self._biased_sample_around(agent.position, radius=self._max_radius*3)\n\n            # Find nearest vertex in graph to q_sample\n            distances = [(v, self._heuristic_distance(v.position, q_sample)) for v in self._graph.vertices]\n            distances.sort(key=lambda x: x[1])\n            q_near = distances[0][0]\n\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_radius)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            # Check if path from q_near to q_new is valid\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Add vertex and edge q_near -> q_new\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(q_near, q_new)\n            self._graph.add_edge(q_new, q_near)\n\n            # Connect q_new to all vertices within radius in graph (including roots)\n            neighbours = self._near(q_new)\n            for v in neighbours:\n                if v is q_new:\n                    continue\n                seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n                if self._get_grid().is_valid_line_sequence(seq):\n                    self._graph.add_edge(q_new, v)\n                    self._graph.add_edge(v, q_new)\n\n            self.key_frame()\n\n            # Check connectivity from agent to goal\n            if goal in agent.connectivity:\n                self._extract_path()\n                return\n\n        # If here, max iterations exceeded without path found - treat as failure\n        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of RRT* by incorporating a goal-biased sampling strategy and adaptive neighbor radius computation.\n    It uses a heuristic that biases sampling towards the goal to improve convergence speed.\n    The neighbor radius dynamically shrinks as the tree grows to reduce unnecessary rewiring checks.\n    Additionally, a 30-second timeout is enforced to terminate the search if no path is found within the time limit.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved path planning approach based on RRT, inspired by RRT*. It integrates goal biasing and a rewire step to improve path quality and speed up convergence.\n- Goal biasing: samples the goal point with a fixed probability to direct growth towards the goal.\n- Rewiring: after adding a new vertex, attempts to reconnect nearby vertices through the new vertex if it results in lower cost paths.\n- Utilizes a cost function representing path length from start.\n- Stops search if path not found within 30 seconds to avoid long waits.\n- Inherits from SampleBasedAlgorithm and follows the given interface.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring for better path improvements\n        self._init_displays()\n\n        # Parameters for the algorithm\n        self._max_dist: float = 10.0\n        self._iterations: int = 10000\n        self._goal_sample_rate: float = 0.10  # 10% samples directly from goal to bias growth\n        self._near_radius: float = 15.0  # Radius to search neighbors for rewiring\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        diff = p1.to_tensor() - p2.to_tensor()\n        return float(torch.norm(diff))\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability goal_sample_rate, sample goal point\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        # Otherwise, uniform random sampling inside map valid positions\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        vertices_near = []\n        radius = self._near_radius\n        for v in self._graph.vertices:\n            if self._distance(v.position, q_new.position) <= radius:\n                vertices_near.append(v)\n        return vertices_near\n\n    def _choose_parent(self, q_near_list: List[Vertex], q_new_pos: Point) -> Optional[Vertex]:\n        # Choose the vertex from q_near_list that yields minimal cost + distance to q_new_pos and valid edge\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in q_near_list:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new_pos)):\n                continue\n            cost = vertex.cost + self._distance(vertex.position, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, q_near_list: List[Vertex]) -> None:\n        # For each near vertex, check if routing through q_new improves cost, if so, rewire\n        for vertex in q_near_list:\n            if vertex == q_new.parent:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            new_cost = q_new.cost + self._distance(q_new.position, vertex.position)\n            if new_cost < vertex.cost:\n                # Rewire the tree by changing the parent edge\n                # Remove old parent's edge to vertex and add new edge from q_new to vertex\n                # Assume Forest class handles edge update properly\n                if vertex.parents:\n                    old_parent = vertex.parents[0]\n                    self._graph.remove_edge(old_parent, vertex)\n                self._graph.add_edge(q_new, vertex)\n                vertex.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> List[Vertex]:\n        path = [q_goal]\n        current = q_goal\n        while current.parents:\n            current = current.parents[0]\n            path.append(current)\n        path.reverse()\n        return path\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        start_vertex.cost = 0.0\n        self._graph.vertices = [start_vertex]\n        self._graph.edges = []\n        \n        for i in range(self._iterations):\n            current_time = time.time()\n            if (current_time - start_time) > 30.0:\n                # Timeout at 30 seconds, terminate search treated as not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([start_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            # Get new vertex in direction of q_sample limited by max_dist\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            dist_to_sample = torch.norm(dir_vec)\n            if dist_to_sample <= self._max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / dist_to_sample\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + self._max_dist * dir_normalized)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n                continue\n\n            # Find near vertices for potential parent and rewiring\n            dummy_q_new = Vertex(q_new_pos)  # temporary vertex for neighbor search\n            q_near_list = self._get_near_vertices(dummy_q_new)\n\n            # Choose best parent from neighbors\n            best_parent = self._choose_parent(q_near_list, q_new_pos)\n            if best_parent is None:\n                # If no suitable parent found among neighbors, default to q_near if valid edge\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new_pos)):\n                    continue\n                best_parent = q_near\n\n            q_new = Vertex(q_new_pos)\n            q_new.cost = best_parent.cost + self._distance(best_parent.position, q_new.position)\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.vertices.append(q_new)\n\n            # Rewire the neighbors to improve paths through q_new\n            self._rewire(q_new, q_near_list)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect goal vertex and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                    self._graph.add_edge(q_new, goal_vertex)\n                    path_vertices = self._extract_path(goal_vertex)\n                    \n                    for vertex in path_vertices:\n                        self.move_agent(vertex.position)\n                        self.key_frame(ignore_key_frame_skip=True)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant of the RRT-Connect, combining bidirectional tree growth with informed sampling to accelerate pathfinding.\nInstead of purely random sampling, it uses heuristic bias towards the line segment between start and goal to reduce exploration time.\nAdditionally, it limits the search duration strictly to 30 seconds, after which it aborts and considers the path not found.\nThis approach aims to find a collision-free path faster by focusing sampling in the most promising regions,\nwhile preserving the backbone of the original RRT-Connect algorithm structure and interfaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: 'Forest'\n    _max_dist: float\n    _iterations: int\n    _timeout: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._timeout = 30.0  # seconds\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"\n        Generates samples biased towards the ellipse defined by start and goal,\n        aiming to improve efficiency by sampling more frequently in promising areas.\n        If the ellipse sampling point is invalid, fallback to uniform random valid point.\n        \"\"\"\n        start = self._graph.root_vertices[0].position.to_tensor()\n        goal = self._graph.root_vertices[-1].position.to_tensor()\n        dimension = start.shape[0]\n\n        c_best = (goal - start).norm().item()\n        if c_best == 0:\n            # Start and goal are the same\n            return Point.from_tensor(start)\n\n        # Ellipse parameters - A simple heuristic: here, just a line segment with radius heuristics\n        c_min = c_best\n        x_center = (start + goal) / 2\n\n        # Cholesky decomposition of ellipse matrix (for unit ball to ellipse mapping)\n        # Construct rotation matrix C from standard basis to ellipse frame\n        e1 = (goal - start) / c_min\n\n        # For 2D/3D, build basis orthonormal complement matrix U for e1\n        # Here we approximate with identity since no specific ellipsoid orientation provided;\n        # sampling in a ball scaled by max_dist * c_best\n        try:\n            if dimension == 2:  # 2D specific construction\n                U = torch.eye(2)\n                U[:, 0] = e1\n                # Orthogonal:\n                ortho = torch.tensor([-e1[1], e1[0]])\n                U[:, 1] = ortho\n            elif dimension == 3:\n                import torch.linalg as LA\n                # Gram-Schmidt for basis completion\n                b1 = e1\n                if abs(b1[0].item()) < 0.9:\n                    tmp = torch.tensor([1,0,0], dtype=b1.dtype, device=b1.device)\n                else:\n                    tmp = torch.tensor([0,1,0], dtype=b1.dtype, device=b1.device)\n                b2 = tmp - (tmp @ b1) * b1\n                b2 /= torch.norm(b2)\n                b3 = torch.cross(b1, b2)\n                U = torch.stack((b1, b2, b3), dim=1)\n            else:\n                U = torch.eye(dimension)\n        except Exception:\n            U = torch.eye(dimension)\n\n        # Sample in unit n-ball (uniform)\n        while True:\n            sample_ball = torch.randn(dimension)\n            norm = torch.norm(sample_ball)\n            if norm > 1e-6:\n                sample_ball = sample_ball / norm * (np.random.rand() ** (1.0 / dimension))\n                break\n\n        # Scale the sample within informed set (using a heuristic radius)\n        a1 = c_best / 2.0\n        r = self._max_dist if self._max_dist > a1 else a1\n        L = torch.diag(torch.tensor([a1] + [r]*(dimension - 1)))\n\n        # Generate sample in ellipsoid frame\n        informed_point = U @ L @ sample_ball + x_center\n\n        sample_point = Point.from_tensor(informed_point.round().to(torch.int))\n\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback uniform random until valid\n            return self._get_random_sample()\n\n    # We reuse _get_random_sample from original code without changes\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self) -> None:\n        # Same extraction as RRT-Connect. Trace back parents from both trees.\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout:\n                # Timeout reached: fail gracefully\n                break\n\n            q_rand: Point = self._get_informed_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis improved path planning algorithm enhances the original SPRM approach by integrating a prioritized connection strategy inspired by RRT* to reduce unnecessary edge checks and speed up convergence. \nIt maintains a cyclic graph of vertices but focuses connection attempts on promising nodes near the newly added vertex.\nAdditionally, it uses a goal bias sampling strategy to increase the chance of sampling near the goal and incorporates early termination when a path is found or 30 seconds pass.\nThe method yields faster pathfinding by focusing expansion efforts more efficiently while preserving roadmap connectivity.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._goal_sample_rate = 0.1  # 10% chance to directly sample goal position\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Get vertices within max_radius from given vertex.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample a random point in the map, with goal bias to speed convergence.\n        \"\"\"\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_sample_rate:\n            # bias toward goal\n            goal_pos = grid.goal.position\n            if grid.is_agent_valid_pos(goal_pos):\n                return goal_pos\n        while True:\n            sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        \"\"\"\n        Create new vertex moving from q_near toward q_sample with max distance constraint.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _extract_path(self):\n        \"\"\"\n        Extract path from agent to goal following connectivity links and move agent.\n        \"\"\"\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Core planning routine implementing a goal-biased incremental roadmap connection approach,\n        limiting edge connection trials with a prioritized near set.\n        Terminates if path is found or time exceeds 30 seconds.\n        \"\"\"\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Special early check - direct connection agent<->goal\n        if grid.is_valid_line_sequence(grid.get_line_sequence(agent_vertex.position, goal_vertex.position)):\n            self._graph.add_edge(agent_vertex, goal_vertex)\n            self._graph.add_edge(goal_vertex, agent_vertex)\n            self._extract_path()\n            return\n\n        start_time = time.time()\n\n        # We'll incrementally add edges by sampling around the graph vertices, prioritizing closing the gap agent->goal.\n        max_iterations = 5000  # cap for safety\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:  # time cutoff for no solution\n                return\n\n            q_sample_pos: Point = self._get_random_sample()\n            # Find nearest node in graph to q_sample_pos\n            q_near = self._graph.get_nearest_vertex(q_sample_pos)\n            if q_near is None:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample_pos, self._max_radius)\n            # Valid position check\n            if not grid.is_agent_valid_pos(q_new.position):\n                continue\n\n            # Skip adding duplicate vertex if already in graph near position\n            near_to_new = self._near(q_new)\n            duplicate_found = False\n            for v in near_to_new:\n                if v.position == q_new.position:\n                    q_new = v\n                    duplicate_found = True\n                    break\n            if not duplicate_found:\n                self._graph.add_vertex(q_new)\n\n            # Attempt to connect q_new to nearby vertices in prioritized fashion\n            connection_candidates = self._near(q_new)\n\n            # Sort candidates by distance heuristic to goal (closer first)\n            connection_candidates.sort(key=lambda v: torch.dist(v.position.to_tensor(), goal_vertex.position.to_tensor()))\n\n            for v in connection_candidates:\n                if v is q_new:\n                    continue\n                # Check line of travel collision\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, v.position)):\n                    # Add bidirectional edges if not already connected\n                    if v not in q_new.connectivity:\n                        self._graph.add_edge(q_new, v)\n                    if q_new not in v.connectivity:\n                        self._graph.add_edge(v, q_new)\n                    self.key_frame()\n\n            # Also try direct connect to agent and goal if close enough and not connected\n            for root_vertex in self._graph.root_vertices:\n                dist_root = torch.dist(root_vertex.position.to_tensor(), q_new.position.to_tensor())\n                if dist_root <= self._max_radius and root_vertex not in q_new.connectivity:\n                    if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, root_vertex.position)):\n                        self._graph.add_edge(q_new, root_vertex)\n                        self._graph.add_edge(root_vertex, q_new)\n                        self.key_frame()\n\n            # Check if path found\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return\n\n        # If we reach here, no path found in allotted iterations/time\n        return\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planner inspired by RRT*,\n    called Informed RRT*. It accelerates the search by sampling directly\n    in an ellipsoidal subset of the state space that contains the shortest\n    path and pruning the tree by removing vertices outside this region.\n    This reduces computational overhead and focuses search toward the goal,\n    improving convergence speed. A timeout of 30 seconds is enforced to abort\n    if no path is found within that period.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Informed RRT* requires tracking best solution cost found so far:\n        self._best_cost: float = float('inf')\n        self._best_vertex: Vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample_informed(self, c_best: float, c_min: float, x_center: Point, C: torch.Tensor) -> Point:\n        \"\"\"\n        Samples a random point in the prolate hyperspheroid defined by the current best path cost c_best,\n        minimal cost c_min, centered at x_center, and rotation matrix C.\n        \"\"\"\n        # Dimension is 2:\n        if c_best == float('inf'):\n            # No solution found yet: sample uniformly in entire map\n            return self._get_random_sample()\n\n        # Sample from unit ball\n        while True:\n            # Sample random point inside unit ball\n            r = np.random.rand() ** (1/2)  # radius with uniform volume distribution\n            theta = np.random.uniform(0, 2*math.pi)\n            x_ball = torch.tensor([r * math.cos(theta), r * math.sin(theta)])\n            # Define the ellipsoid axes radii\n            a1 = c_best / 2.0\n            a2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            # Stretch and rotate the sample in ellipsoid space\n            L = torch.diag(torch.tensor([a1, a2]))\n            x_rand_tensor = torch.matmul(torch.matmul(C, L), x_ball) + x_center.to_tensor()\n            sample_point = Point.from_tensor(x_rand_tensor)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _compute_rotation_to_world_frame(self, start_pos: Point, goal_pos: Point) -> torch.Tensor:\n        \"\"\"\n        Computes rotation matrix C that aligns the local frame of ellipsoid with the world frame.\n        \"\"\"\n        direction = goal_pos.to_tensor() - start_pos.to_tensor()\n        e1 = direction / torch.norm(direction)\n        # Construct orthonormal basis in 2D: e1 and e2 such that [e1 e2] is rotation matrix\n        R = torch.eye(2)\n        R[:, 0] = e1\n        e2 = torch.tensor([-e1[1], e1[0]])  # perpendicular vector in 2D\n        R[:, 1] = e2\n        return R\n\n    def _prune_tree(self, cost_threshold: float) -> None:\n        \"\"\"\n        Removes vertices from the graph whose cost from start exceeds the cost_threshold.\n        This focuses the tree on promising paths within the informed RRT* ellipsoid.\n        \"\"\"\n        vertices_to_remove = []\n        for v in list(self._graph.get_vertices()):  # get all vertices in graph\n            if v.cost is None:\n                continue\n            if v.cost >= cost_threshold:\n                vertices_to_remove.append(v)\n        for v in vertices_to_remove:\n            # Remove all edges and from graph\n            for parent in list(v.parents):\n                self._graph.remove_edge(parent, v)\n            self._graph.remove_vertex(v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        goal_position: Point = self._get_grid().goal.position\n        start_position: Point = self._get_grid().agent.position\n        c_min = torch.norm(goal_position.to_tensor() - start_position.to_tensor())\n        x_center = Point(\n            *(0.5 * (start_position.to_tensor() + goal_position.to_tensor()))\n        )\n        C = self._compute_rotation_to_world_frame(start_position, goal_position)\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout after 30 seconds - treat as no path found\n                break\n\n            c_best = self._best_cost\n            if c_best == float('inf'):\n                # No solution yet: sample uniformly\n                q_sample: Point = self._get_random_sample()\n            else:\n                # Sample in informed ellipsoid\n                q_sample: Point = self._get_random_sample_informed(c_best, c_min, x_center, C)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            # Include the nearest vertex if not already in Q_near:\n            if q_nearest not in Q_near:\n                Q_near.append(q_nearest)\n\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    # Remove old edge\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    self._graph.add_edge(q_new, q_near)\n\n            # If q_new is better and reaches goal, update best solution\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n                self._graph.add_edge(q_new, goal_vertex)\n\n                if goal_vertex.cost < self._best_cost:\n                    self._best_cost = goal_vertex.cost\n                    self._best_vertex = goal_vertex\n                    # Prune the tree using the new best cost\n                    self._prune_tree(self._best_cost)\n                    self._extract_path(goal_vertex)\n                    break\n\n            self.key_frame()\n\n        # If timeout and no path found, optionally key_frame as done\n        if self._best_vertex is None:\n            # no path found situation\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT called RRT-Connect.\n    It simultaneously grows two trees: one from the start and one from the goal,\n    attempting to connect them for faster pathfinding.\n    It utilizes bidirectional search, extending the trees towards random samples and each other,\n    dramatically reducing the search time compared to the unidirectional RRT.\n    The algorithm stops if a path is found or if 30 seconds have passed.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: Optional[BasicTesting] = None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 10.0\n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, self._goal_vertex, self._start_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        # prepare displays for both trees combined\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self.__map_displays = []\n        # Reuse GraphMapDisplay to show start tree\n        from algorithms.classic.sample_based.core.graph_display import GraphMapDisplay\n        self.__map_displays.append(GraphMapDisplay(self._services, self._graph_start))\n        # A second display for goal tree with different color could be added if support exists,\n        # else just show the combined graphs later if needed.\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Same helper as in RRT: extends from q_near towards q_sample no more than max_dist.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _steer(self, forest: Forest, q_from: Vertex, q_to: Point) -> Optional[Vertex]:\n        \"\"\"\n        Attempts to extend the tree from q_from towards q_to respecting max_dist \n        Returns the new vertex if extension is possible and valid, else None.\n        \"\"\"\n        q_new = self._get_new_vertex(q_from, q_to, self._max_dist)\n        line_seq = self._get_grid().get_line_sequence(q_from.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        forest.add_edge(q_from, q_new)\n        return q_new\n\n    def _try_connect(self, forest: Forest, q_near: Vertex, q_target: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Attempts to connect q_near to q_target by extension steps up to max_dist,\n        extending the tree as close as possible to q_target.\n        Returns the last vertex in the extension or None if no progress.\n        \"\"\"\n        while True:\n            q_new = self._get_new_vertex(q_near, q_target.position, self._max_dist)\n            if q_new.position == q_near.position:\n                return q_near  # no progress\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return None\n\n            forest.add_edge(q_near, q_new)\n            if q_new.position == q_target.position:\n                return q_new\n\n            q_near = q_new\n            # If close enough to q_target, stop early\n            dist_to_target = torch.norm(q_target.position.to_tensor() - q_near.position.to_tensor())\n            if dist_to_target <= self._max_dist:\n                return q_near\n\n    def _build_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Builds path from start to goal by tracing parents from connection_vertex_start up to root\n        and from connection_vertex_goal up to root in goal tree, then moves agent along it.\n        \"\"\"\n        # Trace path backward from start side vertex\n        path_start = [connection_vertex_start]\n        current = connection_vertex_start\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                current = parent\n                path_start.append(current)\n                break\n        path_start.reverse()  # start to connection point\n\n        # Trace path backward from goal side vertex\n        path_goal = []\n        current = connection_vertex_goal\n        while len(current.parents) != 0:\n            for parent in current.parents:\n                current = parent\n                path_goal.append(current)\n                break\n\n        # Complete path is start side path + reversed goal side path\n        full_path = path_start + path_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Returns a valid random sample point on the grid.\n        Biases samples with a chance towards the goal for faster convergence.\n        \"\"\"\n        bias_towards_goal_prob = 0.1\n        if np.random.rand() < bias_towards_goal_prob:\n            return self._goal_vertex.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_time = 30.0  # seconds\n\n        for _ in range(10000):\n\n            if (time.time() - start_time) > max_time:\n                # Consider no path found if timeout\n                if self.testing is not None:\n                    self.testing.log(\"PathPlanning: Timeout reached. No path found.\")\n                break\n\n            # Sample random point\n            q_sample = self._get_random_sample()\n\n            # Extend start tree towards q_sample\n            q_near_start = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            if q_near_start.position == q_sample:\n                continue\n            q_new_start = self._steer(self._graph_start, q_near_start, q_sample)\n            if q_new_start is None:\n                continue\n\n            # Extend goal tree towards q_new_start.position\n            q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n            q_new_goal = self._try_connect(self._graph_goal, q_near_goal, q_new_start)\n            if q_new_goal is None:\n                self.key_frame()\n                continue\n\n            # Check if the two trees are connected (positions match or close enough)\n            dist = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor())\n            if dist <= self._max_dist:\n                # Path found, build and move the agent along path\n                self._build_path(q_new_start, q_new_goal)\n                break\n\n            # Swap roles each iteration (bidirectional growth)\n            self._graph_start, self._graph_goal = self._graph_goal, self._graph_start\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT* which enhances the basic RRT \n    by rewiring the tree to reduce path cost dynamically during tree expansion. \n    This approach biases sampling towards the goal occasionally to speed up convergence.\n    It maintains and updates a tree of vertices, connects new samples to nearest vertex, \n    and attempts to reconnect nearby vertices for shorter paths. \n    The algorithm stops after finding a path within the goal region or after 30 seconds timeout.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _goal_bias_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._goal_bias_rate = 0.1  # 10% samples biased towards goal\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removing edges for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        With probability goal_bias_rate, returns the goal position as sample to bias search towards goal.\n        Otherwise, returns a uniformly random valid point in grid.\n        \"\"\"\n        if np.random.rand() < self._goal_bias_rate:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Finds all vertices in the graph within a radius of q_new.position.\n        \"\"\"\n        near_vertices = []\n        for vertex in self._graph.all_vertices():\n            dist = torch.norm(vertex.position.to_tensor() - q_new.position.to_tensor())\n            if dist <= radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Vertex:\n        \"\"\"\n        Chooses the best parent for q_new to minimize cost to come.\n        Returns the parent if found, else None.\n        \"\"\"\n        min_cost = inf\n        best_parent = None\n        cost_to_qnew_position = None\n\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_to_parent = self._graph.cost_to_come(v)\n            dist_v_to_qnew = torch.norm(v.position.to_tensor() - q_new.position.to_tensor()).item()\n            total_cost = cost_to_parent + dist_v_to_qnew\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = v\n                cost_to_qnew_position = total_cost\n\n        if best_parent is not None:\n            q_new.cost_to_come = cost_to_qnew_position\n        else:\n            q_new.cost_to_come = inf\n\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire near vertices to go through q_new for reduced cost.\n        \"\"\"\n        for v in near_vertices:\n            if v == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            current_cost = self._graph.cost_to_come(v)\n            dist_qnew_to_v = torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n            new_cost = q_new.cost_to_come + dist_qnew_to_v\n\n            if new_cost < current_cost:\n                # Remove old edge from its parent and add new edge from q_new\n                old_parents = list(v.parents)\n                for p in old_parents:\n                    self._graph.remove_edge(p, v)\n                self._graph.add_edge(q_new, v)\n                v.cost_to_come = new_cost\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extracts path from q_new to root start and moves agent along this path.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.get_display_info() if hasattr(self._graph, 'get_display_info') else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        radius: float = 15  # radius to consider neighbors for rewiring\n\n        start_time = time.time()\n\n        # Initialize root vertex cost_to_come = 0\n        self._graph.root_vertex_start.cost_to_come = 0.0\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout after 30 seconds, treat route as not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            near_vertices = self._near_vertices(q_new, radius)\n            best_parent = self._choose_parent(q_new, near_vertices)\n            if best_parent is None:  # cannot find valid parent near q_new\n                # fallback to q_near direct connection if valid\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    best_parent = q_near\n                    q_new.cost_to_come = self._graph.cost_to_come(q_near) + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                else:\n                    continue\n\n            self._graph.add_edge(best_parent, q_new)\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved and optimized variant of RRT-Connect by introducing informed sampling. \nInspired by RRT* and Informed RRT*, it restricts random sampling to an ellipsoidal subset of the search space \nbounded by the current best path cost, which significantly improves convergence time in large discrete maps. \nIt retains the original bi-directional tree growing and connecting mechanism, reusing helper methods for extending and connecting trees.\nIt also includes a 30-second timeout for search termination if no path is found.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _best_path_cost: float\n    _found_path: bool\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._best_path_cost = float(\"inf\")  # Initialize with no path found yet\n        self._found_path = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        # Euclidean distance between two points\n        dir_vec = p1.to_tensor() - p2.to_tensor()\n        return torch.norm(dir_vec).item()\n\n    def _informed_sample(self, c_best: float, start: Point, goal: Point) -> Point:\n        # Informed sampling: sample within ellipsoidal region bounded by c_best (best path length)\n        # When no solution found yet (c_best=inf), sample uniformly\n        if c_best == float(\"inf\"):\n            return self._get_random_sample()\n\n        # Ellipsoid parameters\n        c_min = self._euclidean_distance(start, goal)\n        if c_min == 0:\n            # Start and goal are same\n            return start\n\n        # Sample in unit ball\n        while True:\n            # Sample a random point within unit n-ball (n = dimension)\n            dim = start.n_dim\n            u = torch.randn(dim)\n            u_norm = torch.norm(u)\n            if u_norm == 0:\n                continue\n            r = torch.pow(torch.rand(1), 1.0/dim).item()\n            x_ball = (u / u_norm * r).tolist()\n\n            # Create transformation matrix from unit ball to ellipsoid\n            # Rotation matrix: rotate x-axis to (goal - start)\n            start_tensor = start.to_tensor()\n            goal_tensor = goal.to_tensor()\n            diff = (goal_tensor - start_tensor)\n            e1 = diff / torch.norm(diff)\n\n            # Create an orthonormal basis using Gram-Schmidt\n            # We only need rotation matrix that aligns x-axis to e1\n            # For simplicity, use Householder transformation or directly construct rotation\n            eye = torch.eye(dim)\n            x_axis = eye[0]\n            v = (x_axis - e1).unsqueeze(1)\n            if torch.norm(v) < 1e-9:\n                R = eye\n            else:\n                H = eye - 2 * (v @ v.t()) / (v.t() @ v).item()\n                R = H\n\n            L1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                L2 = 0.0\n            else:\n                L2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            # Define scaling matrix for axes: [L1, L2, ..., L2]\n            # For dims > 2, all axes except x-axis have length L2\n            Ldiag = torch.eye(dim)\n            Ldiag[0,0] = L1\n            for i in range(1, dim):\n                Ldiag[i,i] = L2\n\n            # Transform sample from unit ball to ellipsoid\n            x_rand_tensor = R @ Ldiag @ torch.tensor(x_ball).float() + ((goal_tensor + start_tensor) / 2.0)\n            x_rand = Point.from_tensor(x_rand_tensor)\n\n            if self._get_grid().is_agent_valid_pos(x_rand):\n                return x_rand\n\n    def _extract_path(self):\n        \"\"\"\n        Reuse original extraction logic: \n        - trace parents from meeting vertices in both trees\n        - concatenate and reverse path if needed\n        - move agent stepwise through path with keyframe animation\n        \"\"\"\n        # trace back from q_new\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back from extension_target\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        # Update best path cost\n        cost = 0.0\n        for i in range(1, len(path)):\n            cost += self._euclidean_distance(path[i-1].position, path[i].position)\n        if cost < self._best_path_cost:\n            self._best_path_cost = cost\n            self._found_path = True\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[-1]\n        start_point = start_vertex.position\n        goal_point = goal_vertex.position\n\n        for i in range(self._iterations):\n            # check timeout 30 seconds\n            if time.time() - start_time > 30:\n                # Timeout exceeded\n                break\n\n            q_rand: Point = self._informed_sample(self._best_path_cost, start_point, goal_point)\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame()\n\n        # If no path found within iterations or timeout treat as not found\n        if not self._found_path:\n            # Optionally log or handle failure (not required)\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This improved path planning algorithm named PathPlanning enhances the SPRM approach by integrating a heuristic-driven sampling strategy inspired by RRT* concepts.\nIt efficiently expands the graph by sampling both uniformly and biased toward the goal region, attempting to construct shorter and faster-to-find paths.\nThe algorithm incrementally rewires connectivity within a radius to optimize paths and uses collision checks only when necessary, reducing redundant checks.\nA time limit of 30 seconds is enforced during the search to bound computation time.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _goal_sample_rate: float\n    _max_extend_length: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15.0\n        self._goal_sample_rate = 0.1  # 10% samples biased toward goal\n        self._max_extend_length = 15.0\n\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random valid point.\n        With probability goal_sample_rate, returns goal position.\n        \"\"\"\n        if torch.rand(()) < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            while True:\n                sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Find vertices in graph within max_radius of vertex.position.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        \"\"\"\n        Creates a new vertex steering from q_near to q_sample up to max_dist.\n        \"\"\"\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _choose_parent(self, q_new: Vertex, neighbours: List[Vertex]) -> Vertex:\n        \"\"\"\n        Choose the best parent for q_new from neighbours minimizing cost.\n        Approximates cost by path length from root_vertex0 (agent) to the neighbour + neighbour to q_new.\n        \"\"\"\n        agent = self._graph.root_vertices[0]\n        best_parent = None\n        best_cost = float('inf')\n        for neighbour in neighbours:\n            if neighbour in agent.connectivity:\n                # cost from agent to neighbour's goal through connectivity stored\n                path_cost = torch.norm((q_new.position.to_tensor() - neighbour.position.to_tensor())) + torch.norm((neighbour.position.to_tensor() - agent.position.to_tensor()))\n                if path_cost < best_cost:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbour.position, q_new.position)):\n                        best_parent = neighbour\n                        best_cost = path_cost\n        if best_parent is None and len(neighbours) > 0:\n            # fallback to first neighbour with collision-free edge\n            for neighbour in neighbours:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbour.position, q_new.position)):\n                    best_parent = neighbour\n                    break\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbours: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire neighbours through q_new if it improves their cost to root.\n        \"\"\"\n        agent = self._graph.root_vertices[0]\n        for neighbour in neighbours:\n            if neighbour is q_new:\n                continue\n            if neighbour in agent.connectivity:\n                # cost from agent to neighbour currently in connectivity\n                current_cost = torch.norm((neighbour.position.to_tensor() - agent.position.to_tensor()))\n                # cost if rewired through q_new\n                cost_via_new = torch.norm((neighbour.position.to_tensor() - q_new.position.to_tensor())) + torch.norm((q_new.position.to_tensor() - agent.position.to_tensor()))\n                if cost_via_new < current_cost:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, neighbour.position)):\n                        # Rewire neighbor to q_new\n                        self._graph.add_edge(q_new, neighbour)\n                        self._graph.add_edge(neighbour, q_new)\n                        # Update connectivity path towards goal if necessary\n                        if self._graph.root_vertices[1] in neighbour.connectivity:\n                            # Propagate rewiring in connectivity map\n                            neighbour.connectivity[self._graph.root_vertices[1]] = q_new\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extracts and moves the agent through the path found between start and goal using connectivity.\n        \"\"\"\n        goal_vertex = self._graph.root_vertices[1]\n        agent_vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent_vertex\n        path = list()\n        while current_vertex is not goal_vertex:\n            if goal_vertex not in current_vertex.connectivity:\n                # No path found, exit extraction\n                return\n            current_vertex = current_vertex.connectivity[goal_vertex]\n            path.append(current_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [GraphMapDisplay(self._services, self._graph)]\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Improved sample-based algorithm with rewiring,\n        goal-biased sampling, incremental edge additions, and 30-second timeout.\n        \"\"\"\n        start_time = time.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Make sure agent and goal vertices are in the main vertex list and connectivity initialized\n        if agent_vertex not in self._graph.vertices:\n            self._graph.vertices.append(agent_vertex)\n        if goal_vertex not in self._graph.vertices:\n            self._graph.vertices.append(goal_vertex)\n\n        # Initialize connectivity map for root vertices\n        agent_vertex.connectivity[agent_vertex] = agent_vertex\n        agent_vertex.connectivity[goal_vertex] = None\n\n        # Start from initial vertex set given by graph\n        vertices_to_process = self._graph.vertices.copy()\n\n        while True:\n            if (time.time() - start_time) > 30.0:\n                # Time exceeded, no path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_closest_vertex(q_sample)\n            q_new = self._get_new_vertex(q_near, q_sample, self._max_extend_length)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbours = self._near(q_new)\n\n            parent = self._choose_parent(q_new, neighbours)\n            if parent is None:\n                # If no suitable parent found, skip this sample\n                continue\n\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(parent, q_new)\n            self._graph.add_edge(q_new, parent)\n\n            # Update connectivity for q_new based on parent's connectivity\n            if goal_vertex in parent.connectivity:\n                q_new.connectivity[goal_vertex] = parent\n            else:\n                q_new.connectivity[goal_vertex] = None\n\n            # Add q_new connectivity to agent vertex if path exists\n            if agent_vertex in parent.connectivity:\n                agent_vertex.connectivity[q_new] = q_new\n\n            self._rewire(q_new, neighbours)\n            self.key_frame()\n\n            # Check if goal is reachable from agent_vertex via connectivity\n            if goal_vertex in agent_vertex.connectivity and agent_vertex.connectivity[goal_vertex] is not None:\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved sample-based planner inspired by SPRM.\n    It implements an incremental RRT* style approach that incrementally builds a graph by sampling points,\n    connecting them to the nearest neighbors within a radius, and rewiring to optimize the path cost.\n    This improves path quality and typically reduces computation time by focusing connections locally.\n    A timeout of 30 seconds is enforced to stop the search if no path is found in that time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional parameters for RRT*-like improvements\n        self._V_size = 200                  # Number of samples\n        self._max_radius = 15               # Radius for connections\n        self._goal_sample_rate = 0.1        # Probability of sampling goal point to bias search\n        # Initialize samples\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    # Helper: Cost function between two vertices (Euclidean distance)\n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        vec = v1.position.to_tensor() - v2.position.to_tensor()\n        return torch.norm(vec).item()\n\n    # Helper: Find near vertices within radius r\n    def _near(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, radius)\n\n    # Helper: Sample random point in map space with goal bias\n    def _get_random_sample_biased(self) -> Point:\n        # Bias sampling toward goal with probability _goal_sample_rate\n        if torch.rand(1).item() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    # Helper: Extract path from agent to goal based on connectivity links with lowest cost\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Reconstruct path via parents (connectivity dict links to parent)\n        path_reversed = []\n        current_vertex = goal\n        while current_vertex is not agent:\n            # Find parent vertex that led here, connectivity's keys are target vertices,\n            # but the original SPRM stores paths as connectivity[target] = next vertex toward target.\n            # Here, invert to find parent: parent.connectivity contains current_vertex.\n            # We assume connectivity stores parent->child edges.\n            found_parent = None\n            for v in self._graph.vertices:\n                if current_vertex in v.connectivity and v.connectivity[current_vertex] is not None:\n                    found_parent = v\n                    break\n            if found_parent is None:\n                # Path not complete; no parent found; exit extraction as failure\n                return\n            path_reversed.append(current_vertex)\n            current_vertex = found_parent\n        path_reversed.append(agent)\n        path = list(reversed(path_reversed))\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to improve the cost to near vertices if going through q_new is better.\n        \"\"\"\n        for v in near_vertices:\n            if v is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                new_cost = q_new.cost + self._cost(q_new, v)\n                if new_cost < v.cost:\n                    parent_before = None\n                    # Find previous parent of v to remove connectivity edge\n                    for vertex in self._graph.vertices:\n                        if v in vertex.connectivity and vertex.connectivity[v] is not None:\n                            parent_before = vertex\n                            break\n                    # Remove old edge\n                    if parent_before:\n                        parent_before.connectivity.pop(v, None)\n                        self._graph.remove_edge(parent_before, v)\n                    # Add new edge with lower cost\n                    self._graph.add_edge(q_new, v)\n                    q_new.connectivity[v] = v  # update connectivity mapping to imply parent link as q_new\n                    v.cost = new_cost\n                    self.key_frame()\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        RRT*-style incremental planning with rewiring improvements.\n        Abort if search exceeds 30 seconds.\n        \"\"\"\n        start_time = time.time()\n\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize costs: start cost zero, others infinity\n        for v in self._graph.vertices:\n            v.cost = float('inf')\n        agent_vertex.cost = 0.0\n\n        # Add existing edges initially from SPRM generation\n        for v in self._graph.vertices:\n            v.connectivity = dict()\n\n        # Insert the starting vertex into graph connectivity (self loop cost 0)\n        agent_vertex.connectivity[agent_vertex] = agent_vertex\n\n        for iteration in range(self._V_size * 10):  # Arbitrary max iterations (can be adjusted)\n            if time.time() - start_time > 30.0:  # Timeout 30 seconds\n                return\n\n            q_rand_point = self._get_random_sample_biased()\n            q_rand = Vertex(q_rand_point)\n\n            # Find nearest vertex in graph\n            nearest_vertex = None\n            min_dist = float('inf')\n            for v in self._graph.vertices:\n                dist = torch.norm(q_rand.position.to_tensor() - v.position.to_tensor()).item()\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest_vertex = v\n            if nearest_vertex is None:\n                continue\n\n            # Create new vertex q_new in direction of q_rand at max_radius distance max\n            q_new = self._get_new_vertex(nearest_vertex, q_rand.position, self._max_radius)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n            # Check collision between nearest and q_new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(nearest_vertex.position, q_new.position)):\n                continue\n\n            # Extend graph by adding q_new, initialize cost to high\n            q_new.cost = float('inf')\n            q_new.connectivity = dict()\n            self._graph.vertices.append(q_new)\n\n            # Find near vertices within radius\n            near_vertices = self._near(q_new, self._max_radius)\n\n            # Choose parent vertex from near vertices with lowest cost + dist that has collision free path\n            parent = None\n            c_min = float('inf')\n            for near_v in near_vertices:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                    c_temp = near_v.cost + self._cost(near_v, q_new)\n                    if c_temp < c_min:\n                        c_min = c_temp\n                        parent = near_v\n\n            if parent is None:\n                # Could not find valid parent; discard q_new and continue\n                self._graph.vertices.remove(q_new)\n                continue\n\n            # Add q_new to graph, cost and connectivity\n            self._graph.add_edge(parent, q_new)\n            parent.connectivity[q_new] = q_new\n            q_new.cost = c_min\n\n            # Rewire near vertices to q_new if it improves their cost\n            self._rewire(q_new, near_vertices)\n\n            self.key_frame()\n\n            # Check if goal can be connected directly to q_new with better cost\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                c_goal = q_new.cost + self._cost(q_new, goal_vertex)\n                if c_goal < goal_vertex.cost:\n                    # Update goal connection\n                    # Remove old parent edge for goal if exists\n                    old_parent = None\n                    for vertex in self._graph.vertices:\n                        if goal_vertex in vertex.connectivity and vertex.connectivity[goal_vertex] is not None:\n                            old_parent = vertex\n                            break\n                    if old_parent:\n                        old_parent.connectivity.pop(goal_vertex, None)\n                        self._graph.remove_edge(old_parent, goal_vertex)\n                    # Add new edge\n                    self._graph.add_edge(q_new, goal_vertex)\n                    q_new.connectivity[goal_vertex] = goal_vertex\n                    goal_vertex.cost = c_goal\n                    self.key_frame()\n\n                    # Path found, extract and move agent\n                    self._extract_path()\n                    return\n\n        # If here, no path found in time limit\n        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT*, called Informed RRT*, which focuses sampling within an ellipsoidal region \n    that heuristically covers only the space between the start and goal, reducing unnecessary exploration and improving time efficiency. \n    It leverages the existing RRT* backbone but incorporates heuristic guided sampling and early termination if time exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._best_goal_vertex: Optional[Vertex] = None\n        self._best_cost: float = float('inf')\n        self._start_position: Point = self._get_grid().agent.position\n        self._goal_position: Point = self._get_grid().goal.position\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, c_max: float, c_min: float, x_center: np.ndarray, rotation: np.ndarray) -> Point:\n        \"\"\"\n        Samples a point in the 2D ellipsoidal subset of the free space defined by start-goal and current best cost.\n        If c_max is inf, fallback to uniform random sample.\n        \"\"\"\n\n        if math.isinf(c_max):\n            # Fallback to uniform sampling in full space\n            return self._get_random_sample()\n\n        # Sampling inside the ellipsoid defined by the start and goal positions and best path cost c_max\n        r1 = c_max / 2.0\n        r2 = math.sqrt(c_max**2 - c_min**2) / 2.0\n        while True:\n            # Sample uniformly in unit disk\n            angle = np.random.uniform(0, 2 * math.pi)\n            radius = math.sqrt(np.random.uniform(0, 1))\n            sample_unit_disk = np.array([radius * math.cos(angle), radius * math.sin(angle)])\n            # Scale by ellipse radii\n            sample_ellipse = np.array([r1 * sample_unit_disk[0], r2 * sample_unit_disk[1]])\n            # Rotate and translate to center\n            sample_world = rotation @ sample_ellipse + x_center\n            sample_pt = Point(*np.round(sample_world).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _compute_rotation(self, start: np.ndarray, goal: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Compute rotation matrix to align x-axis with the line from start to goal\n        \"\"\"\n        delta = goal - start\n        theta = math.atan2(delta[1], delta[0])\n        cos_theta = math.cos(theta)\n        sin_theta = math.sin(theta)\n        return np.array([[cos_theta, -sin_theta],\n                         [sin_theta,  cos_theta]])\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension: int = 2\n        start_time = time.time()\n\n        start_np = np.array([self._start_position.x, self._start_position.y])\n        goal_np = np.array([self._goal_position.x, self._goal_position.y])\n        c_min = np.linalg.norm(goal_np - start_np)\n        c_max = float('inf')\n        x_center = (start_np + goal_np) / 2.0\n        rotation = self._compute_rotation(start_np, goal_np)\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout reached: treat as path not found\n                break\n\n            q_sample: Point = self._informed_sample(c_max, c_min, x_center, rotation)\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimum cost\n            q_min = q_nearest\n            c_min_local = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_local:\n                    q_min = q_near\n                    c_min_local = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if this vertex is in goal radius and update best solution\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < self._best_cost:\n                    self._best_cost = q_new.cost\n                    self._best_goal_vertex = q_new\n                    c_max = self._best_cost\n                    self._extract_path(q_new)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT-Connect with Adaptive Biasing and Timeout.\n\n    This algorithm enhances the classic RRT-Connect by adaptively biasing sampling towards the current tree frontier \n    and the goal to accelerate convergence, reducing unnecessary random exploration. It also switches \n    between trees as in RRT-Connect to efficiently connect both start and goal trees. The algorithm employs a \n    timeout to terminate the search if it exceeds 30 seconds to ensure time-bounded execution.\n\n    Key improvements:\n    - Adaptive sampling bias: With a probability, samples are chosen near the frontier of the current tree or goal.\n    - Early termination after 30 seconds if no path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _timeout_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._timeout_seconds = 30.0\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back from q_new to root of second tree\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back from extension_target to root of first tree\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # If root_vertices[0] is goal root, reverse for consistent direction\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        # Adaptive biased sampling:\n        # With 20% chance sample near frontier of root_vertices[0]'s latest added vertex.\n        # With 10% chance sample directly at the goal.\n        # Else, sample uniformly random valid position.\n        prob = np.random.rand()\n        if prob < 0.2:\n            # sample near frontier (last added vertex) of first tree - bias towards exploration front\n            frontier_vertex = self._graph.root_vertices[0]\n            # Find the newest vertex on this root tree: choose deepest leaf (vertex with no children)\n            # If none, fallback to root.\n            frontier = frontier_vertex\n            # Preferring the newest added vertex is tricky; fallback to root_vertex for simplicity\n            # We can sample around root vertex within max_dist\n            base_point = frontier.position\n            for _ in range(5):\n                offset = np.random.randint(-self._max_dist, self._max_dist + 1, size=self._get_grid().size.n_dim)\n                candidate_coords = base_point.to_tensor().numpy() + offset\n                candidate_coords = np.clip(candidate_coords, 0, self._get_grid().size.n - 1)\n                candidate = Point(*candidate_coords.astype(int))\n                if self._get_grid().is_agent_valid_pos(candidate):\n                    return candidate\n            # fallback to uniform random if above 5 tries fail\n        elif prob < 0.3:\n            # sample goal directly as bias\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n\n        # Uniform random sample\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size.n, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        \n        for i in range(self._iterations):\n            if time.time() - start_time > self._timeout_seconds:\n                # Timeout triggered - no path found within time limit\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant of RRT, namely RRT-Connect.\n    It grows two trees simultaneously: one from the start and one from the goal.\n    In each iteration, it samples a random valid point and attempts to extend the start tree towards it.\n    Then it attempts to connect the goal tree to the newly added node in the start tree.\n    This bidirectional growth accelerates pathfinding by reducing wasted samples.\n    The algorithm stops and extracts the path once the trees meet.\n    Additionally, the path search terminates if it exceeds 30 seconds, \n    declaring no path was found within practical time.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT* with informed sampling to reduce exploration time.\n    It uses the RRT* backbone with rewiring and optimization but enhances performance by focusing sampling \n    within an ellipsoidal subset (informed set) of the configuration space once a first solution is found.\n    \n    This focusing drastically reduces unnecessary exploration, accelerating convergence toward the optimal path.\n    It also enforces a maximum timeout of 30 seconds to abort and treat the route as not found if no path is found within the time.\n    \n    The algorithm inherits from SampleBasedAlgorithm, reusing helper functions and graph structure from the base.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._solution_found: bool = False\n        self._best_cost: Optional[float] = None\n        self._goal_vertex: Optional[Vertex] = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipsoid(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample a point inside an ellipsoid defined by start, goal, and c_best path cost.\n        This implements Informed RRT* sampling to focus sampling to the region that can improve the current solution.\n        \"\"\"\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        center = (start_tensor + goal_tensor) / 2.0\n        diff = goal_tensor - start_tensor\n        c_min = torch.norm(diff)\n        if c_min == 0:\n            # Start and goal are same, just return start\n            return start\n\n        # Define rotation matrix from unit vector along x-axis to diff normalized\n        a1 = diff / c_min\n        dim = diff.shape[0]\n        # Construct an orthonormal basis via SVD\n        # We want a rotation matrix C so that C * [1, 0, ..., 0]^T = a1\n        # Use Householder transform or SVD to get C\n        I = torch.eye(dim)\n        e1 = I[:, 0]\n        v = a1 - e1\n        v_norm = torch.norm(v)\n        if v_norm < 1e-10:\n            C = I\n        else:\n            v = v / v_norm\n            H = I - 2.0 * torch.outer(v, v)\n            C = H\n\n        # Semi-axes lengths of the ellipsoid\n        r1 = c_best / 2.0\n        if c_best < float('inf'):\n            # note that c_best >= c_min always; otherwise no informed set possible\n            r = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        else:\n            r = float('inf')\n\n        # Sample within unit n-dim ball\n        while True:\n            # Sample from unit ball using normal distribution then normalize\n            sample = torch.randn(dim)\n            sample_norm = torch.norm(sample)\n            if sample_norm < 1e-10:\n                continue\n            sample_unit = sample / sample_norm\n            # Radius: uniform sample in [0,1]^(1/dim) to ensure uniform sampling inside ball\n            radius = torch.rand(1) ** (1.0 / dim)\n            sample_in_ball = sample_unit * radius\n\n            # Scale according to ellipsoid axes\n            scales = torch.zeros(dim)\n            scales[0] = r1\n            for i in range(1, dim):\n                scales[i] = r if r != float('inf') else r1 * 10  # large radius fallback if infinite\n\n            sample_scaled = sample_in_ball * scales\n\n            # Rotate and translate\n            sample_ellipsoid = torch.mv(C, sample_scaled) + center\n\n            # Convert back to Point (clamp to map boundaries)\n            map_size = self._get_grid().size\n            sample_coords = sample_ellipsoid.clamp(min=0, max=map_size - 1).round().to(torch.int64)\n            point_sample = Point(*sample_coords.tolist())\n\n            if self._get_grid().is_agent_valid_pos(point_sample):\n                return point_sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # reuse same implementation as RRT_Star for path extraction and movement\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 100000  # large iteration cap, but will timeout early\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex = goal_vertex\n\n        start_time = time.time()\n        self._solution_found = False\n        self._best_cost = float('inf')\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout reached -> no solution found\n                break\n\n            if self._solution_found:\n                # Use informed sampling around current best solution cost\n                q_sample = self._sample_in_ellipsoid(start_vertex.position, goal_vertex.position, self._best_cost)\n            else:\n                # Uniform random sample in map\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision for edge from q_nearest to q_new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent minimizing cost + dist to new\n            q_min = q_nearest\n            dist_nearest_to_new = torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            c_min = q_nearest.cost + dist_nearest_to_new\n\n            for q_near in Q_near:\n                dist_near_to_new = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + dist_near_to_new\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors as in RRT*\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new reaches goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._solution_found = True\n                # Update best cost if better path found\n                goal_cost_estimate = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n                if goal_cost_estimate < self._best_cost:\n                    self._best_cost = goal_cost_estimate\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved sample-based path planner inspired by SPRM. \nIt uses an incremental PRM-style roadmap with a k-nearest neighbor connection strategy \ninstead of radius-based connections to reduce unnecessary edge checks and speed up graph construction.\nA heuristic directs sampling near the line from the start to goal to improve sample efficiency. \nAdditionally, a timeout of 30 seconds is enforced to stop search if no solution is found. \nThe path extraction and agent movement logic is preserved from SPRM.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _k_nearest: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._k_nearest = 10  # Fixed k nearest neighbors for connection instead of radius\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_biased_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _biased_sample_line(self, alpha: float) -> Point:\n        \"\"\"\n        Samples a point with bias towards the line between agent and goal.\n        `alpha` controls the amount of bias: 0 = uniform, 1 = fully on line.\n        \"\"\"\n        start = self._get_grid().agent.position.to_tensor()\n        goal = self._get_grid().goal.position.to_tensor()\n        if alpha <= 0:\n            # Pure random sample\n            return self._get_random_sample()\n        # Sample along line + orthogonal Gaussian noise\n        line_vec = goal - start\n        line_len = torch.norm(line_vec)\n        if line_len.item() == 0:\n            return Point.from_tensor(start)\n        line_dir = line_vec / line_len\n        t = torch.rand(1).item()\n        point_on_line = start + t * line_vec\n        # Generate noise perpendicular to line_dir\n        noise_dim = len(point_on_line)\n        noise = torch.randn(noise_dim)\n        # Project noise orthogonal to line_dir\n        noise = noise - torch.dot(noise, line_dir) * line_dir\n        # Scale noise by (1-alpha)*some_radius\n        radius = min(self._get_grid().size.tolist()) * 0.2  # noise scale portion\n        sample_tensor = point_on_line + noise * radius * (1-alpha)\n        # Clamp sample to valid grid size boundaries\n        sample_tensor_clamped = torch.clamp(sample_tensor, min=0)\n        for i in range(len(sample_tensor_clamped)):\n            sample_tensor_clamped[i] = min(sample_tensor_clamped[i], self._get_grid().size[i]-1)\n        sample_point = Point.from_tensor(sample_tensor_clamped)\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._get_random_sample()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Returns biased sample close to start-goal line with some randomness.\n        \"\"\"\n        return self._biased_sample_line(alpha=0.7)\n\n    def _nearest_k(self, vertex: Vertex, vertices: List[Vertex], k: int) -> List[Vertex]:\n        \"\"\"\n        Returns the k nearest vertices to the given vertex (excluding itself).\n        \"\"\"\n        dist_list = []\n        v_pos_tensor = vertex.position.to_tensor()\n        for v in vertices:\n            if v is vertex:\n                continue\n            d = torch.norm(v.position.to_tensor() - v_pos_tensor).item()\n            dist_list.append((d, v))\n        dist_list.sort(key=lambda x: x[0])\n        return [v for _, v in dist_list[:k]]\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # If no connectivity found, exit path extraction\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        # Initialize roots - agent (start) and goal vertices already in self._graph.root_vertices\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        vertices: List[Vertex] = list(self._graph.vertices)\n        # Add root vertices explicitly if not already present\n        if agent_vertex not in vertices:\n            vertices.append(agent_vertex)\n        if goal_vertex not in vertices:\n            vertices.append(goal_vertex)\n\n        # Connect roots to graph initially if possible\n        near_agent = self._nearest_k(agent_vertex, vertices, self._k_nearest)\n        for v in near_agent:\n            line_seq = self._get_grid().get_line_sequence(agent_vertex.position, v.position)\n            if v is not agent_vertex and self._get_grid().is_valid_line_sequence(line_seq):\n                self._graph.add_edge(agent_vertex, v)\n                self._graph.add_edge(v, agent_vertex)\n                self.key_frame()\n\n        near_goal = self._nearest_k(goal_vertex, vertices, self._k_nearest)\n        for v in near_goal:\n            line_seq = self._get_grid().get_line_sequence(goal_vertex.position, v.position)\n            if v is not goal_vertex and self._get_grid().is_valid_line_sequence(line_seq):\n                self._graph.add_edge(goal_vertex, v)\n                self._graph.add_edge(v, goal_vertex)\n                self.key_frame()\n\n        connected = False\n        checked_edges: Set = set()\n\n        # Iteratively expand edges in graph with k-nearest connections for all vertices\n        for v in vertices:\n            near_vs = self._nearest_k(v, vertices, self._k_nearest)\n            for u in near_vs:\n                # Skip if edge already checked\n                edge_id = tuple(sorted((id(u), id(v))))\n                if edge_id in checked_edges:\n                    continue\n                checked_edges.add(edge_id)\n\n                line_seq = self._get_grid().get_line_sequence(u.position, v.position)\n                if u is not v and self._get_grid().is_valid_line_sequence(line_seq):\n                    self._graph.add_edge(v, u)\n                    self._graph.add_edge(u, v)\n                    self.key_frame()\n\n                    # Check connectivity between start and goal\n                    if goal_vertex in agent_vertex.connectivity:\n                        self._extract_path()\n                        connected = True\n                        break\n            if connected:\n                break\n\n            # Stop if runtime exceeds 30 seconds\n            if time.time() - start_time > 30:\n                # Treat as route not found and return\n                return\n\n        # If not found in above loop, optionally try incremental edge connection on random samples\n        if not connected:\n            # Attempt incremental vertex expansion to improve connectivity until timeout or found\n            while time.time() - start_time <= 30:\n                q_rand = self._get_biased_sample()\n                q_new = Vertex(q_rand, store_connectivity=True)\n                vertices.append(q_new)\n                self._graph.vertices.append(q_new)\n\n                near_vs = self._nearest_k(q_new, vertices, self._k_nearest)\n                for u in near_vs:\n                    if u is not q_new:\n                        line_seq = self._get_grid().get_line_sequence(q_new.position, u.position)\n                        if self._get_grid().is_valid_line_sequence(line_seq):\n                            self._graph.add_edge(q_new, u)\n                            self._graph.add_edge(u, q_new)\n                            self.key_frame()\n                # Check connectivity again:\n                if goal_vertex in agent_vertex.connectivity:\n                    self._extract_path()\n                    connected = True\n                    break\n\n            if not connected:\n                # Give up if no connection found within time\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an enhanced variant of RRT*, named \"Informed RRT*\".\n    It improves time efficiency by focusing sampling within an ellipsoidal region \n    computed using the current best solution cost, which reduces exploration of irrelevant \n    areas and accelerates convergence towards the optimal path.\n    It maintains the rewiring and path optimization features of RRT*, preserving asymptotic optimality.\n    The search aborts if it exceeds 30 seconds without finding the goal.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _best_cost: Optional[float]\n    _start_vertex: Vertex\n    _goal_vertex: Vertex\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._start_vertex = Vertex(self._get_grid().agent.position)\n        self._start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, self._start_vertex, self._goal_vertex, [])\n        self._best_cost = None\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    # Helper Functions #\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample a point in the free space.\n        If best solution cost exists, sample inside an informed ellipsoid to improve convergence.\n        Otherwise, sample uniformly.\n        \"\"\"\n        if self._best_cost is None:\n            # Uniform sampling as in RRT*\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Informed sampling inside the ellipsoid between start and goal\n            return self._sample_informed_ellipsoid()\n\n    def _sample_informed_ellipsoid(self) -> Point:\n        \"\"\"\n        Sample uniformly within the prolate hyperspheroid defined by start and goal and the current best cost.\n        \"\"\"\n        start_np = self._start_vertex.position.to_tensor().numpy()\n        goal_np = self._goal_vertex.position.to_tensor().numpy()\n        c_min = np.linalg.norm(start_np - goal_np)\n        c_best = self._best_cost\n\n        if c_best is None or c_best < c_min:\n            # No better solution found, fallback to uniform sampling\n            return self._sample_uniform()\n\n        # Center of the ellipse\n        center = (start_np + goal_np) / 2\n\n        # Unit vector from start to goal\n        a1 = (goal_np - start_np) / c_min\n\n        # Create orthonormal basis using SVD\n        dim = len(start_np)\n        id1 = np.array([1.0 if i == 0 else 0.0 for i in range(dim)])\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1.0] * dim) @ Vt  # Rotation matrix\n\n        # Radii of the ellipse\n        r1 = c_best / 2.0\n        r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n        if dim == 2:\n            radii = np.array([r1, r2])\n        else:\n            # In higher dims, axis other than the main one are r2\n            radii = np.array([r1] + [r2] * (dim - 1))\n\n        for _ in range(100):\n            # Sample random point within unit n-ball\n            x_ball = self._sample_unit_n_ball(dim)\n            # Scale according to radii\n            x_scaled = radii * x_ball\n            # Rotate and translate back to global coords\n            sample_pt = C @ x_scaled + center\n            sample = Point(*np.round(sample_pt).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # fallback to uniform if ellipsoid sampling fails\n        return self._sample_uniform()\n\n    def _sample_unit_n_ball(self, dim: int) -> np.ndarray:\n        \"\"\"\n        Sample a point uniformly inside a unit n-dimensional ball.\n        \"\"\"\n        x = np.random.randn(dim)\n        x /= np.linalg.norm(x)\n        r = np.random.rand() ** (1.0 / dim)\n        return x * r\n\n    def _sample_uniform(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius([self._graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Timeout: Treat as route not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent that minimizes cost to q_new and has collision-free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost = q_near.cost + self._distance(q_near.position, q_new.position)\n                    if cost < c_min:\n                        q_min = q_near\n                        c_min = cost\n\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire the neighbors if this offers a cost reduction\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_through_q_new = q_new.cost + self._distance(q_new.position, q_near.position)\n                    if cost_through_q_new < q_near.cost:\n                        # Remove old edge\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        # Add new edge and update cost\n                        q_near.cost = cost_through_q_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # If q_new improves path to goal, update best cost\n            dist_to_goal = self._distance(q_new.position, self._goal_vertex.position)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                current_path_cost = q_new.cost + dist_to_goal\n                if self._best_cost is None or current_path_cost < self._best_cost:\n                    self._best_cost = current_path_cost\n                    self._extract_path(q_new)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nImproved path planning algorithm based on RRT-Connect with heuristic biasing using goal bias and adaptive maximum extension distance.\nThis algorithm accelerates convergence by sampling towards the goal more frequently, and dynamically adjusting the extension step\nbased on progress to allow longer extensions in empty space and shorter steps in clutter. It also implements a 30-second timeout to\nhalt the search early if no path is found.\n\nThe backbone idea of the given algorithm (RRT-Connect) is to simultaneously grow two trees (one from start and one from goal)\nand attempt to connect them by extending vertices towards random samples. This version improves efficiency by introducing a goal bias,\nadaptive max extension distance, and timeout to speed up path finding.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n    _timeout_seconds: float\n    _min_max_dist: float\n    _max_max_dist: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10.0\n        self._min_max_dist = 3.0       # minimal extension length for tight spaces\n        self._max_max_dist = 20.0      # maximal extension length when in free spaces\n        self._iterations = 10000\n        self._goal_bias = 0.2          # probability to sample the goal directly\n        self._timeout_seconds = 30.0   # hard timeout on planning time in seconds\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        With a probability of goal_bias, return the goal position to bias growth towards the goal.\n        Otherwise, sample randomly in the free space.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _adaptive_max_dist(self, q_near: Vertex, q_sample: Point) -> float:\n        \"\"\"\n        Adaptively adjust the max extension distance based on local environment density.\n        If the direct line extension is free for long distance, increase max_dist;\n        if local space is cluttered, decrease max_dist for finer exploration.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_sample)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            dist = torch.norm(q_sample.to_tensor() - q_near.position.to_tensor()).item()\n            # Scale max_dist proportionally but clamp\n            scaled_dist = min(max(dist, self._min_max_dist), self._max_max_dist)\n            return scaled_dist\n        else:\n            # If blocked, use a small max_dist to try to make incremental progress\n            return self._min_max_dist\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adaptive_dist = self._adaptive_max_dist(self._q_near, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, adaptive_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back from connection middle point to start and goal roots\n\n        path_mid_to_goal: List[Vertex] = [self._q_new]\n        while len(path_mid_to_goal[-1].parents) != 0:\n            parent = next(iter(path_mid_to_goal[-1].parents))\n            path_mid_to_goal.append(parent)\n\n        path_start_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_start_to_mid[-1].parents) != 0:\n            parent = next(iter(path_start_to_mid[-1].parents))\n            path_start_to_mid.append(parent)\n\n        path_start_to_mid.reverse()\n        path = path_start_to_mid + path_mid_to_goal\n\n        # If the root vertex order is reversed, reverse path to maintain ordering from start to goal\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_seconds:\n                # Timeout exceeded, stop search - no path found\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            extend_result_start = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result_start != 'trapped':\n                self._extension_target = self._q_new\n                connect_result_goal = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result_goal == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            # visualization code\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, improves upon the SPRM sample-based path planning approach by integrating a prioritized search \nstrategy inspired by RRT* concepts and a more focused sampling technique near the current tree frontier to accelerate the discovery \nof a valid path. It maintains a cyclic graph of sampled vertices, but instead of connecting all neighbors indiscriminately, it \nconnects vertices by increasing distance order with early stopping and rewiring to optimize paths. The search explores from the \nagent's initial position towards the goal with adaptive sampling radius adjustments, connectivity caching, and a timeout of 30 seconds \nto prevent indefinite search times. This results in improved time efficiency and solution quality.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _timeout_s: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._timeout_s = 30.0\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _near(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, radius)\n\n    def _get_random_sample_focused(self, focus_center: Point, radius: float) -> Point:\n        \"\"\"\n        Sample a point around a focus center within a radius; fallback to global random if fails repeatedly.\n        \"\"\"\n        attempts = 0\n        max_attempts = 50\n        while attempts < max_attempts:\n            dims = self._get_grid().size.n_dim\n            coords = []\n            for d in range(dims):\n                low = max(0, int(focus_center[d] - radius))\n                high = min(self._get_grid().size[d], int(focus_center[d] + radius) + 1)\n                if low >= high:\n                    coord = low\n                else:\n                    coord = torch.randint(low, high, (1,)).item()\n                coords.append(coord)\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # fallback global sample\n        return self._get_random_sample()\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # Path not found, abort\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Rewiring step inspired by RRT* to optimize paths to the new_vertex and its neighbors.\n        \"\"\"\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Cost to new_vertex from agent\n        agent_vertex = self._graph.root_vertices[0]\n        if agent_vertex in new_vertex.connectivity:\n            c_new = self._distance(agent_vertex.position, new_vertex.position)\n        else:\n            c_new = float('inf')\n\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if new_vertex in neighbor.connectivity:\n                cost_through_new = (self._distance(agent_vertex.position, new_vertex.position) +\n                                    self._distance(new_vertex.position, neighbor.position))\n                # If rewiring through new_vertex reduces cost to neighbor, update connectivity\n                if cost_through_new < self._distance(agent_vertex.position, neighbor.position):\n                    neighbor.connectivity[agent_vertex] = new_vertex\n                    new_vertex.connectivity[goal_vertex] = neighbor\n\n        # Try rewire from neighbors to new_vertex as well (reverse)\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if new_vertex in neighbor.connectivity:\n                cost_through_neighbor = (self._distance(agent_vertex.position, neighbor.position) +\n                                        self._distance(neighbor.position, new_vertex.position))\n                if cost_through_neighbor < c_new:\n                    new_vertex.connectivity[agent_vertex] = neighbor\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _find_path_internal(self) -> None:\n        import heapq\n\n        start_time = time.time()\n\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize priority queue: (distance to goal heuristic, vertex)\n        # We'll approximate heuristic by Euclidean distance to goal\n        frontier = []\n        heapq.heappush(frontier, (0.0, agent_vertex))\n\n        visited = set()\n        # Maintain a queue of vertices pending edge expansion for connections\n        pending_expansions = set(self._graph.root_vertices)\n\n        while time.time() - start_time < self._timeout_s:\n            if not frontier:\n                # No more vertices to expand, path not found\n                break\n\n            _, current_vertex = heapq.heappop(frontier)\n            if current_vertex in visited:\n                continue\n            visited.add(current_vertex)\n\n            # Early extraction if goal connected\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return\n\n            # Try to connect current_vertex to near vertices within max radius\n            neighbors = self._near(current_vertex, self._max_radius)\n\n            # Sort neighbors by distance to current_vertex ascending\n            neighbors = sorted(neighbors, key=lambda v: self._distance(v.position, current_vertex.position))\n\n            for neighbor in neighbors:\n                if neighbor is current_vertex:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, current_vertex.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Add edge both ways if not already connected\n                    if neighbor not in current_vertex.connectivity:\n                        self._graph.add_edge(current_vertex, neighbor)\n                    if current_vertex not in neighbor.connectivity:\n                        self._graph.add_edge(neighbor, current_vertex)\n\n                    self.key_frame()\n                    # Rewire to improve paths\n                    self._rewire(current_vertex, neighbors)\n\n                    # If after adding the edge the goal is reachable, extract path\n                    if goal_vertex in agent_vertex.connectivity:\n                        self._extract_path()\n                        return\n\n            # Add newly connected neighbors to frontier along with heuristic distance to goal\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    dist_to_goal = self._distance(neighbor.position, goal_vertex.position)\n                    heapq.heappush(frontier, (dist_to_goal, neighbor))\n\n            # Focused sampling around last expanded vertices to improve exploration\n            last_expanded_pos = current_vertex.position\n            sample = self._get_random_sample_focused(last_expanded_pos, self._max_radius)\n            new_vertex = self._get_new_vertex(current_vertex, sample, self._max_radius)\n            if self._get_grid().is_agent_valid_pos(new_vertex.position):\n                self._graph.vertices.append(new_vertex)\n                self._graph.add_edge(current_vertex, new_vertex)\n                self._graph.add_edge(new_vertex, current_vertex)\n                dist_to_goal = self._distance(new_vertex.position, goal_vertex.position)\n                heapq.heappush(frontier, (dist_to_goal, new_vertex))\n                self.key_frame()\n\n        # Timeout expired or no path found after exploration\n        # No explicit return needed; path not found ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* variant called Batch Informed RRT* (BI-RRT*), \nwhich speeds up convergence to an optimal path by sampling within an informed subset \nellipsoid after an initial feasible path is found. It performs batch sampling with rewiring \nand prioritizes exploration inside the heuristic-informed ellipsoidal region bounded by \nthe current best path cost. It also respects a 30 second search timeout to abort if no path \nis found timely.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # no structural changes to __init__, but can add members:\n        self._start_time = None\n        self._best_cost = float('inf')\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex.cost = float('inf')  # Initially no path to goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Reuse displays from parent class which show the graph\n        return super().set_display_info()\n\n    def _informed_sample(self, c_best: float, c_min: float, x_start: Point, x_goal: Point) -> Point:\n        \"\"\"\n        Sample a point inside the ellipsoidal informed subset given current best cost c_best,\n        minimum possible cost c_min, start and goal.\n        \"\"\"\n        import math\n        from numpy.linalg import norm\n\n        def sample_unit_ball():\n            # Uniform sample in unit n-ball\n            dim = len(x_start.to_tensor())\n            while True:\n                sample = np.random.uniform(-1, 1, size=dim)\n                if np.linalg.norm(sample) <= 1:\n                    return sample\n\n        if c_best == float('inf'):\n            # No current solution, sample uniformly over whole space\n            return self._get_random_sample()\n\n        # Compute center of the ellipse\n        x_center = (x_start.to_tensor() + x_goal.to_tensor()) / 2.0\n\n        # Compute unit vector between start and goal\n        e1 = (x_goal.to_tensor() - x_start.to_tensor())\n        e1_norm = np.linalg.norm(e1)\n        if e1_norm == 0:\n            return Point.from_tensor(x_start.to_tensor())\n        e1 /= e1_norm\n\n        # Create rotation matrix C from ellipsoid frame to world\n        # For 2D only: rotation aligning e1 to x-axis\n        dim = len(x_start.to_tensor())\n        if dim == 2:\n            a1 = e1\n            a2 = np.array([-e1[1], e1[0]])\n            C = np.stack((a1, a2), axis=1)\n        else:\n            # For higher dim, use Householder reflection or QR for base (not provided in baseline)\n            # fallback: identity\n            C = np.eye(dim)\n\n        # Radii of the ellipsoid\n        r1 = c_best / 2.0\n        if c_best == 0 or c_min == 0:\n            r2 = 0\n        else:\n            val = np.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n            r2 = val\n\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        # Sample in unit ball\n        x_ball = sample_unit_ball()\n        # Map sample to ellipsoid\n        x_rand = x_center + C @ (L @ x_ball)\n\n        # Convert back to Point\n        p = Point.from_tensor(torch.tensor(x_rand))\n        if self._get_grid().is_agent_valid_pos(p):\n            return p\n        else:\n            # fallback to uniform sampling if invalid\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new):\n        # Same as in RRT_Star - move agent along path and publish waypoints\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations_per_batch = 100  # batch size for sampling & rewiring\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        self._graph = gen_forest(self._services, start_vertex, self._goal_vertex, [])\n        self._init_displays()\n\n        # To track time for 30 seconds max search\n        self._start_time = time.time()\n        c_min = torch.norm(start_vertex.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n        c_best = float('inf')\n\n        path_found = False\n        sampled_vertices = []\n\n        for _ in range(10000):  # large max outer iterations (could be timed out earlier)\n            if time.time() - self._start_time > 30.0:  # timeout 30 seconds\n                break\n\n            # If no solution yet, sample uniformly; else sample in informed subset ellipsoid\n            if c_best == float('inf'):\n                q_sample = self._get_random_sample()\n            else:\n                q_sample = self._informed_sample(c_best, c_min, start_vertex.position, self._goal_vertex.position)\n\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Find neighbors for rewiring\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose parent with minimum cost + edge cost\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if beneficial\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_through_new < q_near.cost:\n                    # Remove old connection\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new edge and update cost\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Track all sampled vertices in current batch\n            sampled_vertices.append(q_new)\n\n            # Check if new vertex reached the goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and path extraction\n                candidate_goal_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                if candidate_goal_cost < c_best:\n                    c_best = candidate_goal_cost\n                    path_found = True\n                    self._extract_path(q_new)\n                    # Continue sampling inside ellipsoid to improve path\n                    # We don't break here to improve solution quality\n\n            # Batch processing: periodically key frame (for animations/debug)\n            if len(sampled_vertices) >= iterations_per_batch:\n                self.key_frame()\n                sampled_vertices.clear()\n\n        # End of main loop\n        if not path_found:\n            # No path found in time\n            if self.testing is not None:\n                self.testing.algorithm_failure() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is an improved sample-based planner inspired by RRT but implements the RRT-Connect approach, which grows two trees (one from start and one from goal) simultaneously to reduce exploration time and speed up convergence. At each iteration, it alternates between extending the start and goal trees towards random samples and tries to connect the two trees when possible. It includes a timeout of 30 seconds to treat search failure. This bidirectional strategy generally leads to faster path finding compared to unidirectional RRT.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm based on RRT-Connect with Bidirectional Trees and Goal Biasing.\n    This algorithm enhances timed search efficiency by incorporating:\n    - Goal bias sampling to increase chances of connecting near the goal.\n    - A time cutoff of 30 seconds to abort long searches.\n    - A higher max extend distance (adaptive) for faster tree growth but capped.\n    The backbone remains bidirectional tree growing and connecting, but sampling is biased towards the goal periodically, \n    improving convergence speed in complex grid environments.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 15  # Increased max distance to speed up exploration\n        self._iterations = 100000  # Increased iterations but time cutoff will apply\n        self._goal_bias_frequency = 5  # Every 5 iterations sample is goal biased\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self):\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self, iteration: int) -> Point:\n        # Goal biased sampling every _goal_bias_frequency iterations\n        if iteration % self._goal_bias_frequency == 0:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30:\n                # Timeout: treat as path not found\n                break\n\n            q_rand = self._get_random_sample(i)\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm, named PathPlanning, improves upon the SPRM sample-based pathfinding algorithm by integrating the principles of RRT* (Rapidly-exploring Random Tree star).\nIt maintains a cyclic graph structure like SPRM but enhances search efficiency and path quality by incrementally rewiring the graph to reduce path cost.\nThe main differences are:\n- Uses incremental sampling and extension towards random samples.\n- Connects not only nearest vertex but also rewires nearby vertices within a radius for optimal connections.\n- Maintains graph connectivity and stops once a path from agent to goal is found or time exceeds 30 seconds.\nThis approach speeds up convergence to lower-cost paths while preserving probabilistic completeness.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._rewire_radius = 20\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow edge rewiring/removal for optimization\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        \"\"\"Euclidean distance cost.\"\"\"\n        from_pos = from_vertex.position.to_tensor()\n        to_pos = to_vertex.position.to_tensor()\n        return float(torch.norm(to_pos - from_pos).item())\n\n    def _choose_parent(self, nearest: Vertex, new_vertex: Vertex, neighbors: List[Vertex]) -> Vertex:\n        \"\"\"\n        Choose the best parent for new_vertex among neighbors to minimize cost.\n        \"\"\"\n        min_cost = self._cost(nearest, new_vertex)\n        best_parent = nearest\n        for neighbor in neighbors:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, new_vertex.position)):\n                cost = self._cost(neighbor, new_vertex)\n                # Total cost is cost to neighbor + cost from neighbor to new\n                if neighbor in self._graph.root_vertices[0].connectivity:\n                    # calculate cost from start to neighbor + cost neighbor to new\n                    cost_from_start = neighbor.connectivity[self._graph.root_vertices[0]] if self._graph.root_vertices[0] in neighbor.connectivity else 0\n                    total_cost = cost_from_start + cost\n                else:\n                    total_cost = cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Rewire neighboring vertices through new_vertex if it improves cost.\n        \"\"\"\n        for neighbor in neighbors:\n            if neighbor == new_vertex:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)):\n                current_cost = self._cost(neighbor, self._graph.root_vertices[0])\n                new_cost = self._cost(new_vertex, neighbor) + (self._cost(new_vertex, self._graph.root_vertices[0]) if self._graph.root_vertices[0] in new_vertex.connectivity else 0)\n                # Check if going through new_vertex improves cost\n                if neighbor in new_vertex.connectivity and new_cost < current_cost:\n                    # Remove old edge and add new edge\n                    self._graph.remove_edge(neighbor, neighbor.connectivity.get(self._graph.root_vertices[0], neighbor))\n                    self._graph.add_edge(new_vertex, neighbor)\n                    self._graph.add_edge(neighbor, new_vertex)\n                    self.key_frame()\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Reconstruct path from agent to goal using connectivity edges with goal as target\n        current_vertex = agent\n        path = []\n        visited = set()\n        while current_vertex != goal:\n            if goal not in current_vertex.connectivity:\n                # No path exists (fail-safe)\n                break\n            next_vertex = current_vertex.connectivity[goal]\n            if next_vertex in visited:\n                # Loop detected, break to avoid infinite loop\n                break\n            visited.add(next_vertex)\n            path.append(next_vertex)\n            current_vertex = next_vertex\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize connectivity cost dictionary (distance from start)\n        cost_from_start: Dict[Vertex, float] = {agent_vertex: 0}\n\n        for iteration in range(self._V_size * 5):  # Increase iterations for better chance to find solution\n            if time.time() - start_time > 30:\n                # Timeout: Stop search with no path found\n                return\n\n            q_rand = self._get_random_sample()\n            nearest = self._graph.get_nearest_vertex(agent_vertex.position, q_rand)\n\n            q_new = self._get_new_vertex(nearest, q_rand, self._max_radius)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(nearest.position, q_new.position)):\n                continue\n\n            new_vertex = Vertex(q_new.position, store_connectivity=True)\n            self._graph.add_vertex(new_vertex)\n\n            neighbors = self._graph.get_vertices_within_radius(self._graph.vertices, new_vertex.position, self._rewire_radius)\n\n            # Select the best parent for new_vertex\n            best_parent = nearest\n            min_cost = cost_from_start.get(nearest, float('inf')) + self._cost(nearest, new_vertex)\n            for neighbor in neighbors:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, new_vertex.position)):\n                    cost_to_neighbor = cost_from_start.get(neighbor, float('inf'))\n                    cost_total = cost_to_neighbor + self._cost(neighbor, new_vertex)\n                    if cost_total < min_cost:\n                        best_parent = neighbor\n                        min_cost = cost_total\n\n            # Connect new vertex to best parent\n            self._graph.add_edge(best_parent, new_vertex)\n            self._graph.add_edge(new_vertex, best_parent)\n\n            cost_from_start[new_vertex] = min_cost\n\n            # Rewire the neighbors if going through new_vertex improves cost\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)):\n                    current_cost = cost_from_start.get(neighbor, float('inf'))\n                    new_cost = cost_from_start[new_vertex] + self._cost(new_vertex, neighbor)\n                    if new_cost < current_cost:\n                        # Remove old parent edge for neighbor\n                        old_parent = neighbor.connectivity.get(agent_vertex, None)\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                            self._graph.remove_edge(neighbor, old_parent)\n                        # Add edge from new_vertex to neighbor\n                        self._graph.add_edge(new_vertex, neighbor)\n                        self._graph.add_edge(neighbor, new_vertex)\n                        cost_from_start[neighbor] = new_cost\n                        self.key_frame()\n\n            # Check if goal is connected to the tree (agent)\n            if goal_vertex in self._graph.vertices:\n                # Check if path exists between agent and goal\n                if goal_vertex in agent_vertex.connectivity:\n                    self._extract_path()\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT*.\n    This implementation speeds up the search by incorporating:\n    - Bidirectional RRT* growth starting from both the start and the goal vertices.\n    - Attempt to connect tree branches from both sides when samples connect them.\n    - Early termination when the trees connect, yielding a shorter overall path faster.\n    - Timeout after 30 seconds if no solution is found.\n    \n    The bidirectional approach tends to greatly improve convergence speed and path quality \n    over unidirectional RRT*, especially in large or complex maps.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an Improved RRT called RRT-Connect for faster path planning.\n    It simultaneously grows two trees: one from the start and one from the goal.\n    Each iteration alternates growth attempts between the two trees, trying to connect them.\n    This bidirectional approach typically finds a path quicker than the original single-tree RRT.\n    Additionally, it imposes a 30-second timeout on the search to prevent excessive runtime.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        map_grid = self._get_grid()\n        self._graph_start = gen_forest(self._services, Vertex(map_grid.agent.position), Vertex(map_grid.goal.position), [])\n        self._graph_goal = gen_forest(self._services, Vertex(map_grid.goal.position), Vertex(map_grid.agent.position), [])\n        # Both trees should not have removable edges for reliability\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        self._max_dist = 10\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Display both trees\n        self.__map_displays = [\n            GraphMapDisplay(self._services, self._graph_start),\n            GraphMapDisplay(self._services, self._graph_goal)\n        ]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Reuse from base: Move towards q_sample, limit step size\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # Same as base for valid sample\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extend(self, tree: Forest, q_target: Point) -> Tuple[Vertex, bool]:\n        \"\"\"\n        Attempts to add a new vertex towards q_target from nearest vertex in the tree.\n        Returns the new vertex and a bool indicating if extension succeeded.\n        \"\"\"\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return q_near, False  # No extension needed or possible\n\n        q_new: Vertex = self._get_new_vertex(q_near, q_target, self._max_dist)\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n            return q_new, False\n        tree.add_edge(q_near, q_new)\n        return q_new, True\n\n    def _connect(self, tree: Forest, q_target: Point) -> Vertex:\n        \"\"\"\n        Repeatedly extends tree towards q_target until it cannot progress.\n        Returns the final vertex reached.\n        \"\"\"\n        q_new, extended = self._extend(tree, q_target)\n        while extended:\n            if q_new.position == q_target:\n                break\n            q_new, extended = self._extend(tree, q_target)\n        return q_new\n\n    def _extract_path(self, connecting_vertex_start: Vertex, connecting_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start tree root to connecting_vertex_start,\n        and from goal tree root to connecting_vertex_goal (reversed),\n        then combine and move agent along that path.\n        \"\"\"\n        path_start: List[Vertex] = [connecting_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()  # From start root to connecting vertex start\n\n        path_goal: List[Vertex] = [connecting_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n        # path_goal is from connecting vertex in goal tree to goal root\n        # reverse to go from connecting vertex goal to goal\n        # Then skip connecting_vertex_goal because it is same as connecting_vertex_start in space but differ in vertex\n        path_goal = path_goal[:-1]\n\n        full_path = path_start + path_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        max_duration = 30  # seconds\n        iter_limit = 10000\n\n        # Alternate tree growth: 0 for start, 1 for goal\n        for i in range(iter_limit):\n            if time() - start_time > max_duration:\n                # Timeout: stop and treat as no path found\n                break\n\n            # Sample random point\n            q_rand: Point = self._get_random_sample()\n\n            # Alternate growing start and goal trees\n            if i % 2 == 0:\n                # Grow start tree towards q_rand\n                q_new_start, extended_start = self._extend(self._graph_start, q_rand)\n                if not extended_start:\n                    self.key_frame()\n                    continue\n                # Then try to connect goal tree towards q_new_start\n                q_new_goal = self._connect(self._graph_goal, q_new_start.position)\n\n                # Check if connected (positions close enough)\n                dist_connect = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor()).item()\n                if dist_connect <= self._max_dist:\n                    # Trees connected; extract and move agent along the found path\n                    self._extract_path(q_new_start, q_new_goal)\n                    break\n            else:\n                # Grow goal tree towards q_rand\n                q_new_goal, extended_goal = self._extend(self._graph_goal, q_rand)\n                if not extended_goal:\n                    self.key_frame()\n                    continue\n                # Then try to connect start tree towards q_new_goal\n                q_new_start = self._connect(self._graph_start, q_new_goal.position)\n\n                dist_connect = torch.norm(q_new_start.position.to_tensor() - q_new_goal.position.to_tensor()).item()\n                if dist_connect <= self._max_dist:\n                    self._extract_path(q_new_start, q_new_goal)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT, inspired by RRT-Connect.\n    It simultaneously grows two trees: one from the start and one from the goal,\n    attempting to connect them efficiently. This bidirectional growth accelerates\n    path discovery by reducing exploration space and improving connection chances.\n    Additionally, time limit is enforced (30 seconds) to terminate search if no path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_goal.edges_removable = False\n\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Combine displays from both graphs\n        displays = super().set_display_info()\n        # Add displays for goal tree\n        if hasattr(self, '_map_displays_goal'):\n            displays += self._map_displays_goal\n        return displays\n\n    def _init_displays(self) -> None:\n        # Displays for start tree\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start)]\n        # Displays for goal tree\n        self._map_displays_goal = [GraphMapDisplay(self._services, self._graph_goal)]\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Same helper reused from RRT\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Same helper reused from RRT\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path_bidirectional(self, q_connect_start: Vertex, q_connect_goal: Vertex) -> None:\n        # Extract path from start tree to connection vertex\n        path_start = [q_connect_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Extract path from goal tree to connection vertex\n        path_goal = [q_connect_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # Combine paths: start to connect + connect to goal (reversed)\n        full_path = path_start + path_goal\n\n        # Move the agent along the combined path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect(self, tree_from: Forest, tree_to: Forest, q_new_from: Vertex, max_dist: float) -> Vertex:\n        \"\"\"\n        Attempt to connect tree_from's new vertex q_new_from to nearest vertex in tree_to.\n        Returns the new vertex in tree_to if connected, otherwise None.\n        \"\"\"\n        q_near_to: Vertex = tree_to.get_nearest_vertex([tree_to.root_vertex_start], q_new_from.position)\n        if q_near_to.position == q_new_from.position:\n            return None\n\n        # Create a new vertex in tree_to towards q_new_from\n        q_new_to: Vertex = self._get_new_vertex(q_near_to, q_new_from.position, max_dist)\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_to.position, q_new_to.position)):\n            return None\n\n        tree_to.add_edge(q_near_to, q_new_to)\n\n        # Check if connected (positions coincide)\n        if q_new_to.position == q_new_from.position:\n            return q_new_to\n\n        # We can try to connect further by repeated extensions towards q_new_from\n\n        while True:\n            q_near_to = q_new_to\n            q_new_to_candidate: Vertex = self._get_new_vertex(q_near_to, q_new_from.position, max_dist)\n            if q_new_to_candidate.position == q_new_to.position:\n                break  # No more progress\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_to.position, q_new_to_candidate.position)):\n                break\n\n            tree_to.add_edge(q_near_to, q_new_to_candidate)\n\n            q_new_to = q_new_to_candidate\n\n            if q_new_to.position == q_new_from.position:\n                return q_new_to\n\n        return None\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        start_time = time.time()\n\n        # To speed up nearest vertex searching, keep references\n        # We alternate between extending start tree and goal tree\n        trees = [(self._graph_start, self._graph_goal), (self._graph_goal, self._graph_start)]\n\n        for i in range(iterations):\n            # Check timeout of 30 seconds\n            if time.time() - start_time > 30:\n                # Path search timed out, no path found\n                break\n\n            # Alternate extension direction every iteration\n            idx = i % 2\n            tree_from, tree_to = trees[idx]\n\n            q_sample: Point = self._get_random_sample()\n\n            q_near_from: Vertex = tree_from.get_nearest_vertex([tree_from.root_vertex_start], q_sample)\n            if q_near_from.position == q_sample:\n                continue\n\n            q_new_from: Vertex = self._get_new_vertex(q_near_from, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_from.position, q_new_from.position)):\n                continue\n\n            tree_from.add_edge(q_near_from, q_new_from)\n\n            # Try to connect the other tree to this new vertex\n            q_new_to = self._try_connect(tree_from=tree_to, tree_to=tree_from, q_new_from=q_new_from, max_dist=max_dist)\n            if q_new_to is not None:\n                # Trees connected; extract path and end search\n                if idx == 0:\n                    # tree_from = start tree, tree_to = goal tree\n                    self._extract_path_bidirectional(q_new_from, q_new_to)\n                else:\n                    # tree_from = goal tree, tree_to = start tree\n                    self._extract_path_bidirectional(q_new_to, q_new_from)\n                break\n\n            # Additional check: if new vertex gets close enough to goal (for start tree)\n            if tree_from is self._graph_start and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new_from.position):\n                # Connect goal vertex explicitly and extract path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                tree_from.add_edge(q_new_from, goal_vertex)\n                self._extract_path_bidirectional(q_new_from, goal_vertex)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation improves the RRT-Connect algorithm by incorporating a heuristic bias \n    towards the goal to speed up convergence, inspired by Informed RRT*. \n\n    Instead of purely random sampling, it samples points within an ellipsoidal informed subset \n    of the search space defined by the current best solution cost, focusing growth towards \n    the most promising areas, pruning exploration of irrelevant regions and thus reducing \n    search time. We maintain the dual-tree connection structure from RRT-Connect to benefit \n    from fast tree connection.\n\n    Additionally, the search is bounded with a 30-second timeout to gracefully abort if no path \n    is found timely.\n\n    The algorithm retains the original structure and reuses helper functions from the provided \n    RRT-Connect for vertex expansion, nearest neighbor retrieval, and path extraction, \n    adapting sampling and path cost estimation to improve efficiency.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm improves upon the SPRM sample-based method by implementing a \n    bidirectional RRT* inspired approach combined with caching and pruning connections. \n    It grows two trees from the agent and the goal simultaneously, connecting random samples \n    to the nearest tree vertex. When the two trees connect, it extracts the path and moves the agent.\n    Early termination occurs upon connection or timeout of 30 seconds, improving time efficiency.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V_start: List[Vertex] = []\n        V_goal: List[Vertex] = []\n        for _ in range(self._V_size // 2):\n            sample_start = self._get_random_sample()\n            V_start.append(Vertex(sample_start, store_connectivity=True))\n            sample_goal = self._get_random_sample()\n            V_goal.append(Vertex(sample_goal, store_connectivity=True))\n        self._graph = CyclicGraph(self._services)\n        # Initialize two root vertices: agent and goal\n        agent_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        self._graph.root_vertices = [agent_vertex, goal_vertex]\n\n        # Add sampled nodes to graph separately tagged (not required by CyclicGraph,\n        # but we'll manage connectivity manually)\n        self._vertices_start = [agent_vertex] + V_start\n        self._vertices_goal = [goal_vertex] + V_goal\n\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _near(self, vertices: List[Vertex], position: Point) -> List[Vertex]:\n        return [v for v in vertices if (v.position.to_tensor() - position.to_tensor()).norm() <= self._max_radius]\n\n    def _get_nearest_vertex(self, vertices: List[Vertex], position: Point) -> Vertex:\n        best_vertex = None\n        best_dist = float(\"inf\")\n        position_tensor = position.to_tensor()\n        for v in vertices:\n            dist = (v.position.to_tensor() - position_tensor).norm().item()\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _extract_path_bidirectional(self, connection_vertex_start: Vertex, \n                                    connection_vertex_goal: Vertex) -> None:\n        # Reconstruct path from agent to connection_vertex_start\n        path_start = []\n        current = connection_vertex_start\n        root_agent = self._graph.root_vertices[0]\n        while current is not root_agent:\n            # connectivity maps: current.connectivity stores best next vertex towards root\n            if root_agent not in current.connectivity:\n                # fallback: no connection path found\n                break\n            current = current.connectivity[root_agent]\n            path_start.append(current)\n\n        # Reconstruct path from goal to connection_vertex_goal (reverse)\n        path_goal = []\n        current = connection_vertex_goal\n        root_goal = self._graph.root_vertices[1]\n        while current is not root_goal:\n            if root_goal not in current.connectivity:\n                break\n            current = current.connectivity[root_goal]\n            path_goal.append(current)\n        path_goal.reverse()\n\n        # Combine: path from agent to connection + path from connection to goal\n        full_path = path_start[::-1] + [connection_vertex_start] + path_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        root_agent = self._graph.root_vertices[0]\n        root_goal = self._graph.root_vertices[1]\n\n        # Use sets for faster connectivity check\n        connected_pairs = set()\n\n        # Build connectivity dicts for root vertices\n        root_agent.connectivity = {root_agent: root_agent}\n        root_goal.connectivity = {root_goal: root_goal}\n\n        # Vertices sets for tree start and tree goal\n        tree_start = set(self._vertices_start)\n        tree_goal = set(self._vertices_goal)\n\n        # Initialize connectivity dict for each vertex\n        for v in tree_start:\n            if not hasattr(v, 'connectivity') or v.connectivity is None:\n                v.connectivity = dict()\n        for v in tree_goal:\n            if not hasattr(v, 'connectivity') or v.connectivity is None:\n                v.connectivity = dict()\n\n        # Add roots self connections\n        root_agent.connectivity[root_agent] = root_agent\n        root_goal.connectivity[root_goal] = root_goal\n\n        max_iter = 10000  # large iteration limit but will be limited by time\n\n        # We will grow both trees in alternation starting from root agent and root goal\n        vertices_start_list = list(tree_start)\n        vertices_goal_list = list(tree_goal)\n\n        for iteration in range(max_iter):\n            if time.time() - start_time > 30.0:\n                # timed out - no path found\n                return\n\n            # Alternate expansion between trees\n            expanding_from_start = (iteration % 2 == 0)\n\n            if expanding_from_start:\n                sample = self._get_random_sample()\n                nearest = self._get_nearest_vertex(vertices_start_list, sample)\n                if nearest is None:\n                    continue\n                new_vertex = self._get_new_vertex(nearest, sample, self._max_radius)\n                if not self._get_grid().is_agent_valid_pos(new_vertex.position):\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(nearest.position, new_vertex.position)):\n                    continue\n                new_vertex.connectivity = dict()\n                # Connect new vertex to nearest vertex in the tree\n                new_vertex.connectivity[root_agent] = nearest\n                nearest.connectivity[root_agent] = nearest  # Ensure nearest points to itself\n\n                vertices_start_list.append(new_vertex)\n                tree_start.add(new_vertex)\n\n                # Try to connect to the other tree by checking neighbors from new_vertex in tree_goal\n                neighbors_in_goal = self._near(vertices_goal_list, new_vertex.position)\n                for ng in neighbors_in_goal:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, ng.position)):\n                        # Connect trees - set bidirectional connectivity\n                        new_vertex.connectivity[root_goal] = ng\n                        ng.connectivity[root_agent] = new_vertex\n\n                        # Extract path and finish\n                        self._extract_path_bidirectional(new_vertex, ng)\n                        return\n\n                self.key_frame()\n\n            else:\n                sample = self._get_random_sample()\n                nearest = self._get_nearest_vertex(vertices_goal_list, sample)\n                if nearest is None:\n                    continue\n                new_vertex = self._get_new_vertex(nearest, sample, self._max_radius)\n                if not self._get_grid().is_agent_valid_pos(new_vertex.position):\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(nearest.position, new_vertex.position)):\n                    continue\n                new_vertex.connectivity = dict()\n                # Connect new vertex to nearest vertex in goal tree\n                new_vertex.connectivity[root_goal] = nearest\n                nearest.connectivity[root_goal] = nearest\n\n                vertices_goal_list.append(new_vertex)\n                tree_goal.add(new_vertex)\n\n                # Test connectivity from new_vertex to start tree vertices\n                neighbors_in_start = self._near(vertices_start_list, new_vertex.position)\n                for ns in neighbors_in_start:\n                    if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, ns.position)):\n                        # Connect trees\n                        new_vertex.connectivity[root_agent] = ns\n                        ns.connectivity[root_goal] = new_vertex\n\n                        self._extract_path_bidirectional(ns, new_vertex)\n                        return\n\n                self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved sample-based planner inspired by SPRM but uses a heuristic to guide sampling \nand connection attempts toward the goal to reduce unnecessary exploration and speed up convergence. \nIt uses a Best-First style expansion combined with radius-restricted neighbor connections and early stopping \nbased on connectivity, also respecting a maximum search time of 30 seconds for practical time constraints.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._goal_bias = 0.2  # probability of sampling near goal to bias sampling\n        self._graph = None\n\n        # Initialize vertices list with goal bias incorporated\n        V: List[Vertex] = list()\n        grid = self._get_grid()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_biased_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        agent_vertex = Vertex(grid.agent.position, store_connectivity=True)\n        goal_vertex = Vertex(grid.goal.position, store_connectivity=True)\n        self._graph = gen_cyclic_graph(self._services, agent_vertex, goal_vertex, V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Sample randomly with a bias towards the goal position to speed convergence.\n        \"\"\"\n        import torch\n        grid = self._get_grid()\n        if torch.rand(1).item() < self._goal_bias:\n            # Sample near goal within max_radius\n            center = grid.goal.position.to_tensor()\n            while True:\n                # Sample in a circle of radius _max_radius around goal\n                offset = (torch.rand(2) * 2 - 1) * self._max_radius\n                sample_tensor = center + offset\n                sample = Point.from_tensor(sample_tensor)\n                if all(0 <= sample_tensor[d] < grid.size[d] for d in range(grid.size.n_dim)) \\\n                        and grid.is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Uniform random sample on map\n            while True:\n                sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n                if grid.is_agent_valid_pos(sample):\n                    return sample\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return (p1.to_tensor() - p2.to_tensor()).norm().item()\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        # Build path by following connectivity to goal\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # Path broken - no connection to goal found\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import heapq\n        start_time = time.time()\n        MAX_RUNTIME = 30.0  # seconds\n\n        agent_vertex, goal_vertex = self._graph.root_vertices\n\n        # Initialize priority queue for exploration (min-heap based on heuristic distance to goal)\n        open_set = []\n        heapq.heappush(open_set, (0.0, agent_vertex))\n        visited = set([agent_vertex])\n        \n        # We maintain connectivity links shortest towards goal by heuristic guidance:\n        # connectivity dict from SPRM already stores best known path towards goal.\n\n        while open_set:\n            if time.time() - start_time > MAX_RUNTIME:\n                # Timed out, treat route as not found\n                return\n\n            _, current_vertex = heapq.heappop(open_set)\n\n            # Try to connect current_vertex with near vertices within radius (bidirectional edges)\n            neighbors = self._near(current_vertex)\n            for neighbor in neighbors:\n                if neighbor is current_vertex:\n                    continue\n\n                # Check if line between current_vertex and neighbor is valid\n                line_seq = self._get_grid().get_line_sequence(neighbor.position, current_vertex.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                # Add edges both ways if not connected already\n                if neighbor not in current_vertex.connectivity:\n                    self._graph.add_edge(current_vertex, neighbor)\n                if current_vertex not in neighbor.connectivity:\n                    self._graph.add_edge(neighbor, current_vertex)\n\n                # If we found a connectivity path to goal via this neighbor, extract full path\n                if goal_vertex in current_vertex.connectivity:\n                    self._extract_path()\n                    return\n\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    # Priority by distance to goal\n                    h = self._distance(neighbor.position, goal_vertex.position)\n                    heapq.heappush(open_set, (h, neighbor))\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved RRT* variant called Informed RRT* for faster convergence.\nIt enhances the classic RRT* path planner by focusing sampling within an ellipsoidal subset of the \nsearch space after an initial solution is found. This heuristic reduces the explored space and \nimproves planning time. Additionally, a timeout of 30 seconds is enforced to abort the search if \nno path is found within the time limit.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # reuse start and goal vertices from the graph\n        self._start_vertex = self._graph.root_vertex_start\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipse(self, c_best: float, c_min: float, x_center: np.ndarray, C: np.ndarray, dim: int) -> Point:\n        \"\"\"\n        Sample a random point in an n-dimensional prolate hyperspheroid (ellipsoid) defined by\n        the current best cost c_best, minimum cost c_min, center x_center and rotation matrix C.\n        If c_best is inf (no solution yet), sample uniformly in the whole space.\n        \"\"\"\n        if math.isinf(c_best):\n            # No solution found, sample uniformly in entire space\n            return self._get_random_sample()\n\n        # Sampling unit ball\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball > 1e-9:\n                x_ball = x_ball / norm_x_ball\n                break\n\n        r = np.random.rand() ** (1/dim)\n        x_ball = x_ball * r\n\n        # Define lengths of ellipsoid axes\n        a1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            # Numerical fix if inside sqrt negative due to float errors\n            a2 = math.sqrt(abs(c_best**2 - c_min**2)) / 2.0\n        else:\n            a2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n        L = np.diag([a1] + [a2]*(dim-1))  # scaling matrix\n\n        # Transform sample from unit ball to ellipsoid\n        x_rand = C @ L @ x_ball + x_center\n\n        # Convert to Point and clamp inside map bounds\n        map_size = self._get_grid().size\n        x_rand_clamped = np.minimum(np.maximum(x_rand, 0), map_size.vector)\n        x_rand_point = Point(*x_rand_clamped.astype(int))\n        if self._get_grid().is_agent_valid_pos(x_rand_point):\n            return x_rand_point\n        else:\n            # fallback uniform sample if sampled point invalid\n            return self._get_random_sample()\n\n    def _rotation_to_world(self, start: np.ndarray, goal: np.ndarray, dim: int) -> np.ndarray:\n        \"\"\"\n        Compute a rotation matrix that aligns the ellipsoid frame to the world frame.\n        \"\"\"\n        a1 = (goal - start) / np.linalg.norm(goal - start)\n        id1 = np.eye(1, dim, 0).flatten()\n\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*dim) @ Vt\n        return C\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reuse logic from RRT_Star\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n        goal_vertex.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_vertex)\n        path: List[Vertex] = [goal_vertex]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        c_best = float('inf')  # Current best path cost (no solution initially)\n        c_min = torch.norm(self._start_vertex.position.to_tensor() - self._goal_vertex.position.to_tensor()).item()\n\n        x_center = (self._start_vertex.position.to_tensor() + self._goal_vertex.position.to_tensor()).numpy() / 2.0\n\n        # Rotation matrix for ellipse frame\n        C = self._rotation_to_world(\n            self._start_vertex.position.to_tensor().numpy(),\n            self._goal_vertex.position.to_tensor().numpy(),\n            dimension\n        )\n\n        for i in range(iterations):\n            # Enforce 30 seconds timeout\n            if time.time() - start_time > 30:\n                # Fail to find a path in time\n                break\n\n            if math.isinf(c_best):\n                # No path found yet: uniform sampling\n                q_sample: Point = self._get_random_sample()\n            else:\n                # Sample inside ellipsoidal informed subset\n                q_sample = self._sample_in_ellipse(c_best, c_min, x_center, C, dimension)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        q_near.cost = None\n                        self._graph.remove_edge(q_parent, q_near)\n                        child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        q_near.cost = q_new.cost + child_parent_dist\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and center/rotation for ellipse sampling\n                path_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                if path_cost < c_best:\n                    c_best = path_cost\n                    x_center = (q_new.position.to_tensor().numpy() + self._goal_vertex.position.to_tensor().numpy()) / 2.0\n                    C = self._rotation_to_world(\n                        q_new.position.to_tensor().numpy(),\n                        self._goal_vertex.position.to_tensor().numpy(),\n                        dimension\n                    )\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis PathPlanning algorithm is an improved variant inspired by the RRT-Connect approach.\nIt integrates goal biasing to speed up convergence by sampling the goal position with\na specified probability to guide the tree growth more directly toward the goal.\nIt also introduces a maximum time limit of 30 seconds to stop the search if no path\nis found within this timeframe. This heuristic improves time efficiency and path-finding\nperformance especially in complex grids.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # Probability to directly sample the goal position for goal biasing\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Sample the goal directly with probability self._goal_sample_rate,\n        otherwise sample randomly in valid positions.\n        \"\"\"\n        from random import random\n        if random() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for iteration in range(self._iterations):\n            if time.time() - start_time > 30.0:  # Time limit of 30 seconds\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT* that incorporates heuristic-guided sampling and adaptive radius adjustment to accelerate convergence and improve path quality. \nIt uses goal biasing to sample towards the goal more frequently, reducing exploration time. \nAlso, the rewiring radius adapts dynamically based on the number of vertices to balance exploration and rewiring cost.\nThe algorithm terminates if no path is found within 30 seconds to ensure timely decision making.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variables\n        self._goal_bias = 0.2  # Probability of sampling the goal to speed up convergence\n        self._max_time_seconds = 30\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Use the superclass implementation to include displays for graph visualization\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            # Time limit check\n            if time.time() - start_time > self._max_time_seconds:\n                # Timeout: no path found within allowed time\n                return\n\n            # Goal biasing: sample goal point with probability goal_bias else random sample\n            if np.random.rand() < self._goal_bias:\n                q_sample: Point = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            # Nearest vertex in current tree\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # New vertex limited by max_dist step\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check if path from q_nearest to q_new is collision-free\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Adaptive radius for rewiring based on current graph size\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), max_radius)\n\n            # Vertices near q_new to consider for rewiring\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost + collision-free edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            # Add q_new to graph with minimal cost parent\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors through q_new to improve costs\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if agent reached goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved sample-based path planner inspired by SPRM, which enhances efficiency \n    by using a radius-limited, prioritized exploration akin to a RRT* approach combined with dynamic rewiring \n    based on shortest path costs. It incrementally builds a graph by sampling points, connecting to \n    nearby vertices if a collision-free connection exists, and performing rewiring to improve paths. \n    A priority queue orders expansion by cost-to-come, promoting quicker discovery of a low-cost path. \n    The search is time-limited to 30 seconds to avoid excessive computation time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 20  # Increased radius for better connectivity\n        V: List[Vertex] = []\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow for rewiring edges\n        self._init_displays()\n\n        # Dictionary to store cost-to-come for each vertex (Vertex -> float)\n        self._cost_to_come: Dict[Vertex, float] = {}\n        # Setup initial costs for root vertices (agent and goal)\n        agent = self._graph.root_vertices[0]\n        goal = self._graph.root_vertices[1]\n        self._cost_to_come[agent] = 0.0\n        self._cost_to_come[goal] = float('inf')\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return vertices within radius _max_radius of given vertex\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Randomly sample a valid point in map\n        \"\"\"\n        grid = self._get_grid()\n        while True:\n            sample = Point(*[torch.randint(0, grid.size[i], (1,)).item() for i in range(grid.size.n_dim)])\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec).item()\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir_vec / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(new_pos, store_connectivity=True)\n\n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        \"\"\"\n        Edge cost between two vertices - Euclidean distance\n        \"\"\"\n        return self._distance(v1.position, v2.position)\n\n    def _update_cost_to_come(self, vertex: Vertex, cost: float):\n        \"\"\"\n        Update stored cost-to-come for given vertex\n        \"\"\"\n        self._cost_to_come[vertex] = cost\n\n    def _get_cost_to_come(self, vertex: Vertex) -> float:\n        return self._cost_to_come.get(vertex, float('inf'))\n\n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        Attempt to rewire neighbors through new_vertex if it improves cost\n        \"\"\"\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)):\n                continue\n            current_cost = self._get_cost_to_come(neighbor)\n            new_cost = self._get_cost_to_come(new_vertex) + self._cost(new_vertex, neighbor)\n            if new_cost < current_cost:\n                # Remove old parent edges and update connectivity\n                to_remove = []\n                for k, v in neighbor.connectivity.items():\n                    if v == neighbor:\n                        continue\n                    to_remove.append(k)\n                for k in to_remove:\n                    del neighbor.connectivity[k]\n                # Add new edge\n                self._graph.add_edge(new_vertex, neighbor)\n                self._update_cost_to_come(neighbor, new_cost)\n                self.key_frame()\n\n    def _extract_path(self) -> None:\n        agent = self._graph.root_vertices[0]\n        goal = self._graph.root_vertices[1]\n        if goal not in self._cost_to_come or self._cost_to_come[goal] == float('inf'):\n            return  # No path found\n\n        # Extract path following connectivity from agent to goal minimizing cost\n        path = []\n        current_vertex = agent\n        while current_vertex != goal:\n            next_vertex = None\n            min_cost = float('inf')\n            for neigh in current_vertex.connectivity.values():\n                cost_to_goal = self._get_cost_to_come(neigh)\n                if cost_to_goal < min_cost:\n                    next_vertex = neigh\n                    min_cost = cost_to_goal\n            if next_vertex is None or next_vertex == current_vertex:\n                break\n            path.append(next_vertex)\n            current_vertex = next_vertex\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        agent = self._graph.root_vertices[0]\n        goal = self._graph.root_vertices[1]\n\n        # Initialize priority queue with (cost-to-come, vertex)\n        frontier: List[Tuple[float, Vertex]] = []\n        heapq.heappush(frontier, (0.0, agent))\n\n        # Initialize cost for all vertices\n        for v in self._graph.vertices:\n            if v != agent:\n                self._update_cost_to_come(v, float('inf'))\n\n        start_time = time.time()\n        max_duration = 30  # seconds\n\n        while frontier:\n            if time.time() - start_time > max_duration:\n                break  # Time limit reached, stop search\n\n            current_cost, current_vertex = heapq.heappop(frontier)\n\n            if current_vertex == goal:\n                self._extract_path()\n                return\n\n            # Sample a random point near current_vertex to guide growth toward unexplored areas\n            q_sample = self._get_random_sample()\n            q_new = self._get_new_vertex(current_vertex, q_sample, self._max_radius)\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            # Check if q_new already in graph (distance < tolerance)\n            existing_vertices = self._near(q_new)\n            closest_vertex = None\n            min_dist = float('inf')\n            for v in existing_vertices:\n                dist = self._distance(v.position, q_new.position)\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_vertex = v\n            # If close vertex found, use it as q_new to avoid duplicates\n            if closest_vertex and min_dist < 1e-3:\n                q_new = closest_vertex\n\n            # Connect q_new to neighbors by valid edges and update costs if improved\n            neighbors = self._near(q_new)\n            best_parent = None\n            best_cost = float('inf')\n            for neighbor in neighbors:\n                if neighbor == q_new:\n                    continue\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, q_new.position)):\n                    new_cost = self._get_cost_to_come(neighbor) + self._cost(neighbor, q_new)\n                    if new_cost < best_cost:\n                        best_cost = new_cost\n                        best_parent = neighbor\n\n            if best_parent is None:\n                # No valid connection for q_new\n                continue\n\n            # If q_new is a new vertex object, add it to the graph\n            if q_new not in self._graph.vertices:\n                self._graph.add_vertex(q_new)\n            # Add edge between best parent and q_new with both directions for connectivity\n            self._graph.add_edge(best_parent, q_new)\n            self._graph.add_edge(q_new, best_parent)\n            self._update_cost_to_come(q_new, best_cost)\n\n            # Add q_new to frontier for expansion\n            heapq.heappush(frontier, (best_cost, q_new))\n            self.key_frame()\n\n            # Rewire neighbors through q_new if it lowers cost\n            self._rewire(q_new, neighbors)\n\n            # Check if goal can be connected directly to q_new with lower cost\n            dist_to_goal = self._distance(q_new.position, goal.position)\n            if dist_to_goal <= self._max_radius and \\\n               self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal.position)):\n                new_goal_cost = self._get_cost_to_come(q_new) + dist_to_goal\n                if new_goal_cost < self._get_cost_to_come(goal):\n                    # Connect new edge to goal updating graph and cost\n                    if goal not in self._graph.vertices:\n                        self._graph.add_vertex(goal)\n                    self._graph.add_edge(q_new, goal)\n                    self._graph.add_edge(goal, q_new)\n                    self._update_cost_to_come(goal, new_goal_cost)\n                    heapq.heappush(frontier, (new_goal_cost, goal))\n                    self.key_frame()\n\n        # If reached here: no path found within time limit, no movement done ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    PathPlanning algorithm implements an improved RRT* that accelerates convergence by \n    employing goal biasing with a probabilistic guided sampling strategy and adaptive \n    radius rewiring for more efficient local rewiring. These improvements aim at quicker \n    discovery of feasible paths and faster path optimization.\n\n    Key features:\n    - Goal biasing: Occasionally sample directly at the goal to steer tree growth towards it.\n    - Adaptive rewiring radius warm-started with tree size and iteration count.\n    - Early termination if the time limit (30 seconds) is exceeded.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        # Add goal bias ratio and initial rewiring radius scaling factor variables\n        self._goal_sample_rate: float = 0.1  # 10% of samples bias towards goal\n        self._lambda_rrt_star_initial: float = 50.0  # initial rewiring lambda\n        self._max_radius: float = 50.0  # max rewiring radius\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_iterations: int = 10000\n        dimension: int = 2\n        start_time = time.time()\n\n        for i in range(max_iterations):\n            # Time check for 30 seconds limit\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Path not found within time limit\n                break\n\n            # Goal biased sampling: with probability goal_sample_rate, sample goal position\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample: Point = self._get_grid().goal.position\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision free line\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Compute adaptive radius for rewiring\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                card_v = torch.tensor(2.0)\n            log_card_v = torch.log(card_v)\n            # Adaptive radius reduces over iterations to speed up local rewiring\n            lambda_rrt_star = max(self._lambda_rrt_star_initial * (1.0 - (i / max_iterations)), 10.0)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), self._max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost connecting to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                if q_near.position == q_new.position:\n                    continue\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors around q_new\n            for q_near in Q_near:\n                if q_near.position == q_new.position:\n                    continue\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        # Remove old edge and attach to q_new\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        q_near.cost = q_new.cost + child_parent_dist\n                        self._graph.add_edge(q_new, q_near)\n\n            # If q_new is within goal radius, extract and move agent along path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        path.pop()  # Remove the last dummy vertex\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):  # Support ROS publish if available\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning class implements an improved sample-based algorithm inspired by RRT-Connect.\n    It integrates a goal-biased sampling approach that samples towards the goal with high frequency,\n    increasing the chance of quickly extending the tree towards the goal. Additionally, it dynamically \n    adjusts the maximum extension distance (max_dist) to allow longer edges when the tree is sparse \n    and shorter edges when closer to goal regions, improving local refinement and global exploration. \n    Furthermore, the algorithm respects a 30-second timeout constraint for timely termination.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample the goal directly\n    _min_max_dist: float\n    _max_max_dist: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10.0\n        self._min_max_dist = 5.0\n        self._max_max_dist = 20.0\n        self._iterations = 20000\n        self._goal_sample_rate = 0.2  # 20% chance sample goal directly; 80% uniform random\n\n    def _goal_biased_sample(self) -> Point:\n        rng = np.random.rand()\n        if rng < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _adjust_max_dist(self, q_near: Vertex, q_sample: Point) -> float:\n        \"\"\"\n        Dynamically adjust max_dist based on distance to goal and current extension.\n        Longer extension allowed when far, shorter when close for refinement.\n        \"\"\"\n        dist_to_goal = torch.norm(q_near.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n        dist_sample = torch.norm(q_near.position.to_tensor() - q_sample.to_tensor())\n        \n        scale = float(dist_to_goal / (self._get_grid().size.n_dim * self._get_grid().size))\n        scale = max(0.0, min(scale, 1.0))\n        \n        adjusted_max_dist = self._min_max_dist + scale * (self._max_max_dist - self._min_max_dist)\n        adjusted_max_dist = min(adjusted_max_dist, dist_sample)\n        return adjusted_max_dist\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adjusted_max_dist = self._adjust_max_dist(self._q_near, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, adjusted_max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from q_new and extension target\n        path_mid_to_b: List[Vertex] = [self._q_new]\n\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout: failed to find route within 30 seconds\n                break\n\n            q_rand: Point = self._goal_biased_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame()\n        \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm is an improved version of RRT called Bi-directional RRT (RRT-Connect). \nIt grows two trees simultaneously: one from the start and one from the goal position. \nEach iteration, a random valid sample is drawn, and the nearest vertex in the start tree extends towards it.\nThen the goal tree attempts to extend towards this new vertex as far as possible.\nThe trees attempt to connect with each other continually.\nThis approach typically improves exploration efficiency and reduces search time compared to the unidirectional RRT.\nAdditionally, a 30-second timeout limit is enforced to abort the search if no path is found within that time.\nThe algorithm reuses helper methods from the base class with added tree connection logic.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n\n        # For display, unify graphs or display both\n        # We show start tree by default\n        self._graph = self._graph_start  \n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Optional[Vertex]:\n        \"\"\"\n        Returns a new vertex in direction from q_near towards q_sample constrained by max_dist.\n        Returns None if new vertex position invalid.\n        \"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir == 0:\n            return None\n        if norm_dir <= max_dist:\n            q_new_point = q_sample\n        else:\n            dir_normalized = dir / norm_dir\n            q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n\n        # Check if the line path is valid\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_point)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        return Vertex(q_new_point)\n\n    def _extend(self, tree: Forest, q_target: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Attempts to extend the tree towards q_target by at most max_dist.\n        Returns the new vertex if extension successful; else None.\n        \"\"\"\n        q_near = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            # Already at target, no extension possible\n            return None\n        q_new = self._get_new_vertex(q_near, q_target, max_dist)\n        if q_new is None:\n            return None\n        tree.add_edge(q_near, q_new)\n        return q_new\n\n    def _connect(self, tree: Forest, q_target: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Repeatedly extend the tree towards q_target until no further progress can be made.\n        Returns last vertex extended to or None if no extension possible.\n        \"\"\"\n        q_new = None\n        while True:\n            v_new = self._extend(tree, q_target, max_dist)\n            if v_new is None:\n                break\n            q_new = v_new\n            if q_new.position == q_target:\n                break\n        return q_new\n\n    def _extract_path(self, connection_vertex_start: Vertex, connection_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Extracts path from start to goal by tracing parents in both trees from connection vertices,\n        merges them, then moves agent along resultant path.\n        \"\"\"\n        # Trace path back to start from connection in start tree\n        path_start = [connection_vertex_start]\n        current_v = connection_vertex_start\n        while len(current_v.parents) != 0:\n            current_v = current_v.parents[0]\n            path_start.append(current_v)\n        path_start.reverse()\n\n        # Trace path back to goal from connection in goal tree\n        path_goal = [connection_vertex_goal]\n        current_v = connection_vertex_goal\n        while len(current_v.parents) != 0:\n            current_v = current_v.parents[0]\n            path_goal.append(current_v)\n        # Do not reverse path_goal because it's from goal towards connection\n\n        # Merge paths (omit duplicate connection vertex)\n        full_path = path_start + path_goal[1:]\n\n        # Animate movement along the full path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iteration_limit: int = 100000\n        time_limit_sec: float = 30.0\n        start_time: float = time.time()\n\n        # Alternate between expanding start and goal trees\n        for i in range(iteration_limit):\n            if time.time() - start_time > time_limit_sec:\n                # Timeout reached, treat as no path found\n                break\n\n            # Sample random valid point\n            q_sample = self._get_random_sample()\n\n            # Extend start tree towards sample\n            q_new_start = self._extend(self._graph_start, q_sample, max_dist)\n            if q_new_start is None:\n                self.key_frame()\n                continue\n\n            # Try to connect goal tree towards the new vertex in start tree\n            q_new_goal = self._connect(self._graph_goal, q_new_start.position, max_dist)\n            if q_new_goal is not None:\n                # Trees connected, extract path\n                self._extract_path(q_new_start, q_new_goal)\n                return  # Path found, end function\n\n            self.key_frame()\n\n            if time.time() - start_time > time_limit_sec:\n                break\n\n            # Swap roles: Extend goal tree towards sample\n            q_sample_2 = self._get_random_sample()\n            q_new_goal_2 = self._extend(self._graph_goal, q_sample_2, max_dist)\n            if q_new_goal_2 is None:\n                self.key_frame()\n                continue\n\n            # Try to connect start tree towards the new vertex in goal tree\n            q_new_start_2 = self._connect(self._graph_start, q_new_goal_2.position, max_dist)\n            if q_new_start_2 is not None:\n                self._extract_path(q_new_start_2, q_new_goal_2)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nPathPlanning algorithm improves over the RRT* by incorporating informed sampling using an ellipsoidal heuristic \n(inspired by Informed RRT*) to focus the search in a subset of the search space likely containing the optimal path, \nthus improving time efficiency. It also adds a 30-second timeout to abort if no path is found within the limit.\n\"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm, named PathPlanning, is an improved version of the SPRM algorithm.\n    It leverages a sample-based probabilistic roadmap approach but incorporates a heuristic-guided\n    incremental connection strategy inspired by RRT* to accelerate convergence.\n    The improvements include:\n    - Connecting new vertices preferentially to the closest (within max radius) existing vertices,\n      minimizing redundant edge checks.\n    - Using a priority queue to attempt connections starting from the closest vertices to the new vertex.\n    - Early termination if a path to the goal is found.\n    - A 30-second timeout to treat search failure.\n    Overall, the approach balances exploration and exploitation with heuristic proximity, yielding faster path\n    finding in sparse or complex maps.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 250  # Increased samples for better coverage\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        start_vertex: Vertex = self._graph.root_vertices[0]\n        goal_vertex: Vertex = self._graph.root_vertices[1]\n\n        # Connect the root vertices internally on init\n        def can_connect(u: Vertex, v: Vertex) -> bool:\n            line_seq = self._get_grid().get_line_sequence(u.position, v.position)\n            return self._get_grid().is_valid_line_sequence(line_seq)\n\n        # Priority queue will store tuples (distance, vertex) to prioritize closest\n        def vertices_within_radius_priority(center: Vertex, radius: float) -> List[Tuple[float, Vertex]]:\n            vertices_in_radius = self._graph.get_vertices_within_radius([center], center.position, radius)\n            res = []\n            for vert in vertices_in_radius:\n                if vert is center:\n                    continue\n                dist = (vert.position.to_tensor() - center.position.to_tensor()).norm().item()\n                res.append((dist, vert))\n            heapq.heapify(res)\n            return res\n\n        # Incrementally try to grow roadmap guided by proximity, similar to RRT* style rewiring\n        # but without rewiring cost improvements.\n        for i, v in enumerate(self._graph.root_vertices + self._graph.vertices):\n            if time.time() - start_time > 30:\n                # Timeout - no path found within 30 seconds\n                return\n            # Get vertices near v sorted by distance to reduce edge checks\n            near_vertices_with_dist = vertices_within_radius_priority(v, self._max_radius)\n            while near_vertices_with_dist:\n                if time.time() - start_time > 30:\n                    return\n\n                dist, u = heapq.heappop(near_vertices_with_dist)\n\n                # Avoid self loops and edges already present\n                if u is v or u in v.connectivity:\n                    continue\n\n                if can_connect(u, v):\n                    self._graph.add_edge(v, u)\n                    self._graph.add_edge(u, v)\n                    self.key_frame()\n\n                    # Check connectivity from start to goal\n                    if goal_vertex in start_vertex.connectivity:\n                        self._extract_path()\n                        return\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            next_vertex = current_vertex.connectivity.get(goal, None)\n            if next_vertex is None:\n                break  # No path found\n            current_vertex = next_vertex\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improvement over RRT*, aiming to reduce planning time\n    by incorporating informed sampling (Informed RRT*) after an initial solution\n    is found. The algorithm first runs like a standard RRT*. Once a path to the\n    goal is discovered, it switches to informed sampling that restricts random\n    samples to an ellipsoidal heuristic region around the current best path,\n    improving convergence speed toward the optimal path.\n\n    Key improvements:\n    - Time limit of 30 seconds imposed for planning.\n    - Use of informed sampling to bias samples, reducing exploration in irrelevant areas.\n    - Reuse of RRT* rewiring and path extraction logic.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._found_initial_solution: bool = False\n        self._best_goal_vertex: Vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, c_best: float, c_min: float, start_pos: Point, goal_pos: Point) -> Point:\n        \"\"\"\n        Sample uniformly within an ellipsoid that bounds the best known path cost.\n        If c_best is np.inf, revert to uniform random.\n        \"\"\"\n        if c_best == float('inf'):\n            return self._get_random_sample()\n\n        # Convert points to tensor for calculations\n        start = start_pos.to_tensor()\n        goal = goal_pos.to_tensor()\n        center = (start + goal) / 2\n        direction = goal - start\n        length = torch.norm(direction)\n        if length == 0:\n            return Point.from_tensor(center)\n\n        # Rotation matrix that aligns the x-axis with the direction from start to goal\n        a1 = direction / length\n        id1 = torch.tensor([1.0, 0.0])\n        cos_theta = torch.dot(a1, id1)\n        sin_theta = torch.cross(torch.cat((a1, torch.zeros(1))), torch.cat((id1, torch.zeros(1))))[2]  # Scalar z-component of cross product\n        rotation = torch.tensor([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n\n        # Ellipsoid radii\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n        radii = torch.tensor([r1, r2])\n\n        # Sample in unit ball\n        while True:\n            # Sample within unit circle\n            sample_unit = torch.randn(2)\n            if torch.norm(sample_unit) <= 1:\n                break\n        sample_unit = sample_unit / torch.norm(sample_unit) * (torch.rand(1) ** 0.5)\n\n        # Scale and rotate sample\n        sample_ellipse = rotation @ (radii * sample_unit) + center\n\n        # Convert to int grid coords\n        sample_pt = Point.from_tensor(sample_ellipse.round().int())\n        if self._get_grid().is_agent_valid_pos(sample_pt):\n            return sample_pt\n        # fallback in case invalid sample generated\n        return self._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract path from q_new to goal and move the agent.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # Select first parent (tree structure)\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]  # remove last repeated vertex (root)\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension: int = 2\n\n        start_time = time.time()\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_pos = start_vertex.position\n\n        c_best: float = float('inf')  # best solution cost found so far\n        c_min: float = torch.norm(goal_pos.to_tensor() - start_pos.to_tensor()).item()\n\n        for i in range(iterations):\n            if (time.time() - start_time) > 30.0:  # Timeout after 30 seconds\n                # No solution found within time limit\n                break\n\n            # Sample point using informed sampling if solution already found\n            if self._found_initial_solution:\n                q_sample: Point = self._informed_sample(c_best, c_min, start_pos, goal_pos)\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            # If motion between q_nearest and q_new is invalid, skip\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Compute radius for neighbors in rewiring step\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost to q_new\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if beneficial\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if agent reaches goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Mark initial solution found, update best path cost\n                if not self._found_initial_solution or (q_new.cost < c_best):\n                    self._found_initial_solution = True\n                    c_best = q_new.cost\n                    self._best_goal_vertex = q_new\n\n                    # Extract and move agent along current best path\n                    self._extract_path(q_new)\n                    # Do not break immediately, continue refining path with informed sampling\n                    # but if the intention is to stop at first found path, uncomment break:\n                    # break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved bidirectional RRT-Connect variant \n    enhanced with a goal bias and informed sampling to improve convergence speed.\n    A goal bias samples the goal position with higher probability, which focuses \n    the search towards the goal faster. Informed sampling uses an elliptical sampling \n    region defined by the best path cost found, reducing the sampling space to \n    the area likely containing the optimal path, improving efficiency.\n    The algorithm aborts if the path is not found within 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n    _start_time: float\n    _timeout: float\n    _best_cost: float\n    _goal_reached: bool\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        # Initialize forest with root vertices at agent and goal positions\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.2                       # 20% samples directed towards goal\n        self._timeout = 30.0                        # Seconds\n        self._best_cost = float('inf')              # Track best path cost found\n        self._goal_reached = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _heuristic_cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        return self._distance(from_vertex.position, to_vertex.position)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Implements informed sampling:\n        If best cost is known and finite, sample inside an ellipsoid defined by start, goal, and best cost.\n        Else, sample uniformly with goal bias.\n        \"\"\"\n        start_pos = self._graph.root_vertices[0].position\n        goal_pos = self._graph.root_vertices[-1].position\n        \n        # Goal bias sampling\n        if random.random() < self._goal_bias:\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n\n        # If best_cost unknown or infinite, uniform random sample\n        if self._best_cost == float('inf'):\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        \n        # Informed sampling region (ellipsoid) centered between start and goal\n        c_min = self._distance(start_pos, goal_pos)\n        c_best = max(self._best_cost, c_min)\n        \n        if c_best < float('inf'):\n            # Define ellipse parameters:\n            center = Point(\n                *(0.5 * (start_pos.to_tensor() + goal_pos.to_tensor())).tolist()\n            )\n            # Unit vector from start to goal\n            a1_dir_tensor = (goal_pos.to_tensor() - start_pos.to_tensor()) / c_min\n            # Construct orthonormal basis (for 2D or 3D)\n            n_dim = self._get_grid().size.n_dim\n            \n            # Rotation matrix to align sampling to ellipse principal axes \n            # (simple approach: identity if 2D or 3D assuming axis-aligned)\n            # We assume axis-aligned map so can sample axis aligned ellipsoid\n            # Radii of the ellipsoid:\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best**2 - c_min**2) / 2\n            r3 = r2 if n_dim == 3 else 0\n            \n            def sample_unit_ball() -> np.ndarray:\n                # Sample uniformly from unit ball in n_dim\n                while True:\n                    p = np.random.normal(0, 1, n_dim)\n                    norm_p = np.linalg.norm(p)\n                    if norm_p <= 1e-12:\n                        continue\n                    unit_p = p / norm_p\n                    radius = random.random() ** (1.0 / n_dim)\n                    return unit_p * radius\n            \n            for _ in range(100):  # max tries for valid\n                sample_ball = sample_unit_ball()\n                sample_coords = [0.0] * n_dim\n                if n_dim == 2:\n                    sample_coords[0] = sample_ball[0] * r1\n                    sample_coords[1] = sample_ball[1] * r2\n                elif n_dim == 3:\n                    sample_coords[0] = sample_ball[0] * r1\n                    sample_coords[1] = sample_ball[1] * r2\n                    sample_coords[2] = sample_ball[2] * r3\n                else:\n                    # For other dims, uniform random sample in bounding box approx\n                    sample_coords = np.array(sample_ball) * r1\n                # Translate to center\n                sample_tensor = center.to_tensor() + torch.tensor(sample_coords, dtype=torch.float)\n                sample_np = sample_tensor.numpy()\n                # Clamp to map bounds\n                dims = self._get_grid().size\n                for idx in range(n_dim):\n                    sample_np[idx] = max(0, min(sample_np[idx], dims[idx]-1))\n                sample_point = Point(*sample_np.astype(int))\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    return sample_point\n\n            # Fallback uniform if can't get informed sample\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # If cost unknown, fallback uniform sample\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _try_connect(self, root_vertex: Vertex, target_vertex: Vertex) -> str:\n        \"\"\"\n        Attempts to connect root_vertex towards target_vertex repeatedly until trapped, advanced, or reached.\n        \"\"\"\n        status = 'advanced'\n        last_vertex = root_vertex\n        while status == 'advanced':\n            status = self._extend(last_vertex, target_vertex.position)\n            if status == 'advanced':\n                # advance last_vertex to newly created vertex to continue connecting\n                last_vertex = self._q_new\n        return status\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract and move agent along path found by connecting root vertices.\n        Reuses parent's _extract_path logic with minor fix to handle reversed roots.\n        \"\"\"\n        # trace back from _q_new to its root\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = path_mid_to_b[-1].parents[0]  # only first parent trace\n            path_mid_to_b.append(parent)\n\n        # trace from extension target to its root\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = path_a_to_mid[-1].parents[0]\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _calculate_path_cost(self, path_vertices: List[Vertex]) -> float:\n        \"\"\"\n        Calculates the sum of Euclidean distances along the given path vertices.\n        \"\"\"\n        cost = 0.0\n        for i in range(len(path_vertices)-1):\n            cost += self._distance(path_vertices[i].position, path_vertices[i+1].position)\n        return cost\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        for i in range(self._iterations):\n            now = time.time()\n            if now - self._start_time > self._timeout:\n                # Timeout reached, abort search\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            extend_status = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_status != 'trapped':\n                self._extension_target = self._q_new\n                connect_status = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_status == 'reached':\n                    self._extract_path()\n                    self._goal_reached = True\n\n                    # Update best cost from extracted path \n                    # Trace path vertices again\n                    path_mid_to_b = [self._q_new]\n                    while len(path_mid_to_b[-1].parents) != 0:\n                        path_mid_to_b.append(path_mid_to_b[-1].parents[0])\n                    path_a_to_mid = [self._extension_target]\n                    while len(path_a_to_mid[-1].parents) != 0:\n                        path_a_to_mid.append(path_a_to_mid[-1].parents[0])\n                    path_a_to_mid.reverse()\n                    full_path = path_a_to_mid + path_mid_to_b\n\n                    cost = self._calculate_path_cost(full_path)\n                    if cost < self._best_cost:\n                        self._best_cost = cost\n                    \n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame()\n\n        # If no path was found within iterations or timeout,\n        # no path extraction or agent movement happens. ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved path planner based on the RRT* (Rapidly-exploring Random Tree Star) approach.\nCompared to the original RRT, RRT* optimizes the paths by rewiring the tree within a neighborhood radius to reduce cost,\nyielding shorter and more efficient paths over iterations.\nKey improvements include:\n- Connecting new samples to the lowest-cost nearby vertex (not just the nearest).\n- Rewiring nearby vertices to the new vertex if it offers a lower path cost.\n- A dynamic neighborhood radius based on the number of vertices in the tree.\nAdditionally, a 30-second timeout is enforced to terminate the search if no path is found within the timeframe.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _goal_vertex: Vertex\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = Forest(start_vertex, goal_vertex)\n        self._graph.edges_removable = True  # Enable rewiring (removing edges)\n        self._goal_vertex = goal_vertex\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Optional[Vertex]:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n        if dist <= max_dist:\n            q_new_point = q_sample\n        else:\n            direction_normalized = direction / dist\n            q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        q_new = Vertex(q_new_point)\n        return q_new\n\n    def _get_random_sample(self) -> Point:\n        # Enhance sampling with goal bias to improve convergence speed\n        goal_bias_prob = 0.1  # 10% samples are the goal to bias tree growth towards goal\n        if np.random.random() < goal_bias_prob:\n            return self._goal_vertex.position\n\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find all vertices within radius distance from q_new\n        \"\"\"\n        near_vertices = []\n        for v in self._graph.vertices:\n            if torch.norm((v.position.to_tensor() - q_new.position.to_tensor())) <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent from near vertices based on minimum cost + edge cost,\n        also verify if the edge is valid (collision-free).\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n\n        for v in near_vertices:\n            line_seq = grid.get_line_sequence(v.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            cost = v.cost + torch.norm((v.position.to_tensor() - q_new.position.to_tensor()))\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For each vertex in near_vertices, check if going through q_new reduces cost.\n        If so, rewire (change parent to q_new).\n        \"\"\"\n        grid = self._get_grid()\n        for v in near_vertices:\n            if v == q_new.parents[0]:  # skip parent\n                continue\n            line_seq = grid.get_line_sequence(q_new.position, v.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            new_cost = q_new.cost + torch.norm((q_new.position.to_tensor() - v.position.to_tensor()))\n            if new_cost < v.cost:\n                # Rewire parent\n                # Remove old edge: implied by Forest implementation that edges can be removed\n                # Remove old parents and set new parent\n                # In Forest, edges_removable enabled, so this should be handled by graph structure.\n                # Assuming _graph.remove_edge and _graph.add_edge exists or similar functionality.\n                # Here, we skip explicit remove since our graph likely manages parents relations on add_edge.\n                v.parents.clear()\n                self._graph.add_edge(q_new, v)\n                v.cost = new_cost\n\n    def _extract_path(self, q_last: Vertex) -> None:\n        \"\"\"\n        Extract path from q_last to start vertex following parents and move the agent following path.\n        \"\"\"\n        path: List[Vertex] = [q_last]\n        # Follow parents up to start vertex (which has no parents)\n        while len(path[-1].parents) != 0:\n            path.append(path[-1].parents[0])\n        path.reverse()\n\n        # Animate path traversal using move_agent and key_frame\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist = 10.0\n        max_iterations = 10000\n        start_time = time.perf_counter()\n        found_path = False\n\n        # Initialize root vertex cost to zero\n        self._graph.root_vertex_start.cost = 0.0\n\n        for iteration in range(max_iterations):\n            elapsed = time.perf_counter() - start_time\n            if elapsed > 30.0:\n                # Timed out: no path found\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n            if q_new is None:\n                continue\n\n            grid = self._get_grid()\n\n            line_seq = grid.get_line_sequence(q_near.position, q_new.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            # Calculate neighborhood radius as RRT* does: gamma * (log(n)/n)^(1/d)\n            n_vertices = len(self._graph.vertices) + 1  # Including q_new\n            dim = self._get_grid().size.n_dim\n            gamma_rrt_star = 50.0  # constant tuning param: can be adjusted\n            radius = min(max_dist, gamma_rrt_star * (math.log(n_vertices) / n_vertices) ** (1.0 / dim))\n\n            near_vertices = self._near_vertices(q_new, radius)\n\n            # Initially add q_new with no parent and infinite cost to compute best parent\n            q_new.cost = float('inf')\n            self._graph.add_vertex(q_new)\n\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # No valid parent found, remove q_new and continue\n                self._graph.remove_vertex(q_new)\n                continue\n\n            cost_to_q_new = best_parent.cost + torch.norm(best_parent.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = cost_to_q_new\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the tree with q_new as potential better parent\n            self._rewire(near_vertices, q_new)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._graph.add_edge(q_new, self._goal_vertex)\n                self._goal_vertex.parents.clear()\n                self._goal_vertex.parents.append(q_new)\n                self._goal_vertex.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                self._graph.add_vertex(self._goal_vertex)\n                found_path = True\n                self._extract_path(self._goal_vertex)\n                break\n\n            self.key_frame()\n\n        if not found_path:\n            # No path found within time limit or iterations\n            pass  # Could optionally visualize failure or leave as is ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved PathPlanning algorithm inspired by SPRM that accelerates path finding by:\n    - Using informed sampling biased towards the goal region.\n    - Dynamically connecting newly sampled vertices to near neighbors with minimal edge length rather than all within radius to reduce connections.\n    - Using a priority queue based incremental connection approach resembling PRM* for faster convergence.\n    - Early stopping if path found or 30 seconds limit exceeded.\n    \n    The algorithm samples vertices with a bias towards the direct line between agent and goal to produce more relevant samples.\n    It incrementally grows the graph by connecting each new vertex to its nearest neighbors with valid edges.\n    Once the goal becomes reachable from the agent, it extracts and follows the path.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT variant with goal biasing and better path connection strategy to speed up convergence. \nIt samples points mostly around the goal region (goal bias) to direct tree growth faster towards the goal and uses a larger max extension distance adaptively. \nThe algorithm also imposes a 30-second timeout to treat failure to find a path within that duration as no path found. \nThis helps improve planning time especially in large or complex map environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        # Additional member variables\n        self._goal_bias_prob = 0.2   # Probability of sampling goal region to bias towards goal\n        self._max_dist_start = 10.0  # Initial max extension distance\n        self._max_dist_end = 25.0    # Max extension distance increase for faster exploration\n\n    def _get_biased_random_sample(self) -> Point:\n        \"\"\"\n        Sample with goal biasing - sample near the goal with some probability to accelerate convergence.\n        \"\"\"\n        if np.random.uniform(0,1) < self._goal_bias_prob:\n            goal_pos = self._get_grid().goal.position\n            # Sample near goal within radius 10 around goal, if possible, otherwise sample exact goal position\n            goal_radius = 10\n            min_bound = np.maximum(goal_pos.to_np() - goal_radius, 0)\n            max_bound = np.minimum(goal_pos.to_np() + goal_radius, self._get_grid().size - 1)\n            sampled_coords = np.array([np.random.randint(min_bound[d], max_bound[d]+1) for d in range(self._get_grid().size.n_dim)])\n            sample = Point(*sampled_coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            # fallback to exact goal position if random near-goal sampling invalid\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        # Else uniformly random sample in entire map\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extract and follow the path from start to goal through parents.\n        Connect last sampled vertex directly to goal vertex for path extraction.\n        \"\"\"\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Connect last node to the goal vertex if not already connected\n        if goal_v not in self._graph.vertices or goal_v not in self._graph._adjacency.get(q_new, []):\n            if not self._graph.has_edge(q_new, goal_v):\n                self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n\n        # Trace back parents until root (start vertex)\n        while len(path[-1].parents) != 0:\n            path.append(path[-1].parents[0])\n\n        path.pop()  # remove duplicate root vertex at end\n        path.reverse()\n\n        # Animate agent moving along the path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_iterations = 100000\n        start_time = time.time()\n        max_dist = self._max_dist_start\n        grow_time_halftime = 15.0  # seconds after which max_dist increases gradually to max_dist_end\n\n        for iteration in range(max_iterations):\n\n            # Check timeout of 30 seconds\n            elapsed = time.time() - start_time\n            if elapsed > 30:\n                # No path found within time limit\n                break\n\n            # Gradually increase max_dist to encourage faster exploration over time\n            if elapsed < grow_time_halftime:\n                max_dist = self._max_dist_start + (self._max_dist_end - self._max_dist_start) * (elapsed / grow_time_halftime)\n            else:\n                max_dist = self._max_dist_end\n\n            q_sample: Point = self._get_biased_random_sample()\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n            if torch.norm(dir_vec) <= max_dist:\n                q_new_pos = q_sample\n            else:\n                dir_normalized = dir_vec / torch.norm(dir_vec)\n                q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n            \n            q_new = Vertex(q_new_pos)\n            \n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            # If within goal radius, extract and animate path and exit\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-Based Path Planning Algorithm inspired by SPRM.\n    This algorithm uses a bidirectional rapidly-exploring random graph (RRG) approach\n    to speed up pathfinding by simultaneously growing two trees from the agent and the goal.\n    It uses a radius-based neighbor connection strategy to maintain a sparse graph and\n    connects vertices incrementally, ensuring quick discovery of a feasible path.\n    Early termination is enforced by a 30-second timeout to avoid long runtime.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 300  # Increased samples for better coverage\n        self._max_radius = 12  # Slightly reduced radius for efficiency\n\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        # Create two root vertices: agent start and goal\n        agent_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n\n        # Initialize empty cyclic graph and add root vertices\n        self._graph = CyclicGraph()\n        self._graph.add_vertex(agent_vertex)\n        self._graph.add_vertex(goal_vertex)\n        self._graph.root_vertices = [agent_vertex, goal_vertex]\n\n        # Add sampled vertices to graph (no edges yet)\n        for v in V:\n            self._graph.add_vertex(v)\n\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Use parent's implementation including graph display\n        return super().set_display_info()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return vertices within max_radius of vertex.position in the graph.\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract and move agent along the path from agent to goal using connectivity map.\n        \"\"\"\n        start = self._graph.root_vertices[0]  # agent vertex\n        goal = self._graph.root_vertices[1]\n\n        path = []\n        current_vertex = start\n\n        # Traverse the connectivity dict to reconstruct path towards goal\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # No connectivity/path found to goal\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _connect_vertices(self, v1: Vertex, v2: Vertex) -> None:\n        \"\"\"\n        Add bidirectional edge between v1 and v2 if collision free.\n        \"\"\"\n        line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(v1, v2)\n            self._graph.add_edge(v2, v1)\n            self.key_frame()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        # Grow trees from both root vertices (agent and goal) trying to connect\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Separate vertex sets to track which belong to which tree\n        tree_agent: Set[Vertex] = set([agent_vertex])\n        tree_goal: Set[Vertex] = set([goal_vertex])\n\n        vertices = [v for v in self._graph.vertices if v not in self._graph.root_vertices]\n\n        # We'll iteratively try to connect sampled vertices to the existing trees\n        for v in vertices:\n            if time.time() - start_time > 30.0:\n                # Timeout exceeded, treat as no solution found\n                return\n\n            # Connect to agent tree\n            near_agent = [u for u in self._near(v) if u in tree_agent]\n            connected_to_agent = False\n            for near_v in near_agent:\n                self._connect_vertices(v, near_v)\n                if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n                    self._extract_path()\n                    return\n                connected_to_agent = True\n\n            # Connect to goal tree\n            near_goal = [u for u in self._near(v) if u in tree_goal]\n            for near_v in near_goal:\n                self._connect_vertices(v, near_v)\n                if self._graph.root_vertices[1] in self._graph.root_vertices[0].connectivity:\n                    self._extract_path()\n                    return\n\n            # Add vertex to respective trees if connected\n            if connected_to_agent:\n                tree_agent.add(v)\n            if any(u in tree_goal for u in near_goal):\n                tree_goal.add(v)\n\n        # Additional step: try connecting agent and goal roots directly if not connected yet\n        if time.time() - start_time > 30.0:\n            return\n\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(agent_vertex.position, goal_vertex.position)):\n            self._graph.add_edge(agent_vertex, goal_vertex)\n            self._graph.add_edge(goal_vertex, agent_vertex)\n            self.key_frame()\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-Based Path Planning Algorithm inspired by SPRM:\n    This algorithm improves upon the cyclic SPRM by integrating a heuristic bias in sampling towards the goal,\n    combined with a radius-based neighborhood search to dynamically connect sample vertices.\n    It adaptively connects new samples to nearby vertices from the existing graph only if the edge is valid,\n    reducing unnecessary edge additions and accelerating convergence.\n    Additionally, a time limit of 30 seconds is enforced to prevent excessive computation.\n    Upon finding connectivity to the goal, it extracts and executes the resulting path.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _goal_bias_ratio: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._goal_bias_ratio = 0.2  # 20% probability to sample goal directly\n\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_biased_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _get_biased_sample(self) -> Point:\n        # With probability _goal_bias_ratio, return goal position as sample\n        import torch\n        if torch.rand(1).item() < self._goal_bias_ratio:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path: List[Vertex] = []\n        visited = set()\n        # Follow connectivity towards goal until goal is reached\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # No path found\n                return\n            next_vertex = current_vertex.connectivity[goal]\n            # Prevent infinite loops\n            if next_vertex in visited:\n                return\n            visited.add(next_vertex)\n            path.append(next_vertex)\n            current_vertex = next_vertex\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [GraphMapDisplay(self._services, self._graph)]\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize connectivity for root vertices (agent and goal)\n        if goal_vertex not in agent_vertex.connectivity:\n            agent_vertex.connectivity[goal_vertex] = None\n        if agent_vertex not in goal_vertex.connectivity:\n            goal_vertex.connectivity[agent_vertex] = None\n\n        # We try to connect all vertices incrementally. Each iteration tries to connect newly added vertices\n        # to existing graph vertices within the max radius to build connectivity rapidly.\n        while True:\n            # Check time limit\n            if time.time() - start_time > 30.0:\n                # Route search timed out\n                return\n            \n            progress_made = False\n            # For all vertices in the graph (include agent and goal)\n            for v in list(self._graph.vertices):\n                neighbors = self._near(v)\n                for u in neighbors:\n                    if u is v:\n                        continue\n                    # Check if an edge already exists to avoid repeat checks\n                    if u in v.connectivity:\n                        continue\n                    # Validate if path from v to u is collision free\n                    line_seq = self._get_grid().get_line_sequence(v.position, u.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq):\n                        continue\n                    # Add undirected edge\n                    self._graph.add_edge(v, u)\n                    self._graph.add_edge(u, v)\n                    self.key_frame()\n\n                    # Check connectivity from agent to goal via connectivity dict\n                    # If path found, extract and return\n                    if goal_vertex in agent_vertex.connectivity:\n                        self._extract_path()\n                        return\n                    progress_made = True\n            \n            # If no new edges could be added in a complete pass, attempt to grow graph by adding a new sample vertex\n            if not progress_made:\n                q_rand = self._get_biased_sample()\n                q_near_vertices = self._near(Vertex(q_rand))  # get vertices near the sample\n                q_new = None\n\n                for q_near in q_near_vertices:\n                    v_candidate = self._get_new_vertex(q_near, q_rand, self._max_radius)\n                    # Check if valid position\n                    if not self._get_grid().is_agent_valid_pos(v_candidate.position):\n                        continue\n                    # Check edge validity\n                    line_seq = self._get_grid().get_line_sequence(q_near.position, v_candidate.position)\n                    if not self._get_grid().is_valid_line_sequence(line_seq):\n                        continue\n                    q_new = v_candidate\n                    break\n\n                if q_new is None:\n                    # Could not find a valid new vertex from sampled point, try next iteration\n                    continue\n\n                # Add new vertex to graph and connect edges\n                self._graph.add_vertex(q_new)\n                for nv in self._near(q_new):\n                    if nv is q_new:\n                        continue\n                    line_seq = self._get_grid().get_line_sequence(q_new.position, nv.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        self._graph.add_edge(q_new, nv)\n                        self._graph.add_edge(nv, q_new)\n                        self.key_frame()\n                        # Check connectivity\n                        if goal_vertex in agent_vertex.connectivity:\n                            self._extract_path()\n                            return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This implementation is an improved path planning algorithm based on RRT, called RRT-Connect.\n    It grows two trees simultaneously: one from the start and one from the goal,\n    attempting to connect them to find a solution faster.\n    This bidirectional approach generally improves exploration speed and reduces time to find a path.\n    The algorithm alternates extending each tree toward sampled points and tries to connect \n    the new vertex to the opposite tree.\n    If a connection is made, it reconstructs the path from start to goal.\n    A 30 second timeout aborts the search if no path found.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on RRT* with goal biasing and batch processing of samples.\nThe main improvements over standard RRT* are:\n1) Goal biasing: with a certain probability, the sampled point is directly the goal position,\n   which accelerates convergence towards the goal.\n2) Batch sampling: samples multiple points per iteration (batch size) to increase exploration per iteration,\n   improving sampling efficiency.\n3) Early stopping with a timeout of 30 seconds to treat route search as not found if it takes too long.\nThese improvements aim to speed up the time to find a feasible, near-optimal path while preserving\nthe rewiring optimization of RRT*.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Add member variable for batch size and goal bias probability\n        self._batch_size: int = 5\n        self._goal_bias: float = 0.1\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Modified random sample to support goal biasing.\n        With self._goal_bias probability, returns the goal position to focus search around goal.\n        Else returns a uniformly random valid sample.\n        \"\"\"\n        import numpy as np\n        grid = self._get_grid()\n        if np.random.random() < self._goal_bias:\n            return grid.goal.position\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension: int = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Timeout check: terminate search if exceeds 30 seconds\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30:\n                # Timeout reached, no path found\n                break\n\n            batch_samples: List[Point] = []\n            # Sample multiple points in the batch\n            for _ in range(self._batch_size):\n                q_sample = self._get_random_sample()\n                batch_samples.append(q_sample)\n\n            for q_sample in batch_samples:\n\n                # Find nearest vertex in the tree to the sample\n                q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n                if q_nearest.position == q_sample:\n                    continue\n\n                # Generate new vertex moving towards sample but limitted by max_dist\n                q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n                # Check if path to q_new is collision free\n                line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                # Compute radius for neighbors using RRT* formula\n                card_v = torch.tensor(float(self._graph.size))\n                log_card_v = torch.log(card_v)\n                radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n\n                Q_near: List[Vertex] = self._graph.get_vertices_within_radius(\n                    [self._graph.root_vertex_start], q_new.position, radius)\n\n                # Choose best parent (lowest cost) for q_new\n                q_min = q_nearest\n                c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n                for q_near in Q_near:\n                    near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if near_new_collision_free and cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n                # Update cost and add edge q_min -> q_new\n                child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n                q_new.cost = q_min.cost + child_parent_dist\n                self._graph.add_edge(q_min, q_new)\n\n                # Rewire nearby vertices if q_new provides a lower cost path\n                for q_near in Q_near:\n                    near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                        self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if near_new_collision_free and cost_new_to_near < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n                # Check if q_new reached goal radius\n                if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                    self._extract_path(q_new)\n                    return\n\n            # Key frame after processing batch of samples\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version inspired by RRT*. \n    It incorporates goal biasing to focus sampling towards the goal and uses a dynamically decreasing max_dist to speed up convergence. \n    Additionally, it implements early termination if a feasible path is found and optimizes radius calculation for rewiring.\n    A timeout of 30 seconds is enforced to terminate the search if no path is found within that time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variables\n        self._goal_bias_prob = 0.2  # probability to sample goal directly for faster goal convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        min_max_dist: float = 1.0\n        max_iterations: int = 10000\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension: int = 2\n        timeout_seconds: float = 30.0\n\n        start_time = time.time()\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > timeout_seconds:\n                # Terminate if search time exceeds 30 seconds without success\n                break\n\n            # Goal biasing: sample goal with some probability\n            if np.random.rand() < self._goal_bias_prob:\n                q_sample: Point = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n            \n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision for path between nearest and new\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1/dimension)), max_radius)\n\n            # Find near vertices for rewiring\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min: Vertex = q_nearest\n            c_min: float = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Choose best parent with minimal cost that is collision free\n            for q_near in Q_near:\n                line_seq_near_new = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_near_new):\n                    continue\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            dist_to_parent = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + dist_to_parent\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire the tree within radius\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                line_seq_new_near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq_new_near):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if cost_new_to_near < q_near.cost:\n                    # Remove old edge\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    # Add new edge and update cost\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n\n            # Decrease max_dist gradually to allow finer resolution as tree grows\n            max_dist = max(min_max_dist, max_dist * 0.995)\n\n        # If reached here, path not found within time or iterations (do nothing)\n        # Optionally keyframe for the final state\n        self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This PathPlanning algorithm improves upon the SPRM baseline by incorporating an incremental RRT* inspired strategy.\nIt efficiently grows a tree from the agent towards the goal by sampling points and connecting them to the nearest\nvertex with edge rewiring for cost optimization, improving path quality and time efficiency. The algorithm terminates\neither upon finding a valid path from the agent to the goal or after a 30-second timeout. It integrates the given \ngraph structure and leverages existing helper functions (e.g., sampling, movement, connectivity) to maintain compatibility \nwith the framework. Key features include nearest neighbor search, collision-checked incremental growth, and path extraction.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: 'CyclicGraph'\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        # Sample initial vertices before algorithm starts\n        V: List[Vertex] = []\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V\n        )\n        self._graph.edges_removable = True  # Allow rewiring/removal for improved paths\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        agent_vertex: Vertex = self._graph.root_vertices[0]\n        goal_vertex: Vertex = self._graph.root_vertices[1]\n\n        # Initialize tree with start vertex cost = 0\n        agent_vertex.cost = 0.0\n        # Mark initial connectivity empty\n        agent_vertex.connectivity = {}\n\n        # Function to find nearest vertex in graph to a sample point\n        def nearest_vertex(point: Point) -> Vertex:\n            min_dist = float('inf')\n            nearest = None\n            for v in self._graph.vertices:\n                dist = torch.norm(point.to_tensor() - v.position.to_tensor())\n                if dist < min_dist:\n                    min_dist = dist\n                    nearest = v\n            return nearest\n\n        # Function to find vertices near given vertex within radius\n        def near_vertices(vertex: Vertex, radius: float) -> List[Vertex]:\n            vertices_near = []\n            for v in self._graph.vertices:\n                if v is vertex:\n                    continue\n                dist = torch.norm(v.position.to_tensor() - vertex.position.to_tensor())\n                if dist <= radius:\n                    vertices_near.append(v)\n            return vertices_near\n\n        # Initialize connectivity structure if not present\n        for v in self._graph.vertices:\n            if not hasattr(v, 'cost'):\n                v.cost = float('inf')\n            if not hasattr(v, 'parent'):\n                v.parent = None\n            if not hasattr(v, 'connectivity') or v.connectivity is None:\n                v.connectivity = {}\n\n        # Main RRT*-style incremental construction\n        # Limit iterations for safety\n        max_iterations = 5000\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > 30.0:\n                # Path search timed out\n                return\n\n            q_rand: Point = self._get_random_sample()\n            q_near: Vertex = nearest_vertex(q_rand)\n            max_dist = self._max_radius\n\n            q_new_vertex = self._get_new_vertex(q_near, q_rand, max_dist)\n\n            # Check if q_new_vertex position is valid for agent\n            if not self._get_grid().is_agent_valid_pos(q_new_vertex.position):\n                continue\n\n            # Check collision from q_near to q_new_vertex\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Add q_new_vertex to graph vertices if not present\n            if q_new_vertex not in self._graph.vertices:\n                self._graph.vertices.append(q_new_vertex)\n\n            # Connect q_new_vertex initially to q_near\n            q_new_vertex.cost = q_near.cost + torch.norm(q_new_vertex.position.to_tensor() - q_near.position.to_tensor())\n            q_new_vertex.parent = q_near\n            self._graph.add_edge(q_near, q_new_vertex)\n            self._graph.add_edge(q_new_vertex, q_near)\n            self.key_frame()\n\n            # Rewire near vertices around q_new_vertex to try and improve cost\n            near_vs = near_vertices(q_new_vertex, self._max_radius)\n            for v_near in near_vs:\n                if v_near is q_near:\n                    continue\n\n                potential_cost = q_new_vertex.cost + torch.norm(q_new_vertex.position.to_tensor() - v_near.position.to_tensor())\n                if potential_cost < v_near.cost:\n                    seq = self._get_grid().get_line_sequence(q_new_vertex.position, v_near.position)\n                    if self._get_grid().is_valid_line_sequence(seq):\n                        # Remove old edge from v_near.parent to v_near if exists\n                        old_parent = v_near.parent\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, v_near)\n                            self._graph.remove_edge(v_near, old_parent)\n\n                        # Add new edge q_new_vertex <-> v_near\n                        self._graph.add_edge(q_new_vertex, v_near)\n                        self._graph.add_edge(v_near, q_new_vertex)\n\n                        v_near.parent = q_new_vertex\n                        v_near.cost = potential_cost\n                        self.key_frame()\n\n            # Check if q_new_vertex can connect directly to goal\n            dist_to_goal = torch.norm(q_new_vertex.position.to_tensor() - goal_vertex.position.to_tensor())\n            if dist_to_goal <= self._max_radius:\n                seq_goal = self._get_grid().get_line_sequence(q_new_vertex.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(seq_goal):\n                    # Connect q_new_vertex and goal\n                    self._graph.add_edge(q_new_vertex, goal_vertex)\n                    self._graph.add_edge(goal_vertex, q_new_vertex)\n                    goal_vertex.parent = q_new_vertex\n                    goal_vertex.cost = q_new_vertex.cost + dist_to_goal\n                    self.key_frame()\n\n                    # Then extract and follow path\n                    self._extract_path_rrt_star(agent_vertex, goal_vertex)\n                    return\n\n        # If max iterations exhausted without path, simply return (no path found)\n        return\n\n    def _extract_path_rrt_star(self, start_vertex: Vertex, goal_vertex: Vertex) -> None:\n        # Extract path by following parents from goal to start\n        path_vertices = []\n        current = goal_vertex\n        while current is not start_vertex:\n            path_vertices.append(current.position)\n            current = current.parent\n            if current is None:\n                # No path found\n                return\n        path_vertices.append(start_vertex.position)\n        path_vertices.reverse()\n\n        # Move agent along the extracted path\n        for pos in path_vertices[1:]:\n            self.move_agent(pos)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-based Path Planning Algorithm based on SPRM with incorporated goal biasing \n    and dynamic radius shrinking for faster convergence and exploration. \n\n    The backbone idea is a cyclic graph connecting sampled vertices from agent start to goal.\n    The improvement focuses on:\n    - Goal bias sampling to guide exploration towards the goal more frequently.\n    - Dynamic shrinking of connection radius to reduce unnecessary connectivity checks over time.\n    - Early stopping if no path is found within 30 seconds.\n    \n    These improvements help reduce the time complexity of building the graph and finding a valid path.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Reuse SPRM sampling and graph construction\n        self._V_size = 200\n        self._initial_max_radius = 15.0\n        self._max_radius = self._initial_max_radius\n        self._goal_bias_prob = 0.2  # 20% probability sample towards the goal to accelerate convergence\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling: with probability self._goal_bias_prob, return the goal position to guide sampling\n        from random import random\n        if random() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        # Use current max radius that can shrink dynamically during execution\n        return self._graph.get_vertices_within_radius(self._graph.root_vertices, vertex.position, self._max_radius)\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            # Defensive: If no connectivity to goal is found, break loop to avoid infinite loop\n            if goal not in current_vertex.connectivity:\n                return\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _shrink_radius(self, iteration: int, max_iterations: int) -> None:\n        # Dynamically shrink radius linearly from initial_max_radius to half over iterations for efficiency\n        factor = max(0.5, 1.0 - iteration / max_iterations)\n        self._max_radius = self._initial_max_radius * factor\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_duration_seconds = 30.0\n\n        agent_vertex, goal_vertex = self._graph.root_vertices\n        max_iterations = self._V_size * 2  # heuristic for max iterations to allow radius shrink\n\n        # Use a work queue for vertices to expand edges from, initially start and goal\n        work_set = set(self._graph.root_vertices)\n        visited = set()\n\n        for iteration in range(max_iterations):\n            if time.time() - start_time > max_duration_seconds:\n                # Timeout exceeded - no path found\n                return\n\n            self._shrink_radius(iteration, max_iterations)\n\n            new_vertices = set()\n\n            # For vertices in current work set, try to connect them to neighbors\n            for v in work_set:\n                if v in visited:\n                    continue\n                U = self._near(v)\n                for u in U:\n                    if v is not u:\n                        line_seq = self._get_grid().get_line_sequence(u.position, v.position)\n                        if self._get_grid().is_valid_line_sequence(line_seq):\n                            # Add edges both ways for cyclic graph connectivity\n                            previously_connected = u in v.connectivity\n                            self._graph.add_edge(v, u)\n                            self._graph.add_edge(u, v)\n                            if not previously_connected:\n                                new_vertices.add(u)\n                            self.key_frame()\n\n                visited.add(v)\n\n            # Add newly connected vertices to work set to expand from\n            work_set = new_vertices\n\n            # Check if path connectivity from agent to goal exists\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Description:\n    This algorithm implements an improved RRT* variant with time-budgeted search and guided sampling.\n    It integrates a goal-biased sampling strategy to prioritize samples near the goal, accelerating convergence.\n    Additionally, it limits execution to 30 seconds to ensure timely termination.\n    The core optimization remains RRT*'s rewiring and incremental search for minimum-cost paths, \n    but sampling distribution and early timeout improve practical runtime efficiency.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        goal_bias_prob: float = 0.2  # 20% chance to bias sample towards goal\n\n        start_time = time.time()\n\n        goal_point: Point = self._get_grid().goal.position\n        start_vertex: Vertex = self._graph.root_vertex_start\n\n        for i in range(iterations):\n\n            # Timeout check (30 seconds)\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Terminate search as not found\n                break\n\n            # Goal biased sampling\n            if np.random.rand() < goal_bias_prob:\n                q_sample: Point = goal_point\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose the best parent for q_new minimizing cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path through q_new possible\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved path planner based on RRT, incorporating elements from RRT-Connect to enhance exploration efficiency.\n    It maintains two trees growing simultaneously: one from the start and one from the goal. \n    At each iteration, it attempts to extend one tree toward a random sample and then tries to connect\n    the other tree toward this new vertex, significantly accelerating convergence to a complete path.\n    Additionally, a timeout of 30 seconds is enforced to avoid excessive computation.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        self._graph = self._graph_start  # For display purposes, default to start graph\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling: 5% goal bias for faster convergence\n        goal = self._get_grid().goal.position\n        if np.random.rand() < 0.05:\n            if self._get_grid().is_agent_valid_pos(goal):\n                return goal\n        # Otherwise uniform sampling\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extend(self, tree: Forest, q_target: Point, max_dist: float) -> (Optional[Vertex], bool):\n        \"\"\"\n        Attempts to extend the given tree towards q_target by max_dist.\n        Returns the new vertex if extension successful; else None.\n        Returns also a boolean indicating if reached target exactly.\n        \"\"\"\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return None, True  # already at target\n\n        q_new: Vertex = self._get_new_vertex(q_near, q_target, max_dist)\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None, False\n\n        tree.add_edge(q_near, q_new)\n        return q_new, q_new.position == q_target\n\n    def _connect(self, tree: Forest, q_target: Point, max_dist: float) -> Optional[Vertex]:\n        \"\"\"\n        Try to extend the tree toward q_target until cannot extend further.\n        Returns the last vertex added (closest to target), or None if no extension possible.\n        \"\"\"\n        q_new = None\n        reached = False\n        while not reached:\n            q_new_candidate, reached = self._extend(tree, q_target, max_dist)\n            if q_new_candidate is None:\n                break\n            q_new = q_new_candidate\n        return q_new\n\n    def _extract_path(self, vertex_start_tree: Vertex, vertex_goal_tree: Vertex) -> None:\n        \"\"\"\n        Extract the full path by tracing back from both trees to their roots and concatenating.\n        Moves the agent along the path with animation frames.\n        \"\"\"\n        path_start: List[Vertex] = [vertex_start_tree]\n        while len(path_start[-1].parents) != 0:\n            parent = next(iter(path_start[-1].parents))\n            path_start.append(parent)\n        path_start.reverse()\n\n        path_goal: List[Vertex] = [vertex_goal_tree]\n        while len(path_goal[-1].parents) != 0:\n            parent = next(iter(path_goal[-1].parents))\n            path_goal.append(parent)\n\n        full_path = path_start + path_goal  # vertex_start_tree and vertex_goal_tree are connected by edge\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        displays = super().set_display_info()\n        # Update displays to show both trees\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        displays = [GraphMapDisplay(self._services, self._graph_start), GraphMapDisplay(self._services, self._graph_goal)] + displays\n        return displays\n\n    def _find_path_internal(self) -> None:\n        max_dist = 10.0\n        max_time_seconds = 30.0\n        start_time = time.time()\n\n        # Alternate growth between two trees\n        for i in range(100000):  # high number, but actual exit by timeout or solution\n            if time.time() - start_time > max_time_seconds:\n                # Timeout, treat as no path found\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Extend start tree towards sample\n            q_new_start, reached_start = self._extend(self._graph_start, q_sample, max_dist)\n            if q_new_start is None:\n                continue\n\n            # Try to connect goal tree toward new vertex in start tree\n            q_new_goal = self._connect(self._graph_goal, q_new_start.position, max_dist)\n            if q_new_goal is not None:\n                # Check if connected directly\n                dist_connect = torch.norm(q_new_goal.position.to_tensor() - q_new_start.position.to_tensor())\n                if dist_connect <= max_dist and self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)):\n                    # Add connection between two trees to merge the paths\n                    self._graph_start.add_edge(q_new_start, q_new_goal)\n                    # Extract and animate path\n                    self._extract_path(q_new_start, q_new_goal)\n                    break\n\n            # Swap trees for next iteration\n            self._graph_start, self._graph_goal = self._graph_goal, self._graph_start\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm implements an Improved RRT* variant with goal-biased sampling \n    and early pruning for faster convergence on high-quality paths. It biases sampling towards the goal with \n    a defined probability to quickly approach the goal region while maintaining uniform exploration otherwise.\n    The rewiring radius calculation and rewiring process are kept from RRT*, but the algorithm stops if path \n    is not found within 30 seconds to avoid excessive runtimes.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # We keep the graph and goal_vertex for extended use\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex.cost = float('inf')\n        # already initialized self._graph in super().__init__\n        # No structural change, but update graph root/goal\n        # start_vertex already initialized in base __init__\n        # Add goal to graph explicitly (not connected yet)\n        self._graph.add_vertex(self._goal_vertex)\n        self._goal_sample_rate = 0.2  # 20% goal bias\n\n        self._init_displays()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        \n        start_time: float = time.time()\n\n        for i in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:\n                # Time exceeded 30 seconds, path not found\n                break\n\n            # Goal-biased sampling:\n            if np.random.rand() < self._goal_sample_rate:\n                q_sample: Point = self._goal_vertex.position\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost + feasible edge\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    continue\n                cost_through_q_near = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if cost_through_q_near < c_min:\n                    q_min = q_near\n                    c_min = cost_through_q_near\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for better paths\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    continue\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n\n                if cost_new_to_near < q_near.cost:\n                    # Remove old edge(s)\n                    old_parent = None\n                    for parent in q_near.parents:\n                        old_parent = parent\n                        break\n                    if old_parent is not None:\n                        self._graph.remove_edge(old_parent, q_near)\n                    # Add new better edge\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex is inside goal radius to finalize path\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new directly to goal vertex if possible and better\n                goal_dist = torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)):\n                    candidate_cost = q_new.cost + goal_dist\n                    if candidate_cost < self._goal_vertex.cost:\n                        # Remove old edges to goal if any\n                        for parent in self._goal_vertex.parents:\n                            self._graph.remove_edge(parent, self._goal_vertex)\n                        self._goal_vertex.cost = candidate_cost\n                        self._graph.add_edge(q_new, self._goal_vertex)\n\n                if self._goal_vertex.cost < float('inf'):\n                    self._extract_path(self._goal_vertex)\n                    break\n\n            self.key_frame()\n\n    def _extract_path(self, final_vertex: Vertex) -> None:\n        path: List[Vertex] = [final_vertex]\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm improves on the reference SPRM by utilizing a Rapidly-exploring Random Graph (RRG)\n    inspired method with pruning and rewiring that promotes faster convergence to the goal. \n    Instead of only adding edges between sampled vertices near roots, it incrementally samples random states, \n    adds new vertices towards farthest samples within a maximum extension radius, connects them thoughtfully \n    to near vertices to ensure a connected roadmap, and rewires edges to optimize paths. This yields \n    better graph connectivity and shorter paths on average. The search terminates if a path to the goal \n    is found within a 30-second timeout. The approach balances exploration and informed local connection \n    to improve runtime compared to the cyclic graph approach.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    from time import time\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow edge rewiring\n        self._init_displays()\n    \n    def _near(self, vertex: Vertex, radius: float) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, radius)\n    \n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n    \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new, store_connectivity=True)\n    \n    def _cost(self, v1: Vertex, v2: Vertex) -> float:\n        return torch.norm(v1.position.to_tensor() - v2.position.to_tensor()).item()\n    \n    def _choose_parent(self, new_vertex: Vertex, neighbors: List[Vertex]) -> Optional[Vertex]:\n        min_cost = float('inf')\n        best_parent: Optional[Vertex] = None\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(neighbor.position, new_vertex.position)):\n                continue\n            # Cost to come to neighbor plus edge to new_vertex\n            cost = self._graph.get_cost_to_root(neighbor) + self._cost(neighbor, new_vertex)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent\n    \n    def _rewire(self, new_vertex: Vertex, neighbors: List[Vertex]) -> None:\n        for neighbor in neighbors:\n            if neighbor is new_vertex:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(new_vertex.position, neighbor.position)):\n                continue\n            current_cost = self._graph.get_cost_to_root(neighbor)\n            new_cost = self._graph.get_cost_to_root(new_vertex) + self._cost(new_vertex, neighbor)\n            if new_cost < current_cost:\n                # Rewire neighbor's parent to new_vertex\n                old_parent = None\n                # Find old parent - vertex from which neighbor is reachable with min cost\n                for v in self._graph.vertices:\n                    if neighbor in v.connectivity and v.connectivity[neighbor] == neighbor:\n                        old_parent = v\n                        break\n                # Remove old edge if exists\n                if old_parent:\n                    self._graph.remove_edge(old_parent, neighbor)\n                self._graph.add_edge(new_vertex, neighbor)\n                self._graph.add_edge(neighbor, new_vertex)\n                self.key_frame()\n    \n    def _extract_path(self):\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n        if goal not in agent.connectivity:\n            return  # No path yet\n        current_vertex = agent\n        path = []\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    # Overridden #\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n    \n    def _find_path_internal(self) -> None:\n        start_time = self.time()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize graph connectivity\n        self._graph.clear_connectivity()\n        self._graph.add_vertex(agent_vertex)\n        self._graph.add_vertex(goal_vertex)\n        for v in self._graph.vertices:\n            self._graph.add_vertex(v)\n        \n        # Start with the agent vertex connected to itself (cost 0)\n        # We define cost structure in graph for shortest path\n\n        # Main loop, iteratively expand graph\n        for iteration in range(10000):  # large upper bound, but limited by time\n            if self.time() - start_time > 30:\n                # Timeout, treat as route not found\n                break\n            \n            q_rand_point = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(self._graph.vertices, q_rand_point)\n            q_new = self._get_new_vertex(q_near, q_rand_point, self._max_radius)\n            \n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            \n            # Add new vertex and connect optimally\n            self._graph.add_vertex(q_new)\n            \n            neighbors = self._near(q_new, self._max_radius)\n            \n            best_parent = self._choose_parent(q_new, neighbors)\n            if best_parent is None:\n                # Fallback: connect to nearest q_near if possible\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    best_parent = q_near\n                else:\n                    # Unable to connect new vertex, discard\n                    self._graph.remove_vertex(q_new)\n                    continue\n            \n            self._graph.add_edge(best_parent, q_new)\n            self._graph.add_edge(q_new, best_parent)\n            self.key_frame()\n            \n            self._rewire(q_new, neighbors)\n            \n            # Check if goal is reachable from agent (i.e. connectivity exists)\n            if goal_vertex in agent_vertex.connectivity:\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* with the following enhancements:\n    - Implements a goal biasing strategy to sample towards the goal with a given probability,\n      improving convergence speed by focusing exploration near the goal region.\n    - Adds a time limit (30 seconds) to stop the search early if no path is found, avoiding costly endless searches.\n    - Uses existing optimization (rewiring) from RRT* for path cost improvement.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        goal_sample_rate = 0.2  # 20% chance to sample the goal directly for goal biasing\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Stop search after 30 seconds if no path found\n                break\n\n            # Goal biased sampling\n            if np.random.rand() < goal_sample_rate:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check path valid from nearest to new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better cost path found\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of the RRT by integrating the RRT-Connect heuristic.\n    It grows two trees simultaneously: one from the start and one from the goal. \n    Each iteration attempts to extend one tree toward a random sample and then tries \n    to connect the other tree to the newly added node, improving connection speed.\n    This bidirectional growth reduces exploration time. \n    A 30-second timeout stops the search if no path is found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n    _max_dist: float\n    _timeout_secs: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._max_dist = 10\n        self._timeout_secs = 30.0\n\n        start_v = Vertex(self._get_grid().agent.position)\n        goal_v = Vertex(self._get_grid().goal.position)\n        # Initialize two forests for bidirectional search\n        self._graph_start = gen_forest(self._services, start_v, goal_v, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal = gen_forest(self._services, goal_v, start_v, [])\n        self._graph_goal.edges_removable = False\n\n        # Use displays (combined from both graphs)\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [\n            # Assuming GraphMapDisplay can accept multiple graphs or separate displays can be combined\n            # Using start tree display and goal tree display combined\n            GraphMapDisplay(self._services, self._graph_start),\n            GraphMapDisplay(self._services, self._graph_goal)\n        ]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm = torch.norm(dir)\n        if norm <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _extend(self, tree: Forest, q_target: Point) -> Optional[Vertex]:\n        \"\"\"\n        Attempts to extend the tree towards q_target by max_dist.\n        Returns the new vertex if extension is successful (connected and valid), else None.\n        \"\"\"\n        q_near = tree.get_nearest_vertex(tree.get_all_vertices(), q_target)\n        if q_near.position == q_target:\n            return None\n\n        q_new = self._get_new_vertex(q_near, q_target, self._max_dist)\n\n        # Check path validity between q_near and q_new\n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        tree.add_edge(q_near, q_new)\n        return q_new\n\n    def _connect(self, tree: Forest, q_target: Point) -> Optional[Vertex]:\n        \"\"\"\n        Repeatedly tries to extend the tree toward q_target until it cannot extend further or reaches q_target.\n        Returns the last vertex added or None if no extension was possible.\n        \"\"\"\n        q_new = None\n        while True:\n            next_vertex = self._extend(tree, q_target)\n            if next_vertex is None:\n                return q_new\n            q_new = next_vertex\n            if q_new.position == q_target:\n                return q_new\n\n    def _extract_bidirectional_path(self, connect_start: Vertex, connect_goal: Vertex) -> None:\n        \"\"\"\n        Extracts the full path from start to goal by concatenating paths from two trees \n        at the connection vertices. Moves the agent along the path with keyframes.\n        \"\"\"\n        path_start = [connect_start]\n        # Walk up parents from connect_start to root of start tree\n        while len(path_start[-1].parents) != 0:\n            path_start.append(path_start[-1].parents[0])\n        path_start.reverse()  # from start to connection point\n\n        path_goal = [connect_goal]\n        # Walk up parents from connect_goal to root of goal tree\n        while len(path_goal[-1].parents) != 0:\n            path_goal.append(path_goal[-1].parents[0])\n        # path_goal is from goal toward connection point\n\n        # Remove duplicate connection vertex from one side to avoid repeated point\n        path_goal = path_goal[:-1]\n\n        full_path = path_start + list(reversed(path_goal))  # complete path start to goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        while True:\n            elapsed = time.time() - start_time\n            if elapsed > self._timeout_secs:\n                # Timeout reached - no path found\n                if self.testing is not None:\n                    self.testing.key_frame(message=\"Path not found: Timeout reached\")\n                break\n\n            # Sample random point\n            q_rand = self._get_random_sample()\n\n            # Extend start tree towards q_rand\n            q_new_start = self._extend(self._graph_start, q_rand)\n            if q_new_start is None:\n                # No extension on start tree, continue next iteration\n                self.key_frame()\n                continue\n\n            # Try connecting goal tree to q_new_start\n            q_new_goal = self._connect(self._graph_goal, q_new_start.position)\n\n            if q_new_goal is not None and q_new_goal.position == q_new_start.position:\n                # Trees connected\n                self._extract_bidirectional_path(q_new_start, q_new_goal)\n                break\n\n            # Swap roles: extend goal tree towards random sample and try connect start tree\n            q_rand_2 = self._get_random_sample()\n            q_new_goal_2 = self._extend(self._graph_goal, q_rand_2)\n            if q_new_goal_2 is None:\n                self.key_frame()\n                continue\n\n            q_new_start_2 = self._connect(self._graph_start, q_new_goal_2.position)\n\n            if q_new_start_2 is not None and q_new_start_2.position == q_new_goal_2.position:\n                self._extract_bidirectional_path(q_new_start_2, q_new_goal_2)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Implementation of an improved sample-based planner inspired by RRT-Connect, \n    enhanced with informed sampling to accelerate convergence. \n    The algorithm uses an ellipsoidal sampling region based on the current best path length \n    to focus samples closer to the optimal path, reducing wasted exploration.\n    It also incorporates a 30-second timeout to terminate the search if no path is found in time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _best_path_length: float\n    _start_time: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._best_path_length = float(\"inf\")\n        self._start_time = 0.0\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"\n        Generates a random sample within an ellipsoidal region defined by the start and goal positions \n        and the current best path length. If no best path found yet, sample uniformly.\n        \"\"\"\n        if self._best_path_length == float(\"inf\"):\n            # No informed path yet, sample uniformly\n            return self._get_random_sample()\n\n        start_pos = self._graph.root_vertices[0].position\n        goal_pos = self._graph.root_vertices[-1].position\n\n        c_min = self._heuristic_distance(start_pos, goal_pos)\n        if c_min == 0.0:\n            # Start and goal at same position\n            return start_pos\n\n        # Rotation matrix from unit vector on x-axis to the vector from start to goal\n        unit_vec = (goal_pos.to_tensor() - start_pos.to_tensor()) / c_min\n\n        # Sampling inside unit ball\n        while True:\n            # Sample in unit ball using normal distribution and normalize\n            x = np.random.normal(0, 1)\n            y = np.random.normal(0, 1)\n            z = None\n            if start_pos.position.dimension == 3:\n                z = np.random.normal(0, 1)\n            if start_pos.position.dimension == 2:\n                norm = math.sqrt(x * x + y * y)\n                if norm == 0:\n                    continue\n                x, y = x / norm, y / norm\n                r = np.random.random() ** (1 / 2)\n                ball_sample = np.array([r * x, r * y])\n            else:\n                norm = math.sqrt(x * x + y * y + z * z)\n                if norm == 0:\n                    continue\n                x, y, z = x / norm, y / norm, z / norm\n                r = np.random.random() ** (1 / 3)\n                ball_sample = np.array([r * x, r * y, r * z])\n\n            # Length of the ellipse axes\n            a = self._best_path_length / 2.0\n            if a < c_min / 2.0:\n                # Numerical safety\n                a = c_min / 2.0 \n\n            b_sq = a ** 2 - (c_min / 2.0) ** 2\n            if b_sq < 0:\n                b_sq = 0\n            b = math.sqrt(b_sq)\n\n            if start_pos.position.dimension == 2:\n                # Ellipse sample in 2D: (x, y)\n                # Transform ball_sample: scale x by a, y by b\n                sample_ellipse = np.array([ball_sample[0] * a, ball_sample[1] * b])\n                # Rotate sample_ellipse to align with start-goal vector\n                rot_mat = np.array([[unit_vec[0], -unit_vec[1]], [unit_vec[1], unit_vec[0]]])  # 2D rotation matrix\n                rotated = rot_mat.dot(sample_ellipse)\n                sample_point = Point.from_tensor(torch.tensor(rotated) + (start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n            else:\n                # Ellipse sample in 3D: (x, y, z)\n                # In 3D, use prolate spheroid. Axes: a along direction, b in perpendicular planes.\n                # Construct arbitrary orthonormal basis\n                x_dir = unit_vec.numpy()\n                # Create vectors orthogonal to x_dir (Gram-Schmidt)\n                if abs(x_dir[0]) > 1e-6 or abs(x_dir[1]) > 1e-6:\n                    temp = np.array([x_dir[1], -x_dir[0], 0])\n                else:\n                    temp = np.array([0, x_dir[2], -x_dir[1]])\n                temp /= np.linalg.norm(temp)\n                z_dir = np.cross(x_dir, temp)\n                rot_mat_3d = np.vstack([x_dir, temp, z_dir]).T\n                sample_ellipse = np.array([ball_sample[0] * a, ball_sample[1] * b, ball_sample[2] * b])\n                rotated = rot_mat_3d.dot(sample_ellipse)\n                sample_point = Point.from_tensor(torch.tensor(rotated) + (start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self):\n        # Trace back from connection point to both roots and concatenate\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        # Move agent through path points and mark key frames\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        for i in range(self._iterations):\n            if (time.time() - self._start_time) > 30.0:\n                # Timeout condition: stop search and treat as not found\n                break\n\n            q_rand: Point = self._get_informed_sample()\n\n            extend_res = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_res != 'trapped':\n                self._extension_target = self._q_new\n                # Update best path length estimate by heuristic distance from start to this sample plus from sample to goal\n                start_pos = self._graph.root_vertices[0].position\n                goal_pos = self._graph.root_vertices[-1].position\n                current_path_length = self._heuristic_distance(start_pos, self._q_new.position) + self._heuristic_distance(self._q_new.position, goal_pos)\n                if current_path_length < self._best_path_length:\n                    self._best_path_length = current_path_length\n\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This is an improved sample-based path planning algorithm inspired by SPRM but enhanced to reduce planning time by using a batch-incremental graph expansion with efficient pruning. Instead of blindly connecting all near neighbors immediately, it tries to extend the tree from the start towards the goal like an improved Rapidly-exploring Random Graph (RRG). The vertices are incrementally sampled and connected only to vertices within an adaptive radius, considering collision-free edges. The search aborts after 30 seconds if no path is found. This approach reduces unnecessary edge checks and leverages proximity and incremental graph growth for faster convergence.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # To speed up connectivity checks, maintain a set of connected vertices from start\n        connected_set = set([agent])\n        frontier = [agent]\n\n        # Adaptive radius shrinking for connection attempts (optional heuristic)\n        # Avoid large radius initially to limit edge checks, then expand gradually:\n        radius = self._max_radius * 0.5\n\n        # Store vertices separately for quick access\n        all_vertices = self._graph.vertices\n\n        # Helper local function to find neighbors for a given vertex within radius\n        def near_vertices(vertex: Vertex, rad: float) -> List[Vertex]:\n            return self._graph.get_vertices_within_radius(all_vertices, vertex.position, rad)\n\n        # Helper to safely add edge both ways if valid\n        def try_connect(v1: Vertex, v2: Vertex) -> bool:\n            if v1 is v2:\n                return False\n            line_seq = self._get_grid().get_line_sequence(v1.position, v2.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                self._graph.add_edge(v1, v2)\n                self._graph.add_edge(v2, v1)\n                return True\n            return False\n\n        # Batch incremental method: iteratively grow the connected component from start vertex\n        while True:\n            # Check timeout of 30 seconds\n            if time() - start_time > 30:\n                # Timeout, no path found\n                return\n\n            new_frontier = []\n            for current_vertex in frontier:\n                neighbors = near_vertices(current_vertex, radius)\n                # Connect current vertex to neighbors if possible, and add newly connected to frontier\n                for neighbor in neighbors:\n                    if neighbor not in connected_set:\n                        if try_connect(current_vertex, neighbor):\n                            connected_set.add(neighbor)\n                            new_frontier.append(neighbor)\n                            self.key_frame()\n                            # If goal is connected, extract and move agent\n                            if goal in connected_set:\n                                self._extract_path()\n                                return\n            if not new_frontier:\n                # Increase radius gradually to try more connections\n                radius = min(radius * 1.5, self._max_radius)\n                # If radius hits max and no new frontier, try to connect all remaining vertices to goal or stop if stuck\n                if radius >= self._max_radius:\n                    # Try direct connections from all connected vertices to goal\n                    connected_list = list(connected_set)\n                    for v in connected_list:\n                        if goal not in connected_set:\n                            if try_connect(v, goal):\n                                connected_set.add(goal)\n                                self.key_frame()\n                                self._extract_path()\n                                return\n                    # No path found after exhaustive try\n                    return\n            frontier = new_frontier\n\n    def _extract_path(self):\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planner based on RRT* with an adaptive informed sampling strategy (similar to Informed RRT*).\n    After an initial feasible path is found, the sampling space is restricted to an ellipsoidal region containing only points that can potentially improve the current best path.\n    This reduces unnecessary expansion and rewiring outside the promising region, improving time efficiency.\n    The algorithm also stops if path search exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _best_cost: Optional[float]\n    _max_time_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._best_cost = None\n        self._max_time_seconds = 30.0  # Max time for planning in seconds\n\n        self._init_displays()\n\n    def _set_ellipse_sampling_region(self, start: Point, goal: Point, c_best: float) -> None:\n        \"\"\"\n        Calculate ellipsoidal region parameters for Informed RRT* sampling.\n        \"\"\"\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        c_min = torch.norm(start_tensor - goal_tensor).item()\n\n        # If c_best is None or infinite, sampling is uniform over entire space\n        if c_best is None or c_best == float('inf'):\n            self._ellipse_center = None\n            self._ellipse_c_min = c_min\n            self._ellipse_c_best = None\n            self._ellipse_rotation = None\n            self._ellipse_l1 = None\n            self._ellipse_l2 = None\n        else:\n            self._ellipse_center = ((start_tensor + goal_tensor) / 2).numpy()\n            self._ellipse_c_min = c_min\n            self._ellipse_c_best = c_best\n            # Compute rotation matrix from start to goal direction along x-axis\n            direction = (goal_tensor - start_tensor).numpy()\n            norm_dir = np.linalg.norm(direction)\n            if norm_dir == 0:\n                self._ellipse_rotation = np.identity(len(direction))\n            else:\n                # unit vector along x-axis\n                a1 = direction / norm_dir\n                dim = len(direction)\n                # Create orthonormal basis matrices - use Householder transformation\n                e1 = np.zeros(dim)\n                e1[0] = 1.0\n                v = a1 - e1\n                if np.linalg.norm(v) < 1e-10:\n                    self._ellipse_rotation = np.identity(dim)\n                else:\n                    v = v / np.linalg.norm(v)\n                    H = np.identity(dim) - 2 * np.outer(v, v)\n                    self._ellipse_rotation = H\n            # Ellipse axis lengths\n            a = c_best / 2.0  # length of the ellipse's major axis (half)\n            b = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0  # minor axis half-length\n            self._ellipse_l1 = a\n            self._ellipse_l2 = b\n\n    def _informed_sample(self, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample within the informed ellipsoidal region (or uniformly if no solution yet).\n        \"\"\"\n        dim = 2\n        if self._ellipse_center is None:\n            # Uniform sample (same as original)\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, dim)\n                sample = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample in unit ball\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x = np.linalg.norm(x_ball)\n                if norm_x > 1e-10:\n                    x_ball = x_ball / norm_x * (np.random.rand() ** (1 / dim))\n                    break\n            # Scale by ellipse axes and rotate\n            L = np.diag([self._ellipse_l1] + [self._ellipse_l2] * (dim - 1))\n            sample_ellipse = np.dot(self._ellipse_rotation.T, np.dot(L, x_ball)) + self._ellipse_center\n            sample_point = Point(*(np.round(sample_ellipse).astype(int)))\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback uniform sample if invalid point\n                # This fallback is rare; can loop again to sample informed points.\n                return self._informed_sample(start, goal)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        super()._extract_path(q_new)\n\n    # Override displays to reuse existing initialization\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_vertex: Vertex = self._graph.root_vertex_start\n        goal_point: Point = self._get_grid().goal.position\n        start_point: Point = self._get_grid().agent.position\n\n        # Initialize ellipse parameters for informed sampling\n        self._set_ellipse_sampling_region(start_point, goal_point, None)\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            # Check time limit\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._max_time_seconds:\n                # Stop searching and treat as not found\n                break\n\n            if self._best_cost is None:\n                q_sample: Point = self._get_random_sample()\n            else:\n                q_sample: Point = self._informed_sample(start_point, goal_point)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        q_near.cost = q_new.cost + child_parent_dist\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and restrict sampling region\n                goal_vertex_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_point.to_tensor())\n                if self._best_cost is None or goal_vertex_cost < self._best_cost:\n                    self._best_cost = goal_vertex_cost\n                    self._set_ellipse_sampling_region(start_point, goal_point, self._best_cost)\n\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm inspired by RRT, incorporating goal-biased sampling and early stopping based on time.\n    Instead of purely random sampling, this algorithm samples towards the goal with a fixed probability to accelerate convergence.\n    It also imposes a 30-second timeout for the search to avoid endless computation time.\n    The algorithm builds a tree from the start towards the goal, connecting vertices with edges while respecting map constraints.\n    When a vertex falls within the goal radius, the path is extracted and the agent is moved accordingly.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation improves on the baseline RRT algorithm by integrating bidirectional sampling \n    to speed up reaching the goal. Instead of building a single tree from the start, it grows two trees:\n    one from the start and one from the goal, attempting to connect them. This reduces the search depth \n    and explores the space more efficiently. The extension step limits the maximum distance per iteration.\n    The algorithm terminates when the two trees are connected or if the search exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize two separate forests: one from start, one from goal\n        self._graph_start = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph_goal = gen_forest(self._services, Vertex(self._get_grid().goal.position), Vertex(self._get_grid().agent.position), [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        self.__map_displays = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Show both trees on map display\n        from algorithms.classic.sample_based.core.graph_map_display import GraphMapDisplay\n        self.__map_displays = [\n            GraphMapDisplay(self._services, self._graph_start),\n            GraphMapDisplay(self._services, self._graph_goal),\n        ]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse existing RRT helper - step towards sample point with max step length max_dist\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Random valid sample within the grid as per original\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _connect_trees(self, q_new_start: Vertex) -> Optional[List[Vertex]]:\n        \"\"\"\n        Try to connect the new vertex from start tree to closest vertex in goal tree.\n        If connection via collision-free edge possible, reconstruct full path and return.\n        \"\"\"\n        q_near_goal: Vertex = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n        if q_near_goal.position == q_new_start.position:\n            return None\n        # Attempt to create edge from q_new_start to q_near_goal by extending in steps\n        max_dist = 10\n        direction = q_near_goal.position.to_tensor() - q_new_start.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist == 0:\n            return None\n        direction_normalized = direction / dist\n\n        last_vertex = q_new_start\n        steps = int(dist // max_dist)\n        for i in range(1, steps + 1):\n            intermediate_point = Point.from_tensor(q_new_start.position.to_tensor() + direction_normalized * (i * max_dist))\n            intermediate_vertex = Vertex(intermediate_point)\n            line_seq = self._get_grid().get_line_sequence(last_vertex.position, intermediate_vertex.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                return None\n            last_vertex = intermediate_vertex\n        # Check final short segment if any remainder\n        remainder_dist = dist - steps * max_dist\n        if remainder_dist > 0:\n            final_point = q_near_goal.position\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(last_vertex.position, final_point)):\n                return None\n\n        # Add all intermediate vertices and edges to start tree leading towards q_near_goal\n        prev_vertex = q_new_start\n        for i in range(1, steps + 1):\n            intermediate_point = Point.from_tensor(q_new_start.position.to_tensor() + direction_normalized * (i * max_dist))\n            intermediate_vertex = Vertex(intermediate_point)\n            self._graph_start.add_edge(prev_vertex, intermediate_vertex)\n            prev_vertex = intermediate_vertex\n        # Final edge connecting last intermediate or q_new_start to q_near_goal\n        self._graph_start.add_edge(prev_vertex, q_near_goal)\n\n        # Merge the two trees by linking q_near_goal's parent to its root remains intact in goal tree\n        # Now reconstruct path from start root to q_new_start then to q_near_goal and to goal root in goal tree\n        path_start = self._trace_path_to_root(q_new_start, self._graph_start)\n        path_goal = self._trace_path_to_root(q_near_goal, self._graph_goal)\n        path_goal.reverse()  # From goal vertex to q_near_goal\n\n        full_path = path_start + path_goal\n        return full_path\n\n    def _trace_path_to_root(self, vertex: Vertex, forest: Forest) -> List[Vertex]:\n        path: List[Vertex] = [vertex]\n        while len(path[-1].parents) != 0:\n            # one parent only as per tree assumption\n            parent = path[-1].parents[0]\n            path.append(parent)\n        path.reverse()\n        return path\n\n    def _extract_path(self, path: List[Vertex]) -> None:\n        # Animate moving agent along given vertex list path\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_time_seconds: float = 30.0\n        start_time = time.time()\n\n        # Initiate the two forests for bidirectional search in init\n        # We'll alternate expanding start and goal trees each iteration\n\n        for iteration in range(100000):  # Large iteration limit, but halts on timeout or connect\n            if time.time() - start_time > max_time_seconds:\n                # Route not found within timeout\n                break\n\n            # Sample random point\n            q_sample = self._get_random_sample()\n\n            # Expand start tree towards q_sample\n            q_near_start = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            if q_near_start.position == q_sample:\n                # Skip if same point\n                pass\n            else:\n                q_new_start = self._get_new_vertex(q_near_start, q_sample, max_dist)\n                line_seq_start = self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_start):\n                    self._graph_start.add_edge(q_near_start, q_new_start)\n\n                    # Try to connect start tree new vertex to goal tree\n                    connected_path = self._connect_trees(q_new_start)\n                    if connected_path is not None:\n                        self._extract_path(connected_path)\n                        return\n                    self.key_frame()\n\n            # Sample random point again (could be other strategy, here symmetric)\n            q_sample_goal = self._get_random_sample()\n\n            # Expand goal tree towards q_sample_goal\n            q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample_goal)\n            if q_near_goal.position == q_sample_goal:\n                pass\n            else:\n                q_new_goal = self._get_new_vertex(q_near_goal, q_sample_goal, max_dist)\n                line_seq_goal = self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph_goal.add_edge(q_near_goal, q_new_goal)\n\n                    # Try to connect goal tree new vertex to start tree\n                    # We invert roles here, connect from goal tree vertex to start tree\n                    # Since _connect_trees is designed to connect from start tree vertex, we adapt:\n                    connected_path = None\n                    q_in_goal = q_new_goal\n                    # Find closest vertex in start tree\n                    q_near_start_2 = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_in_goal.position)\n                    if q_near_start_2.position != q_in_goal.position:\n                        # Attempt connection from q_in_goal (goal tree) to q_near_start_2 (start tree)\n                        # Swap order: extend from q_in_goal to q_near_start_2 to keep same logic\n                        direction = q_near_start_2.position.to_tensor() - q_in_goal.position.to_tensor()\n                        dist = torch.norm(direction)\n                        if dist != 0:\n                            direction_normalized = direction / dist\n                            last_vertex = q_in_goal\n                            steps = int(dist // max_dist)\n                            can_connect = True\n                            for i in range(1, steps + 1):\n                                intermediate_point = Point.from_tensor(q_in_goal.position.to_tensor() + direction_normalized * (i * max_dist))\n                                line_seq_segment = self._get_grid().get_line_sequence(last_vertex.position, intermediate_point)\n                                if not self._get_grid().is_valid_line_sequence(line_seq_segment):\n                                    can_connect = False\n                                    break\n                                last_vertex = Vertex(intermediate_point)\n                            remainder_dist = dist - steps * max_dist\n                            if remainder_dist > 0 and can_connect:\n                                final_point = q_near_start_2.position\n                                if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(last_vertex.position, final_point)):\n                                    can_connect = False\n                            if can_connect:\n                                # Add intermediate edges in goal tree towards start tree\n                                prev_vertex = q_in_goal\n                                for i in range(1, steps + 1):\n                                    intermediate_point = Point.from_tensor(q_in_goal.position.to_tensor() + direction_normalized * (i * max_dist))\n                                    intermediate_vertex = Vertex(intermediate_point)\n                                    self._graph_goal.add_edge(prev_vertex, intermediate_vertex)\n                                    prev_vertex = intermediate_vertex\n                                self._graph_goal.add_edge(prev_vertex, q_near_start_2)\n\n                                # Reconstruct path: start root -> q_near_start_2, then q_near_start_2 connected to goal tree root via q_in_goal path\n                                path_start = self._trace_path_to_root(q_near_start_2, self._graph_start)\n                                path_goal = self._trace_path_to_root(q_in_goal, self._graph_goal)\n                                path_goal.reverse()\n\n                                full_path = path_start + path_goal\n                                self._extract_path(full_path)\n                                return\n                    self.key_frame()\n\n        # No path found within time or iterations\n        # (Optional: could raise exception or no movement)\n        pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of RRT-Connect modified to speed up the path planning.\n    Improvements include:\n    - Adaptive sampling region biasing towards the goal and current tree frontier to reduce random wandering.\n    - A rewiring step similar to RRT* to improve path quality incrementally.\n    - Early termination if the search exceeds 30 seconds.\n    - Reduced iteration count with use of velocity growth control to reduce redundant expansions.\n    - Uses existing helper methods from RRT-Connect for extension and connection, augmented with rewiring.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True    # allow rewiring edges\n        self._init_displays()\n\n        self._max_dist = 15\n        self._iterations = 4000        # fewer iterations with improvements\n        self._rewire_radius = 20       # radius used in rewiring similar to RRT*\n        self._goal_sample_rate = 0.10  # 10% chance sample is exactly the goal to bias growth\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.get_map_displays() if hasattr(self._graph, \"get_map_displays\") else super().set_display_info()\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Return list of vertices within radius around q_new in graph\n        near_vertices = []\n        for root in self._graph.root_vertices:\n            near = self._graph.get_nearest_vertices([root], q_new.position, radius)\n            near_vertices.extend(near)\n        # Remove duplicates if any\n        unique_vertices = list(set(near_vertices))\n        return unique_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent with lowest cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near.position, q_new.position)):\n                cost = self._graph.get_cost(near) + torch.norm((q_new.position.to_tensor() - near.position.to_tensor()), p=2).item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = near\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        for near in near_vertices:\n            if near is q_new.parents[0]:  # skip parent vertex to avoid cycle\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, near.position)):\n                cost_through_qnew = self._graph.get_cost(q_new) + torch.norm((near.position.to_tensor() - q_new.position.to_tensor()), p=2).item()\n                if self._graph.get_cost(near) > cost_through_qnew:\n                    # rewire near vertex parent to q_new\n                    self._graph.remove_edge(near.parents[0], near)\n                    self._graph.add_edge(q_new, near)\n\n    def _get_biased_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # bias sample directly to goal\n            return self._get_grid().goal.position\n        else:\n            # bias sample inside bounding box between agent and goal + explored space region\n            pos_agent = self._get_grid().agent.position.to_tensor()\n            pos_goal = self._get_grid().goal.position.to_tensor()\n            center = (pos_agent + pos_goal) / 2\n            span = torch.abs(pos_goal - pos_agent) * 1.5\n            sample_coords = []\n            for i in range(self._get_grid().size.n_dim):\n                rand_val = np.random.uniform(max(0, center[i] - span[i]/2), min(self._get_grid().size[i]-1, center[i] + span[i]/2))\n                sample_coords.append(int(rand_val))\n            sample_point = Point(*sample_coords)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n            else:\n                # fallback to uniform random sample if invalid\n                return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        for i in range(self._iterations):\n\n            if time() - start_time > 30:\n                # Timeout after 30 seconds\n                break\n\n            # biased sampling between agent and goal region with goal bias\n            q_rand: Point = self._get_biased_sample()\n\n            # extend tree 0 (starts from agent)\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                q_new_vertex = self._q_new\n                near_vertices = self._get_near_vertices(q_new_vertex, self._rewire_radius)\n                chosen_parent = self._choose_parent(near_vertices, q_new_vertex)\n                if chosen_parent is not None:\n                    # reattach q_new vertex to best parent\n                    if q_new_vertex.parents:\n                        # remove current parent edge\n                        self._graph.remove_edge(q_new_vertex.parents[0], q_new_vertex)\n                    self._graph.add_edge(chosen_parent, q_new_vertex)\n\n                self._rewire(near_vertices, q_new_vertex)  # rewire neighbors to optimize tree cost\n\n                self._extension_target = q_new_vertex\n                connect_result = self._connect(self._graph.root_vertices[1], q_new_vertex)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            # visualization frame\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an improved variant inspired by SPRM and the RRT* \n    style incremental sampling-based planner. It incrementally grows a tree rooted \n    at the agent's start position by sampling random points, attempting to steer toward \n    the sample within a maximum step distance, and connecting the new vertex to \n    nearby vertices within a radius. It rewires connections to shorten the path \n    towards the goal, resulting in faster convergence and improved path quality \n    over the cyclic graph in SPRM. The search aborts if it exceeds 30 seconds.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm, named PathPlanning, is an improvement over the SPRM algorithm by \n    incorporating an incremental, radius-based connection strategy with rewiring inspired by \n    RRT* (Rapidly-exploring Random Tree star). It incrementally builds a tree of vertices \n    starting from the agent's position towards the goal by sampling points on the map and connecting \n    nearby vertices only if the collision-free path exists. Unlike the cyclic graph in SPRM, this \n    approach maintains tree connectivity to ensure a possibly shorter path using rewiring to optimize \n    connections locally for better path quality. The search terminates early once the goal is connected.\n    Additionally, the algorithm enforces a hard timeout of 30 seconds to stop the search if no path \n    is found within that limit, improving robustness on difficult maps.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15.0\n        self._start_vertex = Vertex(self._get_grid().agent.position, store_connectivity=True)\n        self._goal_vertex = Vertex(self._get_grid().goal.position, store_connectivity=True)\n        \n        V: List[Vertex] = []\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = CyclicGraph(self._start_vertex, self._goal_vertex, V)\n        self._graph.edges_removable = True  # Allow rewiring edges for optimization\n        self._init_displays()\n    \n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n    \n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        \"\"\"\n        Return vertices within radius _max_radius from vertex,\n        used to find neighbors for rewiring (like RRT*).\n        \"\"\"\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n    \n    def _choose_parent(self, X_near: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent vertex among X_near for q_new based on cost + edge validity.\n        Returns None if no valid parent found.\n        \"\"\"\n        min_cost = float('inf')\n        best_parent = None\n        for x in X_near:\n            if x == q_new:\n                continue\n            line_seq = self._get_grid().get_line_sequence(x.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = self._graph.get_cost_to_vertex(x) + x.position.distance(q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = x\n        return best_parent\n    \n    def _rewire(self, X_near: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        Try to improve cost of vertices in X_near by rewiring through q_new if better.\n        \"\"\"\n        for x in X_near:\n            if x == q_new or x.parent is None:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, x.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                new_cost = self._graph.get_cost_to_vertex(q_new) + q_new.position.distance(x.position)\n                old_cost = self._graph.get_cost_to_vertex(x)\n                if new_cost < old_cost:\n                    # Remove old edge and add new edge for rewiring\n                    self._graph.remove_edge(x.parent, x)\n                    self._graph.add_edge(q_new, x)\n                    self._graph.add_edge(x, q_new)\n                    x.parent = q_new\n    \n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract and move the agent along the path from start to goal using connectivity.\n        \"\"\"\n        agent: Vertex = self._start_vertex\n        goal: Vertex = self._goal_vertex\n        \n        # Backtrack path from goal to start\n        path: List[Vertex] = []\n        current = goal\n        while current is not None and current != agent:\n            path.append(current)\n            current = current.parent if hasattr(current, 'parent') else None\n        \n        if current != agent:  # No path found, just return\n            return\n        \n        path.reverse()\n        \n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [GraphMapDisplay(self._services, self._graph)]\n    \n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent = self._start_vertex\n        goal = self._goal_vertex\n        \n        # Initialize connectivity and costs\n        agent.parent = None\n        self._graph.root_vertices = [agent, goal]\n        self._graph.vertices = [agent, goal] + self._graph.sampled_vertices\n        \n        # Start with tree containing only start vertex\n        self._graph.clear_edges()\n        \n        for v in self._graph.vertices:\n            # Initialize cost to infinity except start\n            setattr(v, 'cost', float('inf'))\n            setattr(v, 'parent', None)\n        \n        agent.cost = 0.0\n        \n        # Add start and samples to the graph before connections\n        self._graph.vertices = [agent] + self._graph.sampled_vertices + [goal]\n        \n        # Incrementally attempt to connect samples (like RRT*)\n        for iteration in range(len(self._graph.sampled_vertices)):\n            current_time = time.time()\n            if current_time - start_time > 30.0:\n                # Timeout reached - treat as no path found\n                if self.testing is not None:\n                    self.testing.log(\"Timeout: No path found within 30 seconds.\")\n                return\n            \n            q_rand = self._get_random_sample()\n            q_new = self._get_new_vertex(agent, q_rand, self._max_radius)\n            \n            # Skip invalid positions\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n            \n            X_near = self._near(q_new)\n            parent = self._choose_parent(X_near, q_new)\n            if parent is None:\n                continue\n\n            # Assign parent and cost\n            q_new.parent = parent\n            q_new.cost = parent.cost + parent.position.distance(q_new.position)\n\n            # Add q_new vertex and edges\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(parent, q_new)\n            self._graph.add_edge(q_new, parent)\n            \n            # Try rewiring neighbors for better cost\n            self._rewire(X_near, q_new)\n            \n            self.key_frame()\n            \n            # Check if goal can be connected with q_new\n            line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal.position)\n            if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                # Connect goal to q_new\n                goal.parent = q_new\n                goal.cost = q_new.cost + q_new.position.distance(goal.position)\n                self._graph.add_edge(q_new, goal)\n                self._graph.add_edge(goal, q_new)\n                self.key_frame()\n                self._extract_path()\n                return\n        \n        # After all samples processed, if goal is not connected, no path found\n        if self.testing is not None:\n            self.testing.log(\"No path found after processing all samples within 30 seconds or less.\")\n        \n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        if torch.norm(dir) <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir / torch.norm(dir)\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of RRT* by combining:\n    - Goal biasing in the sampling process to speed convergence toward the goal.\n    - Adaptive radius calculation with a dynamic radius adjustment depending on the \n      number of vertices to speed rewiring computation.\n    - Early termination if the goal is reached or 30 seconds timeout is exceeded.\n    The improvements aim to reduce average planning time while preserving path optimality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        self._goal_bias_prob = 0.15  # 15% chance to sample goal directly for faster convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        # Goal biased sampling: with probability select goal position\n        if np.random.random() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        # Otherwise sample random free valid position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius_base: float = 50  # Base max radius for rewiring\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n        start_time = time.time()\n\n        for iteration in range(iterations):\n            # Timeout check for 30 seconds\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Consider path as not found and stop search\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = float(self._graph.size)\n            if card_v < 2:\n                radius = max_radius_base\n            else:\n                log_card_v = np.log(card_v)\n                # Adaptive radius shrinking with number of vertices for faster rewiring\n                radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1.0 / dimension)), max_radius_base)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent providing lowest cost to q_new\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(near_new_line_seq):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if q_new offers cheaper path\n            for q_near in Q_near:\n                new_near_line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(new_near_line_seq):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        # Remove old edge(s)\n                        q_parent: Optional[Vertex] = None\n                        if len(q_near.parents) > 0:\n                            q_parent = next(iter(q_near.parents))\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n\n                        # Update cost and add new edge\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Construct path from q_new back to start via parents and add goal edge\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        dist_goal = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + dist_goal\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Trace parents until root (start)\n        curr = goal_v\n        while len(curr.parents) != 0:\n            parent = next(iter(curr.parents))\n            path.append(parent)\n            curr = parent\n\n        path.pop()  # Remove root extra\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an enhanced RRT-Connect variant with informed sampling \n    to improve search efficiency and reduce planning time. \n    It introduces heuristic-guided sampling biased towards the goal region,\n    and dynamically adjusts maximum extension distances for faster tree growth.\n    A timeout of 30 seconds is implemented to terminate the search if no path \n    is found within the time limit.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 15  # increased max extension distance for faster growth\n        self._iterations = 100000  # large number; actual limit by timeout\n        self._goal_bias = 0.2  # 20% chance to sample directly near goal\n\n    def _get_informed_sample(self) -> Point:\n        \"\"\"\n        Generate a sample point with heuristic bias towards goal.\n        With probability self._goal_bias select a point near goal,\n        else random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            max_dist = self._max_dist * 2  # define radius around goal for bias\n            while True:\n                direction = np.random.randn(self._get_grid().size.n_dim)  # random direction\n                direction = direction / np.linalg.norm(direction)\n                offset = (np.random.rand() * max_dist) * direction\n                sample_pos_arr = goal_pos.to_tensor().numpy() + offset\n                # Clamp sample inside map boundaries\n                sample_pos_arr = np.clip(sample_pos_arr, 0, self._get_grid().size - 1).astype(int)\n                sample = Point(*sample_pos_arr)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Trace back path from connection vertex and move agent along the path.\n        \"\"\"\n        # trace back from q_new towards its root vertex\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back from extension target towards its root vertex\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # If the root_vertex at index 0 is the goal root vertex, reverse path for correct order\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        \"\"\"\n        Try to extend the tree rooted at root_vertex towards point q.\n        \"\"\"\n        self._q_near: Vertex = self._get_nearest_vertex(root_vertex, q)\n        self._q_new: Vertex = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        \"\"\"\n        Keep extending root_vertex towards q.position until trapped or reached.\n        \"\"\"\n        status = 'advanced'\n        while status == 'advanced':\n            status = self._extend(root_vertex, q.position)\n        return status\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Main loop of the improved RRT-Connect based algorithm with informed sampling\n        and 30 seconds timeout termination.\n        \"\"\"\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30:\n                # Timeout, no path found within 30 seconds\n                break\n\n            q_rand: Point = self._get_informed_sample()\n\n            if self._extend(self._graph.root_vertices[0], q_rand) != 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planning method based on RRT*, an optimized version \n    of the RRT algorithm that incrementally rewires the tree to reduce path cost and improve path quality.\n    The core enhancements are:\n    - Incorporation of a rewiring step to connect new vertices to the best parent within a neighborhood \n      and rewire affected neighbors for shorter paths.\n    - Use of a dynamic neighborhood radius based on the number of vertices as defined in RRT* theory.\n    - Early termination upon reaching the goal, reconstructing the best found path.\n    - A 30-second timeout limit to abort search if no path is found in time.\n    This results in faster convergence to a valid, high-quality path compared to basic RRT.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = True  # Allow edge rewiring for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Bias sampling towards the goal with some probability (goal_bias),\n        improving convergence speed.\n        \"\"\"\n        goal_bias = 0.1\n        grid = self._get_grid()\n        if np.random.rand() < goal_bias:\n            sample = grid.goal.position\n            if grid.is_agent_valid_pos(sample):\n                return sample\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _find_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find all vertices in the graph within radius of q_new.position.\n        \"\"\"\n        near_vertices: List[Vertex] = []\n        for v in self._graph.vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new.position.to_tensor())\n            if dist <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_best_parent(self, q_near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent for q_new among q_near_vertices, considering \n        the cost-to-come + cost of edge from parent to q_new,\n        and only connect if the edge is valid.\n        \"\"\"\n        best_parent = None\n        best_cost = math.inf\n        grid = self._get_grid()\n        new_pos = q_new.position\n\n        for q_near in q_near_vertices:\n            # Check if path from q_near to q_new is valid\n            line_seq = grid.get_line_sequence(q_near.position, new_pos)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n\n            c = q_near.cost + torch.norm(q_near.position.to_tensor() - new_pos.to_tensor()).item()\n            if c < best_cost:\n                best_cost = c\n                best_parent = q_near\n\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        For each near vertex, check if going through q_new reduces their cost.\n        If yes and path is valid, rewire the tree (change parent).\n        \"\"\"\n        grid = self._get_grid()\n        new_pos = q_new.position\n\n        for q_near in near_vertices:\n            if q_near == q_new:\n                continue\n            line_seq = grid.get_line_sequence(new_pos, q_near.position)\n            if not grid.is_valid_line_sequence(line_seq):\n                continue\n            proposed_cost = q_new.cost + torch.norm(new_pos.to_tensor() - q_near.position.to_tensor()).item()\n            if proposed_cost < q_near.cost:\n                # Rewire q_near to q_new\n                # Remove old parents edges and set q_new as parent\n                for parent in list(q_near.parents):\n                    self._graph.remove_edge(parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = proposed_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from the goal vertex to start by following parents of minimum cost.\n        Then move agent along path with key frames.\n        \"\"\"\n        path: List[Vertex] = [q_goal]\n\n        # Follow parents until root (start)\n        current_vertex = q_goal\n        while current_vertex.parents:\n            # Choose the parent with minimal cost (usually only one parent)\n            current_vertex = min(current_vertex.parents, key=lambda p: p.cost)\n            path.append(current_vertex)\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 100000  # Large max iteration count; cutoff by time\n        start_time = time()\n        found_goal = False\n        grid = self._get_grid()\n        root = self._graph.root_vertex_start\n\n        # Initialize cost for root vertex\n        root.cost = 0\n\n        for i in range(iterations):\n            if (time() - start_time) > 30.0:  # 30 seconds timeout limit\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([root], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check if path from q_near to q_new is valid\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find nearby vertices within a radius for rewiring\n            # RRT* radius formula: r = gamma * (log(n)/n)^{1/d}\n            n_vertices = len(self._graph.vertices) + 1\n            dim = grid.size.n_dim\n            gamma_rrt_star = max_dist * 2.0  # constant factor, can be tuned\n            radius = min(gamma_rrt_star * (math.log(n_vertices) / n_vertices)**(1/dim), max_dist)\n\n            near_vertices = self._find_near_vertices(q_new, radius)\n\n            # Choose best parent based on cost and valid connection\n            best_parent = self._choose_best_parent(near_vertices + [q_near], q_new)\n            if best_parent is None:\n                continue  # no valid parent found\n\n            # Connect q_new with best parent\n            self._graph.add_edge(best_parent, q_new)\n            q_new.cost = best_parent.cost + torch.norm(best_parent.position.to_tensor() - q_new.position.to_tensor()).item()\n\n            # Rewire neighbors if q_new improves their cost\n            self._rewire(q_new, near_vertices)\n\n            self.key_frame()\n\n            # Check if q_new is in goal radius\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect to goal vertex with shortest cost edge\n                goal_vertex = Vertex(grid.goal.position)\n                # Check if line is valid before connecting to goal\n                if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    goal_vertex.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor()).item()\n                    self._extract_path(goal_vertex)\n                    found_goal = True\n                    break\n        \n        # If not found goal within time limit or iteration, treat as no path found\n        if not found_goal:\n            # Signal no path found by moving agent back to start (optional)\n            self.move_agent(root.position)\n            # Optionally keyframe to show no path found\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Algorithm Description:\n    This algorithm implements an enhanced RRT* variant that incorporates goal biasing\n    and informed sampling techniques to accelerate convergence time. \n    Instead of purely random sampling, a goal bias parameter is used to occasionally sample the goal position directly,\n    thus guiding the tree growth toward the goal more aggressively. After an initial solution is found,\n    the algorithm switches to informed sampling within an ellipsoidal region defined by the current best path cost,\n    reducing unnecessary exploration in areas unlikely to improve the solution.\n\n    Additionally, a 30-second timeout is enforced to abort the search if a path cannot be found in that duration.\n\n    These improvements reduce the number of iterations and improve time efficiency compared to the pure RRT* implementation.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional members for informed sampling and timing\n        self._best_cost = float('inf')\n        self._goal_bias = 0.1  # 10% chance sample is the goal for goal biasing\n        self._start_time = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_ellipsoid_sample(self, start_pos: Point, goal_pos: Point, c_max: float) -> Point:\n        \"\"\"\n        Sample within an ellipsoidal region defined by start, goal and current best cost,\n        an informed subset of the space to improve convergence speed.\n        \"\"\"\n        start_tensor = start_pos.to_tensor()\n        goal_tensor = goal_pos.to_tensor()\n        c_min = torch.norm(goal_tensor - start_tensor)\n        if c_max < c_min:\n            # No informed sampling possible, fallback to uniform random sampling\n            return self._get_random_sample()\n\n        center = (start_tensor + goal_tensor) / 2.0\n        diff = (goal_tensor - start_tensor).unsqueeze(1)  # column vector\n\n        # Unit vector from start to goal\n        e1 = diff / c_min\n\n        # Build rotation matrix to align sampling axis with start-goal line\n        # For 2D, easy rotation matrix construction:\n        # Based on e1 = [cos(theta), sin(theta)]^T, rotate standard basis x-axis to e1\n        if e1.shape[0] == 2:\n            cos_theta = e1[0].item()\n            sin_theta = e1[1].item()\n            rotation = torch.tensor([[cos_theta, -sin_theta],\n                                     [sin_theta,  cos_theta]])\n        else:\n            # For higher dims, identity fallback\n            rotation = torch.eye(e1.shape[0])\n\n        # Radii of ellipsoid axes\n        a1 = c_max / 2.0\n        a2 = torch.sqrt(c_max**2 - c_min**2) / 2.0\n\n        # Sample uniformly inside unit ball in 2D or 3D\n        while True:\n            x = torch.randn(e1.shape[0])\n            norm_x = torch.norm(x)\n            if norm_x > 1e-12:\n                break\n        unit_ball_point = x / norm_x * (torch.rand(1).item() ** (1.0 / e1.shape[0]))\n\n        # Scale by ellipsoid radii\n        if e1.shape[0] == 2:\n            sample_ellipsoid = torch.tensor([a1, a2]) * unit_ball_point\n        else:\n            # For >2D dims, simplify all secondary axes to a2\n            radii = torch.cat([torch.tensor([a1]), torch.ones(e1.shape[0] - 1)*a2])\n            sample_ellipsoid = radii * unit_ball_point\n\n        # Rotate and translate to center\n        sample = rotation @ sample_ellipsoid + center\n\n        sample_point = Point.from_tensor(sample)\n        # Validate in grid, fallback to random sample if invalid\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new):\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = self._graph.root_vertex_goal\n\n        self._start_time = time.time()\n        found_solution = False\n\n        for i in range(iterations):\n            # Timeout check\n            if time.time() - self._start_time > 30.0:\n                # Abort if search time exceeds 30 seconds\n                break\n\n            # Goal biased sampling: with some probability sample goal directly\n            if np.random.rand() < self._goal_bias:\n                q_sample: Point = goal_vertex.position\n            elif self._best_cost < float('inf'):\n                # Use informed sampling inside the ellipsoid of current best path cost\n                q_sample = self._get_ellipsoid_sample(start_vertex.position, goal_vertex.position, self._best_cost)\n            else:\n                # Uniform random sampling\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check path collision\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimum cost\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            # Add edge from best parent to new vertex\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors for optimization\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = next(iter(q_near.parents), None)\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new node is in goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                found_solution = True\n                # Update best cost to enable informed sampling next iteration\n                goal_dist = torch.norm(goal_vertex.position.to_tensor() - q_new.position.to_tensor())\n                total_cost = q_new.cost + goal_dist\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n\n                self._extract_path(q_new)\n                break  # Exit after first path found for time efficiency\n\n            self.key_frame()\n\n        if not found_solution:\n            # If no path found in the iteration or within timeout, handle accordingly or leave as no path found.\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-Based Path Planning Algorithm (inspired by SPRM but incorporating optimization):\n    This algorithm builds upon the SPRM sample-based planner by integrating a prioritized \n    incremental graph growth guided by heuristic cost estimates (like A* heuristic) to speed up \n    convergence towards the goal. Instead of connecting all near vertices blindly, it focuses on \n    expanding vertices that are closer to the goal spatially and cost-wise, thus improving time efficiency. \n    The algorithm uses a max_radius neighbor search combined with an incremental selection of \n    promising vertices, limiting unnecessary edge checks and collisions tests. It terminates \n    early if the path cannot be found within 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        self._graph = None\n        self._init_sample_vertices()\n        self._init_displays()\n\n    def _init_sample_vertices(self) -> None:\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            V\n        )\n        self._graph.edges_removable = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic(self, p_from: Point, p_to: Point) -> float:\n        # Euclidean distance heuristic (can use torch.norm or manual)\n        diff = p_to.to_tensor() - p_from.to_tensor()\n        return float(torch.norm(diff))\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                break\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # Initialize connectivity and cost dictionaries\n        # Cost from agent node to vertex (initialized as infinity except for agent)\n        cost_from_start = {v: float('inf') for v in self._graph.V}\n        cost_from_start[agent] = 0.0\n\n        # Priority queue for vertices to expand (cost + heuristic)\n        # Entries are tuples (priority, vertex)\n        open_set = []\n        heapq.heappush(open_set, (self._heuristic(agent.position, goal.position), agent))\n\n        # Set to keep track of vertices already expanded\n        closed_set = set()\n\n        # Initialize connectivity for agent and goal\n        if goal not in agent.connectivity:\n            agent.connectivity[goal] = None  # Placeholder for path recovery\n\n        while open_set:\n            if time.time() - start_time > 30.0:  # Timeout of 30 seconds\n                return\n\n            curr_priority, current_vertex = heapq.heappop(open_set)\n\n            if current_vertex == goal:\n                # Goal reached, extract path\n                self._extract_path()\n                return\n\n            if current_vertex in closed_set:\n                continue\n            closed_set.add(current_vertex)\n\n            neighbors = self._near(current_vertex)\n\n            for neighbor in neighbors:\n                if neighbor == current_vertex:\n                    continue\n\n                # Check line validity between current_vertex and neighbor\n                line_seq = self._get_grid().get_line_sequence(current_vertex.position, neighbor.position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n\n                tentative_cost = cost_from_start[current_vertex] + self._heuristic(current_vertex.position, neighbor.position)\n\n                if tentative_cost < cost_from_start.get(neighbor, float('inf')):\n                    cost_from_start[neighbor] = tentative_cost\n                    neighbor.connectivity[goal] = None  # Ensure goal connectivity key exists\n\n                    # Update connectivity for path recovery: current_vertex is parent of neighbor\n                    current_vertex.connectivity[neighbor] = neighbor\n                    neighbor.connectivity[current_vertex] = current_vertex\n\n                    # Add neighbor to graph edges if not present\n                    if not self._graph.has_edge(current_vertex, neighbor):\n                        self._graph.add_edge(current_vertex, neighbor)\n                    if not self._graph.has_edge(neighbor, current_vertex):\n                        self._graph.add_edge(neighbor, current_vertex)\n\n                    # Calculate priority with heuristic\n                    priority = tentative_cost + self._heuristic(neighbor.position, goal.position)\n                    heapq.heappush(open_set, (priority, neighbor))\n\n            self.key_frame()\n\n        # If execution reaches here, no path found within time limit\n        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm, named PathPlanning, is an enhanced variant of RRT* that aims to improve runtime efficiency.\nIt incorporates the following improvements:\n- Utilizes informed sampling after an initial feasible path is found to focus sampling in the subset of the search space \n  that can potentially improve the current best path (inspired by Informed RRT*).\n- Limits unnecessary rewiring and costly neighborhood computations by using a dynamic radius based on the current cost \n  to the goal.\n- Stops searching after a 30-second timeout to ensure bounded runtime.\nIt reuses and builds upon the helper functions and graph structure from the base RRT* algorithm.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _best_goal_vertex: Optional[Vertex]\n    _found_path_cost: Optional[float]\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = Forest(self._services, start_vertex, goal_vertex, [])\n        self._best_goal_vertex = None\n        self._found_path_cost = None\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _sample_in_ellipse(self, center: Point, c_min: float, c_max: float, start: Point, goal: Point) -> Point:\n        # Generates samples inside prolate hyperspheroid (ellipse in 2D)\n        # Reference: Informed RRT* paper concept\n        dim = len(center)\n        r = c_max / 2.0  # Max radius of ellipse\n        if c_min is None or c_min == float('inf') or c_min <= 0:\n            # No path found yet, fallback to uniform random sampling\n            return self._get_random_sample()\n\n        # Unit vector along the line from start to goal\n        start_tensor = start.to_tensor()\n        goal_tensor = goal.to_tensor()\n        diff = (goal_tensor - start_tensor).numpy()\n        e1 = diff / np.linalg.norm(diff)\n        # Sampling within unit ball\n        while True:\n            sample_ball = np.random.normal(0,1,dim)\n            sample_ball /= np.linalg.norm(sample_ball)\n            u = np.random.rand() ** (1/dim)\n            sample_unit_ball = u * sample_ball\n            # Scaling and rotation matrix\n            L = np.diag([c_max/2.0] + [np.sqrt(c_max**2 - c_min**2)/2.0]*(dim-1))\n            # Build rotation to align first axis with e1\n            if dim == 2:\n                angle = np.arctan2(e1[1], e1[0])\n                R = np.array([[np.cos(angle), -np.sin(angle)],\n                              [np.sin(angle),  np.cos(angle)]])\n            else:\n                # For dimensions other than 2, fallback random sampling\n                return self._get_random_sample()\n            sampled_point = R.dot(L.dot(sample_unit_ball)) + ((start_tensor + goal_tensor)/2.0)\n            sample_pt = Point(*np.round(sampled_point).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 100000  # large upper bound, but will break on timeout or success\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        best_cost_so_far: Optional[float] = None\n        best_goal_vertex: Optional[Vertex] = None\n\n        for i in range(iterations):\n            if time.time() - start_time > 30.0:  # timeout in seconds\n                break\n\n            # Use informed sampling once a path is found to speed up convergence\n            if best_cost_so_far is not None:\n                c_min = self._heuristic_distance(self._graph.root_vertex_start.position, self._graph.root_vertex_goal.position)\n                c_max = best_cost_so_far\n                q_sample = self._sample_in_ellipse(center=self._graph.root_vertex_start.position,\n                                                  c_min=c_min, c_max=c_max,\n                                                  start=self._graph.root_vertex_start.position,\n                                                  goal=self._graph.root_vertex_goal.position)\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            # radius shrinks if we have a current best_cost to focus rewiring, else normal formula\n            if best_cost_so_far is None:\n                radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1/dimension)), max_radius)\n            else:\n                radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1/dimension)), max_radius,\n                             best_cost_so_far - q_nearest.cost)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_val = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if collision_free and cost_near_to_new < c_min_val:\n                    q_min = q_near\n                    c_min_val = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Calculate tentative cost to goal\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                to_goal_dist = torch.norm(q_new.position.to_tensor() - goal_vertex.position.to_tensor())\n                tentative_cost = q_new.cost + to_goal_dist\n                if best_cost_so_far is None or tentative_cost < best_cost_so_far:\n                    best_cost_so_far = tentative_cost\n                    best_goal_vertex = q_new\n                    # Extract the path from best vertex found so far\n                    self._extract_path(q_new)\n                    # Do not break here, continue to improve path within time limit\n\n            self.key_frame()\n\n        if best_goal_vertex is None:\n            # No path found within time\n            self.key_frame()  # mark done frame anyway ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This is an improved sample-based path planning algorithm inspired by RRT-Connect.\n    It integrates goal biasing and a heuristic-informed adaptive sampling region to speed convergence.\n    Instead of uniform random sampling over the entire map, the algorithm samples points within an ellipse \n    defined by agent and goal positions, focusing exploration where the path is most likely to exist.\n    It also employs a goal bias with a certain probability to directly sample the goal position,\n    improving the chance of connection. The algorithm stops searching after 30 seconds if no path found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n    _start_time: float\n    _max_duration: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 12                                       # Slightly larger max dist for faster extension\n        self._iterations = 10000\n        self._goal_sample_rate = 0.1                              # 10% chance to sample the goal directly\n        self._max_duration = 30.0                                 # 30 seconds cut-off for search\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_ellipse_sample(self) -> Point:\n        \"\"\"\n        Samples a point inside an ellipse between agent and goal with some expansion.\n        Ellipse major axis = distance(agent, goal) + margin.\n        This focuses sampling in the region likely containing the path.\n        \"\"\"\n        agent_pos = self._get_grid().agent.position.to_tensor()\n        goal_pos = self._get_grid().goal.position.to_tensor()\n        center = (agent_pos + goal_pos) / 2\n        diff = goal_pos - agent_pos\n        dist = torch.norm(diff).item()\n        if dist < 1e-5:\n            # If starting very close, fallback to agent position\n            return self._get_grid().agent.position\n\n        # Rotation angle to align ellipse with line between agent and goal\n        theta = torch.atan2(diff[-1], diff[0])\n\n        # Major and minor axes lengths with some margin\n        a = dist / 2 + self._max_dist * 2         # major axis half-length\n        b = a / 2                                 # minor axis half-length\n\n        for _ in range(100):\n            # Sample random point in unit circle\n            r1 = np.random.uniform(0,1)\n            r2 = np.random.uniform(0,2*np.pi)\n            u = np.sqrt(r1)                       # sqrt for uniform distribution in circle\n            x = u * np.cos(r2) * a\n            y = u * np.sin(r2) * b\n\n            # Rotation matrix for ellipse alignment\n            rot_x = x * torch.cos(theta) - y * torch.sin(theta)\n            rot_y = x * torch.sin(theta) + y * torch.cos(theta)\n\n            sample_coords = center + torch.tensor([rot_x, rot_y])\n            # Round and clamp to map size\n            sample_np = sample_coords.numpy()\n            sample_int = np.round(sample_np).astype(int)\n            map_size = self._get_grid().size\n            sample_int = np.clip(sample_int, 0, map_size - 1)\n            sample_point = Point(*sample_int)\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n        # Fallback to uniform random if sampling failed in ellipse\n        return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n\n        # For consistency with reference code: root_vertices[0] is start tree, root_vertices[-1] is goal tree\n        # The forest is always reversed on each iteration so start and goal swap roles\n        for i in range(self._iterations):\n            current_time = time.time()\n            if current_time - self._start_time > self._max_duration:\n                # Timeout: no solution found within 30 seconds\n                break\n\n            # Goal biasing: sample goal directly with probability _goal_sample_rate\n            if np.random.rand() < self._goal_sample_rate:\n                q_rand = self._get_grid().goal.position\n            else:\n                q_rand = self._get_ellipse_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            \n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT* inspired path planning algorithm with rewiring for faster convergence and shorter path.\n    This algorithm builds upon the original RRT by not only adding a new vertex from sampled points,\n    but also rewiring the existing vertices within a neighborhood of the new vertex to reduce the path cost.\n    It uses a fixed maximum distance for edge extension and checks for collision-free edges.\n    The rewiring step improves path optimality and reduces unnecessary exploration.\n    The algorithm aborts if the search exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_nearby_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Find vertices in the graph within radius of q_new.position\n        nearby_vertices: List[Vertex] = []\n        all_vertices = self._graph.get_all_vertices()\n        for vertex in all_vertices:\n            if self._distance(vertex.position, q_new.position) <= radius:\n                nearby_vertices.append(vertex)\n        return nearby_vertices\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Vertex:\n        # Choose the parent vertex from candidates to minimize cost to q_new\n        min_cost = math.inf\n        best_parent = None\n        for q_near in q_near_candidates:\n            proposed_path_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(proposed_path_seq):\n                continue\n            cost_to_q_new = q_near.cost + self._distance(q_near.position, q_new.position)\n            if cost_to_q_new < min_cost:\n                min_cost = cost_to_q_new\n                best_parent = q_near\n        if best_parent is None:\n            # fallback: pick nearest among candidates without considering cost (should rarely happen)\n            best_parent = q_near_candidates[0]\n            min_cost = best_parent.cost + self._distance(best_parent.position, q_new.position)\n        q_new.cost = min_cost\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        for q_near in nearby_vertices:\n            if q_near == q_new or q_near == self._graph.root_vertex_start:\n                continue\n            proposed_path_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            if not self._get_grid().is_valid_line_sequence(proposed_path_seq):\n                continue\n            new_cost = q_new.cost + self._distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # rewire: remove existing parent edge(s) and add edge from q_new to q_near\n                # To do this properly, remove q_near from parents' children and update parents to just q_new\n                # The graph implementation likely supports multiple parents, but we keep single parent for path cost.\n                # Here we remove old edges and add the new edge\n                for old_parent in q_near.parents.copy():\n                    self._graph.remove_edge(old_parent, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal_parent: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_goal_parent, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        current_vertex = goal_v\n        while len(current_vertex.parents) != 0:\n            parent = next(iter(current_vertex.parents))\n            path.append(parent)\n            current_vertex = parent\n\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 10000\n        search_radius: float = 20.0  # radius for rewiring in RRT*\n        start_time = time.time()\n\n        for i in range(iterations):\n            if (time.time() - start_time) > 30.0:\n                # Timeout - stop search and treat as route not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new_pos = self._get_new_vertex(q_near, q_sample, max_dist).position\n            q_new = Vertex(q_new_pos)\n\n            # Get nearby vertices within radius for choosing the best parent and rewiring\n            nearby_vertices = self._get_nearby_vertices(q_new, search_radius)\n            if len(nearby_vertices) == 0:\n                nearby_vertices = [q_near]\n\n            # Choose best parent from nearby vertices to minimize cost\n            best_parent = self._choose_parent(nearby_vertices, q_new)\n\n            # Check if path between best parent and q_new is valid\n            line_seq = self._get_grid().get_line_sequence(best_parent.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Add q_new with chosen parent\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the nearby vertices to improve paths if possible\n            self._rewire(q_new, nearby_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved version of the RRT* algorithm optimized for faster convergence.\n    Improvements include:\n    - Bi-directional tree growth from both start and goal vertices simultaneously,\n      reducing search time by connecting trees from both ends.\n    - Early attempt to connect the two trees when new vertices are added, allowing quicker path discovery.\n    - Adaptive radius calculation based on the current graph size for near neighbor search.\n    - Timeout after 30 seconds to abandon search if no path is found.\n    \n    The backbone idea is to exploit bidirectional growth of RRT* with rewiring, combining the benefits\n    of exploration from both start and goal, thus accelerating convergence and reducing computational time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        goal_vertex.cost = 0\n\n        # Initialize forests for bidirectional RRT*\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        # For display, we combine the graphs (will use display only for start graph)\n        self._graph = self._graph_start  \n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    # Helper Functions for bidirectional RRT*\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph: Forest, q_sample: Point) -> Vertex:\n        return graph.get_nearest_vertex([graph.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius(self, graph: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return graph.get_vertices_within_radius([graph.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _connect_trees(self, vertex_start: Vertex, vertex_goal: Vertex) -> bool:\n        \"\"\"\n        Attempt connection between two trees if collision free and update edges accordingly.\n        Returns True if connection is made.\n        \"\"\"\n        if not self._get_grid().is_valid_line_sequence(\n            self._get_grid().get_line_sequence(vertex_start.position, vertex_goal.position)\n        ):\n            return False\n\n        # Create new connection vertex on both sides with cost updates\n        dist = torch.norm(vertex_start.position.to_tensor() - vertex_goal.position.to_tensor())\n        # Connect goal side vertex back to start side vertex\n        vertex_goal.cost = vertex_start.cost + dist\n        self._graph_start.add_edge(vertex_start, vertex_goal)\n        # Connect start side vertex to goal side vertex\n        vertex_start.cost = vertex_goal.cost + dist\n        self._graph_goal.add_edge(vertex_goal, vertex_start)\n\n        return True\n\n    def _extract_bidirectional_path(self, q_start: Vertex, q_goal: Vertex) -> None:\n        \"\"\"\n        Extract path from start tree and goal tree vertices and merge them,\n        then move agent along extracted path.\n        \"\"\"\n        path_start: List[Vertex] = [q_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        path_goal: List[Vertex] = [q_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # combine path: start to q_start + q_goal to goal (reverse of goal path)\n        full_path_vertices: List[Vertex] = path_start + path_goal\n\n        # Move agent along the path\n        for vertex in full_path_vertices:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _rewire(self, graph: Forest, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        \"\"\"\n        Rewire nearby vertices if the new vertex provides a cheaper path.\n        \"\"\"\n        for q_near in Q_near:\n            near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, q_near.position)\n            )\n            cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if near_new_collision_free and cost_new_to_near < q_near.cost:\n                q_parent = None\n                for parent in q_near.parents:\n                    q_parent = parent\n                    break\n                graph.remove_edge(q_parent, q_near)\n                q_near.cost = cost_new_to_near\n                graph.add_edge(q_new, q_near)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Timeout check (30 seconds)\n            if time.time() - start_time > 30:\n                # No path found within time limit\n                break\n\n            # Alternate sampling between start and goal trees\n            graph_active, graph_other = (self._graph_start, self._graph_goal) if i % 2 == 0 else (self._graph_goal, self._graph_start)\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(graph_active, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(graph_active.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(graph_active, q_new, radius)\n\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            graph_active.add_edge(q_min, q_new)\n\n            self._rewire(graph_active, q_new, Q_near)\n\n            # Try to connect from q_new of active graph to nearest in other graph\n            q_nearest_other = self._get_nearest_vertex(graph_other, q_new.position)\n            dist_connect = torch.norm(q_nearest_other.position.to_tensor() - q_new.position.to_tensor())\n            if dist_connect <= max_dist:\n                # Check connection collision free and connect trees\n                if self._connect_trees(q_new, q_nearest_other):\n                    # Path found, extract and move agent\n                    self._extract_bidirectional_path(q_new, q_nearest_other)\n                    break\n\n            # Also check if q_new is in goal radius (if from start graph)\n            if graph_active is self._graph_start and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_bidirectional_path(q_new, q_nearest_other)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm improves over the SPRM cyclic graph approach by incorporating a \n    Rapidly-exploring Random Graph (RRG) paradigm, which connects new sample vertices \n    not only to their nearest neighbor but also to all neighbors within a given radius.\n    This enhances graph connectivity and exploration efficiency, likely leading to \n    faster path discovery. Additionally, the search is timed, and terminated if no \n    path is found within 30 seconds, respecting the time constraint.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning class implements an improved variant of RRT*, enhancing time efficiency by:\n    - Introducing goal bias sampling to guide exploration towards the goal more frequently.\n    - Dynamically adjusting the rewiring radius with growth to limit unnecessary rewiring checks.\n    - Early stopping if no better paths are found within certain iterations.\n    - Enforcing a hard time limit of 30 seconds for path search.\n    The backbone idea remains sample-based incremental tree construction with rewiring to optimize paths,\n    but with prioritized goal-oriented sampling and adaptive parameters to speed convergence.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # additionally record timing or control variables if needed\n        self._goal_bias_prob = 0.2   # 20% samples are goal biased to speed convergence\n        self._max_rewire_radius = 40  # slightly smaller max radius for rewiring to save time\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_goal_biased_sample(self) -> Point:\n        \"\"\"\n        Returns goal position with a probability of self._goal_bias_prob,\n        else random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias_prob:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_iterations: int = 10000\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        no_improvement_iters = 0\n        improvement_threshold = 100  # stop if no improvement after these many iterations\n\n        best_cost = float(\"inf\")\n\n        for iteration in range(max_iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # time exceeded 30 seconds -> treat as no path found, stop search\n                break\n\n            q_sample: Point = self._get_goal_biased_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            # Dynamic radius decays as tree grows, boosting computational efficiency in rewiring\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), self._max_rewire_radius)\n\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            improved_in_iteration = False\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                            q_near.cost = cost_new_to_near\n                            self._graph.add_edge(q_new, q_near)\n                            improved_in_iteration = True\n\n            # Track improvement to stop early if stuck\n            if q_new.cost < best_cost:\n                best_cost = q_new.cost\n                no_improvement_iters = 0\n            else:\n                no_improvement_iters += 1\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            if no_improvement_iters >= improvement_threshold:\n                # Early stop if no improvement for a significant amount of iterations\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    PathPlanning: An improved RRT-inspired algorithm that integrates goal biasing and a rewiring step to speed up pathfinding.\n    Unlike vanilla RRT which samples uniformly at random, this algorithm samples the goal position \n    with a fixed probability to bias growth towards the goal, improving convergence speed. \n    It also implements a rewiring step similar to RRT*, where newly added vertices attempt to \n    reconnect nearby vertices through them if it creates a shorter and valid path. \n    This reduces overall path cost and improves solution quality. \n    Additionally, a timeout of 30 seconds is enforced to terminate the search if no path is found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Needed for rewiring\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_sample_rate=0.1) -> Point:\n        # With probability goal_sample_rate, sample the goal directly\n        if np.random.rand() < goal_sample_rate:\n            return self._get_grid().goal.position\n        # Otherwise sample randomly\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _nearest_vertices_within_radius(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Return all vertices within radius of q_new\n        near_vertices: List[Vertex] = []\n        for v in self._graph.vertices:\n            if torch.norm(v.position.to_tensor() - q_new.position.to_tensor()) <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_near: Vertex, q_new: Vertex) -> Vertex:\n        # Select the best parent vertex from near_vertices for q_new\n        # Best = minimal cost path through near vertex to q_new with a valid connection\n        min_cost = None\n        best_parent = q_near\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = self._graph.get_cost_to_root(v) + torch.norm((q_new.position.to_tensor() - v.position.to_tensor()))\n            if (min_cost is None) or (cost < min_cost):\n                min_cost = cost\n                best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Try to rewire near vertices through q_new if it improves cost and path is valid\n        cost_to_q_new = self._graph.get_cost_to_root(q_new)\n        for v in near_vertices:\n            if v == q_new.parents[0] if q_new.parents else None:\n                continue  # Skip current parent\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_through_q_new = cost_to_q_new + torch.norm((v.position.to_tensor() - q_new.position.to_tensor()))\n            current_cost = self._graph.get_cost_to_root(v)\n            if cost_through_q_new < current_cost:\n                self._graph.rewire_vertex(v, q_new)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        # Connect q_new to goal vertex if possible\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n            self._graph.add_edge(q_new, goal_v)\n        else:\n            # If direct connection invalid, try to find nearest vertex near goal to connect\n            q_goal_near: Vertex = self._graph.get_nearest_vertex(self._graph.vertices, goal_v.position)\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_goal_near.position, goal_v.position)):\n                self._graph.add_edge(q_goal_near, goal_v)\n            else:\n                # Cannot connect goal, fallback to using q_new as path end\n                pass\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]  # remove root which has no parent\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        max_dist: float = 10\n        iterations: int = 10000\n        radius_rewire: float = 15  # radius to consider neighbors for rewiring\n\n        for i in range(iterations):\n            if time.time() - start_time > 30.0:  # 30 seconds timeout\n                # terminate path search - no path found\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=0.1)\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check if path from q_near to q_new is valid\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices within radius for rewiring and parent selection\n            near_vertices: List[Vertex] = self._nearest_vertices_within_radius(q_new, radius_rewire)\n\n            # Choose best parent for q_new among near_vertices (including q_near)\n            best_parent: Vertex = self._choose_parent(near_vertices, q_near, q_new)\n            self._graph.add_edge(best_parent, q_new)  # add edge from best_parent to q_new\n\n            # Rewire near vertices through q_new if beneficial\n            self._rewire(near_vertices, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This algorithm is an improved version of RRT-Connect that integrates goal biasing and adaptive max extension distance to speed up convergence. It biases sampling towards the goal with a probability to quickly explore the area near the goal while still exploring uniformly otherwise. Additionally, it adapts the extension distance based on the remaining distance to the goal to avoid overshooting and improve connection attempts. It also limits the search duration to 30 seconds to handle cases where no path is found efficiently.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float  # probability to sample goal to bias\n    _timeout_seconds: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% samples towards goal (goal bias)\n        self._timeout_seconds = 30.0  # timeout in seconds for path search\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Sample the goal position with goal_sample_rate probability, otherwise uniform random sample.\n        \"\"\"\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _adaptive_max_dist(self, q_near: Vertex, q_sample: Point) -> float:\n        \"\"\"\n        Adapt the max extension distance depending on distance toward q_sample.\n        Uses the minimum of predefined max_dist and the straight-line distance.\n        \"\"\"\n        dist = torch.norm(q_sample.to_tensor() - q_near.position.to_tensor()).item()\n        return min(self._max_dist, dist)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adaptive_max_dist = self._adaptive_max_dist(self._q_near, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, adaptive_max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from q_new (mid to goal) and from extension target (start to mid)\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            # check timeout\n            if (time.time() - start_time) > self._timeout_seconds:\n                # treat as no path found; just exit\n                break\n\n            q_rand: Point = self._get_biased_sample()\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Sample-Based Path Planning using RRT* inspired approach.\n    This algorithm enhances SPRM by incrementally building a tree rooted at the agent's position,\n    extending towards random samples with a rewiring step to optimize path quality.\n    It uses a fixed maximum radius to connect new vertices to existing ones,\n    enabling faster convergence towards the goal and reduced overall runtime.\n\n    The algorithm stops once the goal is connected and the path is found, or after a 30 seconds timeout.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow edge rewiring for optimization in RRT* style\n        self._init_displays()\n\n    def _near(self, vertex: Vertex) -> List[Vertex]:\n        return self._graph.get_vertices_within_radius(self._graph.vertices, vertex.position, self._max_radius)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _choose_parent(self, q_new: Vertex, neighbors: List[Vertex]) -> Vertex:\n        # Choose the neighbor with minimal cost + cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if grid.is_valid_line_sequence(grid.get_line_sequence(neighbor.position, q_new.position)):\n                cost_to_neighbor = self._graph.get_cost_from_root(neighbor)\n                edge_cost = torch.dist(q_new.position.to_tensor(), neighbor.position.to_tensor()).item()\n                cost = cost_to_neighbor + edge_cost\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = neighbor\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        grid = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor is q_new:\n                continue\n            if grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, neighbor.position)):\n                new_cost = self._graph.get_cost_from_root(q_new) + torch.dist(q_new.position.to_tensor(), neighbor.position.to_tensor()).item()\n                old_cost = self._graph.get_cost_from_root(neighbor)\n                if new_cost < old_cost:\n                    if neighbor in q_new.connectivity:\n                        self._graph.remove_edge(neighbor, neighbor.connectivity[q_new])\n                    # remove old parent edge\n                    for par in self._graph.vertices:\n                        if neighbor in par.connectivity and par.connectivity[neighbor] == neighbor:\n                            self._graph.remove_edge(par, neighbor)\n                    # add edge from q_new to neighbor\n                    self._graph.add_edge(q_new, neighbor)\n                    self._graph.add_edge(neighbor, q_new)\n                    self.key_frame()\n\n    def _extract_path(self) -> None:\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        # Reconstruct path by following connectivity towards goal, assuming connectivity is dict of {destination: next_vertex}\n        current_vertex = agent\n        path: List[Vertex] = []\n        while current_vertex != goal:\n            if goal not in current_vertex.connectivity:\n                # Path incomplete, stop extraction\n                break\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # Initialize tree with start vertex already in graph (assumed by gen_cyclic_graph)\n        self._graph.clear_connectivity()\n        self._graph.root_vertices = [agent, goal]\n        self._graph.vertices = [agent, goal] + self._graph.vertices  # include all vertices\n\n        # Initialize connectivity for root\n        agent.connectivity = {}\n        goal.connectivity = {}\n\n        max_iterations = 10000  # maximum iteration limit for safety\n\n        for _iter in range(max_iterations):\n            if time.time() - start_time > 30:\n                # Timeout exceeded; no path found\n                return\n\n            q_rand_pos = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex(q_rand_pos)\n            q_new = self._get_new_vertex(q_near, q_rand_pos, self._max_radius)\n\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            neighbors = self._near(q_new)\n            parent = self._choose_parent(q_new, neighbors)\n            if parent is None:\n                continue\n\n            self._graph.add_vertex(q_new)\n            self._graph.add_edge(parent, q_new)\n            self._graph.add_edge(q_new, parent)\n            self.key_frame()\n\n            # Rewire neighbors to q_new if it improves cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new can connect to goal\n            if torch.dist(q_new.position.to_tensor(), goal.position.to_tensor()).item() <= self._max_radius:\n                line_seq_goal = self._get_grid().get_line_sequence(q_new.position, goal.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_goal):\n                    self._graph.add_edge(q_new, goal)\n                    self._graph.add_edge(goal, q_new)\n                    self.key_frame()\n                    # Update connectivity to reflect root connectivity to goal\n                    self._graph.update_all_connectivity()\n                    if goal in agent.connectivity:\n                        self._extract_path()\n                        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved sampling-based path planner inspired by RRT*, \ncalled Informed RRT*. The main enhancement is focusing sampling within an ellipsoidal \ninformed subset of the state space once an initial solution is found, which converges \nfaster towards an optimal solution by reducing unnecessary exploration. It also adds a \ntimeout mechanism to terminate search if a path is not found within 30 seconds. \n\nKey improvements over RRT* include:\n- Biased informed sampling within a prolate hyperspheroid defined by the best solution cost.\n- Dynamic radius calculation for neighbor searching based on graph size.\n- Early pruning and rewiring to expedite convergence.\n\nThe algorithm reuses helper functions from the base classes and integrates with the \nexisting map, graph, and vertex structures.\n\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self.best_cost: Optional[float] = None\n        self.best_vertex: Optional = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_informed(self, start: Point, goal: Point, c_best: float, c_min: float) -> Point:\n        \"\"\"\n        Samples a point uniformly from the ellipsoidal informed subset defined by c_best.\n        \"\"\"\n        if c_best == float('inf') or c_best < c_min:\n            # No solution found yet or invalid, sample uniformly over entire space\n            return self._get_random_sample()\n\n        # Compute ellipsoid parameters\n        goal_np = np.array(goal.to_list())\n        start_np = np.array(start.to_list())\n        c = c_best\n        # Ellipse major axis length\n        a1 = (goal_np - start_np) / np.linalg.norm(goal_np - start_np)\n        M = np.eye(len(start_np))\n        if len(start_np) == 2:\n            # 2D rotation aligning x axis with start->goal vector\n            angle = math.atan2(a1[1], a1[0])\n            R = np.array([[math.cos(angle), -math.sin(angle)],\n                          [math.sin(angle),  math.cos(angle)]])\n        else:\n            # In higher dims, just identity (fallback)\n            R = np.eye(len(start_np))\n\n        r1 = c / 2.0\n        rn = math.sqrt(c * c - c_min * c_min) / 2.0\n        L = np.diag([r1] + [rn]*(len(start_np)-1))\n\n        while True:\n            # Sample unit ball\n            x_ball = self._sample_unit_ball(len(start_np))\n            # Sample informed sample in world frame\n            sample_np = R @ L @ x_ball + (start_np + goal_np) / 2.0\n            sample_pt = Point(*np.round(sample_np).astype(int))\n            if self._get_grid().is_agent_valid_pos(sample_pt):\n                return sample_pt\n\n    def _sample_unit_ball(self, dim: int) -> np.ndarray:\n        \"\"\"\n        Uniformly sample a point from unit n-ball using normal distribution method.\n        \"\"\"\n        x = np.random.normal(0, 1, dim)\n        x /= np.linalg.norm(x)\n        r = np.random.rand() ** (1/dim)\n        return r * x\n\n    def _extract_path(self, q_new: 'Vertex'):\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2  # assumes 2D map\n        start_v = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n        start_pos = self._get_grid().agent.position\n        c_min = torch.norm(start_pos.to_tensor() - goal_pos.to_tensor()).item()\n        c_best = float('inf')\n        best_vertex = None\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Timeout: Path not found\n                if self.testing is not None:\n                    self.testing.log(\"Path planning timeout: no path found within 30 seconds.\")\n                break\n\n            if best_vertex is None:\n                # Sample uniformly before any solution\n                q_sample = self._get_random_sample()\n            else:\n                # Sample inside ellipsoidal informed subset\n                q_sample = self._sample_informed(start_pos, goal_pos, c_best, c_min)\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), max_radius)\n\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min_local = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Choose parent with minimum cost + check collision\n            for q_near in Q_near:\n                line_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if line_free and cost_new < c_min_local:\n                    q_min = q_near\n                    c_min_local = cost_new\n\n            child_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire near vertices if new cost is better\n            for q_near in Q_near:\n                line_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_through_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if line_free and cost_through_new < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                    q_near.cost = cost_through_new\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex is in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and best vertex for informed sampling\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < c_best:\n                    c_best = total_cost\n                    best_vertex = q_new\n                    self.best_cost = c_best\n                    self.best_vertex = best_vertex\n\n                # Extract path immediately for visualization and return\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved version of RRT called RRT-Connect. \nIt grows two trees simultaneously: one rooted at the start position and another at the goal.\nEach iteration samples a random point, tries to extend the start tree toward it,\nthen tries to connect the goal tree to the newly added vertex in the start tree.\nThe connection attempts allow faster convergence and path finding by connecting the two trees.\nThe implementation includes a timeout of 30 seconds to abort if no route is found in time.\nThis approach typically improves time efficiency compared to plain RRT in complex spaces.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n        # Two forests for bidirectional trees\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        # For displaying start tree graph\n        self._graph = self._graph_start  \n        self._init_displays()  \n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _connect_trees(self, tree_from: Forest, tree_to: Forest, q_near: Vertex, max_dist: float) -> (bool, Vertex):\n        \"\"\"\n        Try to connect tree_to to q_near expansion vertex in tree_from.\n        Incrementally grow tree_to towards q_near until it reaches or no progress.\n        Returns (connected, q_new) where connected indicates trees connected.\n        \"\"\"\n        current_vertex = tree_to.get_nearest_vertex([tree_to.root_vertex_start], q_near.position)\n        while True:\n            q_new = self._get_new_vertex(current_vertex, q_near.position, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(current_vertex.position, q_new.position)):\n                return False, q_new\n            tree_to.add_edge(current_vertex, q_new)\n            self.key_frame()\n            if q_new.position == q_near.position:\n                return True, q_new\n            current_vertex = q_new\n\n    def _extract_bidirectional_path(self, conn_vertex_start: Vertex, conn_vertex_goal: Vertex):\n        \"\"\"\n        Extracts path from start tree root to conn_vertex_start,\n        and from goal tree root to conn_vertex_goal.\n        Then concatenates them into a complete path from start to goal.\n        Moves agent along the found path with animation key frames.\n        \"\"\"\n        # Path from start root to connection vertex\n        path_start = [conn_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            for p in path_start[-1].parents:\n                path_start.append(p)\n                break\n        path_start.reverse()\n\n        # Path from goal root to connection vertex\n        path_goal = [conn_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            for p in path_goal[-1].parents:\n                path_goal.append(p)\n                break\n\n        # Combined path: start->connection + connection->goal (reverse)\n        full_path = path_start + path_goal\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Combine displays from both trees (start and goal)\n        displays = super().set_display_info()\n        # Add display for goal tree\n        goal_tree_display = [GraphMapDisplay(self._services, self._graph_goal)]\n        return displays + goal_tree_display\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 10000\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            if time.time() - start_time > 30.0:\n                # Timeout: no path found within 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n            # Extend start tree towards sample\n            q_near_start: Vertex = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            if q_near_start.position == q_sample:\n                continue\n            q_new_start: Vertex = self._get_new_vertex(q_near_start, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)):\n                continue\n            self._graph_start.add_edge(q_near_start, q_new_start)\n            self.key_frame()\n\n            # Try to connect goal tree to q_new_start\n            connected, q_new_goal = self._connect_trees(self._graph_start, self._graph_goal, q_new_start, max_dist)\n            if connected:\n                # Path connected - extract the path and move agent\n                self._extract_bidirectional_path(q_new_start, q_new_goal)\n                break\n\n            # Swap role: extend goal tree towards random sample\n            q_near_goal: Vertex = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample)\n            if q_near_goal.position == q_sample:\n                continue\n            q_new_goal: Vertex = self._get_new_vertex(q_near_goal, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)):\n                continue\n            self._graph_goal.add_edge(q_near_goal, q_new_goal)\n            self.key_frame()\n\n            # Try to connect start tree to q_new_goal\n            connected, q_new_start = self._connect_trees(self._graph_goal, self._graph_start, q_new_goal, max_dist)\n            if connected:\n                self._extract_bidirectional_path(q_new_start, q_new_goal)\n                break\n\n# End of PathPlanning class ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This improved path planning algorithm is based on RRT* (Rapidly-exploring Random Tree Star),\n    an optimization of RRT that rewires the tree to find shorter paths and improve convergence time.\n    Key enhancements:\n    - Incorporates a radius-based neighborhood search to rewire edges for better paths.\n    - Limits maximum iterations to prevent infinite loops.\n    - Aborts the search if time exceeds 30 seconds.\n    - Uses a heuristic bias sampling near goal with some probability to speed convergence.\n    - Retains the core sampling and validation methods from RRT.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an Improved RRT-Connect named PathPlanning that accelerates pathfinding by incorporating goal-bias sampling \n    and adaptive maximum extension distance adjustment based on progress. \n    \n    The backbone idea is to maintain two trees growing from start and goal, extending them towards randomly sampled points, but with an increased \n    probability of sampling the goal directly to speed up convergence. Additionally, the maximum extension distance dynamically adjusts \n    depending on recent success in extension (adaptive step size), allowing faster traversal in open spaces and finer exploration near obstacles. \n    \n    The search aborts if no path is found within 30 seconds for timely response.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n    _start_time: float\n    _max_extension_attempts: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 15.0           # Start with larger step length for faster exploration\n        self._iterations = 100000       # Allow large iterations, but time limited\n        self._goal_sample_rate = 0.2    # 20% chance sample goal directly to bias growth\n        self._max_extension_attempts = 5 # Number of consecutive successful extensions before increasing step size\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_goal_sample(self) -> Point:\n        \"\"\"Return the goal position directly as a sample.\"\"\"\n        return self._get_grid().goal.position\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Sample goal directly with probability goal_sample_rate, else sample randomly.\"\"\"\n        import random\n        if random.random() < self._goal_sample_rate:\n            return self._get_goal_sample()\n        else:\n            return super()._get_random_sample()\n\n    def _adjust_max_dist(self, success: bool, consecutive_successes: int) -> float:\n        \"\"\"\n        Adjust maximum distance dynamically based on extension success.\n        Increase max_dist on consecutive successes to speed exploration,\n        decrease on failure for finer exploration near obstacles.\n        \"\"\"\n        max_dist_min = 5.0\n        max_dist_max = 20.0\n        \n        if success:\n            if consecutive_successes >= self._max_extension_attempts:\n                new_max_dist = min(self._max_dist + 2.0, max_dist_max)\n            else:\n                new_max_dist = self._max_dist\n        else:\n            new_max_dist = max(self._max_dist * 0.7, max_dist_min)\n        return new_max_dist\n\n    def _extract_path(self) -> None:\n        # Reuse the same extraction path from RRT_Connect\n\n        # trace back from _q_new to root in second tree\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            for parent in path_mid_to_b[-1].parents:\n                path_mid_to_b.append(parent)\n                break\n\n        # trace back from _extension_target to root in first tree\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n        consecutive_successes = 0\n\n        for i in range(self._iterations):\n            current_time = time.time()\n            if (current_time - start_time) > 30.0:\n                # Timeout after 30 seconds: treat route as not found\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            extend_status = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_status != 'trapped':\n                consecutive_successes +=1\n                self._extension_target = self._q_new\n\n                connect_status = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_status == 'reached':\n                    self._extract_path()\n                    break\n            else:\n                consecutive_successes = 0\n\n            # Adjust max_dist adaptively based on success or failure\n            self._max_dist = self._adjust_max_dist(extend_status != 'trapped', consecutive_successes)\n\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"This algorithm is an improved version of the SPRM sample-based planner called \\\"Informed SPRM\\\". \"\n    \"It accelerates the search by focusing sampling within an ellipsoidal subset of the configuration \"\n    \"space that contains paths shorter than the current best path length, inspired by informed sampling \"\n    \"principles (used in algorithms like Informed RRT*). By adaptively limiting samples to regions more \"\n    \"likely to improve the solution, the algorithm reduces unnecessary explorations and converges faster. \"\n    \"It terminates either when a path is found or when 30 seconds have elapsed.\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Reuse SPRM parameters\n        self._V_size = 200\n        self._max_radius = 15\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            # Initialize samples uniformly initially (will be replaced in _find_path_internal with informed sampling)\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n        # Track best path cost found, start with infinity\n        self._best_cost = float(\"inf\")\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _euclidean_distance(self, p1: Point, p2: Point) -> float:\n        diff = p1.to_tensor() - p2.to_tensor()\n        return float(torch.norm(diff).item())\n\n    def _in_ellipse(self, point: Point, start: Point, goal: Point, c_best: float) -> bool:\n        # If no solution yet found, all space is valid\n        if c_best == float(\"inf\"):\n            return True\n        # Compute focal points distances\n        c_min = self._euclidean_distance(start, goal)\n        if c_best < c_min:\n            # should never happen but treat as no restriction\n            return True\n        a = c_best / 2.0\n        b = math.sqrt(c_best**2 - c_min**2) / 2.0\n        # Coordinate transform so ellipse is center at midpoint and major axis along start->goal\n        midpoint = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2.0)\n        dir_vec = (goal.to_tensor() - start.to_tensor()) / c_min  # normalized\n        # translate point to ellipse frame\n        p_prime = point.to_tensor() - midpoint.to_tensor()\n        # project p_prime into ellipse axes\n        x_proj = torch.dot(p_prime, dir_vec)\n        # perpendicular distance magnitude\n        y_vec = p_prime - x_proj * dir_vec\n        y_proj = torch.norm(y_vec)\n        # ellipse equation (x^2/a^2 + y^2/b^2 <= 1)\n        val = (x_proj.item() ** 2) / (a * a) + (y_proj.item() ** 2) / (b * b)\n        return val <= 1.0\n\n    def _sample_informed(self, c_best: float) -> Point:\n        \"\"\"\n        Samples only within the defined ellipsoidal informed set around start and goal when c_best is finite.\n        Uses rejection sampling on the bounding rectangle.\n        If c_best is inf, sample uniformly in free space.\n        \"\"\"\n        start = self._graph.root_vertices[0].position\n        goal = self._graph.root_vertices[1].position\n        if c_best == float(\"inf\"):\n            return self._get_random_sample()\n\n        c_min = self._euclidean_distance(start, goal)\n        # Ellipsoid major axis half length (a) and minor axis half length (b)\n        a = c_best / 2.0\n        b_sq = c_best ** 2 - c_min ** 2\n        if b_sq < 0:\n            # Numerical safety fallback\n            b_sq = 0.0\n        b = math.sqrt(b_sq) / 2.0\n\n        # Get bounding box corners for sampling\n        midpoint = Point.from_tensor((start.to_tensor() + goal.to_tensor()) / 2.0)\n        dir_vec = (goal.to_tensor() - start.to_tensor()) / c_min  # normalized\n        # Orthogonal direction in 2D or 3D (pick any orthogonal vector)\n        # For n-D: create basis so that dir_vec is first basis vector\n        # For simplicity, we'll do this only for 2D environments\n        if self._get_grid().size.n_dim == 2:\n            # perpendicular vector in 2D\n            ortho_vec = torch.tensor([-dir_vec[1].item(), dir_vec[0].item()])\n        else:\n            # fallback no informed sample for > 2D (uniform)\n            return self._get_random_sample()\n\n        max_attempts = 1000\n        attempts = 0\n        while attempts < max_attempts:\n            # Sample uniformly in bounding box of ellipse\n            x = torch.empty(1).uniform_(-a, a).item()\n            y = torch.empty(1).uniform_(-b, b).item()\n            sample_pos = midpoint.to_tensor() + x * dir_vec + y * ortho_vec\n            sample_point = Point.from_tensor(sample_pos)\n\n            # Check if inside map and free\n            if 0 <= sample_point.x < self._get_grid().size[0] and 0 <= sample_point.y < self._get_grid().size[1]:\n                if self._get_grid().is_agent_valid_pos(sample_point):\n                    # Final check: in ellipse (reapply precise)\n                    if self._in_ellipse(sample_point, start, goal, c_best):\n                        return sample_point\n            attempts += 1\n        # fallback if no informed sample found\n        return self._get_random_sample()\n\n    def _extract_path_with_cost(self):\n        goal_vertex: Vertex = self._graph.root_vertices[1]\n        agent_vertex: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent_vertex\n        path = [current_vertex]\n        total_cost = 0.0\n        while current_vertex is not goal_vertex:\n            if goal_vertex not in current_vertex.connectivity:\n                # No path\n                return [], float(\"inf\")\n            next_vertex = current_vertex.connectivity[goal_vertex]\n            # Sum cost as Euclidean between consecutive vertices\n            cost_segment = self._euclidean_distance(current_vertex.position, next_vertex.position)\n            total_cost += cost_segment\n            current_vertex = next_vertex\n            path.append(current_vertex)\n\n        return path, total_cost\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        max_duration = 30.0  # seconds timeout\n\n        start_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Re-initialize vertex set with informed samples (except start and goal)\n        V: List[Vertex] = list()\n        for _ in range(self._V_size):\n            sample_point = self._sample_informed(self._best_cost)  # informed sampling\n            V.append(Vertex(sample_point, store_connectivity=True))\n\n        self._graph = gen_cyclic_graph(self._services,\n                                       start_vertex,\n                                       goal_vertex,\n                                       V)\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        for v in self._graph.root_vertices + V:\n            U = self._graph.get_vertices_within_radius(self._graph.root_vertices, v.position, self._max_radius)\n            for u in U:\n                if u is v:\n                    continue\n                line_seq = self._get_grid().get_line_sequence(u.position, v.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    self._graph.add_edge(v, u)\n                    self._graph.add_edge(u, v)\n                    self.key_frame()\n\n                    # Check connectivity to goal\n                    if goal_vertex in start_vertex.connectivity:\n                        path, cost = self._extract_path_with_cost()\n                        if path and cost < self._best_cost:\n                            self._best_cost = cost\n                            for p in path[1:]:  # exclude start vertex position\n                                self.move_agent(p.position)\n                                self.key_frame(ignore_key_frame_skip=True)\n                            return\n\n            # Early stop check for timeout\n            if time.time() - start_time > max_duration:\n                # Terminate as no solution found within time\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This is an improved sample-based path planning algorithm named PathPlanning,\n    inspired by RRT*. It integrates goal-biased sampling and adaptive rewiring radius\n    to improve convergence speed and solution quality. The algorithm biases sampling\n    towards the goal with a fixed probability, focuses rewiring radius based on current \n    graph size, and includes early termination if no path is found in 30 seconds.\n    These improvements aim to reduce search time while maintaining path optimality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member variable to control goal biasing chance (20%)\n        self._goal_bias_probability: float = 0.2\n        # We keep a start time to check timeout in path search\n        self._start_time: float = 0.0\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Reuse the displays initialization\n        return super().set_display_info()\n\n    # Helper function to get a random sample with goal bias\n    def _get_random_sample(self) -> Point:\n        if np.random.random() < self._goal_bias_probability:\n            # Directly sample the goal position to bias sampling\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n\n        # Otherwise sample uniformly random valid position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Helper to compute adaptive rewiring radius based on graph size and dimension\n    def _compute_radius(self, n_vertices: int, dimension: int, max_radius: float, lambda_rrt_star: float) -> float:\n        card_v = torch.tensor(float(n_vertices))\n        log_card_v = torch.log(card_v) if card_v > 1 else torch.tensor(0.0)\n        radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n        return radius.item()\n\n    # Extract path identical to RRT_Star base but moved here to maintain encapsulation\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        self._start_time = time.time()\n\n        for i in range(iterations):\n\n            # Check timeout condition (max 30 seconds)\n            if time.time() - self._start_time > 30.0:\n                # Timeout reached, stop search without path found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            # Adaptive radius calculation based on current graph size\n            radius = self._compute_radius(self._graph.size, dimension, max_radius, lambda_rrt_star)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Find best parent to minimize cost\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if better path found through q_new\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if in goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved variant of RRT-Connect by integrating a heuristic-guided sampling to accelerate convergence.\n    Instead of purely random samples, it biases sampling towards the line connecting start and goal positions and occasionally performs uniform \n    random sampling to maintain exploration. It also implements a timeout to abandon search if it exceeds 30 seconds, improving responsiveness.\n    The core RRT-Connect backbone is retained, leveraging dual trees grown from start and goal, but enhanced by the guided sampling \n    strategy and a shorter maximum extension distance to encourage finer growth steps.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _sampling_bias_ratio: float\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 8.0  # slightly smaller step size for finer growth\n        self._iterations = 10000\n        self._sampling_bias_ratio = 0.7  # 70% samples biased toward goal direction\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _heuristic_sample(self) -> Point:\n        \"\"\"\n        Generate a sample biased along the line from agent to goal with some uniform random noise.\n        This accelerates the tree growth toward the goal.\n        \"\"\"\n        grid = self._get_grid()\n        start = grid.agent.position.to_tensor()\n        goal = grid.goal.position.to_tensor()\n\n        if np.random.rand() < self._sampling_bias_ratio:\n            # Biased sampling along line from start to goal with random interpolation factor and slight noise\n            t = np.random.uniform(0, 1)\n            dir_vector = goal - start\n            sample_tensor = start + t * dir_vector\n            \n            # Add small Gaussian noise around sample point\n            noise = torch.randn(sample_tensor.shape) * (self._max_dist / 2)\n            sample_tensor_noisy = sample_tensor + noise\n\n            sample_pos = Point.from_tensor(sample_tensor_noisy)\n            # Clamp to grid bounds\n            clamped_coords = []\n            for dim, val in enumerate(sample_pos):\n                val_int = int(round(val))\n                val_clamped = max(0, min(val_int, grid.size[dim] - 1))\n                clamped_coords.append(val_clamped)\n            sample_point = Point(*clamped_coords)\n        else:\n            # Uniform random sample\n            sample_point = self._get_random_sample()\n\n        # Validity check\n        if grid.is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # If invalid, fallback to uniform random sample until valid\n            for _ in range(10):\n                sp = self._get_random_sample()\n                if grid.is_agent_valid_pos(sp):\n                    return sp\n            return grid.agent.position  # fallback to current position (degenerate)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:  # timeout after 30 secs\n                # Mark no path found by skipping _extract_path and breaking\n                break\n\n            q_rand: Point = self._heuristic_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an improved variant of the classic RRT.\n    It incorporates goal biasing to sample the goal with a certain probability, \n    accelerating convergence towards the goal.\n    Additionally, it uses an adaptive maximum extension distance that shrinks as it approaches the goal\n    to improve path accuracy in the goal region.\n    It limits the search to 30 seconds, after which it terminates as no path found.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planner inspired by RRT*,\n    called Informed RRT*. It improves search time by focusing sampling efforts \n    on the prolate hyperspheroid that bounds the current best solution path, \n    thus accelerating convergence towards an optimal path.\n    Additionally, a timeout of 30 seconds is enforced to terminate search if no path \n    is found within this time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialized as None; holds the best goal vertex found so far\n        self._best_goal_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipsoid(self, center: Point, c_best: float, c_min: float, unit_vector: torch.Tensor) -> Point:\n        \"\"\"\n        Samples a point uniformly from within the prolate hyperspheroid defined by\n        foci at start and goal, with sum of distances to foci less than c_best.\n        \"\"\"\n        dimension = 2\n        if c_best == float(\"inf\"):\n            # No solution yet; uniform sampling over the free space\n            return self._get_random_sample()\n        \n        # Semi-major axis\n        a1 = c_best / 2.0\n        # Distance between foci\n        f = c_min / 2.0\n        # Semi-minor axes\n        if a1**2 - f**2 <= 0:\n            # Numerical tolerance fallback, sample uniformly\n            return self._get_random_sample()\n        b = math.sqrt(a1**2 - f**2)\n        \n        # Sample random point in unit ball\n        while True:\n            # Uniform sample in unit ball in 2D\n            x = random.uniform(-1,1)\n            y = random.uniform(-1,1)\n            if x*x + y*y <=1:\n                unit_ball = torch.tensor([x,y], dtype=torch.float32)\n                break\n        \n        # Scale to ellipsoid space\n        L = torch.diag(torch.tensor([a1, b], dtype=torch.float32))\n        sample_tensor = torch.matmul(L, unit_ball)\n        # Rotate sample to align with start-goal vector and translate to center\n        sample_rotated = torch.matmul(unit_vector.unsqueeze(1), sample_tensor.unsqueeze(0)).squeeze(1)\n        sample_pos = sample_rotated + center.to_tensor()\n        sample_point = Point.from_tensor(sample_pos.round())\n        \n        # Verify sample is valid in environment\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        \n        # Fallback uniform sampling if ellipsoid sample invalid\n        return self._get_random_sample()\n\n    def _extract_path(self, q_new):\n        # Same as in provided RRT_Star implementation\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 10000\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension = 2\n        start_t = time.time()\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        # Distance from start to goal (Euclidean)\n        c_min = torch.norm(start_vertex.position.to_tensor() - goal_pos.to_tensor()).item()\n        c_best = float(\"inf\")  # Best path cost found so far\n\n        # Unit vector from start to goal for ellipsoid alignment\n        vec_start_goal = (goal_pos.to_tensor() - start_vertex.position.to_tensor())\n        norm_vec = torch.norm(vec_start_goal)\n        unit_vector = vec_start_goal / norm_vec if norm_vec > 0 else torch.tensor([1.0,0.0])\n\n        for i in range(iterations):\n            if time.time() - start_t > 30.0:  # Timeout condition: fail if no path found in 30 sec\n                # Optionally indicate failure by not moving agent further\n                break\n\n            # Sample in informed ellipsoid or uniformly\n            q_sample: Point = self._sample_in_ellipsoid((start_vertex.position + goal_pos) * 0.5, c_best, c_min, unit_vector)\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        q_near.cost = None\n                        self._graph.remove_edge(q_parent, q_near)\n                        child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        q_near.cost = q_new.cost + child_parent_dist\n                        self._graph.add_edge(q_new, q_near)\n\n            # Update best solution if improved\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                if q_new.cost < c_best:\n                    c_best = q_new.cost\n                    self._best_goal_vertex = q_new\n                    self._extract_path(q_new)\n                    # Switch to stricter focus on ellipsoid sampling around new best\n                    # Continue searching to improve path if time permits\n\n            self.key_frame()\n\n        # If after iterations or timeout, a path was found (best goal vertex saved), extract and follow it\n        if self._best_goal_vertex is not None:\n            self._extract_path(self._best_goal_vertex) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm based on PRM with informed sampling\n    inspired by RRT* principles to reduce time complexity.\n\n    Instead of blindly connecting vertices in a cyclic graph, this algorithm:\n    - Uses dynamic sampling focused around the current best path to goal (informed sampling).\n    - Employs rewiring to connect new vertices in an optimal way, reducing redundant edges.\n    - Uses a priority-based expansion approach leveraging a cost metric (distance + heuristic)\n      for faster convergence.\n    - Stops search if no path is found within 30 seconds.\n\n    This avoids exhaustive connection attempts and accelerates path finding on large maps.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: CyclicGraph\n    _V_size: int\n    _max_radius: float\n    _goal_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._V_size = 200\n        self._max_radius = 20.0  # slightly larger radius for connections\n        self._goal_radius = 10.0  # radius around goal to bias sampling\n        # Initialize sampled vertices\n        V: List[Vertex] = list()\n        for i in range(self._V_size):\n            q_rand: Point = self._get_random_sample()\n            V.append(Vertex(q_rand, store_connectivity=True))\n        self._graph = gen_cyclic_graph(self._services,\n                                       Vertex(self._get_grid().agent.position, store_connectivity=True),\n                                       Vertex(self._get_grid().goal.position, store_connectivity=True),\n                                       V)\n        self._graph.edges_removable = True  # Allow rewiring\n        self._init_displays()\n\n    def _heuristic(self, p: Point, q: Point) -> float:\n        # Euclidean distance heuristic\n        return torch.norm(p.to_tensor() - q.to_tensor()).item()\n\n    def _near(self, vertex: Vertex, vertices: List[Vertex], radius: float) -> List[Vertex]:\n        # Return vertices within radius of vertex.position\n        close = list()\n        for v in vertices:\n            dist = torch.norm(vertex.position.to_tensor() - v.position.to_tensor())\n            if dist <= radius and v is not vertex:\n                close.append(v)\n        return close\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Bias sampling: \n        With 20% probability sample close to goal within a smaller radius\n        Otherwise uniform random sample\n        \"\"\"\n        goal_pos = self._get_grid().goal.position\n        grid_size = self._get_grid().size\n        prob_goal_bias = 0.2\n\n        if torch.rand(1).item() < prob_goal_bias:\n            # sample around goal within goal_radius\n            for _ in range(50):\n                delta = torch.randint(-int(self._goal_radius), int(self._goal_radius) + 1, (grid_size.n_dim,))\n                sample_coords = goal_pos.to_tensor() + delta\n                # Clip to grid bounds\n                for i in range(grid_size.n_dim):\n                    sample_coords[i] = torch.clamp(sample_coords[i], 0, grid_size[i] - 1)\n                sample = Point.from_tensor(sample_coords)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        # uniform sample fallback\n        while True:\n            sample = Point(*[torch.randint(0, grid_size[i], (1,)).item() for i in range(grid_size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as SPRM: clip to max_dist from q_near towards q_sample\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample, store_connectivity=True)\n        dir_normalized = dir / dist\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos, store_connectivity=True)\n\n    def _choose_parent(self, q_new: Vertex, near_vertices: List[Vertex]) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent for q_new among near_vertices that produce a valid edge\n        with the lowest cost-to-come + edge cost.\n        \"\"\"\n        min_cost = float('inf')\n        best_vertex = None\n        for q_near in near_vertices:\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                cost_to_near = self._graph.get_cost_to_vertex(q_near)\n                if cost_to_near is None:\n                    continue\n                edge_cost = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n                total_cost = cost_to_near + edge_cost\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_vertex = q_near\n        return best_vertex\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Try to rewire near vertices through q_new if it reduces their path cost.\n        \"\"\"\n        cost_q_new = self._graph.get_cost_to_vertex(q_new)\n        if cost_q_new is None:\n            return\n        for q_near in near_vertices:\n            if q_near is q_new:\n                continue\n            if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                cost_to_near = self._graph.get_cost_to_vertex(q_near)\n                edge_cost = torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor()).item()\n                new_cost = cost_q_new + edge_cost\n                if cost_to_near is None or new_cost < cost_to_near:\n                    # Remove existing parent edges to q_near\n                    for parent in list(q_near.connectivity):\n                        self._graph.remove_edge(parent, q_near)\n                    # Add edge from q_new to q_near\n                    self._graph.add_edge(q_new, q_near)\n                    self._graph.add_edge(q_near, q_new)\n                    # Update connectivity with new costs propagated recursively\n                    self._graph.update_connectivity_from_root(q_near)\n\n    def _extract_path(self) -> None:\n\n        goal: Vertex = self._graph.root_vertices[1]\n        agent: Vertex = self._graph.root_vertices[0]\n\n        current_vertex = agent\n        path = list()\n        while current_vertex is not goal:\n            if goal not in current_vertex.connectivity:\n                # Path broken or no path found\n                break\n            current_vertex = current_vertex.connectivity[goal]\n            path.append(current_vertex)\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        agent: Vertex = self._graph.root_vertices[0]\n        goal: Vertex = self._graph.root_vertices[1]\n\n        # Initialize costs to infinity except for agent root\n        for v in self._graph.vertices:\n            v.cost = float('inf')\n        agent.cost = 0.0\n\n        # Priority queue for vertices to expand (cost + heuristic, Vertex)\n        open_set = []\n        heapq.heappush(open_set, (self._heuristic(agent.position, goal.position), agent))\n\n        vertices = self._graph.vertices.copy()\n        vertices_set = set(vertices)\n\n        while open_set:\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout reached, no path found.\n                return\n\n            _, current = heapq.heappop(open_set)\n\n            if current is goal:\n                # Path found, extract it\n                self._extract_path()\n                return\n\n            # Sample new point biased near current on the way to goal\n            q_sample = self._get_random_sample()\n\n            q_new = self._get_new_vertex(current, q_sample, self._max_radius)\n\n            # Check if q_new already in graph by position\n            # If close enough vertex exists, ignore new (avoid duplicates)\n            duplicates = [v for v in vertices if torch.norm(v.position.to_tensor() - q_new.position.to_tensor()) < 1e-3]\n            if duplicates:\n                continue\n\n            # Get neighbors within radius\n            near_vertices = self._near(q_new, vertices, self._max_radius)\n\n            # Choose best parent among near neighbors\n            q_parent = self._choose_parent(q_new, near_vertices + [current])\n\n            if q_parent is None:\n                # No valid parent found, ignore sample\n                continue\n\n            # Add q_new and edge from q_parent to q_new\n            self._graph.add_vertex(q_new)\n            vertices.append(q_new)\n            vertices_set.add(q_new)\n            self._graph.add_edge(q_parent, q_new)\n            self._graph.add_edge(q_new, q_parent)\n\n            # Update cost of q_new\n            cost_to_parent = self._graph.get_cost_to_vertex(q_parent)\n            edge_cost = torch.norm(q_new.position.to_tensor() - q_parent.position.to_tensor()).item()\n            q_new.cost = cost_to_parent + edge_cost\n\n            # Rewire neighbors through q_new if beneficial\n            self._rewire(q_new, near_vertices)\n\n            # Add q_new to open set with priority f = cost + heuristic\n            f_cost = q_new.cost + self._heuristic(q_new.position, goal.position)\n            heapq.heappush(open_set, (f_cost, q_new))\n\n            self.key_frame()\n\n            # If goal is connected in agent's connectivity, path completed\n            if goal in agent.connectivity:\n                self._extract_path()\n                return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Algorithm Description:\n    This is an improved variant of the RRT* algorithm aimed at reducing the running time for path planning.\n    Improvements and modifications include:\n    - Adaptive sampling bias: Increased sampling probability towards the goal region after a certain number of iterations\n      to guide the search more directly towards the goal.\n    - Early stopping timeout: The search terminates if no path is found within 30 seconds.\n    - Caching the goal vertex for rewiring to avoid repeated Vertex creations.\n    - Reduced rewiring radius dynamically shrinking relative to graph size but with a lower bound.\n    - Reduced maximum iterations to balance speed and convergence.\n    These improvements should lead to faster convergence and more efficient exploration whilst maintaining optimality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _goal_vertex: Vertex\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        self._goal_vertex = Vertex(self._get_grid().goal.position)\n        self._graph = gen_forest(self._services, start_vertex, self._goal_vertex, [])\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10\n        max_iterations: int = 6000\n        dimension: int = 2\n        lambda_rrt_star: float = 40  # slightly reduced for adaptive radius\n        max_radius: float = 35\n        min_radius: float = 5  # minimum radius limit\n\n        start_time = time.time()\n\n        for iteration in range(max_iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30:\n                # Timeout reached, no path found within time limit\n                break\n\n            # Adaptive biased sampling: after 30% iterations, sample goal with 20% probability\n            if iteration > int(max_iterations * 0.3) and np.random.rand() < 0.2:\n                q_sample: Point = self._goal_vertex.position\n                # Verify validity of goal sample, else fallback to random sample\n                if not self._get_grid().is_agent_valid_pos(q_sample):\n                    q_sample = self._get_random_sample()\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size if self._graph.size > 0 else 1))\n            log_card_v = torch.log(card_v)\n            radius = max(min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius), min_radius)\n\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose best parent (lowest cost)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_tmp = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_tmp < c_min:\n                        q_min = q_near\n                        c_min = cost_tmp\n\n            # Assign cost and add edge to graph from best parent\n            q_new.cost = c_min\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors if a cheaper path via q_new is found\n            for q_near in Q_near:\n                line_seq_back = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq_back):\n                    cost_through_q_new = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_through_q_new < q_near.cost:\n                        # Remove old parent edge\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        # Add new parent edge\n                        q_near.cost = None\n                        q_near.cost = cost_through_q_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to cached goal vertex if collision free edge\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, self._goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    self._goal_vertex.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_vertex.position.to_tensor())\n                    self._graph.add_edge(q_new, self._goal_vertex)\n                    self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        path: List[Vertex] = [self._goal_vertex]\n        current_vertex = self._goal_vertex\n\n        while len(current_vertex.parents) != 0:\n            # Always pick the first parent (tree structure)\n            current_vertex = current_vertex.parents[0]\n            path.append(current_vertex)\n\n        path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This is an improved path planning algorithm inspired by RRT-Connect. It utilizes a heuristic bias\n    towards the goal to speed up convergence by sampling the goal position with a defined probability,\n    combined with random sampling, thus guiding tree growth more efficiently. It also reduces unnecessary \n    attempts to connect distant points by limiting extensions with adaptive max distances based on progress.\n    A timer enforces a maximum runtime of 30 seconds to abort the search if no path is found in time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize the forest with start and goal vertices\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% of the time sample the goal directly to bias growth\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [SolidIterableMapDisplay(self._services, self._graph)]\n\n    def _get_goal_bias_sample(self) -> Point:\n        \"\"\"\n        Returns a random sample with probability bias towards the goal position\n        \"\"\"\n        from random import random\n        if random() < self._goal_sample_rate:\n            return self._graph.root_vertex_goal.position\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract path from combined trees and move agent along it\n        \"\"\"\n        # Trace back path from connective vertex to root goal\n        path_b_to_mid: List[Vertex] = [self._q_new]\n        while len(path_b_to_mid[-1].parents) != 0:\n            for parent in path_b_to_mid[-1].parents:\n                path_b_to_mid.append(parent)\n                break\n\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            for parent in path_a_to_mid[-1].parents:\n                path_a_to_mid.append(parent)\n                break\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_b_to_mid\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        for i in range(self._iterations):\n            if time.time() - start_time > 30:\n                # Timeout: abort search\n                break\n\n            q_rand: Point = self._get_goal_bias_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame()\n\n    # Reusing helper methods from base or self\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        status = 'advanced'\n        while status == 'advanced':\n            status = self._extend(root_vertex, q.position)\n        return status\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex(self, graph_root_vertex: Vertex, q_sample: Point) -> Vertex:\n        return self._graph.get_nearest_vertex([graph_root_vertex], q_sample)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        direction_normalized = direction / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_normalized)\n        return Vertex(q_new_point) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved path planner inspired by RRT*, which enhances the original RRT algorithm by rewiring the tree to reduce path cost gradually,\n    resulting in shorter and more optimal paths over time. It uses a radius-based neighborhood search to choose better parents for new vertices, rewiring neighbors to reduce cost,\n    and prunes unnecessary edges. Additionally, a goal bias sampling strategy is employed to speed convergence towards the goal.\n    The search terminates either when a path within the goal radius is found or when 30 seconds have elapsed, treating no path found in that case.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services,\n                                 Vertex(self._get_grid().agent.position),\n                                 Vertex(self._get_grid().goal.position),\n                                 [])\n        self._graph.edges_removable = True  # Allow rewiring/removal for RRT*\n        self._init_displays()\n        self._max_dist = 15.0                       # Maximum extension distance\n        self._radius_rewire_factor = 50.0           # Radius factor for rewiring neighbors\n        self._goal_sample_rate = 0.1                # Probability of sampling the goal point to bias sampling toward goal\n        self._max_time_sec = 30.0                    # Maximum allowed time for planning\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        # Same as original helper - step towards sample within max_dist\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir_vec / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self) -> Point:\n        # Goal bias sampling: With probability goal_sample_rate return goal pos, else uniform random sample\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        n_dim = self._get_grid().size.n_dim\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, vertices: List[Vertex], radius: float) -> List[Vertex]:\n        # Return vertices within radius of q_new\n        neighbors = []\n        q_new_tensor = q_new.position.to_tensor()\n        for v in vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor).item()\n            if dist <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _choose_parent(self, q_near: Vertex, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Select the best parent from near_vertices for q_new based on cost + edge validity\n        best_parent = q_near\n        best_cost = q_near.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor()).item()\n\n        for v in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(v.position, q_new.position)):\n                continue\n            cost = v.cost + torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = v\n        return best_parent if best_parent else q_near\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # For each neighbor, if q_new can provide a cheaper path re-parent it and update the tree\n        q_new_pos_tensor = q_new.position.to_tensor()\n        for v in near_vertices:\n            if v == q_new.parent:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, v.position)):\n                continue\n            cost_v = v.cost\n            cost_new = q_new.cost + torch.norm(v.position.to_tensor() - q_new_pos_tensor).item()\n            if cost_new < cost_v:\n                prev_parents = list(v.parents)\n                # Remove old edges from parent to v\n                for p in prev_parents:\n                    self._graph.remove_edge(p, v)\n                # Add new edge q_new -> v\n                self._graph.add_edge(q_new, v)\n                v.cost = cost_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n        # Trace back parents up to root\n        while len(path[-1].parents) != 0:\n            # Use only first parent to reconstruct path\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n        path.reverse()\n\n        # Move agent along the path\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        root_vertex_start = self._graph.root_vertex_start\n        root_vertex_start.cost = 0.0\n\n        iterations = 10000\n        n_dim = self._get_grid().size.n_dim\n\n        # To get all vertices in the graph for neighbor radius queries, keep track explicitly\n        vertices: List[Vertex] = [root_vertex_start]\n\n        # radius based on dimension and iteration as in RRT*\n        def get_radius(iter_num: int) -> float:\n            return min(self._radius_rewire_factor * (np.log(iter_num + 1) / (iter_num + 1)) ** (1/n_dim), self._max_dist)\n\n        for i in range(1, iterations + 1):\n\n            # Time check - stop if exceeding 30 seconds\n            if time.time() - start_time > self._max_time_sec:\n                # Treat as no path found, just exit\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([root_vertex_start], q_sample)\n\n            # Prevent sample identical to q_near\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find neighbors in radius r\n            radius = get_radius(i)\n            near_vertices: List[Vertex] = self._get_near_vertices(q_new, vertices, radius)\n\n            # Choose parent among neighbors minimizing cost\n            best_parent: Vertex = self._choose_parent(q_near, near_vertices, q_new)\n            q_new.cost = best_parent.cost + torch.norm(q_new.position.to_tensor() - best_parent.position.to_tensor()).item()\n            self._graph.add_edge(best_parent, q_new)\n\n            # Add q_new to vertices list\n            vertices.append(q_new)\n\n            # Rewire neighbors based on new vertex q_new\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex for path extraction\n                goal_v = Vertex(self._get_grid().goal.position)\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_v.position)):\n                    goal_v.cost = q_new.cost + torch.norm(goal_v.position.to_tensor() - q_new.position.to_tensor()).item()\n                    self._graph.add_edge(q_new, goal_v)\n                    self._extract_path(goal_v)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved variant of RRT known as RRT-Connect. \n    Instead of growing a single tree, it grows two trees simultaneously: one from the start and one from the goal. \n    During each iteration, it extends one tree towards a randomly sampled point and then tries to connect \n    the second tree towards the newly added vertex to rapidly close the gap. \n    This bidirectional growth significantly reduces the time to find a path compared to a single tree RRT.\n    Additionally, a 30-second time limit ensures the search is aborted reasonably if no path is found.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved path planner based on RRT* with the following enhancements:\n    - Implements informed sampling once a path to the goal is found to focus samples in the ellipsoidal \n      region potentially offering better paths, thereby improving convergence speed and reducing search time.\n    - Limits total search time to 30 seconds and terminates gracefully if no path is found.\n    - Uses existing helper functions and rewiring similar to RRT* to maintain optimality.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _informed_sampling_enabled: bool\n    _c_best: Optional[float]\n    _start_pose: Point\n    _goal_pose: Point\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._start_pose = self._get_grid().agent.position\n        self._goal_pose = self._get_grid().goal.position\n\n        start_vertex = Vertex(self._start_pose)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._goal_pose)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n        self._informed_sampling_enabled = False\n        self._c_best = None  # Best path cost found so far\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_random_sample_informed(self) -> Point:\n        \"\"\"\n        Generates a random sample within the ellipsoidal informed subset of the state space\n        defined by start and goal positions and current best cost.\n        \"\"\"\n        c_min = self._distance(self._start_pose, self._goal_pose)\n        if self._c_best is None:\n            # Fallback to uniform sampling\n            return self._get_random_sample()\n\n        if self._c_best < c_min:\n            # Numerical safety: cost can't be less than min path\n            self._c_best = c_min\n\n        # Compute ellipse parameters\n        center = Point(\n            (self._start_pose.x + self._goal_pose.x) / 2,\n            (self._start_pose.y + self._goal_pose.y) / 2\n        )\n        # Rotation angle of ellipse\n        vec = self._goal_pose.to_tensor() - self._start_pose.to_tensor()\n        theta = math.atan2(vec[1].item(), vec[0].item())\n\n        # Ellipse axes lengths\n        a = self._c_best / 2  # Major axis (half)\n        b_sq = self._c_best**2 - c_min**2\n        b = math.sqrt(b_sq) / 2 if b_sq > 0 else 0  # Minor axis (half)\n\n        # Sample uniformly inside unit circle\n        while True:\n            x, y = np.random.uniform(-1,1,2)\n            if x**2 + y**2 <= 1:\n                break\n\n        # Scale\n        sample_local_x = x * a\n        sample_local_y = y * b\n\n        # Rotate back\n        cos_t = math.cos(theta)\n        sin_t = math.sin(theta)\n        sample_global_x = cos_t * sample_local_x - sin_t * sample_local_y + center.x\n        sample_global_y = sin_t * sample_local_x + cos_t * sample_local_y + center.y\n\n        sample_point = Point(int(round(sample_global_x)), int(round(sample_global_y)))\n\n        # Validate sample inside map and valid position else fallback to uniform random\n        if (\n            0 <= sample_point.x < self._get_grid().size.x\n            and 0 <= sample_point.y < self._get_grid().size.y\n            and self._get_grid().is_agent_valid_pos(sample_point)\n        ):\n            return sample_point\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._goal_pose)\n        child_parent_dist = self._distance(q_new.position, goal_v.position)\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n\n        for it in range(iterations):\n\n            if time.time() - start_time > 30:\n                # Time limit exceeded, abort search\n                break\n\n            if self._informed_sampling_enabled:\n                q_sample: Point = self._get_random_sample_informed()\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min = q_nearest.cost + self._distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                line_seq_near = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(line_seq_near)\n                cost_near_to_new = q_near.cost + self._distance(q_near.position, q_new.position)\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = self._distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Try rewiring neighbors toward q_new if it improves cost\n            for q_near in Q_near:\n                line_seq_near = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(line_seq_near)\n                cost_new_to_near = q_new.cost + self._distance(q_new.position, q_near.position)\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if reached goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best path cost to enable informed sampling\n                goal_dist = self._distance(q_new.position, self._goal_pose)\n                total_cost = q_new.cost + goal_dist\n                if (self._c_best is None) or (total_cost < self._c_best):\n                    self._c_best = total_cost\n                    self._informed_sampling_enabled = True\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm is an improved version of the RRT (Rapidly-exploring Random Tree) path planning algorithm.\nIt integrates RRT-Connect style bidirectional growth of two trees simultaneously from the start and goal positions.\nThese two trees attempt to connect with each other at every iteration, significantly speeding up path finding.\nA timeout of 30 seconds is enforced to prevent infinite search.\nThe algorithm reuses and adapts helper functions from the base RRT to keep sampling and checking valid segments,\nwhile trying to connect the nearest nodes from the opposite tree, thus improving time efficiency compared to plain RRT.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph_start = gen_forest(\n            self._services, \n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph_goal = gen_forest(\n            self._services,\n            Vertex(self._get_grid().goal.position),\n            Vertex(self._get_grid().agent.position),\n            [],\n        )\n        self._graph_start.edges_removable = False\n        self._graph_goal.edges_removable = False\n        # Initialize displays for both graphs\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [\n            GraphMapDisplay(self._services, self._graph_start, color=\"blue\"),\n            GraphMapDisplay(self._services, self._graph_goal, color=\"green\"),\n        ]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    # Reuse helper from RRT: sample a random valid point\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Reuse helper from RRT: generate new vertex at most max_dist from q_near toward q_sample\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    # Attempt to connect one tree's new vertex to the other tree by extending towards nearest vertex in other tree\n    def _connect_trees(\n        self, \n        src_tree: Forest, \n        tgt_tree: Forest, \n        q_new: Vertex, \n        max_dist: float\n    ) -> Optional[Vertex]:\n        # Find nearest vertex in the target tree to q_new position\n        q_near_tgt = tgt_tree.get_nearest_vertex([tgt_tree.root_vertex_start], q_new.position)\n        if q_near_tgt.position == q_new.position:\n            return None\n\n        # Steer from q_new towards q_near_tgt to get next vertex closer to tgt tree\n        q_new_connect = self._get_new_vertex(q_new, q_near_tgt.position, max_dist)\n\n        # Check if direct path valid\n        line_seq = self._get_grid().get_line_sequence(q_new.position, q_new_connect.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n\n        # Add edge in target tree towards newly connected vertex\n        tgt_tree.add_edge(q_new, q_new_connect)\n\n        # Check if connected vertices are close enough to consider connection success\n        dist = torch.norm(q_new_connect.position.to_tensor() - q_near_tgt.position.to_tensor())\n        if dist <= max_dist and self._get_grid().is_valid_line_sequence(\n            self._get_grid().get_line_sequence(q_new_connect.position, q_near_tgt.position)\n        ):\n            # Add final connection edge to close the gap exactly\n            tgt_tree.add_edge(q_new_connect, q_near_tgt)\n            return q_new_connect\n\n        return None\n\n    # Extract path combining paths from both trees once connected\n    def _extract_full_path(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> None:\n        path_start: List[Vertex] = [connect_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        path_goal: List[Vertex] = [connect_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        full_path = path_start + path_goal  # joined path from start to goal\n\n        for p in full_path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        start_time = time.time()\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout after 30 seconds - treat as no path found\n                break\n\n            # Alternate growing trees\n            # Start tree grows towards random sample\n            q_sample: Point = self._get_random_sample()\n            q_near_start: Vertex = self._graph_start.get_nearest_vertex(\n                [self._graph_start.root_vertex_start], q_sample\n            )\n            if q_near_start.position == q_sample:\n                continue\n            q_new_start: Vertex = self._get_new_vertex(q_near_start, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)\n            ):\n                continue\n            self._graph_start.add_edge(q_near_start, q_new_start)\n\n            # Try to connect to goal tree\n            connect_vertex = self._connect_trees(self._graph_start, self._graph_goal, q_new_start, max_dist)\n            if connect_vertex is not None:\n                self._extract_full_path(q_new_start, connect_vertex)\n                break\n\n            # Then goal tree grows towards new vertex in start tree\n            q_near_goal: Vertex = self._graph_goal.get_nearest_vertex(\n                [self._graph_goal.root_vertex_start], q_new_start.position\n            )\n            if q_near_goal.position == q_new_start.position:\n                continue\n            q_new_goal: Vertex = self._get_new_vertex(q_near_goal, q_new_start.position, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)\n            ):\n                continue\n            self._graph_goal.add_edge(q_near_goal, q_new_goal)\n\n            # Try to connect back to start tree with new goal vertex\n            connect_vertex = self._connect_trees(self._graph_goal, self._graph_start, q_new_goal, max_dist)\n            if connect_vertex is not None:\n                self._extract_full_path(connect_vertex, q_new_goal)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT Algorithm with Goal Biasing and Early Termination by Time.\n    This implementation enhances the basic RRT by introducing goal-biased sampling \n    to direct exploration more towards the goal, improving convergence speed. \n    It also incorporates a timeout mechanism that stops the search if it exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize the graph with a forest rooted at start and goal vertices\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            [],\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        # Goal bias probability (e.g., 20%)\n        self._goal_bias = 0.2\n\n    def _get_goal_biased_sample(self) -> Point:\n        \"\"\"\n        Samples a point based on goal bias:\n        - With probability goal_bias, returns the goal position to push exploration towards goal\n        - Otherwise, returns a random sample in valid region\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Reuse the method from RRT to extract and animate the path\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect new vertex to goal\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_time_seconds: float = 30.0\n        start_time: float = time.time()\n        iterations: int = 10000\n\n        for _ in range(iterations):\n            # Check elapsed time for early stopping\n            if time.time() - start_time > max_time_seconds:\n                # Treat search as not found\n                break\n\n            q_sample: Point = self._get_goal_biased_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
