{
     "algorithm": "\"\"\"\n    This algorithm implements an improved Rapidly-exploring Random Tree (RRT*) path planner,\n    which extends the original RRT by optimizing the paths found through rewiring nearby vertices.\n    It ensures asymptotic optimality and generally finds better solutions faster than standard RRT.\n    The approach samples random points, extends the tree towards them with a max step distance,\n    and rewires the tree locally by checking for shorter paths.\n    The search is bounded by a maximum execution time of 30 seconds to prevent infinite runtime.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Enable edge removal for rewiring optimization\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir_vec = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = norm(dir_vec)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir_vec / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Find vertices in the graph within radius of q_new\n        near_vertices: List[Vertex] = []\n        all_vertices = self._graph.get_all_vertices()\n        for vertex in all_vertices:\n            if (vertex.position.to_tensor() - q_new.position.to_tensor()).norm() <= radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _cost(self, from_v: Vertex, to_v: Vertex) -> float:\n        # Cost heuristic: Euclidean distance if path is valid, else large number\n        dist = norm(from_v.position.to_tensor() - to_v.position.to_tensor()).item()\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(from_v.position, to_v.position)):\n            return float(\"inf\")\n        return dist\n\n    def _get_min_cost_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Among near vertices, select the one that yields minimum cost path to q_new and with valid connection\n        min_cost = float(\"inf\")\n        min_parent: Optional[Vertex] = None\n        for vertex in near_vertices:\n            candidate_cost = vertex.cost + self._cost(vertex, q_new)\n            if candidate_cost < min_cost:\n                min_cost = candidate_cost\n                min_parent = vertex\n        return min_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex, radius: float) -> None:\n        # Try to rewire neighbors through q_new if it improves their cost and path is valid\n        for vertex in near_vertices:\n            if vertex == q_new.parents[0]:\n                continue  # Skip actual parent vertex\n            cost_through_q_new = q_new.cost + self._cost(q_new, vertex)\n            if cost_through_q_new < vertex.cost:\n                # Check if path is valid before rewiring\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                    self._graph.remove_edge(vertex.parents[0], vertex)  # Remove old edge\n                    self._graph.add_edge(q_new, vertex)\n                    vertex.cost = cost_through_q_new\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = []\n        current = q_goal\n\n        # Trace back to start\n        while current is not None:\n            path.append(current)\n            if len(current.parents) > 0:\n                current = current.parents[0]\n            else:\n                break\n\n        path.reverse()\n\n        # Move the agent along the extracted path with animation key frames\n        for v in path:\n            self.move_agent(v.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_time_seconds: float = 30.0\n        n_dim: int = self._get_grid().size.n_dim\n\n        iterations: int = 1000000  # Large number but will be bounded by time\n        start_time = time()\n\n        root_vertex: Vertex = self._graph.root_vertex_start\n        root_vertex.cost = 0.0  # cost to reach root is zero\n\n        for i in range(iterations):\n\n            elapsed_time = time() - start_time\n            if elapsed_time > max_time_seconds:\n                # Timeout: stop search and consider path not found.\n                break\n\n            # Goal biasing: with some probability sample the goal to speed convergence\n            if np.random.rand() < 0.1:\n                q_sample = self._get_grid().goal.position\n            else:\n                q_sample = self._get_random_sample()\n\n            q_near = self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Check line validity\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get nearby vertices for rewiring within radius\n            radius = min(50.0, max_dist * 5)  # Adaptive radius\n\n            near_vertices = self._get_near_vertices(q_new, radius)\n\n            # Choose the best parent among near vertices\n            min_parent = self._get_min_cost_parent(near_vertices, q_new)\n            if min_parent is None:\n                min_parent = q_near\n\n            # Add edge and update cost\n            self._graph.add_edge(min_parent, q_new)\n            q_new.cost = min_parent.cost + self._cost(min_parent, q_new)\n\n            # Rewire neighbors for optimization\n            self._rewire(near_vertices, q_new, radius)\n\n            # Check if goal reached (within goal radius)\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Add goal vertex connected to q_new\n                goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n                self._graph.add_edge(q_new, goal_vertex)\n                goal_vertex.cost = q_new.cost + self._cost(q_new, goal_vertex)\n\n                self._extract_path(goal_vertex)\n                break\n\n            self.key_frame()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThe algorithm implemented here is an improved sample-based planner inspired by RRT*.\nIt incorporates adaptive maximum extension distance and uses informed sampling to focus exploration towards\nthe goal after an initial solution is found, thus improving convergence speed.\nFurthermore, it enforces a 30-second maximum runtime to prevent excessive planning time.\nIt reuses the RRT* rewiring and path extraction logic but focuses sampling within an ellipsoidal region\nbetween start and goal to accelerate path finding.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional member to track if initial solution found\n        self._solution_found: bool = False\n        # To store best cost found so far (initialized large)\n        self._best_cost: float = float('inf')\n        # Cache start and goal vertex for convenience\n        self._start_vertex: Vertex = self._graph.root_vertex_start\n        self._goal_vertex: Vertex = Vertex(self._get_grid().goal.position)\n        self._goal_vertex.cost = float('inf')\n        # Prepare display info container\n        self._init_displays()\n    \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n    \n    def _heuristic_distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n    \n    def _informed_sample(self, c_best: float, c_min: float, start: Point, goal: Point) -> Point:\n        \"\"\"\n        Sample within prolate hyperspheroid defined by start, goal, and current best cost.\n        If no solution yet (c_best == inf), sample uniformly.\n        \"\"\"\n        if c_best == float('inf'):\n            return self._get_random_sample()\n\n        # Compute center and coordinate transforms for ellipsoid sampling\n        start_np = np.array(start)\n        goal_np = np.array(goal)\n        c_min = float(c_min)\n        c_best = float(c_best)\n\n        center = (start_np + goal_np) / 2\n\n        # Unit vector along start to goal\n        direction = (goal_np - start_np)\n        norm_dir = np.linalg.norm(direction)\n        if norm_dir == 0:\n            return Point(*goal_np)\n\n        e1 = direction / norm_dir\n        # Create orthonormal basis using SVD or Gram-Schmidt for 2D\n        # In 2D, the orthonormal is just perpendicular vector\n        if e1.size == 2:\n            e2 = np.array([-e1[1], e1[0]])\n            basis = np.vstack((e1, e2)).T  # Columns are basis vectors\n        else:\n            # fallback to identity (should be 2D anyway)\n            basis = np.eye(len(e1))\n\n        # Radii of the ellipsoid along each axis\n        r1 = c_best / 2\n        r2 = math.sqrt(c_best**2 - c_min**2) / 2\n\n        # Sample random point inside unit ball in 2D\n        while True:\n            sample_unit = np.random.randn(2)\n            sample_unit /= np.linalg.norm(sample_unit)\n            if np.random.rand() <= 1.0:\n                break\n        # Uniform scale for 2D unit circle\n        scale = np.random.rand() ** 0.5\n        sample_ball = sample_unit * scale\n\n        # Stretch and rotate sample to ellipsoid\n        sample_ellipsoid = np.array([r1 * sample_ball[0], r2 * sample_ball[1]])\n        sample_world = center + basis @ sample_ellipsoid\n\n        # Clip to grid and make sure it is valid\n        sample_point = Point(*np.clip(sample_world, 0, self._get_grid().size.n_dim - 1).astype(int))\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback uniform sample if invalid\n            return self._get_random_sample()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Similar to RRT* extract path but moves agent with key frames\n        \"\"\"\n        path: List[Vertex] = []\n        current = q_new\n        while current is not None:\n            path.append(current)\n            if len(current.parents) == 0:\n                break\n            # Pick first parent (RRT* is tree)\n            current = next(iter(current.parents), None)\n        path.reverse()\n\n        for v in path:\n            self.move_agent(v.position)\n            grid = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n    \n    def _find_path_internal(self) -> None:\n\n        max_dist_init: float = 10.0\n        max_dist_min: float = 3.0\n        max_dist_decay: float = 0.9995  # decay max_dist slowly over iterations to more refined local exploration\n\n        max_radius: float = 50.0\n        lambda_rrt_star: float = 50.0\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        c_min = self._heuristic_distance(self._start_vertex.position, self._goal_vertex.position)\n        c_best = float('inf')\n\n        for i in range(iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout reached, stop searching and treat as no path found\n                break\n\n            # Use informed sampling once a solution is found, else uniform random sampling\n            if self._solution_found:\n                q_sample = self._informed_sample(c_best, c_min, self._start_vertex.position, self._goal_vertex.position)\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            # Adaptive max extension distance shrinking with iterations\n            max_dist = max(max_dist_min, max_dist_init * (max_dist_decay ** i))\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + self._heuristic_distance(q_nearest.position, q_new.position)\n\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                    cost_candidate = q_near.cost + self._heuristic_distance(q_near.position, q_new.position)\n                    if cost_candidate < c_min_cost:\n                        q_min = q_near\n                        c_min_cost = cost_candidate\n\n            dist_parent_child = self._heuristic_distance(q_min.position, q_new.position)\n            q_new.cost = q_min.cost + dist_parent_child\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                    cost_through_new = q_new.cost + self._heuristic_distance(q_new.position, q_near.position)\n                    if cost_through_new < q_near.cost:\n                        q_parent = None\n                        for parent in q_near.parents:\n                            q_parent = parent\n                            break\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_through_new\n                        self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex is in goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update solution found status\n                cost_to_goal = q_new.cost + self._heuristic_distance(q_new.position, self._goal_vertex.position)\n                if cost_to_goal < c_best:\n                    c_best = cost_to_goal\n                    self._solution_found = True\n                    self._extract_path(q_new)\n                    # Break after first found path improves the solution\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning Algorithm based on RRT with goal biasing and early stopping.\n    This implementation enhances the original RRT approach by:\n    - Introducing goal biasing: with a given probability, the sample is the goal, \n      which guides the tree growth faster towards the goal.\n    - Using a timer to enforce a max allowed planning time of 30 seconds to avoid long runs.\n    - Early stopping when the path to goal is found.\n    - Reusing existing helper functions and structure from the base RRT algorithm.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT-Connect with goal biasing and adaptive max extension distance for faster convergence.\n    This algorithm enhances the standard RRT-Connect by introducing:\n    - Goal biasing: samples the goal position with a fixed probability to direct growth towards the target.\n    - Adaptive step size: dynamically adjusts the maximum extension distance based on the distance to the goal,\n      allowing longer steps in open space and finer steps near obstacles or goal.\n    \n    Additionally, the algorithm terminates the search if it takes longer than 30 seconds to find a path.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.15  # 15% chance to sample goal directly\n        self._min_max_dist = 5\n        self._max_max_dist = 15\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        With probability self._goal_bias, return the goal point to bias tree growth toward the goal.\n        Otherwise, sample uniformly inside valid grid positions.\n        \"\"\"\n        if random.random() < self._goal_bias:\n            return self._get_grid().goal.position\n        return self._get_random_sample()\n\n    def _adaptive_max_dist(self, from_point: Point) -> float:\n        \"\"\"\n        Adapt the max_dist based on distance to goal, capped between min and max.\n        Longer steps when far, shorter steps near goal.\n        \"\"\"\n        dist_to_goal = torch.norm(from_point.to_tensor() - self._get_grid().goal.position.to_tensor()).item()\n        # Map distance to [min_max_dist, max_max_dist] linearly, e.g. max max_dist at distances >= 50\n        max_allowed_step = self._min_max_dist + (self._max_max_dist - self._min_max_dist) * min(dist_to_goal/50.0, 1.0)\n        return max_allowed_step\n\n    def _extend_with_adaptive_dist(self, root_vertex: Vertex, q: Point) -> str:\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        adaptive_dist = self._adaptive_max_dist(self._q_near.position)\n        self._q_new = self._get_new_vertex(self._q_near, q, adaptive_dist)\n        line_seq = self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)\n        if self._get_grid().is_valid_line_sequence(line_seq):\n            self._graph.add_edge(self._q_near, self._q_new)\n            if self._q_new.position == q:\n                return 'reached'\n            else:\n                return 'advanced'\n        return 'trapped'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend_with_adaptive_dist(root_vertex, q.position)\n            if S == 'reached':\n                break\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back mid to b\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = next(iter(path_mid_to_b[-1].parents))\n            path_mid_to_b.append(parent)\n\n        # trace a to mid\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = next(iter(path_a_to_mid[-1].parents))\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            # Check timeout\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30:\n                # Timeout reached, no path found\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_result = self._extend_with_adaptive_dist(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an improved, time-optimized variant inspired by the original RRT* approach.\n    The improvement is mainly achieved by incorporating informed sampling once an initial feasible path is found.\n    Informed RRT* (or Informed Sampling RRT*) restricts the sampling space to the ellipsoidal region that can possibly\n    improve the current best path, reducing unnecessary exploration outside that region, thus improving convergence speed.\n\n    Key improvements:\n    - After finding the first path to the goal, the sampler biases samples within an ellipsoidal subset\n      of the state space defined by the start, goal, and current best path cost, drastically pruning sampling.\n    - Time cutoff of 30 seconds is added to stop search and declare failure if no path is found before timeout.\n    - Retains rewiring and radius-based neighborhood search from RRT* for path cost optimization.\n\n    This algorithm reuses helper functions from the base class and integrates with the existing framework components.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._best_path_cost = float('inf')\n        self._best_goal_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _ellipsoidal_sample(self, start: Point, goal: Point, c_max: float) -> Point:\n        \"\"\"\n        Sample inside the prolate hyperspheroid (ellipsoid) with foci at start and goal, max cost c_max.\n        This improves convergence after first solution is found.\n        Falls back to uniform random if no informed region.\n        \"\"\"\n        if c_max == float('inf'):\n            return self._get_random_sample()\n\n        start_np = start.to_tensor().numpy()\n        goal_np = goal.to_tensor().numpy()\n        foci_dist = np.linalg.norm(start_np - goal_np)\n\n        if foci_dist == 0 or c_max < foci_dist:\n            return self._get_random_sample()\n\n        # Compute the lengths of the ellipsoid axes\n        a1 = c_max / 2.0  # major axis half-length\n        minor_axis_len = math.sqrt(max(c_max ** 2 - foci_dist ** 2, 0)) / 2.0  # minor axis half-length(s)\n\n        # Sample random point in unit ball in dimension 2\n        while True:\n            # Uniform sampling within unit ball (2D)\n            theta = np.random.uniform(0, 2 * math.pi)\n            r = np.sqrt(np.random.uniform(0, 1))\n            x_ball = r * math.cos(theta)\n            y_ball = r * math.sin(theta)\n            # Scale to ellipsoid axes\n            sample_local = np.array([a1 * x_ball, minor_axis_len * y_ball])\n\n            # Find rotation matrix to align x-axis with vector from start to goal\n            direction = goal_np - start_np\n            norm_dir = np.linalg.norm(direction)\n            if norm_dir == 0:\n                # degenerate case fallback\n                return self._get_random_sample()\n            e1 = direction / norm_dir  # major axis unit vector\n            # 2D rotation matrix to rotate x-axis to e1\n            cos_angle = e1[0]\n            sin_angle = e1[1]\n            rot_mat = np.array([[cos_angle, -sin_angle], [sin_angle, cos_angle]])\n\n            sample_world = (rot_mat @ sample_local) + (start_np + goal_np) / 2.0\n\n            sample_point = Point(*sample_world.astype(int))\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extract_path(self, q_new: 'Vertex') -> None:\n        \"\"\"\n        Same as in RRT*, extract path from q_new to goal and move agent accordingly.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        start_position = self._get_grid().agent.position\n        goal_position = self._get_grid().goal.position\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout: treat as route not found and end\n                break\n\n            # Informed sampling after first solution found\n            if self._best_path_cost < float('inf'):\n                q_sample: Point = self._ellipsoidal_sample(start_position, goal_position, self._best_path_cost)\n            else:\n                q_sample: Point = self._get_random_sample()\n\n            q_nearest: 'Vertex' = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: 'Vertex' = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision along edge\n            line_seq = self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire neighbors\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                )\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex in goal region\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Keep only better path\n                if q_new.cost < self._best_path_cost:\n                    self._best_path_cost = q_new.cost\n                    self._best_goal_vertex = q_new\n                    self._extract_path(q_new)\n                    # Continue searching for better solutions within time limit\n                    # (Can comment below break for full anytime behavior)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT, known as RRT-Connect. \n    Instead of growing a single tree from the start state randomly, it grows two trees:\n    one from the start and one from the goal, alternating their expansion.\n    Each iteration tries to extend one tree towards a random sample, then attempts to connect\n    the other tree to the newly extended vertex, potentially producing a faster path solution.\n    This bidirectional approach generally improves time efficiency in path planning \n    especially in complex spaces. Additionally, the search will abandon if it exceeds 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph_start = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph_start.edges_removable = False\n        \n        self._graph_goal = gen_forest(self._services, Vertex(self._get_grid().goal.position), Vertex(self._get_grid().agent.position), [])\n        self._graph_goal.edges_removable = False\n        \n        self.__map_displays = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        # Display both trees\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start), GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_extend(self, tree: Forest, q_target: Point, max_dist: float) -> Vertex:\n        q_near: Vertex = tree.get_nearest_vertex([tree.root_vertex_start], q_target)\n        if q_near.position == q_target:\n            return q_near\n        \n        q_new: Vertex = self._get_new_vertex(q_near, q_target, max_dist)\n        \n        line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n        if not self._get_grid().is_valid_line_sequence(line_seq):\n            return None\n        \n        tree.add_edge(q_near, q_new)\n        return q_new\n\n    def _extract_path(self, connect_vertex_start: Vertex, connect_vertex_goal: Vertex) -> None:\n        \"\"\"\n        Connects the path from root start to connect_vertex_start and from root goal to connect_vertex_goal,\n        then moves agent along path.\n        \"\"\"\n        # Build path from start tree\n        path_start: List[Vertex] = [connect_vertex_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Build path from goal tree\n        path_goal: List[Vertex] = [connect_vertex_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        full_path = path_start + path_goal  # connect paths (goal path is from connection vertex towards goal)\n\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_time_seconds: float = 30.0\n\n        start_time = time()\n\n        # For alternating tree expansion: True => extend start tree first, False => goal tree first\n        extend_start_tree_next = True\n\n        for _ in range(100000):  # Large iteration count but constrained by max_time_seconds\n            # Check timeout\n            if time() - start_time > max_time_seconds:\n                break\n\n            q_sample: Point = self._get_random_sample()\n\n            if extend_start_tree_next:\n                q_new_start = self._try_extend(self._graph_start, q_sample, max_dist)\n                if q_new_start is None:\n                    extend_start_tree_next = not extend_start_tree_next\n                    self.key_frame()\n                    continue\n\n                q_new_goal = self._try_extend(self._graph_goal, q_new_start.position, max_dist)\n                if q_new_goal is not None:\n                    # Check connection line\n                    line_seq = self._get_grid().get_line_sequence(q_new_start.position, q_new_goal.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        # Connect edges between two trees\n                        self._graph_start.add_edge(q_new_start, q_new_goal)\n                        self._graph_goal.add_edge(q_new_goal, q_new_start)\n                        self._extract_path(q_new_start, q_new_goal)\n                        break\n            else:\n                q_new_goal = self._try_extend(self._graph_goal, q_sample, max_dist)\n                if q_new_goal is None:\n                    extend_start_tree_next = not extend_start_tree_next\n                    self.key_frame()\n                    continue\n\n                q_new_start = self._try_extend(self._graph_start, q_new_goal.position, max_dist)\n                if q_new_start is not None:\n                    line_seq = self._get_grid().get_line_sequence(q_new_goal.position, q_new_start.position)\n                    if self._get_grid().is_valid_line_sequence(line_seq):\n                        self._graph_goal.add_edge(q_new_goal, q_new_start)\n                        self._graph_start.add_edge(q_new_start, q_new_goal)\n                        self._extract_path(q_new_start, q_new_goal)\n                        break\n\n            extend_start_tree_next = not extend_start_tree_next\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved sampling-based path planner inspired by RRT* (Rapidly-exploring Random Tree Star).\n    Instead of classic A*, it incrementally builds a tree of collision-free configurations by sampling random points,\n    attempting to connect to the nearest existing vertex, and rewiring the tree to ensure near-optimal paths.\n    This approach is especially useful in high-dimensional or complex spaces where heuristic-guided grid search is intractable.\n    The algorithm terminates when it finds a path to the goal or after 30 seconds, whichever comes first.\n    Key improvements over grid-based A*: better efficiency in large continuous spaces, anytime improvement of the path,\n    and avoidance of exhaustive grid expansion.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # We will keep a graph structure as self._graph (inherited from SampleBasedAlgorithm assumed)\n        # Maintain sets for vertices and edges if needed, else rely on self._graph API\n        # Colors for displaying the tree and final path\n        self._tree_colour = self._services.state.views.add_colour(\"tree edges\", Colour(0.0, 0.7, 0.3, 0.5))\n        self._path_colour = self._services.state.views.add_colour(\"final path\", Colour(0.7, 0.1, 0.1, 1.0))\n        self._visited_vertices = gen_set(services)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        base_displays = super().set_display_info()\n        # Shows tree vertices\n        vertices_display = SolidIterableMapDisplay(self._services, self._visited_vertices, self._tree_colour, z_index=45)\n        return base_displays + [vertices_display]\n\n    def _find_path_internal(self) -> None:\n        start_time = time()\n\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        # Initialize graph with start vertex\n        self._graph.clear()\n        start_vertex = self._graph.add_vertex(start_pos)\n        start_vertex.cost = 0.0\n        self._visited_vertices.add(start_pos)\n\n        max_iter = 10000  # upper bound on iterations to avoid infinite loops in pathological maps\n\n        goal_vertex: Optional = None\n\n        def dist(a: Point, b: Point) -> float:\n            return ((a[0]-b[0])**2 + (a[1]-b[1])**2) ** 0.5\n\n        def sample_free() -> Point:\n            # Sample random free point in the environment\n            attempts = 0\n            while True:\n                pos = self._graph.get_random_sample()\n                if not grid.is_occupied(pos):\n                    return pos\n                attempts += 1\n                # Prevent infinite loops\n                if attempts > 1000:\n                    return start_pos\n\n        def nearest_vertex(p: Point):\n            # Find vertex in the graph nearest to p\n            min_d = float('inf')\n            nearest = None\n            for v in self._graph.vertices():\n                d = dist(v.position, p)\n                if d < min_d:\n                    min_d = d\n                    nearest = v\n            return nearest\n\n        def steer(from_pos: Point, to_pos: Point, max_dist=1.0) -> Point:\n            # Returns a point towards to_pos from from_pos but no further than max_dist\n            vector = (to_pos[0]-from_pos[0], to_pos[1]-from_pos[1])\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            new_p = (from_pos[0] + vector[0]*scale, from_pos[1] + vector[1]*scale)\n            # Round to nearest grid point because we are on grid map\n            new_p_rounded = Point(round(new_p[0]), round(new_p[1]))\n            return new_p_rounded\n\n        def collision_free(p1: Point, p2: Point) -> bool:\n            # Check if path from p1 to p2 is free of obstacles\n            return grid.is_path_free(p1, p2)\n\n        def near_vertices(p: Point, radius=3.0):\n            # Return vertices within a radius of p\n            result = []\n            for v in self._graph.vertices():\n                if dist(v.position, p) <= radius:\n                    result.append(v)\n            return result\n\n        for i in range(max_iter):\n            if (time() - start_time) > 30.0:\n                # Timeout: stop searching\n                break\n\n            rand_sample = sample_free()\n            nearest = nearest_vertex(rand_sample)\n            new_pos = steer(nearest.position, rand_sample, max_dist=3.0)\n\n            if new_pos == nearest.position:\n                # No progress possible\n                continue\n\n            if not collision_free(nearest.position, new_pos):\n                continue\n\n            # Add new vertex and edge to graph\n            new_vertex = self._graph.add_vertex(new_pos)\n            # Cost to reach new_vertex via nearest\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            new_vertex.cost = new_cost\n            self._graph.add_edge(nearest, new_vertex)\n            self._visited_vertices.add(new_pos)\n\n            # Rewire nearby vertices if going through new_vertex is cheaper\n            neighbors = near_vertices(new_pos, radius=5.0)\n            for neighbor in neighbors:\n                if neighbor == nearest or neighbor == new_vertex:\n                    continue\n                if collision_free(new_vertex.position, neighbor.position):\n                    cost_through_new = new_vertex.cost + dist(new_vertex.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        # Rewire edge from neighbor's old parent to new_vertex\n                        old_parent = neighbor.parent\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.cost = cost_through_new\n\n            # Check if new_vertex is close enough to goal to attempt connection\n            if dist(new_vertex.position, goal_pos) <= 3.0:\n                if collision_free(new_vertex.position, goal_pos):\n                    goal_vertex = self._graph.add_vertex(goal_pos)\n                    goal_vertex.cost = new_vertex.cost + dist(new_vertex.position, goal_pos)\n                    self._graph.add_edge(new_vertex, goal_vertex)\n                    self._visited_vertices.add(goal_pos)\n                    break\n\n            self.key_frame()\n\n        # If path found, follow backtrace\n        if goal_vertex is not None:\n            path_positions = []\n            v = goal_vertex\n            while v is not None:\n                path_positions.append(v.position)\n                v = v.parent\n            path_positions.reverse()\n\n            for pos in path_positions:\n                self.move_agent(pos)\n                self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm is an improved sampling-based planner inspired by RRT*,\nenhanced by incorporating a heuristic bias towards the goal and informed sampling\nto accelerate convergence. We sample points either randomly or biased near the goal\nwith a defined probability to focus exploration, improving time efficiency.\nAlso, the rewiring radius adapts dynamically with the number of vertices for better optimization.\nA 30-second timeout exits the search if no path is found.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Additional members for informed sampling and timing\n        self._goal_bias_probability: float = 0.2  # Probability to sample near goal\n        self._timeout_seconds: float = 30.0       # Timeout in seconds for search\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        With some probability, sample near the goal within a small radius,\n        otherwise sample randomly in the entire environment.\n        \"\"\"\n        goal_pos = self._get_grid().goal.position\n        size = self._get_grid().size\n        bias_radius = 15  # radius near the goal to bias sampling\n\n        if random.random() < self._goal_bias_probability:\n            # Sample in a square bounding box around goal (clamp to map size)\n            lower_bounds = [max(0, goal_pos[i] - bias_radius) for i in range(goal_pos.n_dim)]\n            upper_bounds = [min(size[i]-1, goal_pos[i] + bias_radius) for i in range(goal_pos.n_dim)]\n            coords = [np.random.randint(low, high+1) for low, high in zip(lower_bounds, upper_bounds)]\n            sample = Point(*coords)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            else:\n                # fallback to uniform random if biased sample invalid\n                return self._get_random_sample()\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            elapsed_time = time.time() - start_time\n            if elapsed_time > self._timeout_seconds:\n                # Timeout reached, stop trying and return (no path found)\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            if card_v <= 1:\n                radius = max_radius\n            else:\n                log_card_v = torch.log(card_v)\n                radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent: Optional[Vertex] = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved PathPlanning algorithm inspired by RRT*, which enhances RRT by rewiring the tree for better paths.\n    It accelerates finding an optimized path by connecting new vertices not only to the nearest vertex but also\n    attempts to rewire neighbors within a radius to minimize the path cost. It prunes inefficient edges and \n    ensures efficient exploration. A timeout of 30 seconds is enforced to terminate long searches.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, \n                                 Vertex(self._get_grid().agent.position), \n                                 Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True     # Allow removing edges for rewiring\n        self._init_displays()\n        self._max_dist: float = 10.0\n        self._neighbor_radius: float = 15.0\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        norm_dir = torch.norm(dir)\n        if norm_dir <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / norm_dir\n        q_new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_pos)\n\n    def _get_near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Find all vertices in graph within neighbor_radius of q_new\n        near_vertices: List[Vertex] = []\n        for v in self._graph.vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new.position.to_tensor()).item()\n            if dist <= self._neighbor_radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _cost(self, from_vertex: Vertex, to_vertex: Vertex) -> float:\n        # Cost from from_vertex to to_vertex is Euclidean distance\n        return torch.norm(to_vertex.position.to_tensor() - from_vertex.position.to_tensor()).item()\n\n    def _get_path_cost(self, vertex: Vertex) -> float:\n        # Compute cost from root to this vertex by summing edge costs\n        cost = 0.0\n        current = vertex\n        while len(current.parents) > 0:\n            parent = current.parents[0]\n            cost += self._cost(parent, current)\n            current = parent\n        return cost\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        # For each neighbor, check if rewiring via q_new reduces cost and edge is valid\n        for v_near in near_vertices:\n            if v_near == q_new.parents[0]:\n                continue\n            # Current cost to neighbor\n            current_cost = self._get_path_cost(v_near)\n            # Cost if going through q_new\n            possible_cost = self._get_path_cost(q_new) + self._cost(q_new, v_near)\n            if possible_cost < current_cost:\n                # Check if line q_new->v_near is valid\n                line_seq = self._get_grid().get_line_sequence(q_new.position, v_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    # Remove old edge to v_near\n                    for parent in v_near.parents.copy():\n                        self._graph.remove_edge(parent, v_near)\n                    # Add new edge q_new->v_near\n                    self._graph.add_edge(q_new, v_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect to goal\n\n        path: List[Vertex] = [goal_v]\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]  # Remove the root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.display_info if hasattr(self._graph, 'display_info') else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        iterations = 10000\n\n        for i in range(iterations):\n            if time.time() - start_time > 30.0:\n                # Timeout: no path found in 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find near vertices and choose parent with minimal cost to q_new\n            near_vertices = self._get_near_vertices(q_new)\n            min_cost = math.inf\n            best_parent = q_near\n            q_new_cost_est = self._get_path_cost(q_near) + self._cost(q_near, q_new)\n\n            for near_v in near_vertices:\n                line_seq = self._get_grid().get_line_sequence(near_v.position, q_new.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_through_near = self._get_path_cost(near_v) + self._cost(near_v, q_new)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        best_parent = near_v\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire connections to improve paths\n            if len(near_vertices) > 0:\n                self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm is an improved version of RRT* focused on accelerating convergence \n    and reducing redundant computations to improve execution time in discrete grid environments.\n    Key improvements include:\n    - Adaptive sampling with goal bias to direct growth towards the goal more frequently.\n    - Early pruning of vertices with costs exceeding the best known solution to reduce rewiring overhead.\n    - Caching collision checks within each iteration to avoid repeated checks for the same edges.\n    - Time-bounded search: abort path search if it exceeds 30 seconds.\n    It still rewires the tree for optimal paths but applies heuristics to limit unnecessary computations \n    and direct the search more intelligently.",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT-Connect, integrating a heuristic bias \n    towards the goal to accelerate convergence and reduce unnecessary exploration.\n\n    This algorithm, named PathPlanning, uses two trees grown from the start and goal positions,\n    respectively. It incorporates goal-biased sampling: with a certain probability, samples are \n    taken directly at the goal to speed up connection attempts. It also limits the number of iterations \n    dynamically by elapsed time, aborting the search if no path is found within 30 seconds.\n\n    By focusing sampling more often near the goal and pruning redundant full explorations, it aims to \n    reduce the total computation time compared to plain RRT-Connect, thus improving practical runtime performance.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% samples biased directly towards goal\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Returns a sample biased towards the goal with probability self._goal_sample_rate,\n        else a random valid position.\n        \"\"\"\n        if np.random.rand() < self._goal_sample_rate:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _extract_path(self) -> None:\n\n        # trace back from _q_new to root of start tree\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = next(iter(path_mid_to_b[-1].parents))\n            path_mid_to_b.append(parent)\n\n        # trace back from _extension_target to root of goal tree\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = next(iter(path_a_to_mid[-1].parents))\n            path_a_to_mid.append(parent)\n\n        path_a_to_mid.reverse()\n        path = path_a_to_mid + path_mid_to_b\n\n        # Adjust path direction if required\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n        start_time = time.time()\n\n        for i in range(self._iterations):\n\n            # Abort if runtime > 30 seconds\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # No path found within time limit\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nImproved path planning algorithm based on RRT*, an extension of RRT that optimizes the path by \nrewiring the tree to minimize costs and uses a radius neighborhood to try connecting new nodes \nto multiple nearby vertices. It attempts to find shorter paths faster by local optimization. \nThis implementation additionally terminates if runtime exceeds 30 seconds to avoid excessive delays.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring for RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"Return all vertices within radius from q_new.\"\"\"\n        vertices: List[Vertex] = []\n        all_vertices: List[Vertex] = self._graph.get_all_vertices()\n        q_new_tensor = q_new.position.to_tensor()\n        for v in all_vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor)\n            if dist <= radius:\n                vertices.append(v)\n        return vertices\n\n    def _cost(self, vertex: Vertex) -> float:\n        \"\"\"Return path cost from root to vertex.\"\"\"\n        cost = 0.0\n        current = vertex\n        while len(current.parents) > 0:\n            parent = current.parents[0]\n            cost += torch.norm(current.position.to_tensor() - parent.position.to_tensor()).item()\n            current = parent\n        return cost\n\n    def _choose_parent(self, neighbors: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"Choose the best parent from neighbors for q_new based on minimum cost.\"\"\"\n        min_cost = math.inf\n        best_parent = None\n        for v in neighbors:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = self._cost(v) + torch.norm(q_new.position.to_tensor() - v.position.to_tensor()).item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, neighbors: List[Vertex], q_new: Vertex, radius: float) -> None:\n        \"\"\"Try to optimize the path by rewiring nearby vertices to q_new if it reduces cost.\"\"\"\n        q_new_cost = self._cost(q_new)\n        q_new_tensor = q_new.position.to_tensor()\n        for v in neighbors:\n            if v == q_new:\n                continue\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor).item()\n            if dist > radius:\n                continue\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            current_cost = self._cost(v)\n            new_cost = q_new_cost + dist\n            if new_cost < current_cost:\n                # remove old edge parents if mutable graph\n                v.parents.clear()\n                self._graph.add_edge(q_new, v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        current = q_goal\n        while len(current.parents) != 0:\n            current = current.parents[0]\n            path.append(current)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._SampleBasedAlgorithm__map_displays if hasattr(self, \"_SampleBasedAlgorithm__map_displays\") else super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        c: float = 1.0  # tuning parameter for neighborhood radius\n        start_time = time.time()\n\n        for i in range(iterations):\n            if time.time() - start_time > 30:\n                # Timeout: treat route search as not found\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Radius for near neighbors (RRT* radius formula)\n            gamma_rrt_star = c * (math.log(len(self._graph.get_all_vertices()) + 1) / (len(self._graph.get_all_vertices()) + 1)) ** (1 / self._get_grid().size.n_dim)\n            radius = max_dist  # limit radius to max_dist to limit search space locally\n            radius = min(radius, gamma_rrt_star)\n\n            near_vertices = self._get_near_vertices(q_new, radius)\n            best_parent = self._choose_parent(near_vertices, q_new)\n            if best_parent is None:\n                # Fallback to nearest vertex if no suitable parent found in neighborhood\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewire the nearby vertices if better path found via q_new\n            self._rewire(near_vertices, q_new, radius)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                # Check if line from q_new to goal is valid\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                else:\n                    self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of RRT*, named \"Informed RRT*\".\n    It enhances the original RRT* by focusing the sampling within an ellipsoidal \n    informed set once a solution is found, which reduces unnecessary exploration \n    and speeds up convergence to an optimal path. Additionally, a timeout of 30 seconds \n    is implemented to terminate the search early if no path is found in that time frame.\n    \"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm is an improved version of the SPRM sample-based planner.\n    Instead of building a cyclic graph and connecting all points within a fixed radius,\n    it uses a bidirectional incremental connection approach inspired by RRT-Connect to speed up path discovery.\n    Two vertex trees start from the agent and the goal, respectively, and grow towards random samples.\n    Whenever the two trees can connect via a collision-free path, the route is extracted and followed.\n    A 30-second timeout ensures the algorithm halts if no solution is found in time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # parameters for RRT-Connect style bidirectional growth\n        self._V_size = 200\n        self._max_extend_dist = 15\n        self._tree_agent: List[Vertex] = []\n        self._tree_goal: List[Vertex] = []\n        self._graph = gen_cyclic_graph(\n            self._services,\n            Vertex(self._get_grid().agent.position, store_connectivity=True),\n            Vertex(self._get_grid().goal.position, store_connectivity=True),\n            []\n        )\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            sample = Point(*[torch.randint(0, self._get_grid().size[i], (1,)).item() for i in range(self._get_grid().size.n_dim)])\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _nearest(self, tree: List[Vertex], point: Point) -> Vertex:\n        # Find vertex in tree closest to point\n        min_dist = float('inf')\n        nearest_vertex = None\n        p_tensor = point.to_tensor()\n        for vertex in tree:\n            dist = torch.norm(vertex.position.to_tensor() - p_tensor).item()\n            if dist < min_dist:\n                min_dist = dist\n                nearest_vertex = vertex\n        return nearest_vertex\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, max_dist: float) -> Vertex:\n        # From from_vertex, move towards to_point by up to max_dist\n        return self._get_new_vertex(from_vertex, to_point, max_dist)\n\n    def _connect_trees(self, V_from: Vertex, V_to: Vertex) -> bool:\n        # Attempt connection from V_from to V_to by checking line collision,\n        # and add edges if valid, updating connectivity\n        grid = self._get_grid()\n        line = grid.get_line_sequence(V_from.position, V_to.position)\n        if not grid.is_valid_line_sequence(line):\n            return False\n        self._graph.add_edge(V_from, V_to)\n        self._graph.add_edge(V_to, V_from)\n        # Update connectivity map for these vertices\n        # (assuming connectivity maintains shortest path or at least path presence)\n        # We can propagate connectivity updates here if needed\n        # For simplicity, we just add the edge; connectivity handled by CyclicGraph internals\n        return True\n\n    def _extract_path_from_connectivity(self, start: Vertex, goal: Vertex) -> List[Point]:\n        # Extract path following connectivity pointers from start to goal\n        path_vertices = [start]\n        current = start\n        while current is not goal:\n            if goal not in current.connectivity:\n                # No connection found - abort path extraction\n                return []\n            next_vertex = current.connectivity[goal]\n            if next_vertex == current:\n                # Avoid infinite loop if connectivity mismanaged\n                return []\n            path_vertices.append(next_vertex)\n            current = next_vertex\n        return [v.position for v in path_vertices]\n\n    def _extract_path(self, connect_vertex_agent: Vertex, connect_vertex_goal: Vertex) -> None:\n        # When two trees connect, we build path from agent to connection vertex,\n        # then from connection vertex in goal tree to goal.\n        # The goal tree connectivity is from goal backward, so path is reversed.\n        agent_root = self._graph.root_vertices[0]\n        goal_root = self._graph.root_vertices[1]\n\n        path_to_connect = self._extract_path_from_connectivity(agent_root, connect_vertex_agent)\n        path_from_connect = self._extract_path_from_connectivity(goal_root, connect_vertex_goal)\n\n        if not path_to_connect or not path_from_connect:\n            return  # Can't extract full path\n\n        path_from_connect.reverse()  # Because connectivity is towards root, reverse to go from connect to goal\n\n        full_path = path_to_connect + path_from_connect[1:]  # Avoid duplication of connect vertex\n\n        for p in full_path:\n            self.move_agent(p)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        grid = self._get_grid()\n        agent_vertex = self._graph.root_vertices[0]\n        goal_vertex = self._graph.root_vertices[1]\n\n        # Initialize trees with root vertices\n        self._tree_agent = [agent_vertex]\n        self._tree_goal = [goal_vertex]\n        self._graph.edges_removable = True\n\n        start_time = time.time()\n        # Iterative growth with max iterations capped by V_size * 5 to avoid infinite loops\n        max_iterations = self._V_size * 5\n        for _ in range(max_iterations):\n            if time.time() - start_time > 30:\n                # Timeout reached; treat route as not found\n                return\n\n            # Sample a random valid point\n            q_rand = self._get_random_sample()\n\n            # --- Extend agent tree towards q_rand ---\n            nearest_agent = self._nearest(self._tree_agent, q_rand)\n            q_new_agent = self._steer(nearest_agent, q_rand, self._max_extend_dist)\n            line_agent = grid.get_line_sequence(nearest_agent.position, q_new_agent.position)\n            if grid.is_valid_line_sequence(line_agent) and q_new_agent.position != nearest_agent.position:\n                new_vertex_agent = Vertex(q_new_agent.position, store_connectivity=True)\n                self._graph.add_vertex(new_vertex_agent)\n                self._graph.add_edge(nearest_agent, new_vertex_agent)\n                self._graph.add_edge(new_vertex_agent, nearest_agent)\n                self._tree_agent.append(new_vertex_agent)\n                self.key_frame()\n\n                # Try connect new_agent_vertex to the goal tree\n                nearest_goal = self._nearest(self._tree_goal, new_vertex_agent.position)\n                if nearest_goal.position != new_vertex_agent.position:\n                    line_connect = grid.get_line_sequence(new_vertex_agent.position, nearest_goal.position)\n                    if grid.is_valid_line_sequence(line_connect):\n                        # Connect trees\n                        new_vertex_goal = Vertex(nearest_goal.position, store_connectivity=True)\n                        # No need to add nearest_goal again (already in tree_goal)\n                        self._graph.add_edge(new_vertex_agent, nearest_goal)\n                        self._graph.add_edge(nearest_goal, new_vertex_agent)\n                        self.key_frame()\n                        # Extract path and return\n                        self._extract_path(new_vertex_agent, nearest_goal)\n                        return\n\n            # --- Extend goal tree towards q_rand ---\n            nearest_goal = self._nearest(self._tree_goal, q_rand)\n            q_new_goal = self._steer(nearest_goal, q_rand, self._max_extend_dist)\n            line_goal = grid.get_line_sequence(nearest_goal.position, q_new_goal.position)\n            if grid.is_valid_line_sequence(line_goal) and q_new_goal.position != nearest_goal.position:\n                new_vertex_goal = Vertex(q_new_goal.position, store_connectivity=True)\n                self._graph.add_vertex(new_vertex_goal)\n                self._graph.add_edge(nearest_goal, new_vertex_goal)\n                self._graph.add_edge(new_vertex_goal, nearest_goal)\n                self._tree_goal.append(new_vertex_goal)\n                self.key_frame()\n\n                # Try connect new_goal_vertex to the agent tree\n                nearest_agent = self._nearest(self._tree_agent, new_vertex_goal.position)\n                if nearest_agent.position != new_vertex_goal.position:\n                    line_connect = grid.get_line_sequence(new_vertex_goal.position, nearest_agent.position)\n                    if grid.is_valid_line_sequence(line_connect):\n                        # Connect trees\n                        self._graph.add_edge(new_vertex_goal, nearest_agent)\n                        self._graph.add_edge(nearest_agent, new_vertex_goal)\n                        self.key_frame()\n                        # Extract path and return\n                        self._extract_path(nearest_agent, new_vertex_goal)\n                        return ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* variant with goal biasing and adaptive sampling radius for faster convergence.\nThe key improvements over standard RRT* are:\n- Goal bias: a certain fraction of samples are drawn directly from the goal region to guide growth towards the target.\n- Adaptive radius: dynamically adjusts the rewiring radius based on graph size to balance exploration and exploitation.\n- Early termination on timeout (30 seconds).\nThese modifications speed up path discovery and improve performance in complex environments.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _goal_bias: float\n    _max_dist: float\n    _max_iterations: int\n    _max_radius: float\n    _lambda_rrt_star: float\n    _dimension: int\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Added member variables for improved algorithm\n        self._goal_bias = 0.2         # 20% samples from goal region, biases growth towards goal\n        self._max_dist = 10.0         # Maximum extension distance for new vertices\n        self._max_iterations = 10000  # Maximum number of iterations\n        self._max_radius = 50.0       # Maximum radius for neighbor search during rewiring\n        self._lambda_rrt_star = 50.0  # Constant factor used in rewiring radius calculation (as in RRT*)\n        self._dimension = 2           # Dimensionality of the planning space (assumed 2D)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + [EntitiesMapDisplay(self._services)]\n\n    def _get_random_sample(self) -> Point:\n        # With probability goal_bias, sample near or at the goal position to accelerate convergence\n        if np.random.rand() < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            # Small random offset around goal to expand exploration near goal region\n            offset = np.random.uniform(-2, 2, size=self._dimension)\n            goal_sample_array = goal_pos.to_tensor().numpy() + offset\n            goal_sample_array = np.clip(goal_sample_array, 0, self._get_grid().size - 1)\n            sample = Point(*goal_sample_array)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n        # Otherwise, uniform random valid sample in the map\n        return super()._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for iteration in range(self._max_iterations):\n            # Timeout after 30 seconds\n            if time.time() - start_time > 30.0:\n                # Fail to find path within time limit\n                break\n\n            q_sample = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_nearest, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_nearest.position, q_new.position)\n            ):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(\n                self._lambda_rrt_star * ((log_card_v / card_v) ** (1 / self._dimension)),\n                self._max_radius,\n            )\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius(\n                [self._graph.root_vertex_start], q_new.position, radius\n            )\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            # Choose best parent for q_new\n            for q_near in Q_near:\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                ):\n                    cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                    if cost_near_to_new < c_min:\n                        q_min = q_near\n                        c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring for optimization\n            for q_near in Q_near:\n                if q_near == q_min:\n                    continue\n                if self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                ):\n                    cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                    if cost_new_to_near < q_near.cost:\n                        q_parent = next(iter(q_near.parents), None)\n                        if q_parent is not None:\n                            self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = None\n                        q_near.cost = cost_new_to_near\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame()\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n\n        path: List[Vertex] = [goal_v]\n        # Backtrack parent chain from goal to root\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))\n            path.append(parent)\n\n        path.pop()  # Remove root duplicated\n        path.reverse()\n\n        # Move agent along the path\n        for vertex in path:\n            self.move_agent(vertex.position)\n            grid = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm is an improved variant of RRT-Connect, named Biased RRT*, combining the bidirectional growth strategy \nof RRT-Connect with heuristic sampling bias and cost optimization to improve time efficiency and path quality.\nThe key improvements over standard RRT-Connect are:\n- Sampling is biased towards the goal region with some probability to accelerate convergence.\n- Instead of fixed maximum distance steps, it uses incremental cost-based extension to better optimize the path.\n- Attempts rewiring in the trees to continuously improve path quality.\n- The search terminates after 30 seconds if no path is found, preventing excessive runtime.\n\nIt maintains the core concept of connecting two trees grown from start and goal, but uses heuristics and rewiring \nto speed up search and find paths faster.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow rewiring/removal of edges for optimization\n        self._init_displays()\n\n        self._max_dist = 12  # Slightly larger extension step\n        self._iterations = 15000  # Increased iterations, but bounded by time\n        self._goal_sample_rate = 0.1  # 10% goal-biased sampling\n\n    # Override displays to reuse existing display setup\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _get_path_cost(self, vertex: Vertex) -> float:\n        # Sum of edge costs to root; assume edge cost = distance(parent to vertex)\n        cost = 0.0\n        current = vertex\n        while current.parents:\n            parent = current.parents[0]\n            cost += self._distance(current.position, parent.position)\n            current = parent\n        return cost\n\n    def _get_near_vertices(self, root_vertex: Vertex, q_sample: Point, radius: float) -> List[Vertex]:\n        # Returns all vertices within radius of q_sample inside this tree\n        near_vertices = []\n        vertices_to_check = []\n        # BFS or DFS from root vertex to gather all vertices\n        # We assume Forest has method to get all vertices linked from root_vertex\n        vertices_to_check.append(root_vertex)\n        visited = set()\n        while vertices_to_check:\n            v = vertices_to_check.pop()\n            if v in visited:\n                continue\n            visited.add(v)\n            if self._distance(v.position, q_sample) <= radius:\n                near_vertices.append(v)\n            # Add children to check next\n            for edge_child in self._graph.adjacent(v):\n                if edge_child not in visited:\n                    vertices_to_check.append(edge_child)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose best parent that yields minimal path cost to q_new and is collision free\n        min_cost = float('inf')\n        best_parent = None\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(v.position, q_new.position)\n            if self._get_grid().is_valid_line_sequence(line_seq):\n                cost = self._get_path_cost(v) + self._distance(v.position, q_new.position)\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = v\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to rewire near vertices through q_new if it results in lower cost path\n        for v in near_vertices:\n            line_seq = self._get_grid().get_line_sequence(q_new.position, v.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n            cost_through_qnew = self._get_path_cost(q_new) + self._distance(q_new.position, v.position)\n            cost_current = self._get_path_cost(v)\n            if cost_through_qnew < cost_current:\n                # Rewire: remove old parent edge, add new edge from q_new\n                # Note: Forest edges_removable=True allows this operation\n                for p in v.parents:\n                    self._graph.remove_edge(p, v)\n                    break\n                self._graph.add_edge(q_new, v)\n\n    def _extend(self, root_vertex: Vertex, q: Point) -> str:\n        # Modified extend for cost-based parent selection and rewiring\n        self._q_near = self._get_nearest_vertex(root_vertex, q)\n        self._q_new = self._get_new_vertex(self._q_near, q, self._max_dist)\n        if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(self._q_near.position, self._q_new.position)):\n            return 'trapped'\n\n        near_radius = self._max_dist * 2.0  # radius for near vertices in rewiring\n        near_vertices = self._get_near_vertices(root_vertex, self._q_new.position, near_radius)\n        parent = self._choose_parent(near_vertices, self._q_new)\n\n        if parent is None:\n            # Fallback to nearest vertex if no better parent found\n            parent = self._q_near\n\n        self._graph.add_edge(parent, self._q_new)\n        self._rewire(near_vertices, self._q_new)\n\n        if self._q_new.position == q:\n            return 'reached'\n        else:\n            return 'advanced'\n\n    def _connect(self, root_vertex: Vertex, q: Vertex) -> str:\n        S = 'advanced'\n        while S == 'advanced':\n            S = self._extend(root_vertex, q.position)\n        self._mid_vertex = q\n        return S\n\n    def _extract_path(self) -> None:\n        # trace back path from connection point between start and goal trees\n\n        # From q_new back to start root\n        path_mid_to_start: List[Vertex] = [self._q_new]\n        while len(path_mid_to_start[-1].parents) != 0:\n            for parent in path_mid_to_start[-1].parents:\n                path_mid_to_start.append(parent)\n                break\n\n        # From extension target back to goal root\n        path_goal_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_goal_to_mid[-1].parents) != 0:\n            for parent in path_goal_to_mid[-1].parents:\n                path_goal_to_mid.append(parent)\n                break\n\n        path_goal_to_mid.reverse()\n        path = path_goal_to_mid + path_mid_to_start\n\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling towards goal position to improve search speed\n        if np.random.rand() < self._goal_sample_rate:\n            # sample goal position directly; if valid\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        # else random uniform sample\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    # Main path finding function with 30 sec timeout\n    def _find_path_internal(self) -> None:\n        start_time = time()\n        for iteration in range(self._iterations):\n            # Check timeout after each iteration\n            if time() - start_time > 30.0:\n                # Failed to find path in 30 seconds\n                break\n\n            q_rand: Point = self._get_random_sample()\n\n            if self._extend(self._graph.root_vertices[0], q_rand) != 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved sample-based path planning algorithm inspired by RRT* (Rapidly-exploring Random Tree Star).\n    It incrementally builds a tree of feasible paths by sampling points in the free space and rewiring the tree to optimize \n    the path cost. Unlike the traditional A*, which relies on grid exploration, this approach uses sampling to improve \n    runtime in large or continuous spaces. We enforce a 30-second timeout to avoid long runtimes.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Improved Sample-Based Path Planning algorithm using RRT* style rewiring and optimization.\n    \"\"\"\n\n    def __init__(self, services: Services, testing: Optional[BasicTesting] = None) -> None:\n        super().__init__(services, testing)\n\n        # graph stores vertices for the sample-based method (vertex.position: Point, vertex.cost: float, vertex.parent: Optional[Vertex])\n        self._graph: Dict[Point, Vertex] = {}\n\n        # maximum distance to extend tree per iteration\n        self._max_extend_length = 10.0\n\n        # radius for rewiring neighbors\n        self._neighbor_radius = 15.0\n\n        # Store goal and start vertices\n        self._start_vertex: Optional[Vertex] = None\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Pre-initialize display list\n        self.__map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Initialize graph display once per planning\n        if not self.__map_displays:\n            self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        agent_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        # Initialize start vertex\n        self._start_vertex = Vertex(agent_pos)\n        self._start_vertex.cost = 0.0\n        self._start_vertex.parent = None\n\n        # Add start vertex to graph\n        self._graph.clear()\n        self._graph[agent_pos] = self._start_vertex\n\n        # Initialize goal vertex as placeholder, cost set to infinity initially\n        self._goal_vertex = Vertex(goal_pos)\n        self._goal_vertex.cost = float(\"inf\")\n        self._goal_vertex.parent = None\n\n        start_time = time.time()\n        time_limit = 30.0  # seconds\n\n        found_path = False\n\n        while True:\n            # Check timeout\n            if time.time() - start_time > time_limit:\n                # Timeout reached without path found\n                break\n\n            # Sample random free point in map\n            q_rand: Point = self._sample_free()\n\n            # Find nearest vertex in tree to q_rand\n            q_near: Vertex = self._nearest_vertex(q_rand)\n\n            # Steer from q_near towards q_rand to get q_new\n            q_new_pos: Point = self._steer(q_near.position, q_rand, self._max_extend_length)\n\n            if not grid.is_free(q_new_pos):\n                # Skip if q_new position is in obstacle\n                continue\n\n            # Check if path from q_near to q_new is collision free\n            if not self._collision_free(q_near.position, q_new_pos):\n                continue\n\n            # Create new vertex for q_new\n            q_new = Vertex(q_new_pos)\n\n            # Find neighbors within rewiring radius\n            neighbors = self._near_vertices(q_new_pos, self._neighbor_radius)\n\n            # Choose parent with minimum cost + cost to q_new\n            q_new_parent, q_new_cost = self._choose_parent(q_near, neighbors, q_new_pos)\n            q_new.parent = q_new_parent\n            q_new.cost = q_new_cost\n\n            # Add q_new to graph\n            self._graph[q_new_pos] = q_new\n\n            # Rewire neighbors to q_new if it improves their cost\n            self._rewire(q_new, neighbors)\n\n            # Check if q_new is close enough to goal and path from q_new to goal is free\n            if self._dist(q_new_pos, goal_pos) <= self._max_extend_length and self._collision_free(q_new_pos, goal_pos):\n                temp_goal_cost = q_new.cost + self._dist(q_new_pos, goal_pos)\n                if temp_goal_cost < self._goal_vertex.cost:\n                    # Update goal vertex parent and cost\n                    self._goal_vertex.parent = q_new\n                    self._goal_vertex.cost = temp_goal_cost\n                    self._goal_vertex.position = goal_pos\n                    self._graph[goal_pos] = self._goal_vertex\n                    found_path = True\n\n            self.key_frame()\n\n            # If we found a path, we can stop early or keep running to try and improve it\n            if found_path and (time.time() - start_time) > 0.5:\n                # Small delay after first path found then stop\n                break\n\n        if found_path:\n            self._move_agent_along_path()\n        # else, no path found within time limit; do nothing\n\n    # Helper methods below\n\n    def _sample_free(self) -> Point:\n        \"\"\"\n        Returns a random free point in the map.\n        Uses grid API or uniform sampling over map dimensions.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Try up to 100 times to find free point randomly\n        for _ in range(100):\n            x = self._services.state.rnd.uniform(0, grid.width - 1)\n            y = self._services.state.rnd.uniform(0, grid.height - 1)\n            sample_point = Point(int(x), int(y))\n            if grid.is_free(sample_point):\n                return sample_point\n        # fallback to agent position if no free sample found (unlikely)\n        return grid.agent.position\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Returns the vertex in the graph closest to given point.\n        \"\"\"\n        min_dist = float(\"inf\")\n        nearest = None\n        for v in self._graph.values():\n            dist = self._dist(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within radius distance of the point.\n        \"\"\"\n        neighbors = []\n        for v in self._graph.values():\n            if self._dist(v.position, point) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _steer(self, from_point: Point, to_point: Point, max_dist: float) -> Point:\n        \"\"\"\n        Returns a Point moved from from_point towards to_point by max_dist at most.\n        \"\"\"\n        vector = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = (vector[0] ** 2 + vector[1] ** 2) ** 0.5\n        if dist <= max_dist:\n            return to_point\n        else:\n            scale = max_dist / dist\n            new_x = int(from_point[0] + vector[0] * scale)\n            new_y = int(from_point[1] + vector[1] * scale)\n            return Point(new_x, new_y)\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        \"\"\"\n        Check if path between from_point and to_point is free of obstacles using Bresenham line or similar.\n        \"\"\"\n        grid: Map = self._get_grid()\n        points = self._bresenham_line(from_point, to_point)\n        for p in points:\n            if not grid.is_free(p):\n                return False\n        return True\n\n    def _choose_parent(self, q_near: Vertex, neighbors: List[Vertex], q_new_pos: Point) -> Tuple[Vertex, float]:\n        \"\"\"\n        Chooses the best parent for q_new from neighbors minimizing total cost \n        (cost to neighbor + cost from neighbor to q_new).\n        \"\"\"\n        grid: Map = self._get_grid()\n        min_cost = q_near.cost + self._dist(q_near.position, q_new_pos)\n        best_parent = q_near\n        for neighbor in neighbors:\n            if neighbor == q_near:\n                continue\n            if not self._collision_free(neighbor.position, q_new_pos):\n                continue\n            cost = neighbor.cost + self._dist(neighbor.position, q_new_pos)\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = neighbor\n        return best_parent, min_cost\n\n    def _rewire(self, q_new: Vertex, neighbors: List[Vertex]) -> None:\n        \"\"\"\n        For each neighbor, see if going through q_new improves cost; if yes, rewire tree.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for neighbor in neighbors:\n            if neighbor == q_new.parent:\n                continue\n            if not self._collision_free(q_new.position, neighbor.position):\n                continue\n            cost_through_qnew = q_new.cost + self._dist(q_new.position, neighbor.position)\n            if cost_through_qnew < neighbor.cost:\n                neighbor.parent = q_new\n                neighbor.cost = cost_through_qnew\n\n    def _move_agent_along_path(self) -> None:\n        \"\"\"\n        Follow back from goal vertex to start and move agent along path.\n        \"\"\"\n        grid: Map = self._get_grid()\n        path: List[Point] = []\n        current = self._goal_vertex\n        while current.parent is not None:\n            path.append(current.position)\n            current = current.parent\n        path.append(self._start_vertex.position)\n        path.reverse()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _dist(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between two Points.\n        \"\"\"\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def _bresenham_line(self, start: Point, end: Point) -> List[Point]:\n        \"\"\"\n        Uses Bresenham's line algorithm to get points between start and end (inclusive).\n        \"\"\"\n        points = []\n\n        x0, y0 = start\n        x1, y1 = end\n        dx = abs(x1 - x0)\n        dy = abs(y1 - y0)\n        x, y = x0, y0\n\n        sx = 1 if x0 < x1 else -1\n        sy = 1 if y0 < y1 else -1\n\n        if dx > dy:\n            err = dx / 2.0\n            while x != x1:\n                points.append(Point(x, y))\n                err -= dy\n                if err < 0:\n                    y += sy\n                    err += dx\n                x += sx\n            points.append(Point(x, y))\n        else:\n            err = dy / 2.0\n            while y != y1:\n                points.append(Point(x, y))\n                err -= dx\n                if err < 0:\n                    x += sx\n                    err += dy\n                y += sy\n            points.append(Point(x, y))\n\n        return points ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm, named PathPlanning, is an improvement over the basic RRT* by integrating a heuristic-guided sampling approach inspired by Informed RRT*. \nAfter an initial path to the goal is found, the sampling region is confined to an ellipsoidal subset of the search space that can possibly yield a better path, \nreducing unnecessary exploration and improving convergence speed. Time limiting is enforced to abort if no path is found within 30 seconds.\nThe algorithm inherits from SampleBasedAlgorithm, reuses helper functions from RRT*, and modifies the sampling and iteration logic accordingly.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional member variables for improved sampling\n        self._best_cost: Optional[float] = None\n        # Precompute direct distance from start to goal for ellipsoid calculation\n        self._start_pos = self._graph.root_vertex_start.position\n        self._goal_pos = goal_vertex.position\n        self._c_best_init = torch.norm(self._start_pos.to_tensor() - self._goal_pos.to_tensor()).item()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._graph.display_info if hasattr(self._graph, 'display_info') else super().set_display_info()\n\n    def _get_random_sample_informed(self) -> Point:\n        \"\"\"\n        Sample inside an ellipsoidal informed subset once a path exists\n        If no path found yet, sample uniformly.\n        \"\"\"\n\n        size = self._get_grid().size\n        n_dim = size.n_dim\n\n        if self._best_cost is None:\n            # No solution found yet: uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, size, n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n        else:\n            # Sample from ellipsoid defined by start, goal, and best_cost\n            c_min = self._c_best_init\n            c_max = self._best_cost\n\n            center = Point.from_tensor((self._start_pos.to_tensor() + self._goal_pos.to_tensor()) / 2)\n            a1 = (self._goal_pos.to_tensor() - self._start_pos.to_tensor()) / torch.norm(self._goal_pos.to_tensor() - self._start_pos.to_tensor())\n            # Create an orthonormal basis (for 2D case) - extend for higher dims if necessary\n            if n_dim == 2:\n                a2 = torch.tensor([-a1[1], a1[0]])\n                U = torch.stack([a1, a2], dim=1)\n            else:\n                # For higher dims, create identity basis (fallback)\n                U = torch.eye(n_dim)\n\n            # radii of ellipsoid\n            l1 = c_max / 2\n            # Other axes radii\n            if n_dim > 1:\n                l2 = (c_max**2 - c_min**2)**0.5 / 2\n            else:\n                l2 = 0\n\n            L_diag = torch.diag(torch.tensor([l1] + [l2]*(n_dim - 1), dtype=torch.float32))\n\n            for _ in range(100):  # Attempt sampling to find a valid point\n                # Sample from unit n-ball\n                x_ball = torch.randn(n_dim)\n                norm_x = torch.norm(x_ball)\n                if norm_x == 0:\n                    continue\n                x_ball_unit = x_ball / norm_x\n                # Sample radius inside unit ball uniformly\n                r = np.random.uniform(0, 1) ** (1/n_dim)\n                x_rand_ball = r * x_ball_unit\n                # Map to ellipsoid\n                x_rand = torch.matmul(U, torch.matmul(L_diag, x_rand_ball)) + center.to_tensor()\n\n                # Project to nearest integer grid point\n                x_rand_int = x_rand.round().long()\n                x_rand_int_clamped = torch.clamp(x_rand_int, min=0, max=size - 1)\n                sample = Point.from_tensor(x_rand_int_clamped)\n\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n            # If no valid sample found after attempts, fallback to uniform sampling\n            while True:\n                rand_pos = np.random.randint(0, size, n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        # Same as in RRT_Star; reused with no modification\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Traverse parents to root\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        # Remove duplicate root vertex and reverse path\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        path_found = False\n\n        for i in range(iterations):\n\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Timeout: path not found within 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample_informed()\n            q_nearest: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._graph.get_vertices_within_radius([self._graph.root_vertex_start], q_new.position, radius)\n\n            # Choose minimum cost parent\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewiring nearby vertices\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost and extract path\n                self._best_cost = q_new.cost + torch.norm(q_new.position.to_tensor() - self._goal_pos.to_tensor()).item()\n                self._extract_path(q_new)\n                path_found = True\n                break\n\n            self.key_frame()\n\n        if not path_found:\n            # If no path found within time or iterations, optionally notify or handle here\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved RRT* (Rapidly-exploring Random Tree Star) inspired algorithm for faster path planning.\n    This algorithm incrementally builds a tree by sampling points, connects new vertices considering optimal\n    rewiring to reduce path cost, and prunes unnecessary branches. It biases sampling towards the goal to\n    improve convergence speed, rewires vertices within a radius to optimize paths, and stops searching after\n    30 seconds if no path is found. This improves over basic RRT by seeking lower cost paths and faster convergence.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self, goal_sample_rate: float = 0.1) -> Point:\n        \"\"\"\n        With some probability, sample the goal point to bias tree growth towards goal.\n        Otherwise, sample uniformly at random in valid environment positions.\n        \"\"\"\n        if np.random.random() < goal_sample_rate:\n            # Bias towards goal\n            return self._get_grid().goal.position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return torch.norm(p1.to_tensor() - p2.to_tensor()).item()\n\n    def _find_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Find all vertices within 'radius' of q_new.position in the graph.\n        \"\"\"\n        near_vertices: List[Vertex] = []\n        vertices_to_search = self._graph.all_vertices()\n        for vertex in vertices_to_search:\n            if self._distance(vertex.position, q_new.position) <= radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Choose the best parent for q_new among the near_vertices that minimizes cost to q_new\n        while ensuring the line path is valid.\n        \"\"\"\n        if not near_vertices:\n            return None\n\n        min_cost = math.inf\n        best_parent = None\n\n        for q_near in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + self._distance(q_near.position, q_new.position)\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                best_parent = q_near\n\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        \"\"\"\n        For all near vertices, check if rewiring through q_new would lower cost.\n        If yes and line path is valid, rewire to q_new.\n        \"\"\"\n        for q_near in near_vertices:\n            if q_near == q_new.parent:\n                continue  # skip parent vertex\n            \n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n\n            new_cost = q_new.cost + self._distance(q_new.position, q_near.position)\n            if new_cost < q_near.cost:\n                # Rewire q_near to have q_new as parent\n                if q_near.parents:\n                    for p in list(q_near.parents):\n                        self._graph.remove_edge(p, q_near)\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = new_cost\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        while len(path[-1].parents) != 0:\n            parent = next(iter(path[-1].parents))  # get one parent (tree structure expected)\n            path.append(parent)\n\n        path.reverse()\n\n        # Animate path tracing from start to goal\n        for vertex in path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overrides #\n    # --------- #\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_iterations: int = 10000\n        goal_radius: float = self._get_grid().goal.radius if hasattr(self._get_grid().goal, \"radius\") else 1.0\n        dimension = self._get_grid().size.n_dim\n\n        # Initialize costs for root vertex\n        self._graph.root_vertex_start.cost = 0.0\n\n        start_time = time.time()\n        for i in range(max_iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:  # timeout after 30 seconds\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=0.2)  # bias sampling by 20% towards goal\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # If the path to new vertex invalid, skip\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # Find near vertices within a radius for rewiring and parent selection\n            # Radius chosen based on space dimension and log of iterations (RRT* style)\n            radius = max_dist * 2.0  # can be tuned or adaptive, kept fixed here for simplicity\n\n            near_vertices: List[Vertex] = self._find_near_vertices(q_new, radius)\n\n            # Choose parent with lowest cost connection\n            parent: Optional[Vertex] = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                # fallback: connect to nearest vertex if no better parent found\n                parent = q_near\n\n            # Set q_new cost and parent\n            q_new.cost = parent.cost + self._distance(parent.position, q_new.position)\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire near vertices if better cost found through q_new\n            self._rewire(near_vertices, q_new)\n\n            # Check if q_new is within goal radius (using Euclidean distance)\n            if self._distance(q_new.position, self._get_grid().goal.position) <= goal_radius \\\n               and self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect q_new to goal to complete path\n                goal_vertex = Vertex(self._get_grid().goal.position)\n                goal_vertex.cost = q_new.cost + self._distance(q_new.position, goal_vertex.position)\n                # Validate that path from q_new to goal is collision free\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    break\n\n            # Create visualization keyframe for each iteration\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved path planning algorithm based on RRT* with enhancements to improve \n    time efficiency. The key ideas include:\n    - Incorporating a goal bias sampling strategy to speed up convergence towards the goal by sampling the goal \n      position with a certain probability.\n    - Early stopping condition using a timeout of 30 seconds to abort the search if no path is found within the time limit.\n    - Reuse of graph radius calculation for rewiring but with a slightly reduced max radius to limit unnecessary nearby connections.\n    - Maintaining the laziness of rewiring, only rewiring when a better path is found, preserving the optimized paths.\n    The algorithm inherits SampleBasedAlgorithm and overrides _find_path_internal and set_display_info methods.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Add any new member variables here if needed\n        self._goal_bias = 0.1  # Probability to sample the goal directly for faster convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Samples the goal position with probability self._goal_bias,\n        otherwise returns a random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10.0\n        iterations: int = 10000\n        max_radius: float = 40.0  # Reduced max radius to prune rewiring computations slightly\n        lambda_rrt_star: float = 40.0\n        dimension: int = 2\n\n        start_time = time.time()\n\n        for i in range(iterations):\n\n            # Check elapsed time for early stopping if >30 seconds\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Abort search - no path found in time limit\n                break\n\n            q_sample: Point = self._get_biased_sample()\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position)\n                )\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    # Rewire only if improvement is made\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        q_near.cost = None\n                        self._graph.remove_edge(q_parent, q_near)\n                        q_near.cost = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                        self._graph.add_edge(q_new, q_near)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Algorithm Description:\n    This is an improved RRT-Connect based path planning algorithm named PathPlanning.\n    It introduces goal biasing to efficiently direct tree growth towards the goal, reducing random samples.\n    It also uses bidirectional tree growing but adds a time-based termination condition (30 seconds) to ensure timely response.\n    By periodically biasing samples toward the goal and limiting elapsed search time, it improves pathfinding speed while preserving completeness.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_bias: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_bias = 0.2  # 20% samples towards goal for faster convergence\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_biased_sample(self) -> Point:\n        \"\"\"\n        Return a random sample point with goal biasing:\n        With probability _goal_bias, return the goal position as sample.\n        Otherwise, return a uniform random valid sample.\n        \"\"\"\n        if np.random.rand() < self._goal_bias:\n            goal_pos = self._get_grid().goal.position\n            if self._get_grid().is_agent_valid_pos(goal_pos):\n                return goal_pos\n        return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n            elapsed = time.time() - start_time\n            if elapsed > 30.0:\n                # Timeout, path not found within time limit\n                break\n\n            q_rand: Point = self._get_biased_sample()\n\n            extend_status = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_status != 'trapped':\n                self._extension_target = self._q_new\n                connect_status = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_status == 'reached':\n                    self._extract_path()\n                    break\n\n            self._graph.reverse_root_vertices()\n\n            # Visualization key frame for animation/debugging\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation uses the RRT* (Rapidly-exploring Random Tree Star) algorithm, which is a sample-based \n    path planning algorithm that iteratively builds and optimizes a tree rooted at the start position to find \n    an efficient, collision-free path to the goal. RRT* randomly samples points in the space, connects new samples \n    to the nearest tree vertex if feasible, and rewires the tree to reduce path costs. This approach improves \n    performance and path quality over classic discrete grid search like A*. A 30-second timeout is added to \n    terminate search if path not found timely.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Dict[Point, Vertex]\n    _q_new: Optional[Vertex]\n    _q_near: Optional[Vertex]\n    _q_nearest: Optional[Vertex]\n    _q_parent: Optional[Vertex]\n    _goal_vertex: Optional[Vertex]\n\n    max_search_time: float\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph as a dictionary mapping position to Vertex\n        self._graph = {}\n        self._q_new = None\n        self._q_near = None\n        self._q_nearest = None\n        self._q_parent = None\n        self._goal_vertex = None\n\n        self.max_search_time = 30.0  # seconds timeout\n\n        # Initialize displays list\n        self.__map_displays = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Show the graph of explored paths if generated\n        if not self.__map_displays:\n            self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        Implements RRT* algorithm with improvements in rewiring and cost optimization.\n        Terminates search if path to goal is found or timeout of 30 seconds is reached.\n        After path is found, follows and moves the agent along the path.\n        \"\"\"\n        grid: Map = self._get_grid()\n        self._init_graph(grid.agent.position)\n\n        start_time = time()\n        found_path = False\n\n        while True:\n            if (time() - start_time) > self.max_search_time:\n                # Timeout: Route not found\n                break\n\n            q_rand_point = self._get_random_sample()\n            self._q_nearest = self._nearest_vertex(q_rand_point)\n\n            q_new_pos, valid = self._steer(self._q_nearest.position, q_rand_point)\n            if not valid:\n                self.key_frame()\n                continue\n\n            if self._collision_free(self._q_nearest.position, q_new_pos):\n                self._q_new = Vertex(q_new_pos)\n                self._q_new.cost = float('inf')\n                neighbors = self._near_vertices(self._q_new.position)\n\n                # Choose parent with minimum cost + distance\n                min_cost = self._q_nearest.cost + self._cost(self._q_nearest.position, self._q_new.position)\n                self._q_parent = self._q_nearest\n                for q_near in neighbors:\n                    if self._collision_free(q_near.position, self._q_new.position):\n                        cost_through_qnear = q_near.cost + self._cost(q_near.position, self._q_new.position)\n                        if cost_through_qnear < min_cost:\n                            min_cost = cost_through_qnear\n                            self._q_parent = q_near\n\n                # Attach new node\n                self._q_new.cost = min_cost\n                self._q_new.parent = self._q_parent\n                self._graph[self._q_new.position] = self._q_new\n\n                # Rewire neighbors if we improve their cost\n                for q_near in neighbors:\n                    if q_near == self._q_parent:\n                        continue\n                    if self._collision_free(self._q_new.position, q_near.position):\n                        cost_to_neighbor = self._q_new.cost + self._cost(self._q_new.position, q_near.position)\n                        if cost_to_neighbor < q_near.cost:\n                            q_near.parent = self._q_new\n                            q_near.cost = cost_to_neighbor\n\n                self.key_frame()\n\n                # Check if goal reached (distance threshold)\n                if self._distance(self._q_new.position, grid.goal.position) < grid.get_movement_cost_from_index(0, grid.goal.position):\n                    self._goal_vertex = Vertex(grid.goal.position)\n                    self._goal_vertex.parent = self._q_new\n                    self._goal_vertex.cost = self._q_new.cost + self._cost(self._q_new.position, grid.goal.position)\n                    self._graph[self._goal_vertex.position] = self._goal_vertex\n                    found_path = True\n                    break\n\n        if found_path:\n            self._follow_path()\n        else:\n            # no path found within time limit\n            pass\n\n    def _init_graph(self, start_pos: Point) -> None:\n        \"\"\"Initialize the graph with the start vertex.\"\"\"\n        start_vertex = Vertex(start_pos)\n        start_vertex.cost = 0.0\n        start_vertex.parent = None\n        self._graph = {start_pos: start_vertex}\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Samples a random free position from the map.\n        Uses the map's random_sample API if available, else samples uniformly.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for _ in range(100):  # try 100 times max\n            sample = grid.random_sample()\n            if sample is not None and not grid.is_obstacle(sample):\n                return sample\n        # fallback: return goal if no random sample found avoid infinite loop\n        return grid.goal.position\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"Return the vertex in graph closest to the point.\"\"\"\n        nearest = None\n        min_dist = float('inf')\n        for v in self._graph.values():\n            dist = self._distance(v.position, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = v\n        return nearest\n\n    def _near_vertices(self, point: Point, radius: float = 5.0) -> List[Vertex]:\n        \"\"\"Return graph vertices within radius distance from point.\"\"\"\n        neighbors = []\n        for v in self._graph.values():\n            if self._distance(v.position, point) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _steer(self, from_point: Point, to_point: Point, max_extend_length: float = 3.0) -> (Point, bool):\n        \"\"\"\n        Returns a new point in the direction from from_point to to_point \n        at distance no greater than max_extend_length.\n        Returns (new_point, is_valid) tuple.\n        \"\"\"\n        from_np = self._to_np(from_point)\n        to_np = self._to_np(to_point)\n        direction = to_np - from_np\n        dist = np.linalg.norm(direction)\n        if dist == 0:\n            return from_point, False\n        length = min(max_extend_length, dist)\n        direction = direction / dist\n        new_pos_np = from_np + direction * length\n        new_pos = self._to_point(new_pos_np)\n        return new_pos, True\n\n    def _collision_free(self, from_point: Point, to_point: Point) -> bool:\n        \"\"\"\n        Checks if path from from_point to to_point is free of obstacles.\n        Uses map API for collision checking as necessary.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Sample intermediate points along the line and check collision\n        from_np = self._to_np(from_point)\n        to_np = self._to_np(to_point)\n        dist = np.linalg.norm(to_np - from_np)\n        steps = int(dist / 0.5) + 1\n        for i in range(steps + 1):\n            interm = from_np + (to_np - from_np) * (i / steps)\n            interm_point = self._to_point(interm)\n            if grid.is_obstacle(interm_point):\n                return False\n        return True\n\n    def _cost(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Returns the cost of moving from p1 to p2, \n        incorporating map's movement cost if available.\n        \"\"\"\n        grid: Map = self._get_grid()\n        # Use map's movement cost function if exists for the segment index 0\n        return grid.get_movement_cost_from_index(0, p2) + np.linalg.norm(np.array(p2) - np.array(p1)) * 0.001\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"Euclidean distance between two points.\"\"\"\n        return np.linalg.norm(np.array(p1) - np.array(p2))\n\n    def _to_np(self, point: Point) -> \"np.ndarray\":\n        return np.array(point)\n\n    def _to_point(self, arr: \"np.ndarray\") -> Point:\n        return Point(int(round(arr[0])), int(round(arr[1])))\n\n    def _follow_path(self) -> None:\n        \"\"\"Follow path from goal back to start, moving the agent step by step.\"\"\"\n        if self._goal_vertex is None:\n            return\n        grid: Map = self._get_grid()\n        path = []\n        curr = self._goal_vertex\n        while curr is not None:\n            path.append(curr.position)\n            curr = curr.parent\n        path.reverse()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, type(grid)):  # check if map is RosMap if needed\n                try:\n                    grid.publish_wp(grid.agent.position)\n                except Exception:\n                    pass\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved path planning algorithm based on the RRT* (Rapidly-exploring Random Tree Star) approach,\n    which is a sample-based algorithm designed to efficiently explore large continuous spaces.\n    This algorithm incrementally builds a tree by randomly sampling points in the space, connecting them to\n    the nearest existing tree vertex if valid, and rewiring the tree to find lower-cost paths. It improves\n    upon standard RRT by optimizing the path through rewiring, thus improving path quality over time.\n    To ensure responsiveness, the algorithm terminates if no path is found within 30 seconds.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: List[Vertex] = []  # The tree vertices\n        self._goal_vertex: Optional[Vertex] = None\n\n        self._max_distance: float = 5.0  # max step size for extending the tree\n        self._goal_sample_rate: float = 0.1  # probability of sampling the goal point directly\n        self._search_radius: float = 10.0  # radius for rewiring neighbors\n\n        # Display colors for visualization\n        self._vertex_colour = self._services.state.views.add_colour(\"vertex colour\", Colour(0.2, 0.6, 0.9, 0.7))\n        self._path_colour = self._services.state.views.add_colour(\"path colour\", Colour(0.9, 0.2, 0.2, 0.9))\n\n        self._map_displays: List[MapDisplay] = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self._map_displays = [SolidIterableMapDisplay(self._services, (v.point for v in self._graph), self._vertex_colour, z_index=60)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start = grid.agent.position\n        goal = grid.goal.position\n\n        self._graph = [Vertex(start)]\n        self._goal_vertex = None\n\n        start_time = time()\n        max_duration = 30.0  # seconds\n\n        while (time() - start_time) < max_duration:\n            # Sample a random point in the map or the goal with probability goal_sample_rate\n            rnd_point = self._sample_free_point(goal, grid)\n\n            nearest_vertex = self._nearest_vertex(rnd_point)\n            new_point = self._steer(nearest_vertex.point, rnd_point, self._max_distance)\n\n            if not grid.is_location_valid(new_point):\n                continue\n\n            if not grid.is_path_free(nearest_vertex.point, new_point):\n                continue\n\n            new_vertex = Vertex(new_point)\n            # Choose parent with minimal cost within search radius\n            neighbors = self._near_vertices(new_vertex.point)\n            min_cost = nearest_vertex.cost + self._distance(nearest_vertex.point, new_vertex.point)\n            min_parent = nearest_vertex\n\n            for neighbor in neighbors:\n                if grid.is_path_free(neighbor.point, new_vertex.point):\n                    cost = neighbor.cost + self._distance(neighbor.point, new_vertex.point)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = neighbor\n\n            new_vertex.parent = min_parent\n            new_vertex.cost = min_cost\n            self._graph.append(new_vertex)\n\n            # Rewire neighbors if this new vertex offers a lower cost path\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if grid.is_path_free(new_vertex.point, neighbor.point):\n                    cost_through_new = new_vertex.cost + self._distance(new_vertex.point, neighbor.point)\n                    if cost_through_new < neighbor.cost:\n                        neighbor.parent = new_vertex\n                        neighbor.cost = cost_through_new\n\n            self.key_frame()\n\n            # Check if goal can be connected directly within max_distance\n            if self._distance(new_vertex.point, goal) <= self._max_distance and grid.is_path_free(new_vertex.point, goal):\n                goal_vertex = Vertex(goal, new_vertex)\n                goal_vertex.cost = new_vertex.cost + self._distance(new_vertex.point, goal)\n                self._graph.append(goal_vertex)\n                self._goal_vertex = goal_vertex\n                break\n\n        if self._goal_vertex is not None:\n            self._follow_back_trace()\n        else:\n            # Mark algorithm done without path found\n            self.key_frame()\n\n    def _sample_free_point(self, goal: Point, grid: Map) -> Point:\n        import random\n        if random.random() < self._goal_sample_rate:\n            return goal\n        else:\n            # Sample uniformly from the map bounds\n            map_bounds = grid.get_bounds()  # expected to return (min_x, max_x, min_y, max_y)\n            x = random.uniform(map_bounds[0], map_bounds[1])\n            y = random.uniform(map_bounds[2], map_bounds[3])\n            sampled_point = Point(int(round(x)), int(round(y)))\n            return sampled_point\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        best_vertex = self._graph[0]\n        best_dist = self._distance(point, best_vertex.point)\n        for vertex in self._graph[1:]:\n            dist = self._distance(point, vertex.point)\n            if dist < best_dist:\n                best_dist = dist\n                best_vertex = vertex\n        return best_vertex\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        neighbors = []\n        r = self._search_radius\n        for vertex in self._graph:\n            if self._distance(point, vertex.point) <= r:\n                neighbors.append(vertex)\n        return neighbors\n\n    def _steer(self, from_p: Point, to_p: Point, max_dist: float) -> Point:\n        from_x, from_y = from_p\n        to_x, to_y = to_p\n        dist = self._distance(from_p, to_p)\n        if dist <= max_dist:\n            return to_p\n        else:\n            theta = math.atan2(to_y - from_y, to_x - from_x)\n            new_x = int(round(from_x + max_dist * math.cos(theta)))\n            new_y = int(round(from_y + max_dist * math.sin(theta)))\n            return Point(new_x, new_y)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])\n\n    def _follow_back_trace(self) -> None:\n        grid: Map = self._get_grid()\n\n        # Trace back from goal vertex to start vertex\n        trace: List[Point] = []\n        current = self._goal_vertex\n        while current is not None:\n            trace.append(current.point)\n            current = current.parent\n        trace.reverse()\n\n        # Move agent along the found path\n        for step in trace:\n            self.move_agent(step)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved Path Planning algorithm based on RRT but enhancing efficiency using a bidirectional search \n    strategy (Bidirectional RRT). Instead of growing a single tree from start to goal, this algorithm grows two trees:\n    one from the start and one from the goal. In each iteration, a random sample is generated and used to extend \n    both trees towards each other when possible. Once the two trees connect, the algorithm extracts and traces the \n    path. This approach typically reduces the search time for a path compared to the vanilla RRT. \n\n    Additionally, this implementation includes a 30-second timeout check to stop searching if no path is found \n    within this duration.\n\n    It inherits all useful helper functions from the RRT structure and preserves API and display integration.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph_start: Forest\n    _graph_goal: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_start.edges_removable = False\n        \n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n        self._graph_goal.edges_removable = False\n\n        # For display, unify displays from both forests:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph_start),\n                              GraphMapDisplay(self._services, self._graph_goal)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Provide displays from both trees plus parent displays\n        return super().set_display_info() + self.__map_displays\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse from RRT: step towards q_sample from q_near by max_dist limit\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_random_sample(self) -> Point:\n        # Reuse random valid sample getter from RRT\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _try_connect_trees(self, q_new_start: Vertex) -> bool:\n        # Attempt to connect the new vertex from start tree to the nearest vertex in goal tree.\n        q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n        if q_near_goal.position == q_new_start.position:\n            return True  # Already connected points\n\n        if not self._get_grid().is_valid_line_sequence(\n            self._get_grid().get_line_sequence(q_new_start.position, q_near_goal.position)\n        ):\n            return False\n        \n        self._graph_start.add_edge(q_new_start, q_near_goal)   # Connect start tree to goal tree vertex\n\n        return self._get_grid().is_agent_in_goal_radius(agent_pos=q_near_goal.position)\n\n    def _extract_path_bidirectional(self, q_connect_start: Vertex, q_connect_goal: Vertex) -> None:\n        # Extract path from start root to q_connect_start\n        path_start: List[Vertex] = [q_connect_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Extract path from q_connect_goal to goal root\n        path_goal: List[Vertex] = [q_connect_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # Concatenate paths (start to goal)\n        full_path = path_start + path_goal\n\n        # Animate agent movement along path\n        for vertex in full_path:\n            self.move_agent(vertex.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        start_time = time.time()\n\n        for i in range(iterations):\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Timeout reached; no path found\n                break\n\n            q_sample = self._get_random_sample()\n\n            # Extend start tree towards q_sample\n            q_near_start = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_sample)\n            if q_near_start.position == q_sample:\n                continue\n\n            q_new_start = self._get_new_vertex(q_near_start, q_sample, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_start.position, q_new_start.position)):\n                continue\n            self._graph_start.add_edge(q_near_start, q_new_start)\n\n            # Attempt to connect start tree to goal tree\n            if self._try_connect_trees(q_new_start):\n                q_connect_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_new_start.position)\n                self._extract_path_bidirectional(q_new_start, q_connect_goal)\n                break\n\n            self.key_frame()\n\n            # Swap roles to grow goal tree towards a new sample (from goal tree's perspective)\n            q_sample_goal = self._get_random_sample()\n            q_near_goal = self._graph_goal.get_nearest_vertex([self._graph_goal.root_vertex_start], q_sample_goal)\n            if q_near_goal.position == q_sample_goal:\n                continue\n\n            q_new_goal = self._get_new_vertex(q_near_goal, q_sample_goal, max_dist)\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near_goal.position, q_new_goal.position)):\n                continue\n            self._graph_goal.add_edge(q_near_goal, q_new_goal)\n\n            # Attempt to connect goal tree to start tree\n            q_near_start_check = self._graph_start.get_nearest_vertex([self._graph_start.root_vertex_start], q_new_goal.position)\n            if q_near_start_check.position != q_new_goal.position:\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_goal.position, q_near_start_check.position)):\n                    self._graph_goal.add_edge(q_new_goal, q_near_start_check)\n                    if self._get_grid().is_agent_in_goal_radius(agent_pos=q_near_start_check.position):\n                        self._extract_path_bidirectional(q_near_start_check, q_new_goal)\n                        break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "Improved path planning algorithm based on the Rapidly-exploring Random Tree (RRT*) method.\nThis sample-based approach incrementally builds a tree of feasible paths in the configuration\nspace by sampling random points, connecting them to the nearest existing vertex, and rewiring\nto optimize path cost. It is asymptotically optimal, often faster than grid-based A* in large or\ncomplex spaces. The implementation includes a 30-second timeout to prevent excessive runtime.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph: List[Vertex] = []\n        self._radius_neighbour: float = 3.0  # radius for rewiring neighbors\n        self._max_samples: int = 10000\n        self._goal_tolerance: float = 1.0  # distance to goal to consider path found\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Colours for display\n        self._vertex_colour = self._services.state.views.add_colour(\"rrt vertices\", Colour(0.0, 0.7, 0.0, 0.8))\n        self._edge_colour = self._services.state.views.add_colour(\"rrt edges\", Colour(0.0, 0.5, 0.5, 0.7))\n        self.__map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Use solid points for vertices and lines for edges (if available)\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph, vertex_colour=self._vertex_colour,\n                                              edge_colour=self._edge_colour, z_index=50)]\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        self._init_rrt_star()\n\n        grid: Map = self._get_grid()\n        start_time = time.time()\n\n        for i in range(self._max_samples):\n            # timeout check\n            if time.time() - start_time > 30.0:\n                # time exceeded, consider no path found\n                self.key_frame()\n                return\n\n            x_rand = self._get_random_sample()\n            v_near = self._nearest_vertex(x_rand)\n            if v_near is None:\n                continue\n\n            x_new = self._steer(v_near.point, x_rand)\n\n            if not grid.is_valid_position(x_new):\n                continue\n\n            if self._collision_free(v_near.point, x_new):\n                v_new = Vertex(x_new, v_near)\n                v_new.cost = v_near.cost + self._distance(v_near.point, x_new)\n\n                # find neighbors for potential rewiring\n                neighbors = self._near_vertices(x_new, self._radius_neighbour)\n\n                # choose parent with lowest cost\n                v_best = v_near\n                c_best = v_new.cost\n\n                for v_nei in neighbors:\n                    if self._collision_free(v_nei.point, x_new):\n                        c_new = v_nei.cost + self._distance(v_nei.point, x_new)\n                        if c_new < c_best:\n                            v_best = v_nei\n                            c_best = c_new\n\n                # attach new vertex to best parent\n                v_new.parent = v_best\n                v_new.cost = c_best\n                self._graph.append(v_new)\n\n                # rewire neighbors to new vertex if it improves cost\n                for v_nei in neighbors:\n                    if v_nei == v_best:\n                        continue\n                    if self._collision_free(v_new.point, v_nei.point):\n                        c_nei = v_nei.cost\n                        c_new_to_nei = v_new.cost + self._distance(v_new.point, v_nei.point)\n                        if c_new_to_nei < c_nei:\n                            v_nei.parent = v_new\n                            v_nei.cost = c_new_to_nei\n\n                # Check if close to goal\n                if self._distance(v_new.point, grid.goal.position) <= self._goal_tolerance:\n                    if self._goal_vertex is None or v_new.cost + self._distance(v_new.point, grid.goal.position) < self._goal_vertex.cost:\n                        self._goal_vertex = v_new\n\n            if (i % 50) == 0:\n                self.key_frame()\n\n        # Path found if goal vertex is set\n        if self._goal_vertex is not None:\n            self._follow_back_trace(self._goal_vertex.point)\n        else:\n            # No path found; optionally key_frame for visualization\n            self.key_frame()\n\n    def _init_rrt_star(self) -> None:\n        self._graph = []\n        grid = self._get_grid()\n        start_vertex = Vertex(grid.agent.position, None)\n        start_vertex.cost = 0.0\n        self._graph.append(start_vertex)\n        self._goal_vertex = None\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"Uniform random sample within the map boundaries.\"\"\"\n        grid = self._get_grid()\n        min_x, max_x, min_y, max_y = grid.get_bounds()  # Assume this returns the limits (x_min, x_max, y_min, y_max)\n        while True:\n            x = np.random.uniform(min_x, max_x)\n            y = np.random.uniform(min_y, max_y)\n            sample = Point(int(round(x)), int(round(y)))\n            if grid.is_valid_position(sample):\n                return sample\n\n    def _nearest_vertex(self, point: Point) -> Optional[Vertex]:\n        if not self._graph:\n            return None\n        dist_list = [(self._distance(v.point, point), v) for v in self._graph]\n        dist_list.sort(key=lambda x: x[0])\n        return dist_list[0][1]\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        arr1 = np.array(p1)\n        arr2 = np.array(p2)\n        return float(np.linalg.norm(arr1 - arr2))\n\n    def _steer(self, from_p: Point, to_p: Point, max_len: float = 5.0) -> Point:\n        \"\"\"Return a new point moved from from_p toward to_p by at most max_len.\"\"\"\n        from_arr = np.array(from_p, dtype=float)\n        to_arr = np.array(to_p, dtype=float)\n        direction = to_arr - from_arr\n        dist = np.linalg.norm(direction)\n        if dist == 0:\n            return from_p\n        direction /= dist\n        length = min(max_len, dist)\n        new_point = from_arr + direction * length\n        new_point_int = Point(int(round(new_point[0])), int(round(new_point[1])))\n        return new_point_int\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        \"\"\"Return list of vertices within radius of the given point.\"\"\"\n        near = []\n        for v in self._graph:\n            if self._distance(v.point, point) <= radius:\n                near.append(v)\n        return near\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        \"\"\"Check if path between p1 and p2 is collision free using the grid's API.\"\"\"\n        grid = self._get_grid()\n        # Use Bresenham line or similar discrete line traversal between p1 and p2\n        x1, y1 = p1\n        x2, y2 = p2\n\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        x, y = x1, y1\n\n        n = 1 + dx + dy\n        x_inc = 1 if x2 > x1 else -1\n        y_inc = 1 if y2 > y1 else -1\n        error = dx - dy\n        dx *= 2\n        dy *= 2\n\n        for _ in range(n):\n            pt = Point(x, y)\n            if not grid.is_valid_position(pt):\n                return False\n            if error > 0:\n                x += x_inc\n                error -= dy\n            else:\n                y += y_inc\n                error += dx\n\n        return True\n\n    def _follow_back_trace(self, end_point: Point) -> None:\n        grid: Map = self._get_grid()\n        # reconstruct path from end_point to start\n        path: List[Point] = []\n        vertex = None\n        for v in self._graph:\n            if v.point == end_point:\n                vertex = v\n                break\n        if vertex is None:\n            return\n        while vertex.parent is not None:\n            path.append(vertex.point)\n            vertex = vertex.parent\n        path.append(vertex.point)  # start vertex\n        path.reverse()\n\n        for t in path:\n            self.move_agent(t)\n            self.key_frame(ignore_key_frame_skip=True)\n            if hasattr(grid, \"publish_wp\") and callable(getattr(grid, \"publish_wp\")):\n                grid.publish_wp(grid.agent.position) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Description:\n    This algorithm implements an improved RRT-based planner, inspired by the original RRT approach.\n    It integrates two key improvements to enhance runtime efficiency:\n    1) Goal biasing: A fixed probability to sample the goal directly each iteration, accelerating convergence.\n    2) Parent rewiring: After adding a new vertex, it attempts to rewire nearby vertices to this new node if it yields\n       a shorter and valid path, similar to RRT*, improving path quality on-the-fly.\n    Additionally, the search is bounded to 30 seconds, after which it aborts and treats the path as unfound.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Needed for rewiring edges in RRT*\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        \"\"\"Same as original RRT method: moves from q_near toward q_sample up to max_dist.\"\"\"\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_sample_rate=0.1) -> Point:\n        \"\"\"\n        Samples a random position with goal biasing.\n        With probability goal_sample_rate, returns the goal position.\n        Otherwise, samples uniformly from valid positions.\n        \"\"\"\n        goal_pos = self._get_grid().goal.position\n        if np.random.random() < goal_sample_rate and self._get_grid().is_agent_valid_pos(goal_pos):\n            return goal_pos\n\n        attempts = 0\n        max_attempts = 1000\n        while attempts < max_attempts:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n            attempts += 1\n        # Fallback to goal if no free sample found (unlikely)\n        return goal_pos\n\n    def _find_nearby_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"Find vertices in graph within radius of q_new.position.\"\"\"\n        nearby = []\n        for v in self._graph.vertices:\n            if torch.norm(v.position.to_tensor() - q_new.position.to_tensor()) <= radius:\n                nearby.append(v)\n        return nearby\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        \"\"\"\n        Chooses the best parent for q_new among q_near_candidates by minimum cost from root\n        with valid edge from candidate to q_new.\n        \"\"\"\n        best_parent = None\n        best_cost = float('inf')\n\n        for q_near in q_near_candidates:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost = self._graph.get_cost_from_root(q_near) + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if cost < best_cost:\n                best_cost = cost\n                best_parent = q_near\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, nearby_vertices: List[Vertex]) -> None:\n        \"\"\"\n        For each vertex in nearby_vertices, attempts to rewire its parent to q_new\n        if the path through q_new improves cost and the edge is valid.\n        \"\"\"\n        for q_near in nearby_vertices:\n            if q_near == q_new.parents[0] if q_new.parents else None:\n                continue  # skip current parent\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position)):\n                continue\n            current_cost = self._graph.get_cost_from_root(q_near)\n            new_cost = self._graph.get_cost_from_root(q_new) + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n            if new_cost < current_cost:\n                # Perform rewiring: remove old edge(s) and add new edge from q_new to q_near\n                self._graph.remove_parent(q_near)\n                self._graph.add_edge(q_new, q_near)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        \"\"\"\n        Extracts and moves agent along path from start to goal by following parent chain.\n        Similar to original.\n        \"\"\"\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Follow parents until root\n        while len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]  # There should be only one parent\n            path.append(parent)\n\n        path.pop()  # Remove the root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_dist: float = 10\n        max_iterations: int = 20000\n        goal_radius = self._get_grid().goal.radius\n\n        start_time = time.time()\n\n        while True:\n            if time.time() - start_time > 30.0:\n                # Timeout, treat as no path found\n                break\n\n            if max_iterations <= 0:\n                break\n            max_iterations -= 1\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate=0.1)\n\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n            # If line invalid, skip\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            # RRT* style: find nearby within radius r = gamma*(log(n)/n)^{1/d}\n            n_vertices = len(self._graph.vertices) + 1\n            gamma_rrt_star = 50.0  # tuning parameter\n            dimension = self._get_grid().size.n_dim\n            r = min(max_dist, gamma_rrt_star * ((np.log(n_vertices) / n_vertices) ** (1/dimension)))\n\n            nearby_vertices = self._find_nearby_vertices(q_new, r)\n            parent_candidates = nearby_vertices if len(nearby_vertices) > 0 else [q_near]\n\n            best_parent = self._choose_parent(parent_candidates, q_new)\n            if best_parent is None:\n                # If no suitable parent found, skip\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            self._rewire(q_new, nearby_vertices)\n\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - self._get_grid().goal.position.to_tensor())\n            if dist_to_goal <= goal_radius:\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star).\n    This algorithm improves the basic RRT by rewiring the tree to find shorter paths progressively,\n    thus optimizing the path cost over time. It also implements a timeout of 30 seconds to stop the search\n    if no path is found within that time. The algorithm maintains a graph similar to RRT but after adding\n    a new vertex, it checks nearby vertices for better parent connections (rewiring step),\n    resulting in more efficient paths and faster convergence compared to basic RRT.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True\n        self._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        max_iterations: int = 10000\n        search_start_time = time.time()\n        radius = 15.0  # Radius for neighborhood rewiring\n\n        def vertex_cost(vertex: Vertex) -> float:\n            # Compute cost from root to this vertex by summing up edge distances along parents\n            cost = 0.0\n            cur = vertex\n            while len(cur.parents) > 0:\n                parent = next(iter(cur.parents))\n                cost += (cur.position.to_tensor() - parent.position.to_tensor()).norm().item()\n                cur = parent\n            return cost\n\n        def find_nearest_vertex(vertices: List[Vertex], point: Point) -> Vertex:\n            return self._graph.get_nearest_vertex(vertices, point)\n\n        def near_vertices(q_new: Vertex) -> List[Vertex]:\n            # Find vertices within radius of q_new\n            near_list = []\n            for v in self._graph.vertices:\n                dist = (v.position.to_tensor() - q_new.position.to_tensor()).norm().item()\n                if dist <= radius:\n                    near_list.append(v)\n            return near_list\n\n        def rewire(q_new: Vertex, near_list: List[Vertex]) -> None:\n            for q_near in near_list:\n                if q_near == q_new:\n                    continue\n                # Check if path from q_new to q_near is possible and offers lower cost\n                line_seq = self._get_grid().get_line_sequence(q_new.position, q_near.position)\n                if self._get_grid().is_valid_line_sequence(line_seq):\n                    cost_through_qnew = vertex_cost(q_new) + (q_new.position.to_tensor() - q_near.position.to_tensor()).norm().item()\n                    if cost_through_qnew < vertex_cost(q_near):\n                        # Remove existing edges from q_near parents\n                        for parent in list(q_near.parents):\n                            self._graph.remove_edge(parent, q_near)\n                        # Add edge from q_new to q_near (rewiring)\n                        self._graph.add_edge(q_new, q_near)\n\n        def choose_parent(q_near_list: List[Vertex], q_new_position: Point) -> Optional[Vertex]:\n            min_cost = inf\n            best_parent = None\n            for q_near in q_near_list:\n                line_seq = self._get_grid().get_line_sequence(q_near.position, q_new_position)\n                if not self._get_grid().is_valid_line_sequence(line_seq):\n                    continue\n                cost = vertex_cost(q_near) + (q_near.position.to_tensor() - q_new_position.to_tensor()).norm().item()\n                if cost < min_cost:\n                    min_cost = cost\n                    best_parent = q_near\n            return best_parent\n\n        def extract_path(q_goal: Vertex) -> None:\n            path: List[Vertex] = [q_goal]\n\n            while len(path[-1].parents) != 0:\n                parent = next(iter(path[-1].parents))\n                path.append(parent)\n\n            path.reverse()\n\n            for p in path:\n                self.move_agent(p.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n        start_vertex = self._graph.root_vertex_start\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        for _ in range(max_iterations):\n            # Check timeout of 30 seconds\n            if time.time() - search_start_time > 30.0:\n                # Timeout reached, treat as not found and return\n                break\n\n            q_sample = self._get_random_sample()\n            q_near = find_nearest_vertex([start_vertex], q_sample)\n            if q_near.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            # Prevent adding vertex outside the valid map\n            if not self._get_grid().is_agent_valid_pos(q_new.position):\n                continue\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                continue\n\n            near_list = near_vertices(q_new)\n            best_parent = choose_parent(near_list, q_new.position)\n            if best_parent is None:\n                # If no suitable parent found, fallback to q_near\n                best_parent = q_near\n\n            self._graph.add_edge(best_parent, q_new)\n\n            rewire(q_new, near_list)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect last vertex to goal directly if possible\n                goal_line_seq = self._get_grid().get_line_sequence(q_new.position, goal_vertex.position)\n                if self._get_grid().is_valid_line_sequence(goal_line_seq):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    extract_path(goal_vertex)\n                    break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This PathPlanning algorithm is an optimized sampling-based planner inspired by RRT* (Rapidly-exploring Random Tree Star).\n    Unlike A*, which operates on a discrete grid, this method efficiently explores the space by incrementally building a tree\n    of collision-free paths through random sampling. It improves over standard RRT by rewiring nearby vertices to optimize path cost,\n    resulting in faster convergence toward an optimal path. It also enforces a 30-seconds timeout to bound planning time.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    max_iterations: int\n    search_timeout: float\n    _graph: 'Forest'  # Assuming a graph structure representing the tree, defined elsewhere\n    _q_new: Optional[Point]  # New sampled node\n    _goal_reached_vertex: Optional['Vertex']\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self.max_iterations = 10000  # Max iterations for sampling\n        self.search_timeout = 30.0  # Max search time in seconds\n        self._graph = self._initialize_graph()\n        self._q_new = None\n        self._goal_reached_vertex = None\n        self._init_displays()\n\n    def _initialize_graph(self) -> 'Forest':\n        grid = self._get_grid()\n        root = grid.agent.position\n        # Assuming Forest class has an add_vertex method that accepts Point and cost (0 here)\n        forest = Forest(self._services)\n        forest.add_vertex(root, cost=0.0, parent=None)\n        return forest\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Add graph display from SampleBasedAlgorithm plus additional coloring if needed\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        grid = self._get_grid()\n        goal_position = grid.goal.position\n        reached = False\n\n        for iteration in range(self.max_iterations):\n            if time.time() - start_time > self.search_timeout:\n                # Timeout reached; treat as no path found and exit\n                break\n\n            q_rand = self._get_random_sample()\n            q_nearest = self._graph.get_nearest_vertex(q_rand)\n            q_new = self._steer(q_nearest.position, q_rand, max_extend_length=grid.get_max_step_size())\n            if not grid.is_obstacle_free(q_nearest.position, q_new):\n                continue\n\n            cost_to_q_new = q_nearest.cost + grid.get_movement_cost(q_nearest.position, q_new)\n            neighbors = self._graph.get_near_vertices(q_new, radius=self._get_near_radius())\n\n            q_min_parent, min_cost = q_nearest, cost_to_q_new\n            # Choose best parent for q_new from neighbors\n            for q_near in neighbors:\n                if grid.is_obstacle_free(q_near.position, q_new):\n                    cost_candidate = q_near.cost + grid.get_movement_cost(q_near.position, q_new)\n                    if cost_candidate < min_cost:\n                        q_min_parent = q_near\n                        min_cost = cost_candidate\n\n            # Add q_new to graph with best parent\n            self._graph.add_vertex(q_new, cost=min_cost, parent=q_min_parent)\n            self._q_new = q_new\n\n            # Rewire neighbors to q_new if it improves cost\n            for q_near in neighbors:\n                if q_near == q_min_parent:\n                    continue\n                if grid.is_obstacle_free(q_new, q_near.position):\n                    cost_through_q_new = min_cost + grid.get_movement_cost(q_new, q_near.position)\n                    if cost_through_q_new < q_near.cost:\n                        self._graph.rewire_vertex(q_near, new_parent_position=q_new, new_cost=cost_through_q_new)\n\n            self.key_frame()\n\n            # Check if goal can be connected directly from q_new\n            if grid.is_obstacle_free(q_new, goal_position):\n                goal_cost = min_cost + grid.get_movement_cost(q_new, goal_position)\n                self._graph.add_vertex(goal_position, cost=goal_cost, parent=self._graph.find_vertex_by_position(q_new))\n                self._goal_reached_vertex = self._graph.find_vertex_by_position(goal_position)\n                reached = True\n                break\n\n        if reached:\n            path = self._get_path_from_goal()\n            path.reverse()\n            for point in path:\n                self.move_agent(point)\n                self.key_frame(ignore_key_frame_skip=True)\n        else:\n            # No path found; optionally can log or handle failure here\n            pass\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Generates a random sample point within the map bounds.\n        If a bias towards goal is desired, it could be implemented here.\n        \"\"\"\n        grid = self._get_grid()\n        # Assuming grid provides boundaries: x_min, x_max, y_min, y_max (2D)\n        x_min, x_max, y_min, y_max = grid.get_sampling_bounds()\n        import random\n        # 10% goal bias to speed convergence\n        if random.random() < 0.1:\n            return grid.goal.position\n        else:\n            xr = random.uniform(x_min, x_max)\n            yr = random.uniform(y_min, y_max)\n            return Point(xr, yr)\n\n    def _steer(self, from_point: Point, to_point: Point, max_extend_length: float) -> Point:\n        \"\"\"\n        Returns a new point moved from from_point towards to_point by maximum max_extend_length.\n        \"\"\"\n        vec = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = math.hypot(vec[0], vec[1])\n        if dist <= max_extend_length:\n            return to_point\n        else:\n            scale = max_extend_length / dist\n            new_x = from_point[0] + vec[0] * scale\n            new_y = from_point[1] + vec[1] * scale\n            return Point(new_x, new_y)\n\n    def _get_near_radius(self) -> float:\n        \"\"\"\n        Returns the radius to search for near neighbors for rewiring.\n        Typically depends on log of iteration number and free space dimensionality.\n        For simplicity, return a fixed radius or adapt if iteration count available.\n        \"\"\"\n        grid = self._get_grid()\n        # Could be tuned based on environment size; here using a default fixed radius\n        return 5.0\n\n    def _get_path_from_goal(self) -> List[Point]:\n        \"\"\"\n        Reconstruct the path from the goal vertex back to the root.\n        \"\"\"\n        path: List[Point] = []\n        vertex = self._goal_reached_vertex\n        while vertex is not None:\n            path.append(vertex.position)\n            vertex = vertex.parent\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an enhanced path planner called Informed RRT* (based on RRT*) \nwhich improves convergence speed by biasing samples toward the informed subset (an ellipsoidal region) \nonce a path to the goal is found. It thereby focuses the search on regions more likely to improve \nthe solution, reducing unnecessary exploration and improving runtime. It also enforces \na 30-seconds timeout to stop the search if no path is found.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Maintain best solution vertex found\n        self._best_goal_vertex = None\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_in_ellipsoid(self, c_best: float, c_min: float, x_center: torch.Tensor,\n                             C: torch.Tensor) -> Point:\n        \"\"\"\n        Sample a random point uniformly from an ellipsoid defined by cost c_best,\n        minimum path cost c_min, transformation matrix C and center x_center.\n        Ref: Informed RRT* sampling\n        \"\"\"\n        dim = x_center.shape[0]\n        while True:\n            # Sample from unit n-ball\n            x_ball = torch.randn(dim)\n            x_ball /= torch.norm(x_ball)\n            r = torch.rand(1).item() ** (1/dim)  # Uniform radius distribution in n-dim ball\n            x_ball = x_ball * r\n            \n            # Scaling matrix for ellipsoid\n            L = torch.diag(torch.tensor([c_best/2] + [sqrt(c_best**2 - c_min**2)/2]*(dim-1)))\n            # Map sample from unit ball to ellipsoid\n            x_rand = torch.matmul(C, torch.matmul(L, x_ball)) + x_center\n\n            # Round and convert to Point and check validity\n            sample_point = Point.from_tensor(x_rand)\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_time = time.time()\n        c_best = float('inf')  # best solution cost so far\n        start_pos = self._get_grid().agent.position\n        goal_pos = self._get_grid().goal.position\n        goal_vertex = Vertex(goal_pos)\n\n        # Precompute constants for informed sampling\n        c_min = torch.norm(start_pos.to_tensor() - goal_pos.to_tensor()).item()\n        x_center = ((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n        # Rotation matrix from unit vector in x to the vector from start to goal\n        a1 = (goal_pos.to_tensor() - start_pos.to_tensor())\n        unit_a1 = a1 / torch.norm(a1)\n        # Construct orthonormal basis C using Householder transform\n        eye = torch.eye(dimension)\n        v = unit_a1 - eye[:,0]\n        if torch.norm(v) < 1e-10:\n            C = eye\n        else:\n            v = v / torch.norm(v)\n            C = eye - 2 * torch.outer(v, v)\n        \n        for i in range(iterations):\n            # Check timeout\n            if time.time() - start_time > 30:\n                # Timeout no path found\n                break\n\n            # Select informed sample if solution found, else uniform random sample\n            if c_best < float('inf'):\n                q_sample = self._sample_in_ellipsoid(c_best, c_min, x_center, C)\n            else:\n                q_sample = self._get_random_sample()\n\n            q_nearest = self._get_nearest_vertex(q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            # Check collision for path from q_nearest to q_new\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v)**(1/dimension)), max_radius)\n            Q_near = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose parent with minimal cost\n            q_min = q_nearest\n            c_min_cost = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min_cost:\n                    q_min = q_near\n                    c_min_cost = cost_near_to_new\n\n            q_new.cost = c_min_cost\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire tree\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, q_near.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    if q_parent is not None:\n                        self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if new vertex reaches goal region with improved cost\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Calculate total cost through q_new to goal vertex\n                dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor())\n                total_cost = q_new.cost + dist_to_goal\n                if total_cost < c_best:\n                    c_best = total_cost\n                    # Update best goal vertex and add edge from q_new to goal\n                    if self._best_goal_vertex is not None:\n                        # Remove previous edge if it exists\n                        for parent in self._best_goal_vertex.parents:\n                            self._graph.remove_edge(parent, self._best_goal_vertex)\n                    goal_vertex.cost = c_best\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._best_goal_vertex = goal_vertex\n                    self._extract_path(goal_vertex)\n                    # Update center and rotation matrix again for sampling:\n                    x_center = ((start_pos.to_tensor() + goal_pos.to_tensor()) / 2)\n                    # Already computed above, no change needed within same iteration\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm inspired by RRT* with optimizations for faster convergence and pruning:\n    - Uses informed sampling (sampling within an ellipse defined by current best cost to goal) to focus exploration.\n    - Implements early stopping once cost thresholds or goal condition met.\n    - Limits rewiring radius dynamically based on the number of vertices.\n    - Stops planning after 30 seconds if no path found to prevent long waits.\n    This approach reduces exploration time by focusing the sampling around the best path found so far,\n    hence improving time efficiency compared to vanilla RRT*.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        self._graph = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._init_displays()\n\n        # Additional members for informed sampling\n        self._best_cost = float('inf')\n        self._path_found = False\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _informed_sample(self, start: Point, goal: Point, c_best: float) -> Point:\n        \"\"\"\n        Sample within an ellipse defined by start, goal, and current path cost c_best.\n        If no path found yet (c_best == inf), fallback to uniform random sampling.\n        \"\"\"\n        if c_best == float('inf'):\n            # No solution found yet, sample globally random\n            return self._get_random_sample()\n\n        # Convert Points to tensors\n        start_t = start.to_tensor()\n        goal_t = goal.to_tensor()\n\n        c_min = torch.norm(goal_t - start_t).item()\n        if c_best < c_min:\n            # Numerical stability fallback\n            c_best = c_min + 1e-6\n\n        # Define ellipse parameters\n        center = (start_t + goal_t) / 2\n        a1 = (goal_t - start_t) / c_min  # unit vector along start->goal\n\n        # Define rotation matrix to align with x-axis\n        # We want to rotate sampled point in standard ellipse coordinates back to world coords\n        # For 2D, rotation matrix:\n        # R = [a1, a2], where a2 is orthogonal vector to a1\n        # a1: unit vector start->goal\n        # a2: perpendicular vector\n\n        # perpendicular vector in 2D\n        a2 = torch.tensor([-a1[1].item(), a1[0].item()])\n\n        # ellipse radii\n        r1 = c_best / 2\n        try:\n            r2_val = math.sqrt(c_best ** 2 - c_min ** 2) / 2\n        except ValueError:\n            r2_val = 0.0\n        r2 = r2_val\n\n        # Sample random point in unit circle\n        while True:\n            # Sample from unit disk using polar coordinates\n            t = 2 * math.pi * np.random.random()\n            u = np.random.random() + np.random.random()\n            r = 2 - u if u > 1 else u  # triangular distribution for uniformity\n            \n            x_ball = r * math.cos(t)\n            y_ball = r * math.sin(t)\n\n            if x_ball ** 2 + y_ball ** 2 > 1:\n                continue\n\n            # Scale by ellipse radii\n            sample_ellipse = torch.tensor([x_ball * r1, y_ball * r2])\n\n            # Rotate and translate back to world coords\n            sample_world = center + sample_ellipse[0] * a1 + sample_ellipse[1] * a2\n\n            # Round and convert to Point (integral grid coordinates)\n            sample_coords = torch.round(sample_world).to(torch.int64)\n            sample_point = Point(*sample_coords.tolist())\n\n            if self._get_grid().is_agent_valid_pos(sample_point):\n                return sample_point\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        child_parent_dist = torch.norm(q_new.position.to_tensor() - goal_v.position.to_tensor())\n        goal_v.cost = q_new.cost + child_parent_dist\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            for parent in path[-1].parents:\n                path.append(parent)\n                break\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            grid: Map = self._get_grid()\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10\n        iterations: int = 10000\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n\n        start_vertex = self._graph.root_vertex_start\n        goal_pos = self._get_grid().goal.position\n\n        start_time = time.time()\n\n        for i in range(iterations):\n            current_time = time.time()\n            if current_time - start_time > 30:\n                # Timeout exceeded, stop search\n                break\n\n            # Informed sampling: sample smarter in ellipse based on best cost found\n            q_sample: Point = self._informed_sample(start_vertex.position, goal_pos, self._best_cost)\n            q_nearest: Vertex = self._get_nearest_vertex(q_sample)\n\n            if q_nearest.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(self._graph.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star*((log_card_v/card_v)**(1/dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius(q_new, radius)\n\n            # Choose minimum cost parent\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            self._graph.add_edge(q_min, q_new)\n\n            # Rewire nearby vertices to new vertex if it improves cost\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                if near_new_collision_free and cost_new_to_near < q_near.cost:\n                    q_parent = None\n                    for parent in q_near.parents:\n                        q_parent = parent\n                        break\n                    self._graph.remove_edge(q_parent, q_near)\n                    q_near.cost = cost_new_to_near\n                    self._graph.add_edge(q_new, q_near)\n\n            # Check if q_new is within goal radius\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Update best cost if better\n                goal_dist = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor())\n                total_cost = q_new.cost + goal_dist\n                if total_cost < self._best_cost:\n                    self._best_cost = total_cost\n                    self._path_found = True\n                    self._extract_path(q_new)\n                break\n\n            # Update best cost if new vertex is closer to goal with valid path\n            dist_to_goal = torch.norm(q_new.position.to_tensor() - goal_pos.to_tensor()).item()\n            possible_cost = q_new.cost + dist_to_goal\n            if possible_cost < self._best_cost:\n                self._best_cost = possible_cost\n\n            self.key_frame()\n\n        if not self._path_found:\n            # No path found: can optionally log or mark failure\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved version of the RRT algorithm, \ncalled RRT-Connect. It grows two trees simultaneously: one from the start \nand one from the goal, trying to connect them in each iteration, which improves \nthe convergence speed and reduces planning time compared to the basic RRT. \n\nThe search terminates either when a connecting path is found or when the time \nlimit of 30 seconds is exceeded. Path extraction then follows the connected trees \nto form a complete route from start to goal.\n\"\"\"",
     "code": " ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This algorithm implements an improved RRT* inspired path planner that incrementally builds a tree of feasible configurations. \nIt enhances the basic RRT by rewiring the tree to improve path quality, reducing total path cost and search time. \nA time limit of 30 seconds is imposed to stop the search if no path is found, improving practical runtime. \nCore improvements include: nearest vertex search based on path cost, rewiring within a neighborhood radius, and path cost tracking.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _rewire_radius: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # allow edges removal for rewiring in RRT*\n        self._max_dist = 10.0\n        self._iterations = 10000\n        self._rewire_radius = 15.0  # radius within which to search for rewiring candidates\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _get_near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        # Returns vertices within radius of q_new.position\n        near: List[Vertex] = []\n        for vertex in self._graph.get_all_vertices():\n            if torch.norm(q_new.position.to_tensor() - vertex.position.to_tensor()) <= radius:\n                near.append(vertex)\n        return near\n\n    def _cost(self, vertex: Vertex) -> float:\n        # Calculate cost from root to this vertex by summing edge distances up the parents chain\n        cost = 0.0\n        current = vertex\n        while current.parents:\n            # parents list may contain multiple but we only track single parent in this tree, use first\n            parent = current.parents[0]\n            cost += torch.norm(current.position.to_tensor() - parent.position.to_tensor()).item()\n            current = parent\n        return cost\n\n    def _choose_parent(self, q_near_candidates: List[Vertex], q_new: Vertex) -> Optional[Vertex]:\n        # Choose parent from candidates minimizing total cost to q_new\n        min_cost = float('inf')\n        best_parent = None\n        for near_v in q_near_candidates:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(near_v.position, q_new.position)):\n                continue\n            cost = self._cost(near_v) + torch.norm(q_new.position.to_tensor() - near_v.position.to_tensor()).item()\n            if cost < min_cost:\n                min_cost = cost\n                best_parent = near_v\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        cost_q_new = self._cost(q_new)\n        for near_v in near_vertices:\n            if near_v == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, near_v.position)):\n                continue\n            cost_through_q_new = cost_q_new + torch.norm(q_new.position.to_tensor() - near_v.position.to_tensor()).item()\n            cost_near_v = self._cost(near_v)\n            if cost_through_q_new < cost_near_v:\n                # Rewire near_v parent to q_new\n                self._graph.remove_edge_parents(near_v)  # Remove current parent edges to near_v\n                self._graph.add_edge(q_new, near_v)\n\n    def _extract_path(self, q_goal: Vertex) -> None:\n        path: List[Vertex] = [q_goal]\n\n        while len(path[-1].parents) != 0:\n            parent = path[-1].parents[0]\n            path.append(parent)\n\n        path.pop()  # Remove last duplicate start vertex\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        goal_vertex = Vertex(goal_pos)\n\n        # Add root vertices to tree if not already added\n        if not self._graph.root_vertex_start:\n            self._graph.root_vertex_start = Vertex(self._get_grid().agent.position)\n        if not self._graph.root_vertex_goal:\n            self._graph.root_vertex_goal = goal_vertex\n\n        for _ in range(self._iterations):\n            current_time = time.time()\n            if current_time - start_time > 30.0:  # time limit exceeded\n                break\n\n            q_sample: Point = self._get_random_sample()\n            q_near_candidates: List[Vertex] = self._graph.get_all_vertices()\n            if not q_near_candidates:\n                continue\n\n            # Find nearest vertex in terms of Euclidean distance for initial expansion\n            q_near = min(q_near_candidates, key=lambda v: torch.norm(v.position.to_tensor() - q_sample.to_tensor()).item())\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            near_vertices = self._get_near_vertices(q_new, self._rewire_radius)\n            parent_vertex = self._choose_parent(near_vertices, q_new)\n            if parent_vertex is None:\n                continue\n\n            self._graph.add_edge(parent_vertex, q_new)\n            self._rewire(q_new, near_vertices)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                # Connect directly to goal vertex if reachable\n                if self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, goal_pos)):\n                    self._graph.add_edge(q_new, goal_vertex)\n                    self._extract_path(goal_vertex)\n                    return\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    An improved sample-based path planning algorithm inspired by RRT*.\n    It incrementally builds a tree rooted at the agent's start position and rewires vertices to ensure \n    asymptotic optimality, improving path quality over time compared to classic RRT.\n    The algorithm stops either upon finding a feasible path to the goal or after 30 seconds timeout.\n    Key improvements over basic A* include probabilistic sampling for exploring large continuous spaces, \n    efficient local rewiring for path cost improvement, and lazy collision checking.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: Forest = Forest()\n        self._start_vertex: Optional[Vertex] = None\n        self._goal_vertex: Optional[Vertex] = None\n        self._goal_reached: bool = False\n        self._max_runtime_seconds: float = 30.0\n\n        # Display elements initialized in _init_displays() which will be called later\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self._graph.vertices, \n                                                      colour=Point(0, 1, 0, 0.5), z_index=50)]\n        \n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        self._start_vertex = self._graph.add_vertex(start_pos)\n        self._goal_vertex = None\n        self._goal_reached = False\n\n        start_time = time.time()\n\n        # Number of iterations to attempt sampling (or until timeout / goal reached)\n        max_iterations = 10000\n\n        for i in range(max_iterations):\n            # Check timeout\n            if time.time() - start_time > self._max_runtime_seconds:\n                # Timeout exceeded -> stop search and treat route as not found\n                break\n            \n            sample_point = self._get_random_sample()\n            nearest_vertex = self._graph.get_nearest_vertex(sample_point)\n\n            new_point = self._steer(nearest_vertex.position, sample_point)\n            if not grid.is_traversable(new_point):\n                continue\n            if not grid.check_line_of_sight(nearest_vertex.position, new_point):\n                # Obstacle in path between nearest_vertex and new_point\n                continue\n            \n            # Add new vertex but first connect with best parent within neighborhood radius\n            new_vertex = self._graph.add_vertex(new_point)\n            radius = self._calc_neighborhood_radius(len(self._graph.vertices))\n            neighbors = self._graph.get_vertices_within_radius(new_point, radius)\n\n            # Initialize best parent as nearest vertex and cost as cost to reach it\n            best_parent = nearest_vertex\n            best_cost = nearest_vertex.cost + self._distance(nearest_vertex.position, new_point)\n\n            for neighbor in neighbors:\n                # Check if path is collision free and if vertex is cheaper to reach through neighbor\n                if grid.check_line_of_sight(neighbor.position, new_point):\n                    cost_through_neighbor = neighbor.cost + self._distance(neighbor.position, new_point)\n                    if cost_through_neighbor < best_cost:\n                        best_parent = neighbor\n                        best_cost = cost_through_neighbor\n            \n            # Connect new vertex to best parent\n            self._graph.add_edge(best_parent, new_vertex)\n            new_vertex.cost = best_cost\n            new_vertex.parent = best_parent\n\n            # Rewire neighbors to the new vertex if cheaper\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                if grid.check_line_of_sight(new_point, neighbor.position):\n                    cost_through_new = new_vertex.cost + self._distance(new_point, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        # Rewire neighbor\n                        old_parent = neighbor.parent\n                        if old_parent is not None:\n                            self._graph.remove_edge(old_parent, neighbor)\n                        self._graph.add_edge(new_vertex, neighbor)\n                        neighbor.cost = cost_through_new\n                        neighbor.parent = new_vertex\n            \n            self.key_frame()\n\n            # Check if goal is within radius and can be connected with no collision\n            if self._distance(new_point, goal_pos) <= radius and grid.check_line_of_sight(new_point, goal_pos):\n                # Add goal vertex and connect it\n                self._goal_vertex = self._graph.add_vertex(goal_pos)\n                self._graph.add_edge(new_vertex, self._goal_vertex)\n                self._goal_vertex.cost = new_vertex.cost + self._distance(new_point, goal_pos)\n                self._goal_vertex.parent = new_vertex\n                self._goal_reached = True\n                break\n\n        if self._goal_reached:\n            path = self._extract_path(self._goal_vertex)\n            self._follow_back_trace(path)\n        # else no path found or timeout -> no movement occurs\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random point in the free space of the map.\n        Incorporates goal biasing with 10% chance to sample goal directly.\n        \"\"\"\n        from numpy.random import uniform\n\n        grid = self._get_grid()\n        goal_pos = grid.goal.position\n\n        # 10% goal biasing\n        if uniform(0, 1) < 0.1:\n            return goal_pos\n\n        width = grid.width()\n        height = grid.height()\n\n        while True:\n            x = uniform(0, width)\n            y = uniform(0, height)\n            point = Point(x, y)\n            if grid.is_traversable(point):\n                return point\n\n    def _steer(self, from_point: Point, to_point: Point, max_step: float = 1.0) -> Point:\n        \"\"\"\n        Returns a new point moved from from_point towards to_point by at most max_step distance.\n        \"\"\"\n        vec = (to_point[0] - from_point[0], to_point[1] - from_point[1])\n        dist = (vec[0] ** 2 + vec[1] ** 2) ** 0.5\n        if dist <= max_step:\n            return to_point\n        scale = max_step / dist\n        new_x = from_point[0] + vec[0] * scale\n        new_y = from_point[1] + vec[1] * scale\n        return Point(new_x, new_y)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between two points\n        \"\"\"\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) ** 0.5\n\n    def _calc_neighborhood_radius(self, num_vertices: int) -> float:\n        \"\"\"\n        Radius for neighborhood search using RRT* heuristic.\n        \"\"\"\n        map_area = self._get_grid().width() * self._get_grid().height()\n        gamma_rrt_star = 30.0  # tuning parameter, typical values 20-50\n        radius = min(\n            10.0,\n            gamma_rrt_star * ((map_area / (3.14159 * num_vertices)) ** 0.5)\n        )\n        return radius\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Extracts the path from start to goal by following parent links.\n        \"\"\"\n        path: List[Point] = []\n        current = goal_vertex\n        while current is not None:\n            path.append(current.position)\n            current = current.parent\n        path.reverse()\n        return path\n\n    def _follow_back_trace(self, path: List[Point]) -> None:\n        \"\"\"\n        Moves the agent step by step along the path points.\n        \"\"\"\n        grid: Map = self._get_grid()\n        for pos in path:\n            self.move_agent(pos)\n            if isinstance(grid, Map) and hasattr(grid, 'publish_wp'):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT with goal biasing and adaptive sampling radius.\n    This algorithm incorporates a goal bias to sample the goal position with a certain probability to \n    speed up convergence towards the goal. It also adapts the maximum extension distance dynamically \n    based on progress. The implementation includes a 30-second timeout to prevent long-running searches.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        # Initialize graph with start and goal vertices\n        self._graph = gen_forest(\n            self._services,\n            Vertex(self._get_grid().agent.position),\n            Vertex(self._get_grid().goal.position),\n            []\n        )\n        self._graph.edges_removable = False\n        self._init_displays()\n        # Parameters for improved sampling\n        self._goal_sample_rate = 0.15    # Probability to sample the goal (goal bias)\n        self._max_dist_min = 3.0          # Minimum max step\n        self._max_dist_max = 15.0         # Maximum max step\n        self._max_dist = 10.0             # Initial max step\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_random_sample_goal_bias(self) -> Point:\n        \"\"\"\n        Sample randomly with a bias towards the goal\n        \"\"\"\n        import numpy as np\n        if np.random.random() < self._goal_sample_rate:\n            # Sample goal point directly\n            return self._get_grid().goal.position\n        else:\n            # Otherwise uniform random sample in valid position\n            while True:\n                rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n                sample: Point = Point(*rand_pos)\n                if self._get_grid().is_agent_valid_pos(sample):\n                    return sample\n\n    def _adapt_max_dist(self, newly_added: bool, iteration: int) -> None:\n        \"\"\"\n        Adapt the max_dist based on progress and iteration count.\n        If new node was added, increase max_dist slowly to encourage exploration.\n        If no node added for a long time, decrease to focus on local refinements.\n        \"\"\"\n        if newly_added:\n            # Increase max_dist but cap at max_dist_max\n            self._max_dist = min(self._max_dist + 0.5, self._max_dist_max)\n        else:\n            # Decrease max_dist slowly but not below min threshold\n            if iteration % 100 == 0:\n                self._max_dist = max(self._max_dist - 0.5, self._max_dist_min)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # Always take the first parent (tree structure)\n            path.append(path[-1].parents[0])\n\n        del path[-1]\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        import time\n\n        max_iterations: int = 10000\n        start_time = time.time()\n        last_added = False\n\n        for i in range(max_iterations):\n            # Timeout if running for more than 30 seconds\n            if (time.time() - start_time) > 30.0:\n                # No path found within time limit\n                break\n\n            q_sample: Point = self._get_random_sample_goal_bias()\n            q_near: Vertex = self._graph.get_nearest_vertex([self._graph.root_vertex_start], q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, self._max_dist)\n\n            line_seq = self._get_grid().get_line_sequence(q_near.position, q_new.position)\n            if not self._get_grid().is_valid_line_sequence(line_seq):\n                self._adapt_max_dist(newly_added=False, iteration=i)\n                continue\n\n            self._graph.add_edge(q_near, q_new)\n\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                return\n\n            self.key_frame()\n            self._adapt_max_dist(newly_added=True, iteration=i)\n            last_added = True\n\n        # If here, path not found within max_iterations or timeout; no action needed (fail quietly) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\nThis algorithm implements an improved RRT-based planner inspired by the baseline RRT.\nIt adds goal biasing during sampling to accelerate convergence towards the goal,\nand uses a rewiring step similar to RRT* to improve path quality and reduce total cost\nby connecting new nodes through lower-cost parents when possible.\nAdditionally, it imposes a 30-second timeout on the path search to prevent excessive computation.\n\"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # Allow edge rewiring for improved paths\n        self._init_displays()\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist: float) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(dir)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n        dir_normalized = dir / dist\n        q_new_point = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new_point)\n\n    def _get_random_sample(self, goal_sample_rate: float = 0.2) -> Point:\n        \"\"\"\n        Samples randomly in the map with a probability of goal_sample_rate to sample the goal directly.\n        This biases the tree growth towards the goal for faster convergence.\n        \"\"\"\n        grid = self._get_grid()\n        if np.random.random() < goal_sample_rate:\n            return grid.goal.position\n        while True:\n            rand_pos = np.random.randint(0, grid.size, grid.size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if grid.is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex, radius: float) -> List[Vertex]:\n        \"\"\"\n        Returns list of vertices within given radius of q_new.position.\n        \"\"\"\n        near_vertices: List[Vertex] = []\n        q_new_tensor = q_new.position.to_tensor()\n        for v in self._graph.vertices:\n            dist = torch.norm(v.position.to_tensor() - q_new_tensor)\n            if dist <= radius:\n                near_vertices.append(v)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex, max_dist: float) -> Vertex:\n        \"\"\"\n        Chooses best parent from the list of near vertices for q_new based on cost.\n        \"\"\"\n        grid = self._get_grid()\n        min_cost = float('inf')\n        best_parent = None\n\n        for q_near in near_vertices:\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n            cost_to_new = q_near.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if cost_to_new < min_cost:\n                min_cost = cost_to_new\n                best_parent = q_near\n\n        if best_parent is None:\n            # fallback to single nearest vertex if no near vertices are connected validly\n            best_parent = self._graph.get_nearest_vertex(self._graph.vertices, q_new.position)\n\n        # Set cost and parent accordingly\n        q_new.cost = min_cost if best_parent is not None else 0.0\n        return best_parent\n\n    def _rewire(self, q_new: Vertex, near_vertices: List[Vertex]) -> None:\n        \"\"\"\n        Attempts to rewire near vertices to q_new if cost can be improved.\n        \"\"\"\n        grid = self._get_grid()\n        pos_new_tensor = q_new.position.to_tensor()\n        for q_near in near_vertices:\n            if q_near == q_new.parents[0] if q_new.parents else None:\n                continue\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_new.position, q_near.position)):\n                continue\n\n            cost_through_new = q_new.cost + torch.norm(q_near.position.to_tensor() - pos_new_tensor)\n            if cost_through_new < q_near.cost:\n                # Remove old edge(s) - assume one parent in typical tree structure\n                for p in list(q_near.parents):\n                    self._graph.remove_edge(p, q_near)\n                # Add new edge from q_new to q_near\n                self._graph.add_edge(q_new, q_near)\n                q_near.cost = cost_through_new\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        self._graph.add_edge(q_new, goal_v)  # connect last sampled point close to goal vertex to goal vertex\n        path: List[Vertex] = [goal_v]\n\n        while len(path[-1].parents) != 0:\n            # go through parents, only single parent assumed (tree)\n            parent = path[-1].parents[0]\n            path.append(parent)\n\n        del path[-1]  # remove root (start) duplicate\n        path.reverse()\n\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Overridden Implementation #\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        max_dist: float = 10.0\n        iterations: int = 10000\n        goal_sample_rate: float = 0.2\n        rewire_radius: float = 15.0\n\n        start_time = time.time()\n        grid = self._get_grid()\n\n        for iteration in range(iterations):\n            if (time.time() - start_time) > 30.0:\n                # Timeout, path search failed\n                break\n\n            q_sample: Point = self._get_random_sample(goal_sample_rate)\n            q_near: Vertex = self._graph.get_nearest_vertex(self._graph.vertices, q_sample)\n            if q_near.position == q_sample:\n                continue\n\n            q_new: Vertex = self._get_new_vertex(q_near, q_sample, max_dist)\n\n            if not grid.is_valid_line_sequence(grid.get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Find nearby vertices for parent selection & rewiring\n            near_vertices: List[Vertex] = self._near_vertices(q_new, rewire_radius)\n\n            best_parent: Vertex = self._choose_parent(near_vertices, q_new, max_dist)\n            if best_parent is None:\n                continue\n\n            self._graph.add_edge(best_parent, q_new)\n\n            # Rewiring near vertices to improve path cost\n            self._rewire(q_new, near_vertices)\n\n            if grid.is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This implementation is an improved sample-based path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star). \nIt incrementally grows a search tree by randomly sampling points in the map, connecting them to the nearest vertex \nin the tree while rewiring connections to ensure near-optimal paths. This approach significantly improves time \nefficiency over exhaustive A* on grids by avoiding full grid expansion, and it utilizes heuristic sampling \nand rewiring to optimize the path quality. The implementation also stops searching if no solution is found \nwithin 30 seconds, treating it as not found to maintain responsiveness in complex maps.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    \"\"\"\n    Sample-based planner inspired by RRT* algorithm for improved performance over A* in large/complex maps.\n    It grows a tree of vertices by sampling and locally optimizing the path by rewiring neighbors.\n    Stops after 30 seconds if no path found.\n    \"\"\"\n    _graph: Set[Vertex]\n    _vertex_map: Dict[Point, Vertex]\n    _max_distance: float\n    _goal_radius: float\n    _goal_vertex: Optional[Vertex]\n    _map: Map\n    _pq_colour_max: DynamicColour\n    _pq_colour_min: DynamicColour\n    _visited_colour: DynamicColour\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        self._graph = set()\n        self._vertex_map = {}\n        self._goal_vertex = None\n        self._max_distance = 5.0  # max step length for a new edge; can be tuned\n        self._goal_radius = 2.0   # radius to consider goal reached\n\n        self._map = self._get_grid()\n\n        self._pq_colour_max = self._services.state.views.add_colour(\"rrt star max\", BLUE)\n        self._pq_colour_min = self._services.state.views.add_colour(\"rrt star min\", Colour(0.3, 0.4, 0.5, 0.3))\n        self._visited_colour = self._services.state.views.add_colour(\"rrt star visited\", Colour(0.2, 0.55, 0.3, 0.8))\n\n        self.__map_displays = []\n        self._init_displays()\n\n    def _init_displays(self) -> None:\n        from simulator.views.map.display.graph_map_display import GraphMapDisplay\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.monotonic()\n        start_point = self._map.agent.position\n        goal_point = self._map.goal.position\n\n        root_vertex = Vertex(start_point)\n        self._graph.add(root_vertex)\n        self._vertex_map[start_point] = root_vertex\n\n        found_goal = False\n\n        # Set initial pause for keyframe visualization\n        self.key_frame()\n\n        while True:\n            current_time = time.monotonic()\n            if current_time - start_time > 30.0:\n                # Timeout no path found\n                break\n\n            q_rand = self._get_random_sample()\n\n            q_nearest = self._nearest_vertex(q_rand)\n            q_new_point = self._steer(q_nearest.point, q_rand, self._max_distance)\n            if not self._map.is_valid_position(q_new_point):\n                # Invalid position (e.g. obstacle)\n                continue\n            if self._map.is_collision_between(q_nearest.point, q_new_point):\n                # Path blocked by obstacle, skip\n                continue\n\n            q_new = Vertex(q_new_point)\n            q_new.parent = q_nearest\n            q_new.cost = q_nearest.cost + self._map.get_movement_cost(q_nearest.point, q_new_point)\n            self._graph.add(q_new)\n            self._vertex_map[q_new_point] = q_new\n\n            # Rewire neighbors within radius to reduce costs\n            radius = self._get_neighbour_radius(len(self._graph))\n            neighbors = self._near_vertices(q_new_point, radius)\n\n            for q_neighbor in neighbors:\n                if q_neighbor == q_nearest:\n                    continue\n                if self._map.is_collision_between(q_neighbor.point, q_new_point):\n                    continue\n                new_cost = q_new.cost + self._map.get_movement_cost(q_new_point, q_neighbor.point)\n                if new_cost < q_neighbor.cost:\n                    # Rewire\n                    if q_neighbor.parent is not None:\n                        q_neighbor.parent.children.discard(q_neighbor)\n                    q_neighbor.parent = q_new\n                    q_neighbor.cost = new_cost\n                    q_new.children.add(q_neighbor)\n\n            q_nearest.children.add(q_new)\n\n            self.key_frame()\n\n            # Check if goal is reached (within radius)\n            if self._distance(q_new_point, goal_point) <= self._goal_radius:\n                if not self._map.is_collision_between(q_new_point, goal_point):\n                    found_goal = True\n                    self._goal_vertex = Vertex(goal_point)\n                    self._goal_vertex.parent = q_new\n                    self._goal_vertex.cost = q_new.cost + self._map.get_movement_cost(q_new_point, goal_point)\n                    self._graph.add(self._goal_vertex)\n                    self._vertex_map[goal_point] = self._goal_vertex\n                    q_new.children.add(self._goal_vertex)\n                    break\n\n        if found_goal:\n            path = self._extract_path(self._goal_vertex)\n            for p in path:\n                self.move_agent(p)\n                if isinstance(self._map, RosMap):\n                    self._map.publish_wp(self._map.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        # else no path found, do nothing\n\n    def _get_random_sample(self) -> Point:\n        # Bias sampling with goal probability 0.1 to improve goal-directed growth\n        goal_point = self._map.goal.position\n        if np.random.rand() < 0.1:\n            return goal_point\n        else:\n            xmin, ymin = self._map.get_min_bounds()\n            xmax, ymax = self._map.get_max_bounds()\n            return Point(np.random.uniform(xmin, xmax), np.random.uniform(ymin, ymax))\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        # Linear search for nearest vertex in the tree - can be optimized\n        nearest_v = None\n        min_dist = float('inf')\n        for v in self._graph:\n            d = self._distance(v.point, point)\n            if d < min_dist:\n                min_dist = d\n                nearest_v = v\n        assert nearest_v is not None\n        return nearest_v\n\n    def _steer(self, from_point: Point, to_point: Point, max_length: float) -> Point:\n        dist = self._distance(from_point, to_point)\n        if dist <= max_length:\n            return to_point\n        else:\n            direction = np.array(to_point) - np.array(from_point)\n            direction_norm = direction / dist\n            new_point_arr = np.array(from_point) + direction_norm * max_length\n            return Point(float(new_point_arr[0]), float(new_point_arr[1]))\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(np.linalg.norm(np.array(p1) - np.array(p2)))\n\n    def _get_neighbour_radius(self, num_vertices: int) -> float:\n        # Radius strategy per RRT* theoretical guarantees: gamma * (log(n)/n)^(1/d)\n        # Here d = 2 for 2D space, gamma chosen as 20 for practical tuning\n        if num_vertices <= 1:\n            return self._max_distance\n        gamma = 20.0\n        r = gamma * (np.log(num_vertices) / num_vertices) ** 0.5\n        return max(r, self._max_distance)\n\n    def _near_vertices(self, point: Point, radius: float) -> List[Vertex]:\n        neighbors = []\n        radius_sq = radius * radius\n        point_np = np.array(point)\n        for v in self._graph:\n            if np.sum((np.array(v.point) - point_np) ** 2) <= radius_sq:\n                neighbors.append(v)\n        return neighbors\n\n    def _extract_path(self, goal_vertex: Vertex) -> List[Point]:\n        path = []\n        current = goal_vertex\n        while current is not None:\n            path.append(current.point)\n            current = current.parent\n        path.reverse()\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "This is an improved sample-based path planning algorithm inspired by RRT-Connect but enhanced by incorporating heuristics that bias sampling towards the goal region, \nresulting in faster convergence. Instead of purely random sampling, this approach uses goal-biased sampling to reduce unnecessary exploration.\nAdditionally, a timeout has been added to terminate the search after 30 seconds if no path is found.\nThis algorithm preserves the bidirectional tree growth and connection strategy of RRT-Connect but improves efficiency by focusing growth in promising areas.",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _goal_sample_rate: float\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n\n        self._max_dist = 10\n        self._iterations = 10000\n        self._goal_sample_rate = 0.2  # 20% goal bias sampling\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _get_goal_biased_sample(self) -> Point:\n        if np.random.rand() < self._goal_sample_rate:\n            # Return the goal position directly for biased sampling\n            return self._get_grid().goal.position\n        else:\n            return self._get_random_sample()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        for i in range(self._iterations):\n\n            # Timeout check - end search if > 30 seconds\n            curr_time = time.time()\n            if curr_time - start_time > 30:\n                # No path found within allowed time\n                break\n\n            q_rand: Point = self._get_goal_biased_sample()\n\n            if not self._extend(self._graph.root_vertices[0], q_rand) == 'trapped':\n                self._extension_target = self._q_new\n                if self._connect(self._graph.root_vertices[-1], self._q_new) == 'reached':\n                    self._extract_path()\n                    break\n            self._graph.reverse_root_vertices()\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on Rapidly-exploring Random Tree (RRT*) that\n    incrementally builds a tree of feasible paths by sampling the space and rewiring \n    connections for asymptotic optimality.\n    The algorithm balances exploration and exploitation by connecting new samples with \n    the best parent to reduce path cost, while rewiring nearby nodes to improve existing paths.\n    This sample-based approach can perform better in large, high-dimensional, or complex\n    discrete grid environments by avoiding exhaustive search and improving path quality over time.\n    The search is time-limited to 30 seconds to prevent excessive runtime without success.\n    \"\"\"",
     "code": "self.g = {}\n            self.h = {}\n\n    mem: InternalMemory\n\n    pq_colour_max: DynamicColour\n    pq_colour_min: DynamicColour\n    visited_colour: DynamicColour\n\n    __map_displays: List[MapDisplay]\n\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        self.mem = AStar.InternalMemory(self._services)\n\n        self.pq_colour_max = self._services.state.views.add_colour(\"explored max\", BLUE)\n        self.pq_colour_min = self._services.state.views.add_colour(\"explored min\", Colour(0.27, 0.33, 0.35, 0.2))\n        self.visited_colour = self._services.state.views.add_colour(\"visited\", Colour(0.19, 0.19, 0.2, 0.8))\n\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self.mem.visited, self.visited_colour, z_index=50),\n                               GradientListMapDisplay(self._services, self.mem.priority_queue, min_colour=self.pq_colour_min,\n                                                  max_colour=self.pq_colour_max, z_index=49, inverted=True)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Read super description\n        \"\"\"\n        return super().set_display_info() + self.__map_displays\n\n    # noinspection PyUnusedLocal\n    # @profile\n    def _find_path_internal(self) -> None:\n        self._init_mem()\n\n        if self._expand():\n            self._follow_back_trace()\n\n    def _init_mem(self) -> None:\n        grid: Map = self._get_grid()\n\n        # push agent\n        self.mem.g[grid.agent.position] = 0\n        item: Tuple[float, Point] = (self.get_heuristic(grid.agent.position), grid.agent.position)\n        self.mem.priority_queue.push(item)\n        self.mem.back_pointer[grid.agent.position] = None\n\n    def _expand(self) -> bool:\n        grid: Map = self._get_grid()\n\n        while len(self.mem.priority_queue) > 0:\n            total_dist: float\n            next_node: Point\n            # peek and check if we need to terminate\n            total_dist, next_node = self.mem.priority_queue.pop()\n\n            if grid.is_goal_reached(next_node):\n                self.mem.priority_queue.push((total_dist, next_node))\n                return True\n\n            self.mem.visited.add(next_node)\n\n            for n, idx in grid.get_next_positions_with_move_index(next_node):\n                if n not in self.mem.visited:\n                    dist = grid.get_movement_cost_from_index(idx, n)\n                    if n not in self.mem.g or self.mem.g[next_node] + dist < self.mem.g[n]:\n                        # it does not matter if we have duplicates as we will not be looking at them\n                        # therefore it does not affect the priority\n                        self.mem.g[n] = self.mem.g[next_node] + dist\n                        item = (self.f(n), n)\n                        self.mem.priority_queue.push(item)\n                        self.mem.back_pointer[n] = next_node\n\n            self.key_frame()\n        return False\n\n    def f(self, x: Point) -> float:\n        g = self.mem.g[x]\n        h = self.get_heuristic(x)\n        ret = g + h\n        return ret\n\n    def _follow_back_trace(self):\n        grid: Map = self._get_grid()\n        \n        trace: List[Point] = self.get_back_trace(grid.goal)\n        trace.reverse()\n        for t in trace:\n            self.move_agent(t)\n            if isinstance(grid, RosMap):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def get_back_trace(self, goal: Goal) -> List[Point]:\n        \"\"\"\n        Follows the back pointer until it gets to the agent position\n        :return: The trace\n        \"\"\"\n        trace = []\n        pos = goal.position\n        while self.mem.back_pointer[pos] is not None:\n            trace.append(pos)\n            pos = self.mem.back_pointer[pos]\n        return trace\n\n    def get_heuristic(self, pos: Point) -> float:\n        \"\"\"\n        Returns the euclidean distance from the given position to the goal\n        It does memoization as well\n        :param goal: The goal\n        :param pos: The initial position\n        :return:\n        \"\"\"\n        self.mem.h.setdefault(pos, np.linalg.norm(np.array(pos) - np.array(self._get_grid().goal.position)))\n        return self.mem.h[pos]\n\nPlease help us create a new algorithm with improved time by modifying the provided algorithm. \nIdentify the backbone idea in the provided algorithms.\nThe class you generate must inherit from `SampleBasedAlgorithm`, which itself inherits from `Algorithm`.\n\nYou must conform to this interface structure and override the required abstract methods, including:\n- `set_display_info(self) -> List[MapDisplay]`\n- `_find_path_internal(self) -> None`\n\n\nfrom utility.threading import Condition\nfrom typing import Optional, List\nfrom abc import ABC, abstractmethod\n\nfrom algorithms.basic_testing import BasicTesting\nfrom algorithms.configuration.entities.goal import Goal\nfrom algorithms.configuration.maps.map import Map\nfrom simulator.services.services import Services\nfrom simulator.views.map.display.entities_map_display import EntitiesMapDisplay\nfrom simulator.views.map.display.map_display import MapDisplay\nfrom simulator.views.map.display.solid_iterable_map_display import SolidIterableMapDisplay\nfrom structures import Point\n\n\nclass Algorithm(ABC):\n    \"\"\"\n    Class for defining basic API for algorithms.\n    All algorithms must inherit from this class.\n    \"\"\"\n    testing: Optional[BasicTesting]\n    _services: Services\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        self._services = services\n        self.testing = testing\n        self.__root_key_frame = self._services.algorithm\n\n    def set_condition(self, key_frame_condition: Condition) -> None:\n        \"\"\"\n        This method is used to initialise the debugging condition\n        :param key_frame_condition: The condition\n        \"\"\"\n        if self.testing is not None:\n            self.testing.set_condition(key_frame_condition)\n\n    def get_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Returns the info displays\n        :return: A list of info displays\n        \"\"\"\n        if self.testing is not None:\n            return self.testing.display_info\n        return []\n\n    def key_frame(self, *args, **kwargs) -> None:\n        \"\"\"\n        Method that marks a key frame\n        It is used in animations\n        \"\"\"\n        if self.testing is not None:\n            self.testing.key_frame(*args, **kwargs, root_key_frame=self.__root_key_frame)\n\n    def set_root_key_frame(self, algo):\n        self.__root_key_frame = algo\n\n    def find_path(self) -> None:\n        \"\"\"\n        Method for finding a path from agent to goal\n        Movement should be done using the map APIs\n        \"\"\"\n        if self.testing is not None:\n            self.testing.algorithm_start()\n        self._find_path_internal()\n        if self.testing is not None:\n            self.testing.algorithm_done()\n\n    def _get_grid(self) -> Map:\n        \"\"\"\n        Shortcut to get the map\n        :return: The map\n        \"\"\"\n        return self._services.algorithm.map\n\n    def move_agent(self, to: Point) -> None:\n        \"\"\"\n        Method used to move the agent on the map\n        :param to: the destination\n        \"\"\"\n        #method is in map.py. follow param means Instead of teleport, moves in a straight line\n        self._get_grid().move_agent(to, follow=True)\n\n    @abstractmethod\n    def set_display_info(self) -> List[MapDisplay]:\n        \"\"\"\n        Method used for setting the info displays\n        All algorithms must override this method\n        :return: A list of info displays\n        \"\"\"\n        return []\n\n    @abstractmethod\n    def _find_path_internal(self) -> None:\n        \"\"\"\n        The internal implementation of :ref:`find_path`\n        All algorithms must override this method\n        \"\"\"\n        pass\n\n\nclass SampleBasedAlgorithm(Algorithm):\n    __map_displays: List[MapDisplay]\n\n    def _init_displays(self) -> None:\n        self.__map_displays = [GraphMapDisplay(self._services, self._graph)]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n\n\n### Constraints:\n- Please write a brief description of the algorithm you generated.\n- The description must be inside a brace and placed at the very top of the code.\n- Implement it in Python.\n- You do not need to declare the imports, as they are already provided in the codebase.\n- Your class must be named `PathPlanning`.\n- It must inherit from `SampleBasedAlgorithm` which inherits 'Algorithm'.(you can utilize the existing methods from `SampleBasedAlgorithm` and `Algorithm`).\n- You must reuse existing helper functions where applicable. If necessary, you may define and use new helper functions to support the implementation.\n- It should work with existing components: `Forest`, `Point`, `Vertex`, etc.\n- The `__init__` method must not be modified. However, you are allowed to add new member variables within it (no structural changes or logic modifications).\n- When referencing multiple algorithms, don't forget to declare variables in __init__.\n- The core logic of the path planning algorithm must be implemented inside the `_find_path_internal` function. You may call any helper functions from within `_find_path_internal`.\n- Analyze the usage patterns and conventions from the provided codebase (e.g., class structure, function calls, and service access), and ensure your code follows the same patterns.\n- All variables or objects used in the code must be explicitly declared before use. Do not use undeclared variables, even if they appear to be implied from context.\n- If the reference code uses specific variable declarations (e.g., `self._graph`, `self._q_new`, 'self._get_random_sample', etc.), ensure these are preserved and correctly initialized before being used.\n- Always verify that any newly introduced variables are properly initialized and assigned in a contextually valid location.\n- Do not assume the existence of any variables that are not shown in the provided reference code. If a variable is required, define it explicitly and ensure it is logically scoped.\n- After code generation, you must review the code to ensure it is syntactically correct, logically coherent, and executable within the expected environment.\n- Add code to treat a route search as not found if it takes more than 30 seconds to find the route.(in function `_find_path_internal`)\n\n### You may freely define new helper functions if necessary\n- If your approach benefits from additional utility methods (e.g., cost estimation, region sampling, custom distance functions), feel free to create and use them.\n\n### The `_find_path_internal` function is the main function executed for path planning.\n\n\n### Constraints:\n- Please write a brief description of the algorithm you generated.\n- The description must be inside a brace and placed at the very top of the code.\n- Implement it in Python.\n- You do not need to declare the imports, as they are already provided in the codebase.\n- Your class must be named `PathPlanning`.\n- It must inherit from `SampleBasedAlgorithm` which inherits 'Algorithm'.(you can utilize the existing methods from `SampleBasedAlgorithm` and `Algorithm`).\n- You must reuse existing helper functions where applicable. If necessary, you may define and use new helper functions to support the implementation.\n- It should work with existing components: `Forest`, `Point`, `Vertex`, etc.\n- The `__init__` method must not be modified. However, you are allowed to add new member variables within it (no structural changes or logic modifications).\n- When referencing multiple algorithms, don't forget to declare variables in __init__.\n- The core logic of the path planning algorithm must be implemented inside the `_find_path_internal` function. You may call any helper functions from within `_find_path_internal`.\n- Analyze the usage patterns and conventions from the provided codebase (e.g., class structure, function calls, and service access), and ensure your code follows the same patterns.\n- All variables or objects used in the code must be explicitly declared before use. Do not use undeclared variables, even if they appear to be implied from context.\n- If the reference code uses specific variable declarations (e.g., `self._graph`, `self._q_new`, 'self._get_random_sample', etc.), ensure these are preserved and correctly initialized before being used.\n- Always verify that any newly introduced variables are properly initialized and assigned in a contextually valid location.\n- Do not assume the existence of any variables that are not shown in the provided reference code. If a variable is required, define it explicitly and ensure it is logically scoped.\n- After code generation, you must review the code to ensure it is syntactically correct, logically coherent, and executable within the expected environment.\n- Add code to treat a route search as not found if it takes more than 30 seconds to find the route.(in function `_find_path_internal`)\n\n### You may freely define new helper functions if necessary\n- If your approach benefits from additional utility methods (e.g., cost estimation, region sampling, custom distance functions), feel free to create and use them.\n\n### The `_find_path_internal` function is the main function executed for path planning.\n\n\nDo not give additional explanations. ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved sample-based path planning algorithm \n    inspired by RRT* (Rapidly-exploring Random Tree Star). \n\n    Unlike classic A* which operates on a grid, this algorithm incrementally builds a tree in continuous space, \n    using random sampling to explore the map efficiently and improve the path cost over time.\n\n    It samples random points, tries to connect them to the nearest existing tree vertices, rewires \n    nearby vertices to maintain optimal cost paths, and stops once it finds a path to the goal or time exceeds 30s.\n\n    This approach reduces pathfinding time especially in high-dimensional or large spaces compared to exhaustive search.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = set()  # type: Set[Vertex]\n        self._vertices = {}  # type: Dict[Point, Vertex]\n        self._q_new: Optional[Vertex] = None\n        self._radius: float = 5.0  # Radius for rewiring (can be tuned based on map scale)\n        self._goal_vertex: Optional[Vertex] = None\n        self._max_iter: int = 10000\n        self._map = self._get_grid()\n\n        # Initialize display list\n        self._display_graph = GraphMapDisplay(self._services, self._graph)\n        self._map_displays = [self._display_graph]\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        self._init_graph()\n\n        found_path = False\n        iter_count = 0\n\n        while iter_count < self._max_iter:\n            iter_count += 1\n            if (time.time() - start_time) > 30.0:\n                # Timeout condition: no path found within 30s\n                break\n\n            x_sample = self._get_random_sample()\n\n            nearest_vertex = self._nearest_vertex(x_sample)\n            x_new = self._steer(nearest_vertex.position, x_sample)\n\n            if not self._map.is_walkable(x_new):\n                # Ignore sample in obstacles or invalid\n                continue\n\n            if self._collision_free(nearest_vertex.position, x_new):\n                new_vertex = Vertex(x_new)\n                new_vertex.parent = nearest_vertex\n                new_vertex.cost = nearest_vertex.cost + self._distance(nearest_vertex.position, x_new)\n\n                neighbors = self._near_vertices(new_vertex.position)\n\n                min_cost = new_vertex.cost\n                min_parent = nearest_vertex\n\n                # Choose best parent from neighbors for new vertex to optimize path cost\n                for neighbor in neighbors:\n                    if self._collision_free(neighbor.position, new_vertex.position):\n                        cost_through_neighbor = neighbor.cost + self._distance(neighbor.position, new_vertex.position)\n                        if cost_through_neighbor < min_cost:\n                            min_cost = cost_through_neighbor\n                            min_parent = neighbor\n\n                new_vertex.parent = min_parent\n                new_vertex.cost = min_cost\n\n                self._graph.add(new_vertex)\n                self._vertices[new_vertex.position] = new_vertex\n\n                # Rewire neighbors to new vertex if it improves their cost\n                for neighbor in neighbors:\n                    if neighbor == min_parent:\n                        continue\n                    if self._collision_free(new_vertex.position, neighbor.position):\n                        cost_through_new = new_vertex.cost + self._distance(new_vertex.position, neighbor.position)\n                        if cost_through_new < neighbor.cost:\n                            neighbor.parent = new_vertex\n                            neighbor.cost = cost_through_new\n\n                # Check if new vertex connects to goal\n                if self._map.is_goal_reached(new_vertex.position):\n                    self._goal_vertex = new_vertex\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        if found_path:\n            path_points = self._build_path(self._goal_vertex)\n            # Move agent along the path\n            for pt in path_points:\n                self.move_agent(pt)\n                if isinstance(self._map, RosMap):\n                    self._map.publish_wp(self._map.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n\n    def _init_graph(self) -> None:\n        self._graph.clear()\n        self._vertices.clear()\n\n        start_pos = self._map.agent.position\n        start_vertex = Vertex(start_pos)\n        start_vertex.parent = None\n        start_vertex.cost = 0.0\n\n        self._graph.add(start_vertex)\n        self._vertices[start_pos] = start_vertex\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random point within the map's bounds.\n        With some probability, sample the goal to bias exploration.\n        \"\"\"\n        goal_pos = self._map.goal.position\n\n        # Probability to sample goal to help directed search\n        goal_sample_prob = 0.1\n\n        import random\n        if random.random() < goal_sample_prob:\n            return goal_pos\n\n        xmin, ymin = self._map.bounds_min\n        xmax, ymax = self._map.bounds_max\n\n        while True:\n            x = random.uniform(xmin, xmax)\n            y = random.uniform(ymin, ymax)\n            pt = (x, y)\n            if self._map.is_walkable(pt):\n                return pt\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Find the nearest vertex in the tree to the given point by Euclidean distance.\n        \"\"\"\n        nearest = None\n        nearest_dist = math.inf\n        for vertex in self._graph:\n            dist = self._distance(vertex.position, point)\n            if dist < nearest_dist:\n                nearest_dist = dist\n                nearest = vertex\n        return nearest\n\n    def _steer(self, from_pt: Point, to_pt: Point, max_dist: float = 1.0) -> Point:\n        \"\"\"\n        Move from 'from_pt' towards 'to_pt' by at most max_dist.\n        \"\"\"\n        from_arr = np.array(from_pt)\n        to_arr = np.array(to_pt)\n        direction = to_arr - from_arr\n        length = np.linalg.norm(direction)\n        if length <= max_dist:\n            return to_pt\n        direction = direction / length\n        new_point = from_arr + direction * max_dist\n        return tuple(new_point)\n\n    def _collision_free(self, from_pt: Point, to_pt: Point) -> bool:\n        \"\"\"\n        Check if path between from_pt and to_pt is free of obstacles.\n        Uses map's line collision checking capability or samples line with fine discretization.\n        \"\"\"\n        # We use the map's method if it exists, else fallback to manual checking\n        if hasattr(self._map, \"line_collision_free\"):\n            return self._map.line_collision_free(from_pt, to_pt)\n\n        # fallback manual collision checking with steps\n        steps = int(math.ceil(self._distance(from_pt, to_pt) / 0.1))\n        if steps == 0:\n            steps = 1\n        for i in range(steps + 1):\n            interp = np.array(from_pt) + (np.array(to_pt) - np.array(from_pt)) * (i / steps)\n            pt = tuple(interp)\n            if not self._map.is_walkable(pt):\n                return False\n        return True\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return float(np.linalg.norm(np.array(p1) - np.array(p2)))\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"\n        Find all vertices in the graph within self._radius distance of the point.\n        \"\"\"\n        near = []\n        for vertex in self._graph:\n            if self._distance(vertex.position, point) <= self._radius:\n                near.append(vertex)\n        return near\n\n    def _build_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Traverse parents from goal vertex back to start vertex to build path.\n        Returns path from start to goal.\n        \"\"\"\n        path = []\n        v = goal_vertex\n        while v is not None:\n            path.append(v.position)\n            v = v.parent\n        path.reverse()\n        return path ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    Improved path planning algorithm based on RRT* (Rapidly-exploring Random Tree Star).\n    This sample-based algorithm incrementally builds a tree rooted at the agent's start position,\n    samples random points in the environment, and attempts to connect them to the existing tree to\n    find an optimized path avoiding obstacles. It improves over basic RRT by rewiring the tree locally\n    to shorten paths, thus approximating the optimal path asymptotically. The algorithm terminates\n    once it finds a path to the goal or after 30 seconds timeout.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        self._graph: Dict[Point, List[Point]] = {}  # adjacency list for tree graph\n        self._cost: Dict[Point, float] = {}  # cost from start to node\n        self._parent: Dict[Point, Optional[Point]] = {}  # parent pointer for path reconstruction\n\n        self._vertex_set: Set[Point] = gen_set(self._services)  # all vertices in the tree\n\n        # Display components\n        self.__map_displays: List[MapDisplay] = []\n\n    def _init_displays(self) -> None:\n        # Display vertices in the tree\n        self.__map_displays = [SolidIterableMapDisplay(self._services, self._vertex_set,\n                                                      colour=self._services.state.views.add_colour(\"tree vertices\", Point(0.2, 0.7, 0.3, 0.8)),\n                                                      z_index=55)]\n        # call super to add parent displays if needed\n        super()._init_displays()\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n\n        grid: Map = self._get_grid()\n        start: Point = grid.agent.position\n        goal: Point = grid.goal.position\n\n        # Initialize graph\n        self._graph.clear()\n        self._cost.clear()\n        self._parent.clear()\n        self._vertex_set.clear()\n\n        # Add start vertex\n        self._add_vertex(start, cost=0.0, parent=None)\n\n        max_iterations = 10000\n        radius = 10.0  # radius for neighbor searching to rewire (tune as needed)\n\n        found_goal = False\n\n        for _ in range(max_iterations):\n            # Timeout check\n            if time.time() - start_time > 30.0:\n                # Treat as no path found due to timeout\n                return\n\n            # Sample random point in the map\n            q_rand: Point = self._get_random_sample()\n\n            # Find nearest vertex in tree\n            q_nearest: Point = self._nearest_vertex(q_rand)\n\n            # Steer from q_nearest toward q_rand with step size limit\n            q_new: Point = self._steer(q_nearest, q_rand, max_distance=5.0)\n\n            # Check collision for edge q_nearest -> q_new\n            if not self._collision_free(q_nearest, q_new):\n                self.key_frame()\n                continue\n\n            # Find neighbors within radius for potential rewiring\n            neighbors: List[Point] = self._near_vertices(q_new, radius)\n\n            # Choose best parent for q_new from neighbors (including q_nearest)\n            q_min, c_min = self._choose_parent(q_new, neighbors)\n\n            if q_min is None:\n                # No valid parent found; skip iteration\n                self.key_frame()\n                continue\n\n            self._add_vertex(q_new, cost=c_min, parent=q_min)\n\n            # Rewire neighbors if new connection is better\n            self._rewire(q_new, neighbors)\n\n            self.key_frame()\n\n            # Check if goal can be connected directly\n            if self._distance(q_new, goal) < 5.0 and self._collision_free(q_new, goal):\n                # Add goal to graph\n                self._add_vertex(goal, cost=self._cost[q_new] + self._distance(q_new, goal), parent=q_new)\n                found_goal = True\n                break\n\n        if found_goal:\n            self._follow_back_trace(goal)\n        # else we end with no path found\n\n    # ----- Helper methods -----\n\n    def _add_vertex(self, vertex: Point, cost: float, parent: Optional[Point]) -> None:\n        self._vertex_set.add(vertex)\n        self._cost[vertex] = cost\n        self._parent[vertex] = parent\n        self._graph.setdefault(vertex, [])\n        if parent is not None:\n            self._graph.setdefault(parent, []).append(vertex)\n\n    def _nearest_vertex(self, q_rand: Point) -> Point:\n        # Find vertex in self._vertex_set with minimum Euclidean distance to q_rand\n        best_vertex = None\n        min_dist = float('inf')\n        for v in self._vertex_set:\n            dist = self._distance(v, q_rand)\n            if dist < min_dist:\n                min_dist = dist\n                best_vertex = v\n        return best_vertex\n\n    def _steer(self, from_point: Point, to_point: Point, max_distance: float) -> Point:\n        # Move from from_point towards to_point by max_distance, or less if closer\n        vec = np.array(to_point) - np.array(from_point)\n        dist = np.linalg.norm(vec)\n        if dist <= max_distance:\n            return to_point\n        else:\n            direction = vec / dist\n            new_point_np = np.array(from_point) + direction * max_distance\n            return Point(int(round(new_point_np[0])), int(round(new_point_np[1])))\n\n    def _collision_free(self, p1: Point, p2: Point) -> bool:\n        # Check if path between p1 and p2 is free of obstacles using the map API\n        grid: Map = self._get_grid()\n        # Using line interpolation to check cells between p1 and p2\n        return grid.is_path_valid(p1, p2)\n\n    def _near_vertices(self, q_new: Point, radius: float) -> List[Point]:\n        # Return all vertices within radius of q_new\n        neighbors = []\n        for v in self._vertex_set:\n            if self._distance(v, q_new) <= radius:\n                neighbors.append(v)\n        return neighbors\n\n    def _choose_parent(self, q_new: Point, neighbors: List[Point]) -> Tuple[Optional[Point], float]:\n        # Choose the neighbor with minimal cost + cost to q_new among neighbors that can connect collision-free\n        min_cost = float('inf')\n        best_neighbor = None\n        grid: Map = self._get_grid()\n\n        for q_near in neighbors:\n            if not self._collision_free(q_near, q_new):\n                continue\n            cost = self._cost[q_near] + self._distance(q_near, q_new)\n            if cost < min_cost:\n                min_cost = cost\n                best_neighbor = q_near\n\n        return best_neighbor, min_cost\n\n    def _rewire(self, q_new: Point, neighbors: List[Point]) -> None:\n        # Attempt to rewire neighbors to go through q_new if cheaper path found\n        grid: Map = self._get_grid()\n\n        for q_near in neighbors:\n            if q_near == self._parent.get(q_new, None):\n                continue  # Skip current parent\n            if not self._collision_free(q_new, q_near):\n                continue\n            new_cost = self._cost[q_new] + self._distance(q_new, q_near)\n            if new_cost < self._cost.get(q_near, float('inf')):\n                # Rewire q_near to q_new\n                old_parent = self._parent[q_near]\n                if old_parent is not None:\n                    if q_near in self._graph.get(old_parent, []):\n                        self._graph[old_parent].remove(q_near)\n                self._parent[q_near] = q_new\n                self._cost[q_near] = new_cost\n                self._graph.setdefault(q_new, []).append(q_near)\n                # Propagate cost updates downstream recursively\n                self._propagate_cost_update(q_near)\n\n    def _propagate_cost_update(self, vertex: Point) -> None:\n        # Recursively update children costs after rewiring\n        for child in self._graph.get(vertex, []):\n            new_cost = self._cost[vertex] + self._distance(vertex, child)\n            if new_cost < self._cost.get(child, float('inf')):\n                self._cost[child] = new_cost\n                self._propagate_cost_update(child)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        return np.linalg.norm(np.array(p1) - np.array(p2))\n\n    def _follow_back_trace(self, goal: Point) -> None:\n        # Reconstruct path from goal to start and move agent along it\n        grid: Map = self._get_grid()\n        path: List[Point] = []\n\n        pos = goal\n        while pos is not None:\n            path.append(pos)\n            pos = self._parent.get(pos, None)\n\n        path.reverse()\n\n        for point in path:\n            self.move_agent(point)\n            if isinstance(grid, Map) and hasattr(grid, \"publish_wp\"):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True) ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved sample-based path planning method inspired by RRT*,\n    which incrementally builds a tree of feasible paths in the continuous state space. \n    By sampling random points and rewiring the tree to maintain minimum cost paths to nodes, \n    it improves efficiency and path optimality over classical methods like A* on discrete grids.\n    \n    To improve time performance, it incorporates a timeout mechanism that halts the search \n    after 30 seconds if no path is found.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None):\n        super().__init__(services, testing)\n\n        # Initialize the graph as a list of vertices (since we do not have Forest code explicitly)\n        self._graph: List[Vertex] = []\n        self._goal_vertex: Optional[Vertex] = None\n\n        # Parameters for RRT* inspired approach\n        self._max_samples = 10000  # Max samples before timing out\n        self._neighborhood_radius = 5.0  # Radius to look around for rewiring\n\n        # Display initialization\n        self._map_displays: List[MapDisplay] = []\n\n    def set_display_info(self) -> List[MapDisplay]:\n        # Assuming GraphMapDisplay can be constructed with services and graph; else adjust accordingly.\n        from simulator.views.map.display.entities_map_display import EntitiesMapDisplay\n        from simulator.views.map.display.map_display import MapDisplay\n        \n        # Initialize map displays if empty\n        if not self._map_displays:\n            try:\n                from simulator.views.map.display.graph_map_display import GraphMapDisplay\n                self._map_displays = [GraphMapDisplay(self._services, self._graph)]\n            except ImportError:\n                # fallback if GraphMapDisplay unavailable\n                self._map_displays = []\n        return super().set_display_info() + self._map_displays\n\n    def _find_path_internal(self) -> None:\n        grid: Map = self._get_grid()\n        start_pos: Point = grid.agent.position\n        goal_pos: Point = grid.goal.position\n\n        self._graph.clear()\n        self._goal_vertex = None\n\n        # Insert start vertex\n        start_vertex = Vertex(start_pos, parent=None, cost=0.0)\n        self._graph.append(start_vertex)\n\n        start_time = time.time()\n        found_path = False\n\n        for _ in range(self._max_samples):\n            if time.time() - start_time > 30:\n                # Timeout: stop search without finding path\n                found_path = False\n                break\n\n            q_rand = self._get_random_sample()\n            q_near = self._nearest_vertex(q_rand)\n            q_new = self._steer(q_near, q_rand)\n\n            if not self._is_collision_free(q_near.point, q_new):\n                self.key_frame()\n                continue\n\n            # Initialize new vertex cost\n            new_cost = q_near.cost + self._cost(q_near.point, q_new)\n\n            # Find nearby vertices for rewiring\n            neighbors = self._near_vertices(q_new)\n\n            min_cost = new_cost\n            min_parent = q_near\n\n            # Choose the best parent for q_new\n            for neighbor in neighbors:\n                if self._is_collision_free(neighbor.point, q_new):\n                    cost = neighbor.cost + self._cost(neighbor.point, q_new)\n                    if cost < min_cost:\n                        min_cost = cost\n                        min_parent = neighbor\n\n            q_new_vertex = Vertex(q_new, parent=min_parent, cost=min_cost)\n            self._graph.append(q_new_vertex)\n\n            # Rewire neighbors where q_new offers a lower cost path\n            for neighbor in neighbors:\n                if neighbor == min_parent:\n                    continue\n                if self._is_collision_free(q_new, neighbor.point):\n                    cost_through_q_new = q_new_vertex.cost + self._cost(q_new, neighbor.point)\n                    if cost_through_q_new < neighbor.cost:\n                        neighbor.parent = q_new_vertex\n                        neighbor.cost = cost_through_q_new\n\n            # Check if goal can be connected directly to q_new\n            if self._distance(q_new, goal_pos) <= self._neighborhood_radius:\n                if self._is_collision_free(q_new, goal_pos):\n                    self._goal_vertex = Vertex(goal_pos, parent=q_new_vertex,\n                                              cost=q_new_vertex.cost + self._cost(q_new, goal_pos))\n                    self._graph.append(self._goal_vertex)\n                    found_path = True\n                    break\n\n            self.key_frame()\n\n        if found_path and self._goal_vertex is not None:\n            path = self._construct_path(self._goal_vertex)\n            for point in path:\n                self.move_agent(point)\n                if isinstance(grid, type(grid)):\n                    grid.publish_wp(grid.agent.position)\n                self.key_frame(ignore_key_frame_skip=True)\n        # else fail silently (no path found)\n\n    def _get_random_sample(self) -> Point:\n        \"\"\"\n        Sample random free point from the map space\n        \"\"\"\n        grid: Map = self._get_grid()\n        width, height = grid.width, grid.height\n\n        import random\n\n        while True:\n            x = random.uniform(0, width - 1)\n            y = random.uniform(0, height - 1)\n            point = Point(int(round(x)), int(round(y)))\n            if not grid.is_obstacle(point):\n                return point\n\n    def _nearest_vertex(self, point: Point) -> Vertex:\n        \"\"\"\n        Find vertex in graph closest to given point (Euclidean distance)\n        \"\"\"\n        nearest = None\n        min_dist = float('inf')\n        for vertex in self._graph:\n            dist = self._distance(vertex.point, point)\n            if dist < min_dist:\n                min_dist = dist\n                nearest = vertex\n        return nearest\n\n    def _steer(self, from_vertex: Vertex, to_point: Point, extend_length: float = 5.0) -> Point:\n        \"\"\"\n        Move from from_vertex.point towards to_point by max extend_length.\n        Return new point.\n        \"\"\"\n        from_point = from_vertex.point\n        dist = self._distance(from_point, to_point)\n        if dist <= extend_length:\n            return to_point\n        else:\n            direction = ((to_point[0] - from_point[0]) / dist, (to_point[1] - from_point[1]) / dist)\n            new_x = from_point[0] + direction[0] * extend_length\n            new_y = from_point[1] + direction[1] * extend_length\n            return Point(int(round(new_x)), int(round(new_y)))\n\n    def _is_collision_free(self, p1: Point, p2: Point) -> bool:\n        \"\"\"\n        Check collision-free path between p1 and p2 on the map by Bresenham's line algorithm.\n        \"\"\"\n        grid: Map = self._get_grid()\n        points = self._bresenham_line(p1, p2)\n        for pt in points:\n            if grid.is_obstacle(pt):\n                return False\n        return True\n\n    def _cost(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Cost function (Euclidean distance)\n        \"\"\"\n        return self._distance(p1, p2)\n\n    def _distance(self, p1: Point, p2: Point) -> float:\n        \"\"\"\n        Euclidean distance between points p1 and p2\n        \"\"\"\n        import math\n        return math.hypot(p1[0] - p2[0], p1[1] - p2[1])\n\n    def _near_vertices(self, point: Point) -> List[Vertex]:\n        \"\"\"\n        Return list of vertices in the graph within neighborhood radius of point.\n        \"\"\"\n        neighbors = []\n        for vertex in self._graph:\n            if self._distance(vertex.point, point) <= self._neighborhood_radius:\n                neighbors.append(vertex)\n        return neighbors\n\n    def _construct_path(self, goal_vertex: Vertex) -> List[Point]:\n        \"\"\"\n        Construct path from start to goal by following parent links.\n        \"\"\"\n        path = []\n        node = goal_vertex\n        while node is not None:\n            path.append(node.point)\n            node = node.parent\n        path.reverse()\n        return path\n\n    def _init_displays(self) -> None:\n        # Initialize display info for this sample-based planner\n        self._map_displays = []\n        try:\n            from simulator.views.map.display.graph_map_display import GraphMapDisplay\n            self._map_displays.append(GraphMapDisplay(self._services, self._graph))\n        except ImportError:\n            pass ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm improves upon RRT-Connect by incorporating informed sampling to focus exploration on\n    an ellipsoidal region bounded by the start and goal and the best current path cost. This reduces \n    unnecessary sampling in regions unlikely to improve the solution, thereby improving convergence time.\n    Additionally, the algorithm tracks elapsed time and aborts search if no path is found within 30 seconds.\n    The algorithm still uses a bi-directional tree connection approach inspired by RRT-Connect, but leverages\n    heuristic sampling from the informed set.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n    _max_dist: float\n    _iterations: int\n    _start_time: float\n    _time_limit: float\n    \n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        \n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = False\n        self._init_displays()\n        \n        self._max_dist = 10\n        self._iterations = 10000\n        self._time_limit = 30.0  # seconds\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _sample_informed(self, start: Point, goal: Point, c_best: Optional[float]) -> Point:\n        \"\"\"\n        Samples a random point inside an ellipsoidal informed set defined by start, goal, and \n        current best path cost c_best. If c_best is None or infinite, fall back to uniform sampling.\n        \"\"\"\n        if c_best is None or math.isinf(c_best):\n            # Uniform random sample - fallback\n            return self._get_random_sample()\n        \n        # Distance between start and goal\n        c_min = start.distance(goal)\n        if c_min == 0:\n            # Start and goal coincide; return start\n            return start\n        \n        # Define ellipsoid axes lengths\n        a1 = c_best / 2.0  # major axis length semi\n        b = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best**2 - c_min**2 > 0 else 0.0  # minor axis semi\n        \n        # Sample unit ball in n-dim (here n=2 or general n_dim)\n        n_dim = self._get_grid().size.n_dim\n        \n        # sample random point in unit n-ball (uniform)\n        while True:\n            sample_unit = np.random.normal(0, 1, n_dim)\n            norm = np.linalg.norm(sample_unit)\n            if norm > 0:\n                sample_unit = sample_unit / norm\n                break\n        radius = np.random.uniform(0,1) ** (1/n_dim)  # scaled radius for uniform ball\n        sample_ball = sample_unit * radius\n        \n        # Rotation to align ellipse major axis with start->goal vector\n        start_to_goal = (goal.to_tensor() - start.to_tensor()).numpy()  # numpy array\n        start_to_goal_norm = np.linalg.norm(start_to_goal)\n        e1 = start_to_goal / start_to_goal_norm\n        \n        # Construct rotation matrix that maps x-axis unit vector to e1\n        # We assume 2D or n-D general with first axis aligned to start->goal vector\n        # Create orthonormal basis with e1 and others via Gram-Schmidt\n        U = np.zeros((n_dim, n_dim))\n        U[:, 0] = e1\n        \n        # Build orthonormal complement for n_dim > 1\n        if n_dim > 1:\n            # Using Gram-Schmidt for rest of basis vectors\n            basis = np.eye(n_dim)\n            count = 1\n            for i in range(n_dim):\n                v = basis[:, i]\n                # make orthogonal to e1\n                v = v - np.dot(v, e1) * e1\n                norm_v = np.linalg.norm(v)\n                if norm_v > 1e-10:\n                    U[:, count] = v / norm_v\n                    count += 1\n                if count >= n_dim:\n                    break\n        else:\n            # 1D case, trivial\n            pass\n        \n        # Scale matrix (diagonal) with ellipse radii\n        L = np.diag([a1] + [b] * (n_dim - 1))\n        \n        # Map sample_ball to ellipse\n        mapped = np.dot(U, np.dot(L, sample_ball)) + (start.to_tensor() + goal.to_tensor()) / 2.0\n        sample_point = Point.from_tensor(torch.tensor(mapped))\n        \n        # validate sample inside map and collision free\n        if self._get_grid().is_agent_valid_pos(sample_point):\n            return sample_point\n        else:\n            # fallback uniform if invalid\n            return self._get_random_sample()\n\n    def _calculate_path_cost(self, vertices_path: List[Vertex]) -> float:\n        \"\"\"\n        Calculate the cost of a path as the sum of Euclidean distances between consecutive vertices.\n        \"\"\"\n        total_cost = 0.0\n        for i in range(1, len(vertices_path)):\n            p1 = vertices_path[i - 1].position\n            p2 = vertices_path[i].position\n            total_cost += p1.distance(p2)\n        return total_cost\n\n    def _extract_path(self) -> None:\n        \"\"\"\n        Extract path from the two trees and move the agent along the found path.\n        \"\"\"\n        # trace back mid to goal side\n        path_mid_to_b: List[Vertex] = [self._q_new]\n        while len(path_mid_to_b[-1].parents) != 0:\n            parent = path_mid_to_b[-1].parents[0]\n            path_mid_to_b.append(parent)\n\n        # trace back start to mid side\n        path_a_to_mid: List[Vertex] = [self._extension_target]\n        while len(path_a_to_mid[-1].parents) != 0:\n            parent = path_a_to_mid[-1].parents[0]\n            path_a_to_mid.append(parent)\n        path_a_to_mid.reverse()\n        \n        path = path_a_to_mid + path_mid_to_b\n        \n        # If graph root vertices order inverted, reverse path\n        if self._graph.root_vertices[0] is self._graph.root_vertex_goal:\n            path.reverse()\n        \n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _find_path_internal(self) -> None:\n        self._start_time = time.time()\n        best_path_cost: Optional[float] = math.inf\n        best_path_found: bool = False\n\n        for _ in range(self._iterations):\n            # Check time limit\n            elapsed = time.time() - self._start_time\n            if elapsed > self._time_limit:\n                # Exceeded time limit; stop search (no path found)\n                break\n\n            # Sample informed, using best_path_cost known so far\n            q_rand: Point = self._sample_informed(self._graph.root_vertices[0].position,\n                                                  self._graph.root_vertices[-1].position,\n                                                  best_path_cost)\n\n            extend_result = self._extend(self._graph.root_vertices[0], q_rand)\n            if extend_result != 'trapped':\n                self._extension_target = self._q_new\n                connect_result = self._connect(self._graph.root_vertices[-1], self._q_new)\n                if connect_result == 'reached':\n                    # Extract path vertices\n                    # Compute cost of combined path for informed sampling\n                    path_mid_to_b: List[Vertex] = [self._q_new]\n                    while len(path_mid_to_b[-1].parents) != 0:\n                        path_mid_to_b.append(path_mid_to_b[-1].parents[0])\n                    path_a_to_mid: List[Vertex] = [self._extension_target]\n                    while len(path_a_to_mid[-1].parents) != 0:\n                        path_a_to_mid.append(path_a_to_mid[-1].parents[0])\n                    path_a_to_mid.reverse()\n                    combined_path = path_a_to_mid + path_mid_to_b\n                    \n                    path_cost = self._calculate_path_cost(combined_path)\n                    if path_cost < best_path_cost:\n                        best_path_cost = path_cost\n                        best_path_found = True\n                        self._extract_path()\n                        break\n                    \n            self._graph.reverse_root_vertices()\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This algorithm implements an improved RRT* variant called Bidirectional RRT*. \n    It grows two trees simultaneously: one from the start and one from the goal. \n    By attempting to connect the two trees during expansion, it can find a feasible path faster. \n    It preserves the rewiring optimization of RRT* to improve path costs iteratively.\n    Additionally, a 30-second timeout is used to stop search if no path is found in time. \n    This approach generally achieves faster convergence to a solution compared to single-tree RRT*.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n\n        start_vertex = Vertex(self._get_grid().agent.position)\n        start_vertex.cost = 0\n        goal_vertex = Vertex(self._get_grid().goal.position)\n\n        # Two forests: start -> goal and goal -> start\n        self._graph_start = gen_forest(self._services, start_vertex, goal_vertex, [])\n        self._graph_goal = gen_forest(self._services, goal_vertex, start_vertex, [])\n\n        self._init_displays_bidirectional()\n\n    def _init_displays_bidirectional(self) -> None:\n        map_displays = [EntitiesMapDisplay(self._services),\n                        SolidIterableMapDisplay(self._services)]\n        # Add graph displays for both forests\n        if hasattr(self, '_graph_start') and hasattr(self, '_graph_goal'):\n            from algorithms.classic.sample_based.core.graph import GraphMapDisplay\n            map_displays.append(GraphMapDisplay(self._services, self._graph_start))\n            map_displays.append(GraphMapDisplay(self._services, self._graph_goal))\n        self.__map_displays = map_displays\n\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info() + self.__map_displays\n\n    def _get_random_sample(self) -> Point:\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample: Point = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _get_nearest_vertex_from(self, forest: Forest, q_sample: Point) -> Vertex:\n        return forest.get_nearest_vertex([forest.root_vertex_start], q_sample)\n\n    def _get_vertices_within_radius_from(self, forest: Forest, vertex: Vertex, radius: float) -> List[Vertex]:\n        return forest.get_vertices_within_radius([forest.root_vertex_start], vertex.position, radius)\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        dir = q_sample.to_tensor() - q_near.position.to_tensor()\n        dir_norm = torch.norm(dir)\n        if dir_norm <= max_dist:\n            return Vertex(q_sample)\n\n        dir_normalized = dir / dir_norm\n        q_new = Point.from_tensor(q_near.position.to_tensor() + max_dist * dir_normalized)\n        return Vertex(q_new)\n\n    def _rewire(self, forest: Forest, q_new: Vertex, Q_near: List[Vertex]) -> None:\n        for q_near in Q_near:\n            if q_near == q_new:\n                continue\n            near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                self._get_grid().get_line_sequence(q_new.position, q_near.position))\n            cost_new_to_near = q_new.cost + torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n            if near_new_collision_free and cost_new_to_near < q_near.cost:\n                # Remove old edge\n                q_parent = None\n                for parent in q_near.parents:\n                    q_parent = parent\n                    break\n                if q_parent is not None:\n                    forest.remove_edge(q_parent, q_near)\n                # Add new edge and update cost\n                child_parent_dist = torch.norm(q_new.position.to_tensor() - q_near.position.to_tensor())\n                q_near.cost = q_new.cost + child_parent_dist\n                forest.add_edge(q_new, q_near)\n\n    def _extract_bidirectional_path(self, q_connect_start: Vertex, q_connect_goal: Vertex) -> None:\n        # Build path from start root to q_connect_start\n        path_start: List[Vertex] = [q_connect_start]\n        while len(path_start[-1].parents) != 0:\n            for parent in path_start[-1].parents:\n                path_start.append(parent)\n                break\n        path_start.reverse()\n\n        # Build path from q_connect_goal to goal root\n        path_goal: List[Vertex] = [q_connect_goal]\n        while len(path_goal[-1].parents) != 0:\n            for parent in path_goal[-1].parents:\n                path_goal.append(parent)\n                break\n\n        # Concatenate paths (start->connect + connect->goal)\n        full_path = path_start + path_goal\n\n        # Move agent through path, with keyframes and waypoint publishing as before\n        for v in full_path:\n            self.move_agent(v.position)\n            grid: Map = self._get_grid()\n            if hasattr(grid, 'publish_wp') and callable(grid.publish_wp):\n                grid.publish_wp(grid.agent.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    def _try_connect_trees(self, q_new_start: Vertex, forest_goal: Forest, radius: float) -> Tuple[bool, Vertex, Vertex]:\n        # Attempt to connect q_new_start to nearest vertices in the goal tree within radius\n        Q_near_goal = self._get_vertices_within_radius_from(forest_goal, q_new_start, radius)\n\n        q_connect_goal = None\n        c_min = float('inf')\n\n        for q_goal in Q_near_goal:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new_start.position, q_goal.position)):\n                continue\n            cost = q_new_start.cost + torch.norm(q_new_start.position.to_tensor() - q_goal.position.to_tensor()) + q_goal.cost\n            if cost < c_min:\n                c_min = cost\n                q_connect_goal = q_goal\n\n        if q_connect_goal is not None:\n            return True, q_new_start, q_connect_goal\n        return False, None, None\n\n    def _find_path_internal(self) -> None:\n\n        max_dist: float = 10\n        max_radius: float = 50\n        lambda_rrt_star: float = 50\n        dimension = 2\n        iterations: int = 10000\n\n        start_time = time()\n\n        for i in range(iterations):\n            if time() - start_time > 30:\n                # Timeout: path not found in 30 seconds\n                break\n\n            # Alternate samples between trees to balance growth\n            if i % 2 == 0:\n                forest_a = self._graph_start\n                forest_b = self._graph_goal\n            else:\n                forest_a = self._graph_goal\n                forest_b = self._graph_start\n\n            q_sample: Point = self._get_random_sample()\n            q_nearest: Vertex = self._get_nearest_vertex_from(forest_a, q_sample)\n            if q_nearest.position == q_sample:\n                continue\n            q_new: Vertex = self._get_new_vertex(q_nearest, q_sample, max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_nearest.position, q_new.position)):\n                continue\n\n            card_v = torch.tensor(float(forest_a.size))\n            log_card_v = torch.log(card_v)\n            radius = min(lambda_rrt_star * ((log_card_v / card_v) ** (1 / dimension)), max_radius)\n            Q_near: List[Vertex] = self._get_vertices_within_radius_from(forest_a, q_new, radius)\n\n            # Choose parent with minimum cost + collision free\n            q_min = q_nearest\n            c_min = q_nearest.cost + torch.norm(q_nearest.position.to_tensor() - q_new.position.to_tensor())\n            for q_near in Q_near:\n                near_new_collision_free = self._get_grid().is_valid_line_sequence(\n                    self._get_grid().get_line_sequence(q_near.position, q_new.position))\n                cost_near_to_new = q_near.cost + torch.norm(q_near.position.to_tensor() - q_new.position.to_tensor())\n                if near_new_collision_free and cost_near_to_new < c_min:\n                    q_min = q_near\n                    c_min = cost_near_to_new\n\n            child_parent_dist = torch.norm(q_min.position.to_tensor() - q_new.position.to_tensor())\n            q_new.cost = q_min.cost + child_parent_dist\n            forest_a.add_edge(q_min, q_new)\n\n            self._rewire(forest_a, q_new, Q_near)\n\n            # Try to connect the two trees\n            connected, q_tree_a_connect, q_tree_b_connect = self._try_connect_trees(q_new, forest_b, radius)\n\n            if connected:\n                # Build and extract path from start to goal via q_tree_a_connect and q_tree_b_connect\n                if forest_a == self._graph_start:\n                    self._extract_bidirectional_path(q_tree_a_connect, q_tree_b_connect)\n                else:\n                    self._extract_bidirectional_path(q_tree_b_connect, q_tree_a_connect)\n                break\n\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
{
     "algorithm": "\"\"\"\n    This implementation is an improved RRT-inspired algorithm named PathPlanning.\n    It incorporates goal-bias sampling and a rewiring step inspired by RRT* to improve path quality and speed up convergence.\n    The algorithm balances exploration and exploitation by sampling the goal with a fixed probability and attempts to rewire nearby vertices to reduce path costs.\n    The search stops either when a path is found to the goal or when 30 seconds have elapsed.\n    \"\"\"",
     "code": "class PathPlanning(SampleBasedAlgorithm):\n    _graph: Forest\n\n    def __init__(self, services: Services, testing: BasicTesting = None) -> None:\n        super().__init__(services, testing)\n        self._graph = gen_forest(self._services, Vertex(self._get_grid().agent.position), Vertex(self._get_grid().goal.position), [])\n        self._graph.edges_removable = True  # enable rewiring (remove edges)\n        self._init_displays()\n        # Parameters for algorithm tuning\n        self.max_dist: float = 10.0\n        self.iterations: int = 10000\n        self.goal_sample_rate: float = 0.1  # 10% of samples are the goal (goal bias)\n        self.rewire_radius: float = 15.0  # radius for rewiring nearby vertices\n\n    def _get_new_vertex(self, q_near: Vertex, q_sample: Point, max_dist) -> Vertex:\n        # Reuse from RRT: Create new vertex in direction from q_near to q_sample with max_dist step limit\n        direction = q_sample.to_tensor() - q_near.position.to_tensor()\n        dist = torch.norm(direction)\n        if dist <= max_dist:\n            return Vertex(q_sample)\n\n        direction_norm = direction / dist\n        new_pos = Point.from_tensor(q_near.position.to_tensor() + max_dist * direction_norm)\n        return Vertex(new_pos)\n\n    def _get_random_sample(self) -> Point:\n        # With probability self.goal_sample_rate, return goal position (goal bias)\n        if np.random.rand() < self.goal_sample_rate:\n            return self._get_grid().goal.position\n        # Otherwise random sample in valid position\n        while True:\n            rand_pos = np.random.randint(0, self._get_grid().size, self._get_grid().size.n_dim)\n            sample = Point(*rand_pos)\n            if self._get_grid().is_agent_valid_pos(sample):\n                return sample\n\n    def _near_vertices(self, q_new: Vertex) -> List[Vertex]:\n        # Find vertices in the graph within a distance rewiring radius to q_new\n        near_vertices: List[Vertex] = []\n        q_new_tensor = q_new.position.to_tensor()\n        for vertex in self._graph.vertices:\n            dist = torch.norm(vertex.position.to_tensor() - q_new_tensor)\n            if dist <= self.rewire_radius:\n                near_vertices.append(vertex)\n        return near_vertices\n\n    def _choose_parent(self, near_vertices: List[Vertex], q_new: Vertex) -> Vertex:\n        # Among near vertices, choose the parent that yields lowest cost path to q_new\n        # Cost is approximated as distance from start (root) vertex to parent + distance parent->q_new\n        min_cost = float('inf')\n        best_parent = None\n        for vertex in near_vertices:\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(vertex.position, q_new.position)):\n                continue\n            cost_to_vertex = self._graph.get_cost_to_root(vertex)\n            edge_cost = torch.norm(vertex.position.to_tensor() - q_new.position.to_tensor()).item()\n            total_cost = cost_to_vertex + edge_cost\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_parent = vertex\n        return best_parent\n\n    def _rewire(self, near_vertices: List[Vertex], q_new: Vertex) -> None:\n        # Attempt to rewire the near vertices if going through q_new reduces cost\n        cost_q_new = self._graph.get_cost_to_root(q_new)\n        for vertex in near_vertices:\n            if vertex == q_new:\n                continue\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_new.position, vertex.position)):\n                continue\n            cost_vertex = self._graph.get_cost_to_root(vertex)\n            edge_cost = torch.norm(q_new.position.to_tensor() - vertex.position.to_tensor()).item()\n            new_cost = cost_q_new + edge_cost\n            if new_cost < cost_vertex:\n                # Rewire vertex: remove edge from old parent and add edge from q_new\n                self._graph.remove_edge(vertex.parents[0], vertex)\n                self._graph.add_edge(q_new, vertex)\n\n    def _extract_path(self, q_new: Vertex) -> None:\n        goal_v: Vertex = Vertex(self._get_grid().goal.position)\n        if not self._graph.has_vertex(goal_v):\n            self._graph.add_vertex(goal_v)\n        self._graph.add_edge(q_new, goal_v)\n        path: List[Vertex] = [goal_v]\n\n        # Traverse parents back to root, forming path\n        while len(path[-1].parents) != 0:\n            path.append(path[-1].parents[0])\n\n        path.pop()  # remove root duplicate\n        path.reverse()\n\n        # Animate agent moving along the final path\n        for p in path:\n            self.move_agent(p.position)\n            self.key_frame(ignore_key_frame_skip=True)\n\n    # Override display info, add graph display\n    def set_display_info(self) -> List[MapDisplay]:\n        return super().set_display_info()\n\n    def _find_path_internal(self) -> None:\n        start_time = time.time()\n        goal_pos = self._get_grid().goal.position\n        root_vertex = self._graph.root_vertex_start\n\n        for i in range(self.iterations):\n            # Check for time limit exceeded\n            elapsed_time = time.time() - start_time\n            if elapsed_time > 30.0:\n                # Time exceeded, no path found\n                return\n\n            q_sample = self._get_random_sample()\n            q_near = self._graph.get_nearest_vertex([root_vertex], q_sample)\n\n            if q_near.position == q_sample:\n                continue\n\n            q_new = self._get_new_vertex(q_near, q_sample, self.max_dist)\n\n            if not self._get_grid().is_valid_line_sequence(self._get_grid().get_line_sequence(q_near.position, q_new.position)):\n                continue\n\n            # Get near vertices for rewiring and parent selection\n            near_vertices = self._near_vertices(q_new)\n            # Choose best parent from near vertices or q_near if none better\n            parent = self._choose_parent(near_vertices, q_new)\n            if parent is None:\n                parent = q_near\n\n            self._graph.add_edge(parent, q_new)\n\n            # Rewire near vertices for potential cost improvement\n            self._rewire(near_vertices, q_new)\n\n            # Check goal proximity\n            if self._get_grid().is_agent_in_goal_radius(agent_pos=q_new.position):\n                self._extract_path(q_new)\n                break\n\n            # Visualize addition\n            self.key_frame() ",
     "objective": null,
     "other_inf": null
}
