{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Adaptive Hybrid Sampling Tree (AHST) integrates the strengths of RRT* and informed sampling with dynamic step sizing and adaptive neighborhood radius. It begins by exploring the space broadly using larger steps and wider rewiring neighborhoods, then progressively refines the search focused around the current best solution. It samples preferentially in ellipsoidal informed subsets once an initial path is found, adjusts step sizes based on local obstacle density, and performs smoothing and lazy collision checking to improve path quality and planning speed. This approach aims to enhance convergence speed, path optimality, robustness, and success rates in complex environments.",
     "planning_mechanism": "AHST",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision checking etc.\n\n    def distance(self, other_pos) -> float:\n        return math.dist(self.position, other_pos)\n\n    def path_to_root(self) -> list:\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_max: float = 3.0, step_size_min: float = 0.5, neighbor_radius_max: float = 7.0, neighbor_radius_min: float = 2.0):\n        self.max_iter = max_iter\n        self.step_size_max = step_size_max\n        self.step_size_min = step_size_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize core data structures\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n        start_node = Node(start_position)\n        nodes.append(start_node)\n\n        c_best = float('inf')  # Best path cost found\n\n        # Parameters for adaptive step size and neighbor radius\n        # These will linearly interpolate between max and min values based on iteration progress\n        def adaptive_parameter(iteration):\n            frac = iteration / self.max_iter\n            step = self.step_size_max - frac * (self.step_size_max - self.step_size_min)\n            radius = self.neighbor_radius_max - frac * (self.neighbor_radius_max - self.neighbor_radius_min)\n            return step, radius\n\n        # Sampling function with adaptation to informed ellipsoid after first solution\n        def sample(iteration):\n            if c_best < float('inf'):\n                return self._sample_in_ellipse(start_position, goal_position, c_best, bounds, dim)\n            else:\n                return self._sample_uniform(bounds)\n\n        # Main loop\n        for i in range(self.max_iter):\n            step_size, neighbor_radius = adaptive_parameter(i)\n            sample_point = sample(i)\n\n            nearest = self._nearest_node(nodes, sample_point)\n            new_pos = self._steer(nearest.position, sample_point, step_size)\n            \n            # Lazy collision checking: check only along edge from nearest to new_pos\n            if self._collision(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = self._find_near(nodes, new_node, neighbor_radius)\n\n            # Select best parent among near nodes (including nearest) minimizing cost and collision free\n            min_cost = nearest.cost + nearest.distance(new_pos)\n            min_parent = nearest\n            for near in near_nodes:\n                if near == nearest:\n                    continue\n                cost = near.cost + near.distance(new_pos)\n                if cost < min_cost:\n                    if not self._collision(near.position, new_pos, obstacles, is_3d):\n                        min_cost = cost\n                        min_parent = near\n\n            new_node.parent = min_parent\n            new_node.cost = min_cost\n            min_parent.children.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewire near nodes through new_node if it improves cost and collision free\n            for near in near_nodes:\n                if near == min_parent:\n                    continue\n                new_cost = new_node.cost + new_node.distance(near.position)\n                if new_cost + 1e-6 < near.cost:  # small epsilon for robustness\n                    if not self._collision(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.children.append(near)\n                        edges.append((new_node, near))\n\n            # Check if new_node can connect to goal more cheaply\n            dist_to_goal = new_node.distance(goal_position)\n            if dist_to_goal <= step_size:\n                if not self._collision(new_node.position, goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        success_state = True\n                        extracted_path = self._extract_and_smooth_path(goal_node, obstacles, is_3d)\n\n            # Optional early termination if path is sufficiently good\n            # e.g. if path cost close to minimum euclidean dist * 1.05 --> break\n            c_min = math.dist(start_position, goal_position)\n            if success_state and c_best <= 1.05 * c_min:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_uniform(self, bounds):\n        return tuple(random.uniform(0, b) for b in bounds)\n\n    def _sample_in_ellipse(self, start, goal, c_best, bounds, dim):\n        c_min = math.dist(start, goal)\n        if c_min == 0 or c_best == float('inf'):\n            return self._sample_uniform(bounds)\n\n        # Center of ellipse\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        # Rotation matrix aligning x-axis with start-goal vector\n        direction = tuple(g - s for s, g in zip(start, goal))\n        length = math.dist(start, goal)\n        if length == 0:\n            return self._sample_uniform(bounds)\n\n        # Normalize direction\n        unit_dir = tuple(d / length for d in direction)\n\n        # Define ellipsoid axes lengths\n        a = c_best / 2  # major axis half-length\n        if dim == 2:\n            b = math.sqrt(max(a**2 - (c_min / 2)**2, 0.0))  # minor axis half-length\n            while True:\n                # Sample in unit circle\n                x, y = random.uniform(-1, 1), random.uniform(-1, 1)\n                if x**2 + y**2 <= 1:\n                    break\n            # Transform sample to ellipse frame\n            sample_ellipse = (a * x, b * y)\n            # Rotate sample_ellipse to world frame\n            cos_theta, sin_theta = unit_dir[0], unit_dir[1]\n            sample_rotated = (\n                cos_theta * sample_ellipse[0] - sin_theta * sample_ellipse[1],\n                sin_theta * sample_ellipse[0] + cos_theta * sample_ellipse[1]\n            )\n            sample_point = (center[0] + sample_rotated[0], center[1] + sample_rotated[1])\n            return self._clip_to_bounds(sample_point, bounds)\n\n        else:  # 3D case\n            # Major axis half-length (a)\n            # Two equal minor axes (b)\n            c_min_3d = c_min\n            a = c_best / 2\n            b = math.sqrt(max(a**2 - (c_min_3d / 2)**2, 0.0))\n            # Sample from unit ball\n            while True:\n                x, y, z = random.uniform(-1, 1), random.uniform(-1, 1), random.uniform(-1, 1)\n                if x**2 + y**2 + z**2 <= 1:\n                    break\n            # Scale sample coordinates\n            sample_unit = (a * x, b * y, b * z)\n\n            # Rotation: align major axis with start-goal vector\n            # Find orthonormal basis for rotation\n            # unit_dir = major axis vector, need two orthogonal vectors for minor axes\n            def orthonormal_basis(v):\n                if abs(v[0]) < abs(v[1]):\n                    inv_len = 1.0 / math.sqrt(v[1]*v[1] + v[2]*v[2])\n                    u1 = (0.0, -v[2]*inv_len, v[1]*inv_len)\n                else:\n                    inv_len = 1.0 / math.sqrt(v[0]*v[0] + v[2]*v[2])\n                    u1 = (-v[2]*inv_len, 0.0, v[0]*inv_len)\n                u2 = (\n                    v[1]*u1[2] - v[2]*u1[1],\n                    v[2]*u1[0] - v[0]*u1[2],\n                    v[0]*u1[1] - v[1]*u1[0]\n                )\n                return u1, u2\n\n            u1, u2 = orthonormal_basis(unit_dir)\n            rotated = (\n                unit_dir[0] * sample_unit[0] + u1[0] * sample_unit[1] + u2[0] * sample_unit[2],\n                unit_dir[1] * sample_unit[0] + u1[1] * sample_unit[1] + u2[1] * sample_unit[2],\n                unit_dir[2] * sample_unit[0] + u1[2] * sample_unit[1] + u2[2] * sample_unit[2]\n            )\n            sample_point = tuple(center[i] + rotated[i] for i in range(3))\n            return self._clip_to_bounds(sample_point, bounds)\n\n    def _clip_to_bounds(self, sample, bounds):\n        return tuple(max(0, min(s, b)) for s, b in zip(sample, bounds))\n\n    def _nearest_node(self, nodes, point):\n        return min(nodes, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos, step_size):\n        vec = tuple(t - f for f, t in zip(from_pos, to_pos))\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(f + ratio * (t - f) for f, t in zip(from_pos, to_pos))\n\n    def _collision(self, from_pos, to_pos, obstacles, is_3d, steps_mult=0.5):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(int(dist / steps_mult), 1)\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _find_near(self, nodes, new_node, radius):\n        radius_sq = radius * radius\n        result = []\n        nx, ny = new_node.position[0], new_node.position[1]\n        for node in nodes:\n            dx = node.position[0] - nx\n            dy = node.position[1] - ny\n            dist_sq = dx*dx + dy*dy\n            if dist_sq <= radius_sq:\n                result.append(node)\n        return result\n\n    def _extract_and_smooth_path(self, goal_node, obstacles, is_3d):\n        path = []\n        node = goal_node\n        while node:\n            path.append(node.position)\n            node = node.parent\n        path = path[::-1]\n\n        # Path smoothing via shortcutting\n        if len(path) <= 2:\n            return path\n\n        smoothed_path = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            # Attempt to connect the farthest node without collision\n            for j in range(len(path) - 1, idx, -1):\n                if not self._collision(path[idx], path[j], obstacles, is_3d):\n                    next_idx = j\n                    break\n            smoothed_path.append(path[next_idx])\n            idx = next_idx\n\n        return smoothed_path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid algorithm combines the bidirectional tree growth and fast convergence characteristics of RRT-Connect with the asymptotically optimal rewiring and path quality improvements of RRT*. It grows two trees from start and goal, alternately extending and connecting them like RRT-Connect, but incorporates RRT*\u2019s best-parent selection and rewiring strategies on each extension step to progressively optimize the path cost. By integrating rewiring into bidirectional growth with adaptive sampling and goal bias, this algorithm aims to enhance planning efficiency, success rate, and path quality while maintaining robustness in complex environments.",
     "planning_mechanism": "Initialization of two trees rooted at start and goal; in each iteration, sample a point biased towards the goal or the opposite tree\u2019s newest node; extend the active tree toward this sample by steering within a step size and apply RRT*-style parent choosing and rewiring in the extended tree; then connect or attempt to connect the other tree to the new node greedily; swap active trees each iteration; terminate on connection with path extraction and return the optimized path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        bounds = map.size                   # Tuple[int, ...]\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle specs\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        # Initialize two trees\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n\n        # To keep track of all nodes collectively for rewiring and extraction\n        all_nodes = set(tree_start + tree_goal)  # set for uniqueness\n\n        def steer(from_pos, to_pos):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=10):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def find_near_nodes(tree, point):\n            return [node for node in tree if math.dist(node.position, point) <= self.neighbor_radius]\n\n        def choose_best_parent(new_pos, near_nodes):\n            best_node = None\n            best_cost = float('inf')\n            for node in near_nodes:\n                cost = node.cost + math.dist(node.position, new_pos)\n                if cost < best_cost and not is_edge_in_obstacle(node.position, new_pos):\n                    best_node = node\n                    best_cost = cost\n            return best_node, best_cost\n\n        def rewire(tree_nodes, new_node, near_nodes):\n            for neighbor in near_nodes:\n                if neighbor == new_node.parent:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def extract_path(meeting_node_start: Node, meeting_node_goal: Node) -> List[Tuple[float, ...]]:\n            path_from_start = []\n            node = meeting_node_start\n            while node:\n                path_from_start.append(node.position)\n                node = node.parent\n            path_from_goal = []\n            node = meeting_node_goal\n            while node:\n                path_from_goal.append(node.position)\n                node = node.parent\n            return path_from_start[::-1] + path_from_goal\n\n        # Tree switching flag: True means extend tree_start, connect tree_goal\n        extend_start = True\n\n        for iter_num in range(self.max_iter):\n            # Sample point: goal bias + bias towards other tree's latest node for targeted growth\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if extend_start else start_position\n            else:\n                if extend_start and len(tree_goal) > 0:\n                    # Bias towards goal tree's last node\n                    bias_point = tree_goal[-1].position\n                elif not extend_start and len(tree_start) > 0:\n                    bias_point = tree_start[-1].position\n                else:\n                    bias_point = None\n\n                if bias_point is not None:\n                    rnd = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n                    # Mix uniformly random and bias_point for adaptive sampling\n                    alpha = 0.7\n                    sample = tuple(alpha * b + (1-alpha) * r for b, r in zip(bias_point, rnd))\n                else:\n                    sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Select trees to extend/connect\n            if extend_start:\n                tree_explore = tree_start\n                tree_connect = tree_goal\n            else:\n                tree_explore = tree_goal\n                tree_connect = tree_start\n\n            # --- Extend tree_explore toward sample with RRT* style integration ---\n\n            nearest = find_nearest(tree_explore, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos):\n                # Can't extend here, swap and continue next iteration\n                extend_start = not extend_start\n                continue\n\n            near_nodes = find_near_nodes(tree_explore, new_pos)\n            # Choose best parent among near nodes (including nearest)\n            best_parent, best_cost = choose_best_parent(new_pos, near_nodes if near_nodes else [nearest])\n            if best_parent is None:\n                # fallback parent\n                best_parent = nearest\n                best_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                if is_edge_in_obstacle(best_parent.position, new_pos):\n                    extend_start = not extend_start\n                    continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=best_cost)\n            best_parent.children.append(new_node)\n            tree_explore.append(new_node)\n            all_nodes.add(new_node)\n\n            # Rewire neighbors to new node if beneficial\n            rewire(tree_explore, new_node, near_nodes)\n\n            # --- Attempt to connect tree_connect greedily to new_node ---\n\n            # Find nearest node in tree_connect to new_node\n            nearest_connect = find_nearest(tree_connect, new_pos)\n\n            # Repeatedly try to extend tree_connect toward new_node\n            def connect(tree, target_node):\n                last_node = find_nearest(tree, target_node.position)\n                while True:\n                    new_pos_c = steer(last_node.position, target_node.position)\n                    if is_in_obstacle(new_pos_c) or is_edge_in_obstacle(last_node.position, new_pos_c):\n                        return None\n                    new_node_c = Node(new_pos_c, parent=last_node, cost=last_node.cost + math.dist(last_node.position, new_pos_c))\n                    last_node.children.append(new_node_c)\n                    tree.append(new_node_c)\n                    all_nodes.add(new_node_c)\n                    dist_remain = math.dist(new_node_c.position, target_node.position)\n                    if dist_remain <= self.step_size:\n                        return new_node_c\n                    last_node = new_node_c\n\n            connected_node = connect(tree_connect, new_node)\n\n            if connected_node is not None:\n                # Path found by connecting trees\n                # Extract path back to start and goal roots\n                if extend_start:\n                    path = extract_path(new_node, connected_node)\n                else:\n                    path = extract_path(connected_node, new_node)\n\n                # Collect nodes and edges\n                final_nodes = list(all_nodes)\n                final_edges = [(n.parent, n) for n in final_nodes if n.parent]\n                return PlannerResult(True, path, final_nodes, final_edges)\n\n            # Swap trees for next iteration\n            extend_start = not extend_start\n\n        # Failed to find path within max_iter\n        final_nodes = list(all_nodes)\n        final_edges = [(n.parent, n) for n in final_nodes if n.parent]\n        return PlannerResult(False, [], final_nodes, final_edges)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "An improved hybrid path planning algorithm combining the efficiency of bidirectional RRT and the asymptotic optimality of RRT* with goal biasing, rewiring, and path smoothing. The planner grows two trees simultaneously from start and goal, attempts to connect them, and performs local rewiring and post-processing smoothing to achieve better path quality and higher success rates while reducing search time.",
     "planning_mechanism": "Initialization of two trees from start and goal; iterative sampling with goal bias; nearest node selection and steering; collision checking; connecting trees within step size; rewiring nearby nodes for cost improvement; checking for goal proximity; on success, extraction and smoothing of final path; termination after max iterations.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                # Bias sampling towards goal or start alternately\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=12):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(node1, node2):\n            if is_edge_in_obstacle(node1.position, node2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n            # path_goal.reverse()  # Inverse order\n\n            # Avoid duplication at connection point\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        success_state = False\n        extracted_path: list = []\n        edges: list = []\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate tree to extend\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            # Find neighbors for rewiring\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            # Select best parent among neighbors with min cost\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= self.step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node,\n                                    cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n                # Combine nodes for edges and path extraction\n                success_state = True\n                # Extract path: from start root to connect_node in tree_from and from connect_node to goal in tree_to\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes = tree_goal + tree_start\n\n                # Smooth final path\n                path = smooth_path(path)\n\n                edges = [(node.parent, node) for node in nodes if node.parent]\n                extracted_path = path\n                break\n\n        # If fail, just collect nodes and edges\n        if not success_state:\n            nodes = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes if node.parent]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an adaptive, optimized Bi-RRT* planner that dynamically tunes its parameters like step size and neighborhood radius during planning, incorporates goal biasing, and applies partial path smoothing. These enhancements aim to improve planning efficiency, path quality, success rate, and reduce search time. It maintains the rewiring mechanism of Bi-RRT* for asymptotic optimality while adapting exploration granularity and focusing sampling toward the goal to speed convergence. After path finding, it applies smoothing to reduce unnecessary waypoints for smoother navigation.",
     "planning_mechanism": "The planner grows two trees bidirectionally from start and goal, alternately sampling points biased towards the goal and adapting step size and rewiring radius based on progress and iteration count. Nodes near the new node are rewired to reduce cost. When a connection between trees is found within dynamic thresholds, the path is extracted and smoothed. This adaptive strategy balances global exploration and local refinement efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other: 'Node') -> float:\n        import math\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step_size: float = 1.5, base_radius: float = 10.0, goal_sample_rate: float = 0.15):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate  # Probability of sampling the goal directly to bias search\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return to_pos\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * v for f, v in zip(from_pos, vec))\n\n        def near_nodes(tree, new_pos, radius):\n            return [n for n in tree if math.dist(n.position, new_pos) <= radius]\n\n        def collision_free_line(p1, p2, discretization=10):\n            \"\"\"Check collision along a line by sampling discretization points.\"\"\"\n            for i in range(1, discretization + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / discretization for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def try_connect(node_new, tree_other, step_size):\n            for n in tree_other:\n                if node_new.distance(n) <= step_size:\n                    if collision_free_line(node_new.position, n.position):\n                        return n\n            return None\n\n        def path_smooth(path, max_iter=50):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_line(path[i], path[j]):\n                    del path[i + 1:j]\n            return path\n\n\n        success = False\n        connection_nodes = None\n\n        for k in range(1, self.max_iter + 1):\n\n            # Dynamic tuning: step size shrinks slightly as iterations progress for local refinement\n            step_size = max(self.base_step_size * (1 - k / self.max_iter * 0.7), 0.3)\n            # Radius shrinks but stays within a reasonable minimum to reduce rewiring overhead later\n            radius = max(self.base_radius * (1 - k / self.max_iter * 0.8), 2.5)\n\n            # Goal biased sampling to accelerate convergence\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # Alternate between trees (expand start then goal)\n            for tree_a, tree_b in [(tree_start, tree_goal), (tree_goal, tree_start)]:\n                # Find nearest node in tree_a\n                nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n                new_pos = steer(nearest.position, sample, step_size)\n                if in_obstacle(new_pos):\n                    continue\n                if not collision_free_line(nearest.position, new_pos):\n                    continue\n\n                new_node = Node(new_pos)\n                # Determine best parent among neighbors for lowest cost\n                near = near_nodes(tree_a, new_pos, radius)\n                best_parent = nearest\n                best_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                for n in near:\n                    if collision_free_line(n.position, new_pos):\n                        cost = n.cost + math.dist(n.position, new_pos)\n                        if cost < best_cost:\n                            best_cost = cost\n                            best_parent = n\n                new_node.parent = best_parent\n                new_node.cost = best_cost\n                best_parent.children.append(new_node)\n                tree_a.append(new_node)\n\n                # Rewire near nodes to new node if it improves cost\n                for n in near:\n                    if n is best_parent:\n                        continue\n                    if collision_free_line(new_node.position, n.position):\n                        new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                        if new_cost < n.cost:\n                            if n.parent:\n                                n.parent.children.remove(n)\n                            n.parent = new_node\n                            n.cost = new_cost\n                            new_node.children.append(n)\n\n                # Attempt to connect to other tree\n                connect_node = try_connect(new_node, tree_b, step_size)\n                if connect_node:\n                    success = True\n                    connection_nodes = (new_node, connect_node)\n                    break\n\n            if success:\n                break\n\n        nodes = tree_start + tree_goal\n        edges = [(n.parent, n) for n in nodes if n.parent]\n\n        if success and connection_nodes:\n            path_start = extract_path(connection_nodes[0])\n            path_goal = extract_path(connection_nodes[1])\n            extracted_path = path_start[:-1] + path_goal[::-1]\n            extracted_path = path_smooth(extracted_path, max_iter=75)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "A hybrid planner combining the strengths of informed sampling and bidirectional search. It grows two trees simultaneously from start and goal, incorporating informed sampling around the best current solution to focus exploration and quicken convergence toward the shortest path. By dynamically narrowing the sampling domain based on the best cost found, it efficiently balances exploration and exploitation, improving planning efficiency, success rate, and path quality.",
     "planning_mechanism": "A bidirectional RRT* variant that alternates extending start and goal trees. Sampling is uniform initially, then restricted within an informed ellipsoid once a solution is found. Each extension performs rewiring locally for path optimization. Upon connecting trees, it extracts and smooths the final path for improved path length and smoothness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other_pos):\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_cost = float('inf')\n        best_meeting_nodes = None\n\n        for i in range(self.max_iter):\n            if best_cost < float('inf'):\n                sample = self._sample_in_ellipse(start_pos, goal_pos, best_cost, bounds)\n            else:\n                sample = self._sample_uniform(bounds)\n\n            current_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = self._nearest_node(current_tree, sample)\n            new_pos = self._steer(nearest.position, sample)\n\n            if self._collision(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=nearest.cost + math.dist(nearest.position, new_pos))\n            nearest.children.append(new_node)\n            current_tree.append(new_node)\n\n            near_nodes = self._find_near(current_tree, new_node)\n            min_cost = new_node.cost\n            min_parent = new_node.parent\n            # Rewire current tree locally for path improvement\n            for near in near_nodes:\n                if near == new_node.parent:\n                    continue\n                if not self._collision(near.position, new_node.position, obstacles, is_3d):\n                    cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                    if cost_through_new < near.cost:\n                        # Rewire near node to new_node\n                        if near.parent:\n                            near.parent.children.remove(near)\n                        near.parent = new_node\n                        near.cost = cost_through_new\n                        new_node.children.append(near)\n\n                # Also consider if connecting from near to new_node improves new_node cost\n                if not self._collision(new_node.position, near.position, obstacles, is_3d):\n                    cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                    if cost_through_near < min_cost:\n                        min_cost = cost_through_near\n                        min_parent = near\n            if min_parent != new_node.parent:\n                # Change parent of new_node for better cost\n                new_node.parent.children.remove(new_node)\n                new_node.parent = min_parent\n                new_node.cost = min_cost\n                min_parent.children.append(new_node)\n\n            # Try connect to other tree\n            nearest_other = self._nearest_node(other_tree, new_node.position)\n            if not self._collision(new_node.position, nearest_other.position, obstacles, is_3d) and \\\n               math.dist(new_node.position, nearest_other.position) <= self.step_size:\n\n                meeting_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n                if meeting_cost < best_cost:\n                    best_cost = meeting_cost\n                    best_meeting_nodes = (new_node, nearest_other)\n\n        if best_meeting_nodes is None:\n            # No path found\n            all_nodes = tree_start + tree_goal\n            edges = [(node.parent, node) for node in all_nodes if node.parent]\n            return PlannerResult(False, [], all_nodes, edges)\n\n        # Extract path from start to meeting node\n        path_start = self._extract_path(best_meeting_nodes[0])\n        # Extract path from goal to meeting node (reverse)\n        path_goal = self._extract_path(best_meeting_nodes[1])[::-1]\n        # Merge paths\n        full_path = path_start + path_goal[1:]\n\n        # Optional: path smoothing\n        smoothed_path = self._smooth_path(full_path, obstacles, is_3d)\n\n        all_nodes = tree_start + tree_goal\n        edges = [(node.parent, node) for node in all_nodes if node.parent]\n        return PlannerResult(True, smoothed_path, all_nodes, edges)\n\n    def _sample_uniform(self, bounds):\n        return tuple(random.uniform(0, b) for b in bounds)\n\n    def _sample_in_ellipse(self, start, goal, c_best, bounds):\n        c_min = math.dist(start, goal)\n        if c_min == 0 or c_best == float('inf'):\n            return self._sample_uniform(bounds)\n\n        center = tuple((s + g) / 2 for s, g in zip(start, goal))\n        dir_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n        a = c_best / 2\n        b = math.sqrt(max(a**2 - (c_min / 2)**2, 0))\n\n        # Generate point in unit circle\n        while True:\n            x = random.uniform(-1, 1)\n            y = random.uniform(-1, 1)\n            if x*x + y*y <=1:\n                break\n\n        # 2D ellipse param: rotate sample to align with start-goal direction\n        sample_local = (a * x, b * y)\n\n        # Rotation matrix for 2D dir_vec (cos, sin)\n        cos_theta = dir_vec[0]\n        sin_theta = dir_vec[1]\n\n        sample = (\n            center[0] + sample_local[0]*cos_theta - sample_local[1]*sin_theta,\n            center[1] + sample_local[0]*sin_theta + sample_local[1]*cos_theta\n        )\n\n        # Clip sample to bounds\n        sample = tuple(max(0, min(s, b)) for s, b in zip(sample, bounds))\n        return sample\n\n    def _nearest_node(self, tree, point):\n        return min(tree, key=lambda n: math.dist(n.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        scale = self.step_size / dist\n        return tuple(f + scale * (t - f) for f, t in zip(from_pos, to_pos))\n\n    def _collision(self, from_pos, to_pos, obstacles, is_3d):\n        steps = max(1, int(math.dist(from_pos, to_pos) / 0.5))\n        for i in range(steps + 1):\n            interp = tuple(f + (t - f) * i / steps for f, t in zip(from_pos, to_pos))\n            if self._in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                if x <= pos[0] <= x + w and y <= pos[1] <= y + h and z <= pos[2] <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                if x <= pos[0] <= x + w and y <= pos[1] <= y + h:\n                    return True\n        return False\n\n    def _find_near(self, tree, node):\n        return [n for n in tree if n.distance(node.position) <= self.neighbor_radius]\n\n    def _extract_path(self, node):\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        if len(path) < 3:\n            return path\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._collision(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "An Efficient Guided Batch Informed Sampling Planner (EGBISP) combining batch processing, informed sampling, and dynamic adaptive parameters. It grows a single tree by sampling in batches biased towards informed subsets after initial solutions, uses dynamic step size and neighbor radius adapted per batch based on improvement, applies lazy collision checking with early pruning, and performs inter-batch local rewiring and path smoothing. This planner aims to improve convergence speed, path quality, and robustness, while reducing computation time by leveraging batch expansions and focused sampling.",
     "planning_mechanism": "EGBISP",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision checking etc.\n\n    def distance(self, other_pos) -> float:\n        return math.dist(self.position, other_pos)\n\n    def path_to_root(self) -> list:\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, batch_size: int = 20, step_size_max: float = 3.0, step_size_min: float = 0.5,\n                 neighbor_radius_max: float = 7.0, neighbor_radius_min: float = 2.0, smoothing_interval: int = 10):\n        self.max_iter = max_iter\n        self.batch_size = batch_size\n        self.step_size_max = step_size_max\n        self.step_size_min = step_size_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n        self.smoothing_interval = smoothing_interval\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_node = Node(start_position)\n        nodes.append(start_node)\n\n        c_best = float('inf')      # Best path cost found\n        last_improvement_iter = 0  # Iteration of last c_best improvement\n\n        def adaptive_params(iteration):\n            # Adapt parameters based on progress since last improvement\n            progress = (iteration - last_improvement_iter) / max(1, self.max_iter)\n            step = max(self.step_size_min, self.step_size_max * (1 - progress))\n            radius = max(self.neighbor_radius_min, self.neighbor_radius_max * (1 - progress))\n            return step, radius\n\n        def sample_uniform():\n            return tuple(random.uniform(0, b) for b in bounds)\n\n        def sample_informed():\n            c_min = math.dist(start_position, goal_position)\n            if c_min == 0 or c_best == float('inf'):\n                return sample_uniform()\n\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            direction = tuple(g - s for s, g in zip(start_position, goal_position))\n            length = math.dist(start_position, goal_position)\n            if length == 0:\n                return sample_uniform()\n\n            unit_dir = tuple(d / length for d in direction)\n            a = c_best / 2\n            if dim == 2:\n                b = math.sqrt(max(a*a - (c_min*c_min)/4, 0.0))\n                while True:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        break\n                sample_ellipse = (a * x, b * y)\n                cos_theta, sin_theta = unit_dir[0], unit_dir[1]\n                sample_rotated = (cos_theta * sample_ellipse[0] - sin_theta * sample_ellipse[1],\n                                  sin_theta * sample_ellipse[0] + cos_theta * sample_ellipse[1])\n                sample_point = tuple(center[i] + sample_rotated[i] for i in range(2))\n                return self._clip_to_bounds(sample_point, bounds)\n            else:\n                b = math.sqrt(max(a*a - (c_min*c_min)/4, 0.0))\n                while True:\n                    x, y, z = random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y + z*z <= 1:\n                        break\n                sample_unit = (a * x, b * y, b * z)\n\n                def orthonormal_basis(v):\n                    if abs(v[0]) < abs(v[1]):\n                        inv_len = 1.0 / math.sqrt(v[1]*v[1] + v[2]*v[2]) if (v[1]*v[1] + v[2]*v[2])>0 else 1\n                        u1 = (0.0, -v[2]*inv_len, v[1]*inv_len)\n                    else:\n                        inv_len = 1.0 / math.sqrt(v[0]*v[0] + v[2]*v[2]) if (v[0]*v[0] + v[2]*v[2])>0 else 1\n                        u1 = (-v[2]*inv_len, 0.0, v[0]*inv_len)\n                    u2 = (\n                        v[1]*u1[2] - v[2]*u1[1],\n                        v[2]*u1[0] - v[0]*u1[2],\n                        v[0]*u1[1] - v[1]*u1[0]\n                    )\n                    return u1, u2\n\n                u1, u2 = orthonormal_basis(unit_dir)\n                rotated = (\n                    unit_dir[0]*sample_unit[0] + u1[0]*sample_unit[1] + u2[0]*sample_unit[2],\n                    unit_dir[1]*sample_unit[0] + u1[1]*sample_unit[1] + u2[1]*sample_unit[2],\n                    unit_dir[2]*sample_unit[0] + u1[2]*sample_unit[1] + u2[2]*sample_unit[2]\n                )\n                sample_point = tuple(center[i] + rotated[i] for i in range(3))\n                return self._clip_to_bounds(sample_point, bounds)\n\n        def sample_point(iteration):\n            # After first solution, sample inside ellipsoid with 85% probability, else uniform\n            if c_best < float('inf'):\n                if random.random() < 0.85:\n                    return sample_informed()\n            return sample_uniform()\n\n        def _clip_to_bounds(sample, bounds):\n            return tuple(max(0, min(s, b)) for s,b in zip(sample,bounds))\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step):\n            vec = tuple(t - f for f, t in zip(from_pos, to_pos))\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(f + ratio * (t - f) for f, t in zip(from_pos, to_pos))\n\n        def collision_check(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(int(dist / 0.5), 1)\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                for obs in obstacles:\n                    if is_3d:\n                        x, y, z, w, h, d = obs\n                        px, py, pz = interp\n                        if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                            return True\n                    else:\n                        x, y, w, h = obs\n                        px, py = interp\n                        if x <= px <= x + w and y <= py <= y + h:\n                            return True\n            return False\n\n        def find_near(nodes_list, new_node_pos, radius):\n            radius_sq = radius * radius\n            result = []\n            if dim == 2:\n                nx, ny = new_node_pos[0], new_node_pos[1]\n                for n in nodes_list:\n                    dx = n.position[0] - nx\n                    dy = n.position[1] - ny\n                    if dx*dx + dy*dy <= radius_sq:\n                        result.append(n)\n            else:\n                nx, ny, nz = new_node_pos\n                for n in nodes_list:\n                    dx = n.position[0] - nx\n                    dy = n.position[1] - ny\n                    dz = n.position[2] - nz\n                    if dx*dx + dy*dy + dz*dz <= radius_sq:\n                        result.append(n)\n            return result\n\n        def local_rewire(new_nodes, neighbor_radius):\n            # Rewire nodes inside the current batch for cost improvement\n            for node in new_nodes:\n                neighbors = find_near(new_nodes + nodes, node.position, neighbor_radius)\n                for neighbor in neighbors:\n                    if neighbor == node or neighbor.parent == node:\n                        continue\n                    cost_to_neighbor = node.cost + node.distance(neighbor.position)\n                    if cost_to_neighbor + 1e-9 < neighbor.cost and not collision_check(node.position, neighbor.position):\n                        if neighbor.parent:\n                            neighbor.parent.children.remove(neighbor)\n                        neighbor.parent = node\n                        neighbor.cost = cost_to_neighbor\n                        node.children.append(neighbor)\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            smoothed_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not collision_check(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed_path.append(path[j])\n                i = j\n            return smoothed_path\n\n        iteration = 0\n        while iteration < self.max_iter:\n            step_size, neighbor_radius = adaptive_params(iteration)\n\n            batch_samples = [sample_point(iteration) for _ in range(self.batch_size)]\n            batch_new_nodes = []\n\n            for sample_pt in batch_samples:\n                nearest = nearest_node(nodes, sample_pt)\n                new_pos = steer(nearest.position, sample_pt, step_size)\n                if collision_check(nearest.position, new_pos):\n                    continue\n\n                # Select best parent from near nodes (including nearest)\n                near_nodes = find_near(nodes, new_pos, neighbor_radius)\n                min_cost = nearest.cost + nearest.distance(new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    cost = near.cost + near.distance(new_pos)\n                    if cost + 1e-9 < min_cost and not collision_check(near.position, new_pos):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.children.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                batch_new_nodes.append(new_node)\n\n                # If close enough to goal and can connect with no collision\n                dist_to_goal = new_node.distance(goal_position)\n                if dist_to_goal <= step_size and not collision_check(new_node.position, goal_position):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_to_root()\n                        last_improvement_iter = iteration\n\n            # Local rewiring within expanded batch + existing nodes\n            if batch_new_nodes:\n                local_rewire(batch_new_nodes, neighbor_radius)\n\n            # Periodically smooth path if found\n            if success_state and iteration % self.smoothing_interval == 0 and extracted_path:\n                extracted_path = shortcut_smooth(extracted_path)\n\n                # Early termination: path cost close to minimum possible\n                c_min = math.dist(start_position, goal_position)\n                if c_best <= 1.03 * c_min:\n                    break\n\n            iteration += 1\n\n        if success_state and not extracted_path:\n            # Fallback: extract best path from goal node if available\n            goal_nodes = [n for n in nodes if n.position == goal_position]\n            if goal_nodes:\n                best_goal_node = min(goal_nodes, key=lambda n: n.cost)\n                extracted_path = best_goal_node.path_to_root()\n                extracted_path = shortcut_smooth(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid path planner combining the bidirectional growth and greedy connection strategy of RRT-Connect with the rewiring, cost optimization, and goal-biased sampling of RRT*. This planner grows two trees alternately while performing incremental connection attempts and rewiring to improve path quality dynamically. It integrates goal biasing for efficient exploration, rewiring for cost optimization, and a smoothing post-process to produce high-quality, smooth paths with better success rates and reduced search times.",
     "planning_mechanism": "The planner initializes two trees from start and goal, samples points with goal bias alternately, extends one tree greedily towards the sample while rewiring nearby nodes to minimize cost, then tries to connect the opposite tree greedily to the new node. Trees are swapped each iteration to balance exploration. Upon connection, the path is extracted and smoothed before returning the final result.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            if random.random() < self.goal_sample_rate:\n                # Alternate goal bias: bias toward goal when expanding start tree, toward start when expanding goal tree\n                return goal_position if expanding_start else start_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=12):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def smooth_path(path):\n            if len(path) <= 2:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not is_edge_in_obstacle(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def extend(tree, target_pos):\n            nearest = nearest_node(tree, target_pos)\n            new_pos = steer(nearest.position, target_pos)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                return None\n            new_node = Node(new_pos)\n\n            neighbors = find_neighbors(tree, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n\n            rewire(tree, new_node, neighbors)\n\n            return new_node\n\n        def connect(tree, target_node):\n            current_node = None\n            while True:\n                new_node = extend(tree, target_node.position)\n                if not new_node:\n                    return None\n                current_node = new_node\n                if current_node.distance(target_node) <= self.step_size:\n                    return current_node\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        for iter_count in range(self.max_iter):\n            expanding_start = (iter_count % 2 == 0)\n            tree_from = tree_start if expanding_start else tree_goal\n            tree_to = tree_goal if expanding_start else tree_start\n\n            sample = sample_point()\n\n            new_node = extend(tree_from, sample)\n            if not new_node:\n                continue\n\n            connect_node = connect(tree_to, new_node)\n            if connect_node:\n                success_state = True\n                if expanding_start:\n                    path = extract_path(new_node, connect_node)\n                    nodes = tree_start + tree_goal\n                else:\n                    path = extract_path(connect_node, new_node)\n                    nodes = tree_goal + tree_start\n\n                path = smooth_path(path)\n                edges = [(node.parent, node) for node in nodes if node.parent]\n                extracted_path = path\n                break\n\n        if not success_state:\n            nodes = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes if node.parent]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm implements an optimized bidirectional RRT* (Rapidly-exploring Random Tree Star) planner. It grows two trees\u2014from start and goal simultaneously\u2014and rewires nodes to continuously improve path quality and reduce path cost. The bidirectional growth improves success rate and efficiency, while rewiring improves path smoothness and shortens path length. (The planner initializes two trees rooted at start and goal points. At each iteration, it samples a random point and extends the start tree toward it using RRT* logic (steering, collision checking, nearest neighbor, neighbor radius rewiring for lower cost). Then it attempts to connect the goal tree to the newly added start tree node with repeated greedy extensions. Trees are alternated each iteration. When trees connect, the best combined path is extracted and returned. If the maximum iterations are reached without connection, the planner returns failure with explored trees.)",
     "planning_mechanism": "Rapidly-exploring Random Tree Star",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node from start root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def set_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.children.remove(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 1.0, neighbor_radius: float = 5.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n\n        def nearest(tree: List[Node], point: Tuple[float, ...]) -> Node:\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near(tree: List[Node], point: Tuple[float, ...], radius: float) -> List[Node]:\n            return [n for n in tree if math.dist(n.position, point) <= radius]\n\n        def steer(from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            scale = step / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def collision_free(p1: Tuple[float, ...], p2: Tuple[float, ...]) -> bool:\n            # Check the line segment between p1 and p2 for collision at fine resolution\n            n_checks = max(int(math.dist(p1, p2) / (self.step_size / 2)), 1)\n            for i in range(n_checks + 1):\n                pos = tuple(p1[j] + (p2[j] - p1[j]) * i / n_checks for j in range(dim))\n                if self._is_in_obstacle(pos, obstacles, is_3d):\n                    return False\n            return True\n\n        def rewire(tree: List[Node], new_node: Node):\n            neighbors = near(tree, new_node.position, self.neighbor_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                if collision_free(new_node.position, neighbor.position):\n                    cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                    if cost_through_new < neighbor.cost:\n                        neighbor.set_parent(new_node, cost_through_new)\n                        self._update_children_cost(neighbor)\n\n        def try_extend(tree: List[Node], point: Tuple[float, ...]) -> Node or None:\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if collision_free(nearest_node.position, new_pos):\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                # Initialize cost and parent with best connection (RRT* logic)\n                neighbors = near(tree, new_pos, self.neighbor_radius)\n                min_cost = new_cost\n                min_parent = nearest_node\n                for neighbor in neighbors:\n                    if collision_free(neighbor.position, new_pos):\n                        cost_through_neighbor = neighbor.cost + math.dist(neighbor.position, new_pos)\n                        if cost_through_neighbor < min_cost:\n                            min_cost = cost_through_neighbor\n                            min_parent = neighbor\n                new_node.cost = min_cost\n                new_node.parent = min_parent\n                min_parent.children.append(new_node)\n                tree.append(new_node)\n                # Rewire neighbors if beneficial\n                rewire(tree, new_node)\n                return new_node\n            return None\n\n        def try_connect(tree: List[Node], target_pos: Tuple[float, ...]) -> Node or None:\n            \"\"\"\n            Greedily extend tree towards target_pos until collision or within step_size\n            Returns last extended node or None on failure.\n            \"\"\"\n            current_node = None\n            while True:\n                if len(tree) == 0:\n                    return None\n                nearest_node = nearest(tree, target_pos)\n                new_pos = steer(nearest_node.position, target_pos, self.step_size)\n                if not collision_free(nearest_node.position, new_pos):\n                    return current_node\n                new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                current_node = new_node\n                if math.dist(new_pos, target_pos) <= self.step_size:\n                    return new_node\n\n        def extract_path(meet_node_start: Node, meet_node_goal: Node) -> List[Tuple[float, ...]]:\n            path_start = []\n            node = meet_node_start\n            while node:\n                path_start.append(node.position)\n                node = node.parent\n            path_start.reverse()\n\n            path_goal = []\n            node = meet_node_goal\n            while node:\n                path_goal.append(node.position)\n                node = node.parent\n\n            # To avoid duplicate meet position in middle, omit start of goal path\n            return path_start + path_goal[1:]\n\n        best_path = None\n        best_cost = float('inf')\n        meeting = None\n\n        for i in range(self.max_iter):\n            if random.random() < self.goal_sample_rate:\n                rnd_point = goal_position\n            else:\n                rnd_point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            new_node_start = try_extend(tree_start, rnd_point)\n            if new_node_start is not None:\n                new_node_goal = try_connect(tree_goal, new_node_start.position)\n                if new_node_goal is not None:\n                    total_cost = new_node_start.cost + new_node_goal.cost + math.dist(new_node_start.position, new_node_goal.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        meeting = (new_node_start, new_node_goal)\n                        best_path = extract_path(new_node_start, new_node_goal)\n\n            # Swap trees\n            tree_start, tree_goal = tree_goal, tree_start\n\n        success_state = best_path is not None\n        nodes = tree_start + tree_goal\n        edges = [(n.parent, n) for n in nodes if n.parent]\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _update_children_cost(self, node: Node):\n        # Propagate cost changes recursively to children\n        for child in node.children:\n            old_cost = child.cost\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost < old_cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_cost(child)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This implementation enhances the classic RRT by incorporating goal bias, dynamic step size adjustment, and a simplistic rewiring step inspired by RRT*. The goal bias accelerates convergence by sampling the goal more frequently. The step size adapts based on the proximity to the goal, allowing finer movements near the goal for path quality. Rewiring attempts improve path optimality by connecting new nodes to nearby better parents when collision-free. This combination aims to improve planning efficiency, success rate, and path quality while maintaining robustness and reasonable computation time.",
     "planning_mechanism": "The planner initializes with the start node and repeatedly samples nodes biased toward the goal to grow the tree. It steers toward random or goal-sampled points with dynamic step size, checks collisions, adds nodes, and performs local rewiring for path improvement. Upon reaching near the goal, it extracts the path by backtracking parent nodes.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent: 'Node' = None, cost: float = 0.0):\n        self.position = position          # Tuple[float, ...]: 2D or 3D\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Cost from start\n        self.children: List[Node] = []    # Children nodes\n        self.valid = True                 # For collision or pruning\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_nodes(self) -> List['Node']:\n        # Return nodes from start to self\n        node, path = self, []\n        while node:\n            path.append(node)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, goal_sample_rate: float = 0.1,\n                 min_step_size: float = 0.5, max_step_size: float = 2.0,\n                 neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.goal_sample_rate = goal_sample_rate\n        self.min_step_size = min_step_size\n        self.max_step_size = max_step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> PlannerResult:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        root = Node(start_position)\n        nodes: List[Node] = [root]\n\n        def collision_free(pos1: Tuple[float, ...], pos2: Tuple[float, ...]) -> bool:\n            # Check path collision from pos1 to pos2 with small interpolation steps\n            dist = math.dist(pos1, pos2)\n            steps = max(int(dist / 0.2), 1)\n            for i in range(steps + 1):\n                interp = tuple(\n                    pos1[j] + (pos2[j] - pos1[j]) * i / steps for j in range(dim)\n                )\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def find_near_nodes(new_node: Node) -> List[Node]:\n            r = self.neighbor_radius\n            return [node for node in nodes if node.distance(new_node) <= r]\n\n        def choose_parent(new_node: Node, near_nodes: List[Node]):\n            # Try to find a better parent minimizing cost + collision free\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if collision_free(near_node.position, new_node.position):\n                    cost = near_node.cost + near_node.distance(new_node)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = near_node\n            if best_parent != new_node.parent:\n                # Update parent links\n                if new_node.parent:\n                    try:\n                        new_node.parent.children.remove(new_node)\n                    except ValueError:\n                        pass\n                new_node.parent = best_parent\n                new_node.cost = min_cost\n                best_parent.children.append(new_node)\n\n        def rewire(new_node: Node, near_nodes: List[Node]):\n            for near_node in near_nodes:\n                if near_node == new_node.parent:\n                    continue\n                if collision_free(new_node.position, near_node.position):\n                    new_cost = new_node.cost + new_node.distance(near_node)\n                    if new_cost < near_node.cost:\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            try:\n                                near_node.parent.children.remove(near_node)\n                            except ValueError:\n                                pass\n                        near_node.parent = new_node\n                        near_node.cost = new_cost\n                        new_node.children.append(near_node)\n                        self._update_children_costs(near_node)\n\n        for _ in range(self.max_iter):\n            # 1. Sample point with goal bias\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n            # 2. Nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # 3. Dynamic step size: smaller step near goal for fine path\n            dist_to_goal = math.dist(nearest.position, goal_position)\n            step_size = self.max_step_size if dist_to_goal > self.neighbor_radius else self.min_step_size\n\n            # 4. Steer\n            new_position = self._steer(nearest.position, sample, step_size)\n            if not collision_free(nearest.position, new_position):\n                continue\n\n            new_node = Node(new_position, parent=nearest, cost=nearest.cost + nearest.distance(Node(new_position)))\n            nearest.children.append(new_node)\n            nodes.append(new_node)\n\n            # 5. Find neighbors and choose best parent\n            near_nodes = find_near_nodes(new_node)\n            choose_parent(new_node, near_nodes)\n\n            # 6. Rewire neighbors\n            rewire(new_node, near_nodes)\n\n            # 7. Check goal reached with collision path\n            if math.dist(new_position, goal_position) <= step_size:\n                if collision_free(new_position, goal_position):\n                    goal_node = Node(goal_position, parent=new_node,\n                                     cost=new_node.cost + math.dist(new_position, goal_position))\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    success_state = True\n                    extracted_path = self._extract_path(goal_node)\n                    edges = [(node.parent, node) for node in nodes if node.parent]\n                    return PlannerResult(success_state, extracted_path, nodes, edges)\n\n        # Failure - no path found\n        edges = [(node.parent, node) for node in nodes if node.parent]\n        return PlannerResult(False, [], nodes, edges)\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step_size: float) -> Tuple[float, ...]:\n        vec = [t - f for f, t in zip(from_pos, to_pos)]\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        scale = step_size / dist\n        return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n    def _is_in_obstacle(self, pos: Tuple[float, ...], obstacles: List[Tuple], is_3d: bool) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _extract_path(self, node: Node) -> List[Tuple[float, ...]]:\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def _update_children_costs(self, node: Node) -> None:\n        # Recursively update costs of children nodes after rewiring\n        for child in node.children:\n            old_cost = child.cost\n            child.cost = node.cost + node.distance(child)\n            if child.cost < old_cost:\n                self._update_children_costs(child)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "A streamlined and generalized RRT* planner that balances path quality and computational efficiency by simplifying neighborhood search with a fixed radius, integrating goal biasing, and maintaining essential rewiring for asymptotic optimality. The planner supports both 2D and 3D environments and focuses on clarity and performance improvements by avoiding overcomplexity, ensuring robustness and scalable path smoothing.",
     "planning_mechanism": "The Planner initializes at the start, iteratively samples points with goal bias, extends toward samples with collision checks, selects the best parent among neighbors within a fixed radius, rewires neighbors if a better path is found, and stops once the goal is connected or max iterations are reached. The final path is extracted by backtracking from the goal node.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 3.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        root = Node(start_position)\n        nodes = [root]\n        goal_node = None\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def edge_in_obstacle(p1, p2, steps=8):\n            for i in range(steps + 1):\n                interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(dim))\n                if in_obstacle(interp):\n                    return True\n            return False\n\n        def steer(from_pos, to_pos):\n            vec = [to_pos[i] - from_pos[i] for i in range(dim)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            scale = self.step_size / dist\n            return tuple(from_pos[i] + vec[i] * scale for i in range(dim))\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        for _ in range(self.max_iter):\n            sample = goal_position if random.random() < self.goal_sample_rate else tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n            new_pos = steer(nearest.position, sample)\n\n            if in_obstacle(new_pos):\n                continue\n\n            # Neighborhood nodes within fixed radius\n            neighbors = [n for n in nodes if math.dist(n.position, new_pos) <= self.neighbor_radius and not edge_in_obstacle(n.position, new_pos)]\n\n            # Best parent selection (including nearest if not in neighbors)\n            candidates = neighbors + ([nearest] if nearest not in neighbors else [])\n            best_parent = None\n            min_cost = float('inf')\n            for n in candidates:\n                cost = n.cost + math.dist(n.position, new_pos)\n                if cost < min_cost:\n                    best_parent = n\n                    min_cost = cost\n\n            if best_parent is None:\n                continue\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                if neighbor == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if cost_through_new < neighbor.cost and not edge_in_obstacle(new_node.position, neighbor.position):\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = cost_through_new\n                    new_node.children.append(neighbor)\n\n            # Goal check\n            if math.dist(new_node.position, goal_position) <= self.step_size and not edge_in_obstacle(new_node.position, goal_position):\n                goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + math.dist(new_node.position, goal_position))\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                success_state = True\n                extracted_path = extract_path(goal_node)\n                edges = [(n.parent, n) for n in nodes if n.parent]\n                return PlannerResult(True, extracted_path, nodes, edges)\n\n        edges = [(n.parent, n) for n in nodes if n.parent]\n        return PlannerResult(False, [], nodes, edges)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is an Optimized Informed RRT* with Dynamic Sampling and Batch Rewiring. It integrates informed sampling within an ellipsoidal subset biased towards the currently best solution to focus exploration, dynamically adjusts step sizes and rewiring radius during planning, applies batch rewiring periodically to improve path optimality, and incorporates an efficient incremental collision checking strategy. This method enhances planning efficiency, convergence speed, path quality, robustness, and success rate, producing smooth and shorter paths in less computational time.",
     "planning_mechanism": "The planner starts by building a tree rooted at the start node, dynamically biases sampling towards an ellipsoidal informed subset if a path exists, adapts step and neighborhood radius over iterations, and uses batch rewiring every few iterations to locally optimize the tree. It employs incremental collision checking for edges and applies a final smoothing procedure after path extraction.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []             # List[Node]\n        self.valid = True              # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        import math\n        return math.dist(self.position, other.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, max_batch_rewire_iter: int = 100, \n                 base_step_size: float = 1.0, base_radius: float = 5.0, goal_sample_rate: float = 0.10):\n        self.max_iter = max_iter\n        self.max_batch_rewire_iter = max_batch_rewire_iter  # Interval to perform batch rewiring\n        self.base_step_size = base_step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import random\n        import math\n        from collections import deque\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        root = Node(start_position)\n        nodes = [root]\n\n        # Informed sampling parameters (for ellipsoidal sampling once a path is found)\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        x_center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n        def rotation_matrix():\n            # Calculate rotation to align x-axis with start->goal vector\n            dx = [g - s for s, g in zip(start_position, goal_position)]\n            length = math.dist(start_position, goal_position)\n            if length == 0:\n                return None\n            # Normalize direction vector\n            a1 = [d / length for d in dx]\n            # Build orthonormal basis using Gram-Schmidt\n            if dim == 2:\n                # In 2D, rotation matrix aligns x-axis to a1\n                return ((a1[0], -a1[1]),\n                        (a1[1], a1[0]))\n            else:\n                # For 3D, build rotation matrix [a1, a2, a3]\n                # a2, a3 are orthonormal vectors perpendicular to a1\n                import numpy as np\n                a1_vec = np.array(a1)\n                # Find a vector not parallel to a1 for orthonormal basis\n                v = np.array([1.0, 0.0, 0.0]) if abs(a1[0]) < 0.9 else np.array([0.0, 1.0, 0.0])\n                a2 = np.cross(a1_vec, v)\n                a2 = a2 / np.linalg.norm(a2)\n                a3 = np.cross(a1_vec, a2)\n                # Compose rotation matrix, columns are a1, a2, a3\n                return np.column_stack((a1_vec, a2, a3))\n        rotation = rotation_matrix()\n\n        def in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_free_line(p1, p2, discretization=15):\n            \"\"\"Check collision along edge by discretization sampling.\"\"\"\n            for i in range(discretization + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / discretization for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return to_pos\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * v for f, v in zip(from_pos, vec))\n\n        def sample_in_ellipsoid():\n            # If no c_best found, fallback to uniform sample\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n            # Sample in unit n-ball:\n            # Use method from Informed RRT*\n            import numpy as np\n            while True:\n                u = np.random.normal(0, 1, dim)\n                norm_u = np.linalg.norm(u)\n                if norm_u > 1e-10:\n                    break\n            unit_ball = u / norm_u * random.random()**(1.0/dim)\n\n            # Define ellipsoid radii\n            r1 = c_best / 2.0\n            others = math.sqrt(c_best**2 - c_min**2) / 2.0\n            if dim == 2:\n                L = np.array([[r1, 0],\n                              [0, others]])\n                # Rotation matrix\n                C = np.array(rotation)\n                point = np.dot(C, np.dot(L, unit_ball)) + np.array(x_center)\n                # Clamp inside bounds\n                point_clamped = tuple(max(0.0, min(bounds[i], point[i])) for i in range(dim))\n                return point_clamped\n            else:\n                # 3D dilation matrix\n                L = np.diag([r1] + [others]*(dim - 1))\n                C = rotation\n                point = C @ (L @ unit_ball) + np.array(x_center)\n                point_clamped = tuple(max(0.0, min(bounds[i], point[i])) for i in range(dim))\n                return point_clamped\n\n        def near_nodes(new_pos, radius):\n            return [n for n in nodes if math.dist(n.position, new_pos) <= radius]\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def path_smooth(path, max_iter=75):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_line(path[i], path[j]):\n                    del path[i + 1:j]\n            return path\n\n        def batch_rewire():\n            # Batch rewiring to optimize subtree locally\n            for node in nodes:\n                neighbors = [n for n in nodes if math.dist(n.position, node.position) <= curr_radius and n != node]\n                for neighbor in neighbors:\n                    if neighbor == node.parent:\n                        continue\n                    if neighbor.cost + math.dist(neighbor.position, node.position) < node.cost:\n                        if collision_free_line(neighbor.position, node.position):\n                            # Rewire node\n                            if node.parent:\n                                try:\n                                    node.parent.children.remove(node)\n                                except ValueError:\n                                    pass\n                            node.parent = neighbor\n                            node.cost = neighbor.cost + math.dist(neighbor.position, node.position)\n                            neighbor.children.append(node)\n\n        success = False\n        path = []\n\n        for itr in range(1, self.max_iter + 1):\n\n            # Dynamic adjustment of step size / radius (shrinks with iteration to refine paths)\n            curr_step = max(self.base_step_size * (1 - (itr / self.max_iter)**0.9 * 0.8), 0.2)\n            curr_radius = max(self.base_radius * (1 - (itr / self.max_iter)**0.8 * 0.85), 2.0)\n\n            # Sample\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = sample_in_ellipsoid()\n\n            # Nearest node\n            nearest = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards sample\n            new_pos = steer(nearest.position, sample, curr_step)\n            if in_obstacle(new_pos):\n                continue\n            if not collision_free_line(nearest.position, new_pos):\n                continue\n\n            # Create new node\n            new_node = Node(new_pos)\n\n            # Near neighbors for parent selection & rewiring\n            neighbors = near_nodes(new_pos, curr_radius)\n            neighbors.append(nearest)  # Ensure nearest is included for candidate parent\n\n            # Choose best parent minimizing cost\n            min_cost = float('inf')\n            best_parent = None\n            for n in neighbors:\n                if collision_free_line(n.position, new_pos):\n                    cost = n.cost + math.dist(n.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = n\n            if best_parent is None:\n                continue\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            nodes.append(new_node)\n\n            # Rewire neighbors if new_node offers better cost\n            for n in neighbors:\n                if n is best_parent:\n                    continue\n                if collision_free_line(new_node.position, n.position):\n                    new_cost = new_node.cost + math.dist(new_node.position, n.position)\n                    if new_cost < n.cost:\n                        if n.parent:\n                            try:\n                                n.parent.children.remove(n)\n                            except ValueError:\n                                pass\n                        n.parent = new_node\n                        n.cost = new_cost\n                        new_node.children.append(n)\n\n            # Check if goal can be connected from new_node\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= curr_step and collision_free_line(new_node.position, goal_position):\n                goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                new_node.children.append(goal_node)\n                nodes.append(goal_node)\n                path = extract_path(goal_node)\n\n                # Update best cost and parameters for informed sampling\n                if goal_node.cost < c_best:\n                    c_best = goal_node.cost\n\n                success = True\n\n                # Optional: early stopping after first solution to allow smoothing & return\n                # Could be removed to continue improving paths\n                break\n\n            # Batch rewiring every max_batch_rewire_iter iterations to refine cost tree-wide\n            if itr % self.max_batch_rewire_iter == 0:\n                batch_rewire()\n\n        # If found path, smooth it\n        if success and path:\n            path = path_smooth(path)\n\n        edges = [(n.parent, n) for n in nodes if n.parent]\n\n        return PlannerResult(\n            success=success,\n            path=path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid bidirectional RRT* planner combining informed sampling, adaptive parameter tuning, and goal biasing to balance global exploration and local refinement. It grows two trees simultaneously from start and goal, adaptively adjusts step size and neighbor radius, and incorporates sampling in an informed ellipsoid after a feasible path is found. The planner performs local rewiring in both trees to improve path quality iteratively. Upon connecting the trees, it extracts, merges, and applies repeated path smoothing for enhanced smoothness and length reduction, improving efficiency, success rate, and final path quality.",
     "planning_mechanism": "The planner alternates between extending start and goal trees with dynamic step size and radius that shrink over iterations; it samples points uniformly and with goal bias initially, switching to informed ellipse sampling once a path is found. It performs rewiring in both trees locally to optimize paths, and attempts to connect the trees frequently. Final path extraction and multi-iteration smoothing yield a smooth, short trajectory.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step_size: float = 1.2, base_radius: float = 8.0, goal_sample_rate: float = 0.12):\n        self.max_iter = max_iter\n        self.base_step_size = base_step_size\n        self.base_radius = base_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_pos)]\n        tree_goal = [Node(goal_pos)]\n\n        best_cost = float('inf')\n        best_meeting_nodes = None\n\n        def in_obstacle(pos):\n            if is_3d:\n                px, py, pz = pos\n                for obs in obstacles:\n                    x, y, z, w, h, d = obs\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                px, py = pos\n                for obs in obstacles:\n                    x, y, w, h = obs\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def collision_free_line(p1, p2, resolution=0.4):\n            dist = math.dist(p1, p2)\n            steps = max(1, int(dist / resolution))\n            for i in range(steps + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / steps for j in range(dim))\n                if in_obstacle(interp):\n                    return False\n            return True\n\n        def steer(from_pos, to_pos, step_size):\n            dist = math.dist(from_pos, to_pos)\n            if dist == 0:\n                return to_pos\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * (t - f) for f, t in zip(from_pos, to_pos))\n\n        def sample_uniform(bounds):\n            return tuple(random.uniform(0, b) for b in bounds)\n\n        def sample_in_ellipse(start, goal, c_best, bounds):\n            c_min = math.dist(start, goal)\n            if c_min == 0 or c_best == float('inf'):\n                return sample_uniform(bounds)\n\n            center = tuple((s + g) / 2 for s, g in zip(start, goal))\n            dir_vec = tuple((g - s) / c_min for s, g in zip(start, goal))\n            a = c_best / 2\n            b_val = math.sqrt(max(a ** 2 - (c_min / 2) ** 2, 0))\n\n            # Sampling in unit circle (2D)\n            while True:\n                x = random.uniform(-1, 1)\n                y = random.uniform(-1, 1)\n                if x * x + y * y <= 1:\n                    break\n\n            # Rotation matrix 2D\n            cos_theta = dir_vec[0]\n            sin_theta = dir_vec[1]\n            sample_local = (a * x, b_val * y)\n            sample = (\n                center[0] + sample_local[0] * cos_theta - sample_local[1] * sin_theta,\n                center[1] + sample_local[0] * sin_theta + sample_local[1] * cos_theta,\n            )\n            # Clip to bounds\n            sample = tuple(max(0, min(s, b)) for s, b in zip(sample, bounds))\n            if dim == 3:\n                # Sample z uniformly if 3D (no ellipse shaping in z)\n                sample = sample + (random.uniform(0, bounds[2]),)\n            return sample\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def find_near(tree, new_node, radius):\n            r_sq = radius * radius\n            return [n for n in tree if self._dist_sq(n.position, new_node.position) <= r_sq]\n\n        def try_connect(new_node, tree_other, step_size):\n            # Look for connection node in other tree within step_size and collision free line\n            radius_connect = step_size * 1.5  # Slightly larger connect threshold\n            candidates = [n for n in tree_other if math.dist(n.position, new_node.position) <= radius_connect]\n            candidates.sort(key=lambda n: math.dist(n.position, new_node.position))\n            for n in candidates:\n                if collision_free_line(new_node.position, n.position):\n                    return n\n            return None\n\n        def extract_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def smooth_path(path, max_iter=100):\n            if len(path) < 3:\n                return path\n            for _ in range(max_iter):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                if collision_free_line(path[i], path[j]):\n                    del path[i + 1:j]\n            return path\n\n        # Utility distance squared for efficiency\n        self._dist_sq = lambda p1, p2: sum((a - b) ** 2 for a, b in zip(p1, p2))\n\n        # Main planning loop\n        for iter_num in range(1, self.max_iter + 1):\n\n            # Dynamically adapt step size and neighbor radius (shrink over iterations)\n            step_size = max(self.base_step_size * (1 - iter_num / self.max_iter * 0.75), 0.3)\n            neighbor_radius = max(self.base_radius * (1 - iter_num / self.max_iter * 0.85), 3.0)\n\n            # Sample with goal bias or informed sampling if solution found\n            if best_cost < float('inf'):\n                sample = sample_in_ellipse(start_pos, goal_pos, best_cost, bounds)\n            else:\n                if random.random() < self.goal_sample_rate:\n                    sample = goal_pos\n                else:\n                    sample = sample_uniform(bounds)\n\n            # Alternate tree expansion (start first if even, goal first if odd iteration)\n            if iter_num % 2 == 0:\n                order = [(tree_start, tree_goal), (tree_goal, tree_start)]\n            else:\n                order = [(tree_goal, tree_start), (tree_start, tree_goal)]\n\n            connection_made = False\n            for tree_a, tree_b in order:\n\n                nearest = nearest_node(tree_a, sample)\n                new_pos = steer(nearest.position, sample, step_size)\n\n                if in_obstacle(new_pos):\n                    continue\n                if not collision_free_line(nearest.position, new_pos):\n                    continue\n\n                new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n                new_node = Node(new_pos, parent=nearest, cost=new_cost)\n                nearest.children.append(new_node)\n                tree_a.append(new_node)\n\n                # Local rewiring in tree_a\n                near_nodes = find_near(tree_a, new_node, neighbor_radius)\n                # Try to improve new_node parent using neighbors\n                min_cost = new_node.cost\n                min_parent = nearest\n                for near in near_nodes:\n                    if near is nearest:\n                        continue\n                    if collision_free_line(near.position, new_node.position):\n                        cost_through_near = near.cost + math.dist(near.position, new_node.position)\n                        if cost_through_near < min_cost:\n                            min_cost = cost_through_near\n                            min_parent = near\n                if min_parent != nearest:\n                    nearest.children.remove(new_node)\n                    new_node.parent = min_parent\n                    new_node.cost = min_cost\n                    min_parent.children.append(new_node)\n\n                # Rewire near nodes to new_node if better\n                for near in near_nodes:\n                    if near is min_parent:\n                        continue\n                    if collision_free_line(new_node.position, near.position):\n                        cost_via_new = new_node.cost + math.dist(new_node.position, near.position)\n                        if cost_via_new < near.cost:\n                            if near.parent:\n                                near.parent.children.remove(near)\n                            near.parent = new_node\n                            near.cost = cost_via_new\n                            new_node.children.append(near)\n\n                # Attempt to connect the other tree\n                connect_node = try_connect(new_node, tree_b, step_size)\n                if connect_node:\n                    total_cost = new_node.cost + connect_node.cost + math.dist(new_node.position, connect_node.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_meeting_nodes = (new_node, connect_node)\n                    connection_made = True\n                    break\n\n            if connection_made:\n                # Continue searching for better paths\n                if iter_num > self.max_iter * 0.6:\n                    # After 60% iterations, early stop on good path\n                    break\n\n        nodes_all = tree_start + tree_goal\n        edges = [(n.parent, n) for n in nodes_all if n.parent]\n\n        if best_meeting_nodes is None:\n            # No path found\n            return PlannerResult(False, [], nodes_all, edges)\n\n        # Extract and merge paths\n        path_start = extract_path(best_meeting_nodes[0])\n        path_goal = extract_path(best_meeting_nodes[1])[::-1]\n        full_path = path_start + path_goal[1:]\n\n        # Multiple passes of smoothing for improved path quality\n        smoothed_path = full_path\n        for _ in range(3):\n            smoothed_path = smooth_path(smoothed_path, max_iter=75)\n\n        return PlannerResult(True, smoothed_path, nodes_all, edges)",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "A combined and optimized path planner that integrates bidirectional RRT* with goal biasing, adaptive rewiring, dynamic step size adjustment, and enhanced path smoothing using shortcutting. This planner balances exploration and exploitation by growing two trees from start and goal, rewiring to improve path costs, connecting trees efficiently, and applying post-processing smoothing to yield higher quality, smoother, and shorter paths with better success and reduced planning time. (Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.)",
     "planning_mechanism": "Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_init: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            # Alternate goal bias location with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=15):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(n1, n2):\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_smooth(path, iterations=30):\n            # Attempt shortcut smoothing by skipping intermediate points if direct path is obstacle free\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if j >= len(smoothed):\n                    continue\n                if not is_edge_in_obstacle(smoothed[i], smoothed[j]):\n                    # Remove intermediate points between i and j\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        step_size = self.step_size_init\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate extension between the two trees\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample, step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node, cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n\n                success_state = True\n\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes_all = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes_all = tree_goal + tree_start\n\n                # Apply shortcut smoothing for improved path smoothness and length\n                path = shortcut_smooth(path, iterations=50)\n\n                edges = [(node.parent, node) for node in nodes_all if node.parent]\n                extracted_path = path\n                break\n\n            # Optional dynamic step size adaptation (gradually increase up to max)\n            if iter_count % 500 == 0 and iter_count > 0:\n                step_size = min(step_size * 1.1, self.step_size_init * 3)\n\n        if not success_state:\n            nodes_all = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes_all if node.parent]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "An advanced bidirectional RRT* planner with adaptive parameters, informed sampling, and enhanced rewiring for improved efficiency, path quality, and smoothness. It incorporates heuristic goal biasing, dynamic neighbor radius based on iteration progress, collision checking with clipping for safer steering, and cost propagation to refine paths continuously. The planner swaps trees each iteration, attempts better connections, and returns the best found path.",
     "planning_mechanism": "The planner grows two trees rooted at start and goal simultaneously, sampling either randomly or biased towards the goal. It extends trees using RRT* logic with adaptive neighbor radius rewiring to optimize cost-to-come. Repeated greedy connections attempt to join the trees. Nodes keep track of cost and parent relations, with recursive cost updates to ensure path quality. The process iterates until success or max iterations, returning the best path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost to reach this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        from math import dist\n        return dist(self.position, other.position)\n\n    def set_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            try: self.parent.children.remove(self)\n            except ValueError: pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 1.5, goal_sample_rate: float = 0.15, initial_neighbor_radius: float = 10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.initial_neighbor_radius = initial_neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def dist(p1, p2):\n            return math.dist(p1, p2)\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if dist(n.position, point) <= radius]\n\n        def steer(from_pos, to_pos, step):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            scale = step / d\n            return tuple(f + scale * v for f, v in zip(from_pos, vec))\n\n        def collision_free(p1, p2):\n            length = dist(p1, p2)\n            n_checks = max(int(length / (self.step_size * 0.4)), 1)\n            for i in range(n_checks + 1):\n                interp = tuple(p1[j] + (p2[j] - p1[j]) * i / n_checks for j in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return False\n            return True\n\n        def rewire(tree, new_node, radius):\n            neighbors = near(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                if neighbor is new_node.parent:\n                    continue\n                if collision_free(new_node.position, neighbor.position):\n                    cost_through_new = new_node.cost + dist(new_node.position, neighbor.position)\n                    if cost_through_new + 1e-6 < neighbor.cost:\n                        neighbor.set_parent(new_node, cost_through_new)\n                        self._update_children_cost(neighbor)\n\n        def try_extend(tree, point, radius):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, self.step_size)\n            if not collision_free(nearest_node.position, new_pos):\n                return None\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            neighbors = near(tree, new_pos, radius)\n            min_cost = new_cost\n            min_parent = nearest_node\n            for neighbor in neighbors:\n                if collision_free(neighbor.position, new_pos):\n                    cost_through_neighbor = neighbor.cost + dist(neighbor.position, new_pos)\n                    if cost_through_neighbor < min_cost:\n                        min_cost = cost_through_neighbor\n                        min_parent = neighbor\n            new_node.cost = min_cost\n            new_node.parent = min_parent\n            min_parent.children.append(new_node)\n            tree.append(new_node)\n            rewire(tree, new_node, radius)\n            return new_node\n\n        def try_connect(tree, target_pos):\n            current_best = None\n            for _ in range(50):  # Limit attempts to avoid long loops\n                nearest_node = nearest(tree, target_pos)\n                new_pos = steer(nearest_node.position, target_pos, self.step_size)\n                if not collision_free(nearest_node.position, new_pos):\n                    break\n                new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n                new_node = Node(new_pos)\n                new_node.parent = nearest_node\n                new_node.cost = new_cost\n                nearest_node.children.append(new_node)\n                tree.append(new_node)\n                current_best = new_node\n                if dist(new_pos, target_pos) <= self.step_size * 0.5:\n                    return new_node\n            return current_best\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            n = node_start\n            while n:\n                path_start.append(n.position)\n                n = n.parent\n            path_start.reverse()\n\n            path_goal = []\n            n = node_goal\n            while n:\n                path_goal.append(n.position)\n                n = n.parent\n\n            return path_start + path_goal[1:]\n\n        best_path = None\n        best_cost = math.inf\n        meeting_nodes = None\n\n        for i in range(self.max_iter):\n            neighbor_radius = max(self.initial_neighbor_radius * (1 - i / self.max_iter), self.step_size * 2)\n            if random.random() < self.goal_sample_rate:\n                rnd_point = goal_position\n            else:\n                rnd_point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            new_node_start = try_extend(tree_start, rnd_point, neighbor_radius)\n            if new_node_start is not None:\n                new_node_goal = try_connect(tree_goal, new_node_start.position)\n                if new_node_goal is not None:\n                    total_cost = new_node_start.cost + new_node_goal.cost + dist(new_node_start.position, new_node_goal.position)\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        meeting_nodes = (new_node_start, new_node_goal)\n                        best_path = extract_path(new_node_start, new_node_goal)\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        success_state = best_path is not None\n        all_nodes = tree_start + tree_goal\n        all_edges = [(n.parent, n) for n in all_nodes if n.parent]\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=all_edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        if is_3d:\n            px, py, pz = pos\n            for x, y, z, w, h, d in obstacles:\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n        else:\n            px, py = pos\n            for x, y, w, h in obstacles:\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _update_children_cost(self, node: Node):\n        import math\n        for child in node.children:\n            new_cost = node.cost + math.dist(node.position, child.position)\n            if new_cost + 1e-8 < child.cost:\n                child.cost = new_cost\n                child.parent = node\n                self._update_children_cost(child)",
     "objective": null,
     "other_inf": null
}
