{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Anytime RRT* with Adaptive Sampling and Lazy Collision Checking. It initially performs global exploration with biased sampling towards the goal and obstacle-sparse regions, followed by local rewiring and path smoothing to improve path quality iteratively. Lazy collision checking postpones expensive edge-obstacle checks until necessary, speeding up planning. Adaptive step size varies exploration granularity based on obstacle density. The algorithm balances fast exploration, high success rate, and path optimality with dynamic adjustment to environment complexity.",
     "planning_mechanism": "The planner grows a single tree from the start node using adaptive biased sampling to simultaneously explore unexplored space and focus toward the goal. After an initial feasible path is found via goal biasing, it iteratively improves the path through local rewiring and lazy collision checks, enhancing path smoothness and shortening path length. The adaptive step size reduces in cluttered areas, improving robustness and success rate.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking (lazy)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(new_cost + distance(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point (goal bias)\n        self.rewire_radius = rewire_radius          # Radius for neighbor search during rewiring\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Store best goal node when found\n        goal_node = None\n\n        # Precompute obstacle density heuristic for adaptive step sizing\n        obstacle_density = self._estimate_obstacle_density(obstacles, bounds, is_3d)\n\n        def adaptive_step_size(pos):\n            # Smaller step size in high obstacle density regions, larger in low density\n            density = self._local_density(pos, obstacles, is_3d)\n            min_step = self.step_size * 0.3\n            max_step = self.step_size * 1.5\n            step = max(min_step, max_step*(1.0 - density))\n            return step\n\n        for i in range(self.max_iter):\n            # Sample with goal bias or adaptive uniform sampling biased by obstacle sparsity\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._adaptive_sample(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree, sample)\n            step = adaptive_step_size(nearest.position)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy collision check - assume valid, postpone edge check until rewiring or path extraction\n            new_node = Node(new_pos)\n            cost_through_nearest = nearest.cost + distance(nearest.position, new_pos)\n\n            # Find neighbors within rewire radius for potential better parent\n            neighbors = self._near(tree, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = cost_through_nearest\n\n            for n in neighbors:\n                tentative_cost = n.cost + distance(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = tentative_cost\n\n            # Connect new_node\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path found through new_node\n            for n in neighbors:\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.children.remove(n)\n\n                        # Add new edge\n                        new_node.add_child(n)\n                        n.parent = new_node\n                        n.update_cost(new_cost)\n                        edges.append((new_node, n))\n\n            # Check if goal is reached (lazy edge collision here)\n            if distance(new_node.position, goal_position) <= adaptive_step_size(new_node.position):\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    potential_goal = Node(goal_position, parent=new_node, cost=new_node.cost + distance(new_node.position, goal_position))\n                    # Attach goal node to tree\n                    new_node.add_child(potential_goal)\n                    nodes.append(potential_goal)\n                    edges.append((new_node, potential_goal))\n                    if goal_node is None or potential_goal.cost < goal_node.cost:\n                        goal_node = potential_goal\n                        success_state = True\n\n            # After initial solution found, attempt local path smoothing every 100 iterations\n            if success_state and i % 100 == 0:\n                extracted_path = self._extract_path(goal_node)\n                extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _adaptive_sample(self, bounds, obstacles, is_3d):\n        import random\n        # Uniform rejection sampling with obstacle bias (avoid sampling inside obstacle)\n        while True:\n            if is_3d:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, goal_node):\n        # Returns list of positions from start to goal\n        return goal_node.path_from_root()\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut by removing intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _estimate_obstacle_density(self, obstacles, bounds, is_3d):\n        # Rough estimation of obstacle density as volume / map volume\n        if not obstacles:\n            return 0.0\n        total_volume = 1.0\n        for dim in bounds:\n            total_volume *= dim\n\n        obs_volume = 0.0\n        for obs in obstacles:\n            if is_3d:\n                w, h, d = obs[3], obs[4], obs[5]\n                obs_volume += w * h * d\n            else:\n                w, h = obs[2], obs[3]\n                obs_volume += w * h\n        return min(1.0, obs_volume / total_volume)\n\n    def _local_density(self, pos, obstacles, is_3d, radius=10.0):\n        # Compute fraction of volume occupied by obstacles within radius cube around pos\n        count_in_radius = 0\n        total_points = 20\n        import random\n        dims = len(pos)\n        lower_bound = [max(0, pos[d] - radius/2) for d in range(dims)]\n        upper_bound = [pos[d] + radius/2 for d in range(dims)]\n        in_obs_count = 0\n        for _ in range(total_points):\n            sample = tuple(random.uniform(lower_bound[d], upper_bound[d]) for d in range(dims))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                in_obs_count += 1\n        return in_obs_count / total_points",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "The hybrid planner combines the asymptotic optimality and bidirectional growth of BI-RRT* with the informed sampling, adaptive step sizing, node rejection, and pruning strategies from Improved RRT*-Connect. By integrating heuristic elliptical sampling for focused exploration, adaptive step adjustments near obstacles to maintain collision safety, and rewiring for cost optimization, it robustly searches the free space. The planner simultaneously grows two trees from start and goal, alternates sampling from an informed set when possible to improve convergence speed, aggressively prunes suboptimal branches, and attempts to connect the trees for fast discovery of high-quality paths.",
     "planning_mechanism": "The planner performs bidirectional RRT*-style growth with informed heuristic sampling within the current best path cost ellipse. Each expansion adapts step size based on nearby obstacles, rejects nodes that cannot improve the solution, and rewires neighbors for cost efficiency. When trees connect successfully, the best path is updated. The alternating growth of start and goal trees plus pruning accelerates search and enhances path quality and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:  # Start == Goal\n            return PlannerResult(True, [start], nodes, edges)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Informed sampling inside an ellipsoid defined by start, goal, c_best, and c_min\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(max(0.0, c_best**2 - c_min**2)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            # Prune nodes where cost + heuristic exceeds current best path cost\n            nonlocal edges, nodes\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # Never prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            main_tree, other_tree = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                # Prune by ignoring expansion that cannot improve best path\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            # Attempt to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connect_cost < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                # Aggressively prune both trees by c_best\n                prune(tree_a)\n                prune(tree_b)\n\n                # Early exit if solution is good enough (optional)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner combining strengths of Improved RRT*-Connect and Informed RRT* for enhanced convergence, solution quality, and robustness. Uses bidirectional tree growth with adaptive step size, informed ellipsoidal sampling, node rewiring, pruning, and rigorous collision checks to improve success rate and path smoothness efficiently.",
     "planning_mechanism": "The planner grows two trees from start and goal with informed ellipsoidal sampling after initial solution discovery. It adaptively adjusts step sizes near obstacles, prunes inefficient nodes early, and performs rewiring only if cost improves. Each connection undergoes thorough collision checks. Trees attempt to connect to each other iteratively to quickly discover and refine the optimal path while maintaining computational efficiency.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def informed_sample(c_best_local):\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best_local / 2\n            r2 = math.sqrt(c_best_local**2 - c_min**2) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball * (random.random() ** (1.0 / dim))\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(t_from, t_to):\n            # Attempt to connect last added node in t_from to nearest in t_to\n            last_node = t_from[-1]\n            nearest_other = min(t_to, key=lambda n: math.dist(n.position, last_node.position))\n            dist = math.dist(last_node.position, nearest_other.position)\n            if dist > 0:\n                if not self._is_edge_in_obstacle(last_node.position, nearest_other.position, obstacles, is_3d):\n                    path_cost = last_node.cost + dist + nearest_other.cost\n                    return path_cost, last_node, nearest_other\n            return None\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample(c_best)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Skip if out of boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if can't improve best path cost\n            if new_cost + math.dist(new_pos, goal) >= c_best - 1e-9:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try connect to opposite tree\n            connect_result = try_connect(tree_a, tree_b)\n            if connect_result:\n                path_cost, node_a, node_b = connect_result\n                if path_cost < c_best - 1e-9:\n                    c_best = path_cost\n                    path_from_start = node_a.path_from_root()\n                    path_from_goal = node_b.path_from_root()\n                    # Merge paths (avoid double counting connecting node)\n                    best_path = path_from_start + path_from_goal[::-1][1:]\n                    success = True\n\n            # Early pruning of nodes with cost worse than best found path\n            # Mark nodes invalid to ignore rewiring later\n            if success:\n                # Prune tree_start\n                for node in tree_start[:]:\n                    if node.cost + math.dist(node.position, goal) >= c_best - 1e-9 and node != tree_start[0]:\n                        node.valid = False\n                # Prune tree_goal\n                for node in tree_goal[:]:\n                    if node.cost + math.dist(node.position, start) >= c_best - 1e-9 and node != tree_goal[0]:\n                        node.valid = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an optimized version of RRT*, specifically tuned for improved planning efficiency, path quality, robustness, success rate, and path smoothness by adjusting parameters such as step size, goal bias, and neighbor radius. It incrementally builds and rewires a tree rooted at the start position, always performing collision and obstacle intersection checks, while ensuring samples remain within bounds.",
     "planning_mechanism": "The planner samples points with an adaptive goal bias, finds the nearest node, steers toward the sample with a carefully chosen step size, selects the lowest-cost parent among neighbors within an adaptively tuned radius, and rewires neighbors to improve the path iteratively. The process terminates upon reaching the goal or exhausting iterations, returning a smooth, optimized path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]\n        dim = len(bounds)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle descriptions\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for i in range(self.max_iter):\n            # Goal biasing with increased rate to accelerate goal reaching\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and Limit step_size\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            length = min(self.step_size, dist)\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * length for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n\n            # Find neighbors according to adaptive radius reduced over time (improves efficiency)\n            radius = self.neighbor_radius * (1.0 - i / self.max_iter) + 3.0\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for path quality improvement\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal check with improved step size tolerance and obstacle checks\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Optional: Path smoothing using shortcut heuristic\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 100\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            # Check if direct edge is collision free\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm is a simplified, generalized RRT* with informed sampling and bidirectional growth principles combined. It focuses exploration using ellipsoidal informed sampling after an initial solution and grows two trees simultaneously from start and goal to improve convergence, path quality, and robustness. The planner incorporates rewiring for path optimization, collision and edge checks for safety, and boundary enforcement to reduce computation and improve overall success rate and path smoothness.",
     "planning_mechanism": "The planner initializes two trees from the start and goal. It samples points uniformly at first and within an informed ellipsoid after a solution is found, ensuring samples have potential to improve the path. Both trees extend towards sampled points while avoiding obstacles. When the two trees connect, the path is reconstructed, and neighboring nodes are rewired for path quality improvement. Collision checks on nodes and edges ensure safety. The algorithm runs until max iterations or a satisfying path is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants\n        for child in self.children:\n            child.update_cost_and_parent(self, self.cost + distance(self.position, child.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample(c_best=float(\"inf\")):\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = distance(start_position, goal_position)\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                a1 = np.array(goal_position) - np.array(start_position)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    A1 = np.eye(dim)\n                else:\n                    a1 = a1 / a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n                L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim -1)\n                L = np.diag(L_diag)\n\n                for _ in range(100):\n                    x_ball = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm < 1e-6:\n                        continue\n                    x_ball = x_ball / norm * random.random()**(1/dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    p = tuple(x_rand)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        goal_reached_node_start = None\n        goal_reached_node_goal = None\n        radius = max(bounds) * 0.15  # Adaptive radius for rewiring\n\n        for _ in range(self.max_iter):\n            c_best = best_cost if best_cost < float(\"inf\") else float(\"inf\")\n            x_rand = sample(c_best)\n\n            # Extend tree_start towards sample\n            nearest_s = nearest_node(tree_start, x_rand)\n            new_pos_s = steer(nearest_s.position, x_rand)\n            if not can_connect(nearest_s.position, new_pos_s):\n                continue\n\n            new_node_s = Node(new_pos_s)\n            # Choose best parent from near nodes for new_node_s\n            near_s = near_nodes(tree_start, new_pos_s, radius)\n            min_cost = nearest_s.cost + distance(nearest_s.position, new_pos_s)\n            best_parent = nearest_s\n\n            for node_n in near_s:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_s)\n                if cost_n < min_cost and can_connect(node_n.position, new_pos_s):\n                    min_cost = cost_n\n                    best_parent = node_n\n\n            best_parent.add_child(new_node_s)\n            new_node_s.cost = min_cost\n            tree_start.append(new_node_s)\n            nodes.append(new_node_s)\n            edges.append((best_parent, new_node_s))\n\n            # Rewire near nodes of new_node_s\n            for node_n in near_s:\n                alt_cost = new_node_s.cost + distance(new_node_s.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_s.position, node_n.position):\n                    node_n.update_cost_and_parent(new_node_s, alt_cost)\n                    # Update edges\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except ValueError:\n                        pass\n                    edges.append((new_node_s, node_n))\n\n            # Extend tree_goal towards new_node_s\n            nearest_g = nearest_node(tree_goal, new_node_s.position)\n            new_pos_g = steer(nearest_g.position, new_node_s.position)\n            if not can_connect(nearest_g.position, new_pos_g):\n                continue\n\n            new_node_g = Node(new_pos_g)\n            near_g = near_nodes(tree_goal, new_pos_g, radius)\n            min_cost_g = nearest_g.cost + distance(nearest_g.position, new_pos_g)\n            best_parent_g = nearest_g\n            for node_n in near_g:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_g)\n                if cost_n < min_cost_g and can_connect(node_n.position, new_pos_g):\n                    min_cost_g = cost_n\n                    best_parent_g = node_n\n\n            best_parent_g.add_child(new_node_g)\n            new_node_g.cost = min_cost_g\n            tree_goal.append(new_node_g)\n            nodes.append(new_node_g)\n            edges.append((best_parent_g, new_node_g))\n\n            # Rewire near nodes of new_node_g\n            for node_n in near_g:\n                alt_cost = new_node_g.cost + distance(new_node_g.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_g.position, node_n.position):\n                    node_n.update_cost_and_parent(new_node_g, alt_cost)\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except ValueError:\n                        pass\n                    edges.append((new_node_g, node_n))\n\n            # Check if trees connect (within step_size)\n            if distance(new_node_s.position, new_node_g.position) <= self.step_size and can_connect(new_node_s.position, new_node_g.position):\n                # Connect nodes\n                new_node_s.add_child(new_node_g)\n                edges.append((new_node_s, new_node_g))\n\n                path_start = new_node_s.path_from_root()\n                path_goal = new_node_g.path_from_root()\n                extracted_path = path_start + path_goal[::-1]  # Combine paths\n\n                # Update best cost and success\n                path_length = new_node_s.cost + distance(new_node_s.position, new_node_g.position) + new_node_g.cost\n                if path_length < best_cost:\n                    best_cost = path_length\n                    success_state = True\n\n                return type('PlannerResult', (), dict(\n                    success=success_state,\n                    path=extracted_path,\n                    nodes=nodes,\n                    edges=edges\n                ))()\n\n            # Swap trees for bidirectional growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return type('PlannerResult', (), dict(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "The algorithm is an improved Bidirectional Informed RRT* (Inverse RRT*) planner that combines the efficiency of bidirectional search with heuristic-guided sampling to focus exploration within an informed ellipsoidal subset of the configuration space. It incrementally rewires the tree to improve path quality and shortens the path length by considering optimal parent choices for each new node. Obstacles are rigorously checked to ensure collision-free nodes and edges. This enhances planning efficiency, success rate, and path smoothness.",
     "planning_mechanism": "The planner simultaneously grows two trees rooted at the start and goal positions, biased by heuristic sampling within an ellipsoidal informed subset defined by the current best solution cost. Each extension step involves connecting the trees by extending one tree toward a sampled informed point, then extending the other tree toward the new node. The planner rewires locally for path optimality and terminates early upon a successful connection, extracting the smoothest available path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius  # radius for rewiring neighborhood\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def path_cost(node):\n            c = 0.0\n            while node.parent is not None:\n                c += distance(node.position, node.parent.position)\n                node = node.parent\n            return c\n\n        def backtrace_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def informed_sample(c_best):\n            \"\"\"Upper bound c_best defines an ellipsoidal region to bias sampling.\"\"\"\n            if not math.isfinite(c_best):\n                # No solution yet, sample uniformly\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Compute unit vector in direction start->goal\n            c_min = distance(start_position, goal_position)\n            if c_min == 0:\n                return start_position  # trivial\n\n            center = tuple((start_position[i] + goal_position[i]) / 2.0 for i in range(dim))\n\n            # Alignment unit vector (a1)\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(dim))\n\n            # Create orthonormal basis using Gram-Schmidt\n            # Only needed for dim=2 or 3, simple case:\n\n            import numpy as np\n\n            if dim == 2:\n                # In 2D, a1_perp is perpendicular to a1:\n                a1_perp = (-a1[1], a1[0])\n                basis = np.array([a1, a1_perp])\n            elif dim == 3:\n                a1_np = np.array(a1)\n                # Arbitrary vector not parallel to a1_np\n                if abs(a1_np[0]) < 0.9:\n                    v = np.array([1, 0, 0])\n                else:\n                    v = np.array([0, 1, 0])\n                a2 = v - (np.dot(v, a1_np)) * a1_np\n                a2 /= np.linalg.norm(a2)\n                a3 = np.cross(a1_np, a2)\n                basis = np.vstack((a1_np, a2, a3))\n            else:\n                # fallback: uniform sample\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Radii of the ellipsoid along each axis:\n            r1 = c_best / 2.0\n            r_other = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            # Sample random point in unit ball\n            while True:\n                # Sample point in unit ball for given dim\n                if dim == 2:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        rnd_ball = np.array([x, y])\n                        break\n                else:\n                    x, y, z = random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y + z*z <= 1:\n                        rnd_ball = np.array([x, y, z])\n                        break\n\n            # Stretch point along ellipsoid axes:\n            rnd_diagonal = np.diag(radii)\n            scaled = rnd_diagonal @ rnd_ball\n\n            # Transform back to world frame:\n            sample_np = basis.T @ scaled + np.array(center)\n\n            sample = tuple(float(sample_np[i]) for i in range(dim))\n\n            # Clamp sample inside bounds:\n            clamped = tuple(\n                max(0.0, min(sample[i], bounds[i])) for i in range(dim)\n            )\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def collision_free(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if not all(0 <= pos[i] <= bounds[i] for i in range(dim)):\n                return False\n            return True\n\n        def collision_free_edge(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_extend(tree_a, tree_b, sample, best_cost_local):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not collision_free(new_pos):\n                return None\n\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            # Choose parent with minimal cost in neighbor radius (rewiring prep)\n            neighbors = near(tree_a, new_pos, self.neighbor_radius)\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                if collision_free_edge(nb.position, new_pos):\n                    cost_through_nb = nb.cost + distance(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring neighbors to new_node if beneficial\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, nb.position)\n                if cost_through_new < nb.cost and collision_free_edge(new_node.position, nb.position):\n                    # Rewire\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    nb.parent = new_node\n                    nb.cost = cost_through_new\n                    new_node.add_child(nb)\n                    # edges update\n                    # Remove old edge and add new edge\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except Exception:\n                        pass\n                    edges.append((new_node, nb))\n\n            # Try to connect tree_b to new_node directly\n            connect_node = nearest(tree_b, new_node.position)\n            if distance(connect_node.position, new_node.position) <= self.step_size:\n                if collision_free_edge(connect_node.position, new_node.position):\n                    # Connect by making connect_node the parent of new_node or vice versa\n                    # Choose direction to minimize cost path\n                    connect_cost = connect_node.cost + distance(connect_node.position, new_node.position)\n                    new_cost = new_node.cost + distance(new_node.position, connect_node.position)\n\n                    if connect_cost < new_cost:\n                        # connect_node -> new_node\n                        new_node.parent.remove_child(new_node)\n                        new_node.parent = connect_node\n                        new_node.cost = connect_cost\n                        connect_node.add_child(new_node)\n                    else:\n                        # new_node -> connect_node\n                        if connect_node.parent:\n                            connect_node.parent.remove_child(connect_node)\n                        connect_node.parent = new_node\n                        connect_node.cost = new_cost\n                        new_node.add_child(connect_node)\n\n                    # Update nodes and edges accordingly\n                    # Remove old edges involving connect_node parent if rewired above\n                    edges.append((new_node, connect_node) if connect_cost > new_cost else (connect_node, new_node))\n                    return new_node, connect_node\n\n            else:\n                # Attempt incremental connection from connect_node to new_node\n                current = connect_node\n                last = None\n                while distance(current.position, new_node.position) > self.step_size:\n                    new_p = steer(current.position, new_node.position, self.step_size)\n                    if not collision_free(new_p) or not collision_free_edge(current.position, new_p):\n                        break\n                    intermediate = Node(new_p, parent=current, cost=current.cost + distance(current.position, new_p))\n                    current.add_child(intermediate)\n                    tree_b.append(intermediate)\n                    nodes.append(intermediate)\n                    edges.append((current, intermediate))\n\n                    last = current\n                    current = intermediate\n                else:\n                    # Final connect\n                    if collision_free_edge(current.position, new_node.position):\n                        if current.parent:\n                            current.parent.remove_child(current)\n                        current.parent = new_node\n                        current.cost = new_node.cost + distance(new_node.position, current.position)\n                        new_node.add_child(current)\n                        edges.append((new_node, current))\n                        return new_node, current\n\n            return None\n\n        c_best = float(\"inf\")\n\n        for itr in range(self.max_iter):\n            s = informed_sample(c_best)\n\n            # Extend start_tree towards sample\n            result = try_extend(start_tree, goal_tree, s, c_best)\n            if result:\n                n_start, n_goal = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Extend goal_tree towards sample\n            result = try_extend(goal_tree, start_tree, s, c_best)\n            if result:\n                n_goal, n_start = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Early termination if path found with cost close to direct distance:\n            if success_state and c_best <= distance(start_position, goal_position) * 1.01:\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid planner combining bidirectional RRT*-Connect's informed sampling and adaptive step sizing with RRT*'s optimal rewiring and goal biasing. It uses two trees grown from start and goal, includes heuristic-based sampling within an ellipsoidal informed subset, dynamically adjusts expansion steps near obstacles, prunes non-promising branches, and rewires nodes efficiently to improve solution quality. The planner attempts early connections between trees to quickly find high-quality paths and refines them incrementally for robustness and enhanced performance.",
     "planning_mechanism": "The planner alternates growth between two trees (start and goal), samples candidates with informed heuristics biased towards shortest path ellipsoid, adapts step sizes based on obstacle proximity, rejects costly expansions, and rewires locally to improve path costs. It integrates goal biasing and tries to connect the two trees at every iteration. Upon successful connection, it reconstructs the combined path and returns the best path found within the iteration limit.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a == tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a to the sample\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                # Prune paths that cannot improve existing best path\n                continue\n\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find near nodes in tree_a for rewiring\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire if cheaper path found\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Verify connection path collision free\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Optional pruning near best path could be inserted here (not mandatory)\n\n        # Post-processing: Optional path smoothing for improved path quality\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        # If no solution, sample uniformly in bounds\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Calculate rotation matrix C that aligns x-axis with vector a1\n        # Using SVD-based method to get a proper rotation\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0\n        else:\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # reduce step near obstacle but keep minimum step size of 1\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n\n        path_smoothed = [path[0]]\n        idx = 0\n        while idx < len(path_smoothed):\n            # Attempt to skip intermediate nodes if straight connection is collision free\n            next_idx = len(path) -1\n            for j in range(len(path)-1, idx, -1):\n                if self._is_edge_in_obstacle(path_smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == len(path) -1:\n                path_smoothed += path[idx+1:]\n                break\n            if next_idx == idx:\n                # No farther progress, just add next node\n                path_smoothed.append(path[idx+1])\n                idx += 1\n            else:\n                path_smoothed.append(path[next_idx])\n                idx = next_idx\n        return path_smoothed",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "This planner integrates bidirectional RRT* growth with informed elliptical sampling and adaptive step sizing, enhanced by heuristic-driven node rejection, rewiring for cost minimization, and aggressive pruning. It alternates expansions between start and goal trees, opportunistically attempts tree connection, and carefully maintains collision-free nodes and edges. The planner aims for rapid convergence to high-quality, smooth paths with improved efficiency and robustness.",
     "planning_mechanism": "It generates samples inside the ellipsoidal informed subset defined by the current best cost; expands trees adaptively near obstacles; rewires neighbors to optimize path costs; prunes nodes that cannot improve the solution; and promptly updates and returns the best found path, ensuring all new nodes and edges pass collision checks and remain within map bounds.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Path cost\n        self.children = []\n        self.valid = True                         # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                          # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start                  # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal                    # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles                    # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        tree_a = [Node(start_position)]\n        tree_b = [Node(goal_position)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def informed_sample() -> Tuple[float, ...]:\n            if c_best == float(\"inf\"):\n                # Uniform random sample inside bounds & collision-free\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback if no free sample found fast enough\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s,g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best**2 - c_min**2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        return candidate\n            # fallback uniform sampling inside bounds if failure\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos) -> float:\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # never prune root\n                    h_cost = math.dist(node.position, goal_position)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            main_tree, other_tree = (tree_a, tree_b) if i%2==0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue  # prune non-improving expansion\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connection_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connection_cost < c_best:\n                c_best = connection_cost\n                path_from_a = new_node.path_from_root()\n                path_from_b = other_nearest.path_from_root()\n                best_path = path_from_a + path_from_b[::-1]\n                success = True\n                prune(tree_a)\n                prune(tree_b)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "An enhanced RRT* variant with adaptive parameters and informed sampling to improve path planning efficiency, path quality, and robustness. The algorithm incorporates goal biasing, adaptive neighbor radius based on the number of nodes, heuristic pruning by sampling within an informed ellipsoidal region, and early stopping to reduce search time and improve success rate. It maintains collision and edge checks ensuring safety and correctness.",
     "planning_mechanism": "The planner incrementally samples points biased toward the goal and within an informed ellipsoidal subset to focus the search. It connects nodes with collision-free edges, rewires to optimize paths, and dynamically adjusts the neighbor radius based on the explored tree size to balance exploration and exploitation. Early termination occurs when the goal is connected, thus reducing unnecessary iterations.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.1, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic(p):\n            # Euclidean heuristic to goal\n            return dist(p, goal_position)\n\n        def sample_in_bounds():\n            if is_3d:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]))\n            else:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]))\n\n        def informed_sample(c_best):\n            # Sample inside ellipsoid only if c_best < inf\n            if c_best == float('inf'):\n                return sample_in_bounds()\n\n            # Define ellipsoid parameters\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                c_best = c_min\n\n            # Unit vector from start to goal\n            dx = (goal_position[0] - start_position[0]) / c_min\n            dy = (goal_position[1] - start_position[1]) / c_min\n            if is_3d:\n                dz = (goal_position[2] - start_position[2]) / c_min\n\n            # Radii of the ellipsoid\n            a = c_best / 2.0\n            if is_3d:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                c = b\n            else:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            from random import uniform\n            import math as m\n\n            while True:\n                # Sample random point in unit ball\n                if is_3d:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    z = uniform(-1, 1)\n                    if x * x + y * y + z * z > 1:\n                        continue\n                    # Scale to ellipsoid\n                    px = a*x\n                    py = b*y\n                    pz = c*z\n                    # Rotate and translate\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                        start_position[2] + (c_min/2)*dz + pz,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(3)):\n                        return sample\n                else:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    if x*x + y*y > 1:\n                        continue\n                    px = a*x\n                    py = b*y\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(2)):\n                        return sample\n\n        for i in range(self.max_iter):\n            # Adaptive neighbor radius: gamma * (log(n)/n)^{1/d} with gamma ~ base_neighbor_radius\n            n = len(nodes)\n            dim = len(bounds)\n            gamma = self.base_neighbor_radius\n            r = min(gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 20)\n\n            # Goal biasing + informed sampling after initial solution found\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif best_goal_cost == float('inf'):\n                sample = sample_in_bounds()\n            else:\n                sample = informed_sample(best_goal_cost)\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            step = min(self.step_size, dist_to_sample)\n            new_position = tuple(nearest_node.position[d] + unit[d] * step for d in range(dim))\n\n            # Check bounds\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if dist(n.position, new_position) <= r]\n\n            # Choose best parent among near nodes\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to new_node if cheaper path found\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal closer than previous best\n            dist_to_goal = dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        goal_node = Node(goal_position)\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        # Early exit after connecting goal for efficiency\n                        break\n\n        if success_state and goal_node:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "The algorithm is a simplified and generalized bidirectional RRT* (BI-RRT*) path planner that builds two trees growing from start and goal positions respectively, incrementally searching for an optimal path in a given environment with obstacles. It samples free points within the map bounds, extends trees toward sampled points while rewiring nearby nodes to minimize path cost, and attempts to connect the two trees when close enough, returning an optimized feasible path.",
     "planning_mechanism": "The planner iteratively samples collision-free points within the environment, extends the nearest node in one tree towards this sample with a fixed step size, rewires nearby nodes to improve path cost, then attempts to connect the other tree to the newly added node. Collision checks on nodes and edges ensure path validity. Upon connecting the two trees, the final path is constructed by concatenating paths from both trees and returned along with the explored nodes and edges.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                success = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        r = self.neighbor_radius\n        return [node for node in tree if math.dist(node.position, position) <= r]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        current_pos = nearest.position\n\n        while True:\n            new_pos = self._steer(current_pos, target_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n            min_cost = self._nearest(tree, current_pos).cost + math.dist(current_pos, new_pos)\n            best_parent = self._nearest(tree, current_pos)\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            connect_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(connect_node)\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                return connect_node\n\n            current_pos = connect_node.position\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm, \"Bi-directional Informed FMT* with Lazy Collision Checking and Path Smoothing,\" combines the fast convergence property of Fast Marching Tree (FMT*) methods with bi-directional search and informed sampling. It incrementally builds two trees growing from start and goal using adaptive and heuristic-based neighbor connection, applies lazy collision checking to reduce computational overhead, and employs a post-processing smoothing step to refine the final path, thus improving planning efficiency, success rate, path quality, and robustness.",
     "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling mostly inside an ellipsoidal informed subset once an initial solution is found, connecting neighbors with minimal cost edges when collision-free, but defers edge collision checks until connection attempts in a lazy fashion. When trees connect, the final path is extracted and smoothed using shortcutting techniques to remove unnecessary waypoints, achieving shorter and smoother solutions with reduced runtime.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start (or goal, depending on tree)\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\n\n    def __lt__(self, other):\n        return self.cost < other.cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 8.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        # Initialize two trees, one from start and one from goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Open sets implemented as heaps, storing (cost, node)\n        open_start = [(0.0, tree_start[0])]  # cost from start\n        open_goal = [(0.0, tree_goal[0])]    # cost from goal\n\n        # Maps for fast position lookup\n        visited_start = {tree_start[0].position: tree_start[0]}\n        visited_goal = {tree_goal[0].position: tree_goal[0]}\n\n        # Current best cost and path\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        path_solution = []\n        success = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds until free sample found quickly\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Informed sampling inside prolate hyperspheroid (ellipsoid) between start and goal\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-9:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if collision_free_node(candidate):\n                    return candidate\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + self.step_size * direction[d] for d in range(dim))\n            return new_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect_trees(node_start, tree_goal):\n            # Attempt to connect the node from tree_start to any node in tree_goal within neighbor radius\n            neighbors_goal = near_nodes(tree_goal, node_start.position)\n            for goal_node in neighbors_goal:\n                if collision_free_edge(node_start.position, goal_node.position):\n                    # Total cost of connecting path\n                    path_cost = node_start.cost + goal_node.cost + math.dist(node_start.position, goal_node.position)\n                    nonlocal c_best, path_solution, success\n\n                    if path_cost < c_best:\n                        c_best = path_cost\n\n                        path_from_start = node_start.path_from_root()\n                        path_from_goal = goal_node.path_from_root()\n                        path_solution = path_from_start + path_from_goal[::-1]\n                        success = True\n                        return True\n            return False\n\n        # Lazy collision checking: Edges are created without immediate collision check;\n        # only checked when attempting connection to prune expensive computations.\n        # For each iteration, expand one node from start tree, one from goal tree (bi-directional) in alternation.\n        for iter_count in range(self.max_iter):\n            for tree_flag in [0, 1]:\n                tree_curr = tree_start if tree_flag == 0 else tree_goal\n                tree_other = tree_goal if tree_flag == 0 else tree_start\n                open_set = open_start if tree_flag == 0 else open_goal\n                visited_tree = visited_start if tree_flag == 0 else visited_goal\n\n                if not open_set:\n                    continue\n\n                # Pop node with smallest cost\n                curr_cost, current_node = heapq.heappop(open_set)\n\n                x_sample = informed_sample()\n                x_new_pos = steer(current_node.position, x_sample)\n                if not collision_free_node(x_new_pos):\n                    continue\n\n                if not collision_free_edge(current_node.position, x_new_pos):\n                    continue\n\n                # Check if improvement possible\n                est_total_cost = current_node.cost + math.dist(current_node.position, x_new_pos) + math.dist(x_new_pos, goal_position if tree_flag == 0 else start_position)\n                if est_total_cost >= c_best:\n                    continue  # prune non-improving samples\n\n                # Create new node and find minimal cost parent from near neighbors\n                near = near_nodes(tree_curr, x_new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, x_new_pos)\n                best_parent = current_node\n\n                # Search better parent among near neighbors\n                for neighbor in near:\n                    if neighbor == current_node:\n                        continue\n                    try_cost = neighbor.cost + math.dist(neighbor.position, x_new_pos)\n                    if try_cost < min_cost and collision_free_edge(neighbor.position, x_new_pos):\n                        min_cost = try_cost\n                        best_parent = neighbor\n\n                new_node = Node(x_new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                tree_curr.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                visited_tree[new_node.position] = new_node\n                heapq.heappush(open_set, (new_node.cost, new_node))\n\n                # Attempt to connect trees lazily\n                if try_connect_trees(new_node, tree_other):\n                    break\n            if success and c_best <= c_min * 1.05:\n                break\n\n        # If solution found, perform path smoothing by shortcutting\n        if success:\n            path_solution = self._smooth_path(path_solution, obstacles, is_3d, bounds)\n\n        return PlannerResult(success, path_solution, nodes, edges)\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_attempts=200):\n        import random\n        if len(path) <= 2:\n            return path\n\n        path_pts = path[:]\n        for _ in range(max_attempts):\n            if len(path_pts) <= 2:\n                break\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i + 2, len(path_pts) - 1)\n            p_start = path_pts[i]\n            p_end = path_pts[j]\n\n            if self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                continue\n\n            # If shortcut possible, remove intermediate nodes between i and j\n            path_pts = path_pts[:i + 1] + path_pts[j:]\n        return path_pts",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the informed heuristic sampling, adaptive step size, node pruning, and rewiring strategies from Improved RRT*-Connect with the robust bidirectional tree growth and rewiring approach of RRT*-Connect. It adaptively samples within an informed ellipsoidal domain around the current best path cost to focus the search, grows two trees from start and goal alternately, dynamically adjusts step size near obstacles for safer expansions, prunes suboptimal branches, and performs rewiring intelligently to minimize path cost and improve convergence. The planner tries to connect the two trees frequently and updates the best path found while maintaining collision safety checks throughout.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with informed sampling constrained by the current best path cost. During extension, it adjusts step sizes adaptively around obstacles, rejects expansions that cannot improve the solution, and rewires neighbors to optimize paths locally. Each new node is tested for collision and edges are checked for collisions before addition. It attempts to connect the two trees after each node insertion. Pruning removes nodes and branches that cannot lead to better solutions, improving efficiency and robustness. Upon success, the shortest collision-free path spanning start to goal is returned.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling within bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed ellipsoidal sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Compute rotation matrix C that aligns the x-axis with a1\n            # Using SVD for orthogonal basis\n            I1 = np.eye(dim)[:, 0]\n            M = np.outer(a1, I1)\n            U, _, VT = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(VT)]) @ VT\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):  # Limit to 100 tries to find a valid sample\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacle but not below 1.0\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            d = dist(from_pos, to_pos)\n            if d <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / d for d in range(dim))\n\n        def near_nodes(tree, new_node_pos, radius):\n            return [node for node in tree if dist(node.position, new_node_pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def path_cost(path_nodes: List[Node]) -> float:\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def extract_path(node_from, node_to):\n            path_a = node_from.path_from_root()\n            path_b = []\n            node = node_to\n            while node:\n                path_b.append(node.position)\n                node = node.parent\n            return path_a + path_b[::-1]\n\n        def prune(tree, cost_limit):\n            # Remove nodes from tree that cannot improve the solution >= cost_limit\n            # Recursively invalidate subtrees whose root node cost + heuristic to goal >= cost_limit\n            def invalidate_subtree(node):\n                node.valid = False\n                if node.parent:\n                    node.parent.remove_child(node)\n                for child in list(node.children):\n                    invalidate_subtree(child)\n                node.children = []\n\n            for node in list(tree):\n                if not node.valid:\n                    continue\n                heuristic = dist(node.position, goal_position if tree is start_tree else start_position)\n                if node.cost + heuristic >= cost_limit:\n                    invalidate_subtree(node)\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n\n        for iter in range(self.max_iter):\n            # Alternate trees for extension\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            nearest = min((n for n in tree_a if n.valid), key=lambda n: dist(n.position, sample), default=None)\n            if nearest is None:\n                continue\n\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Pruning: if new cost + heuristic >= current best cost, skip\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_to_goal = dist(new_pos, goal_position)\n            est_total_cost = new_cost + heuristic_to_goal\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in the same tree\n            rewire(tree_a, new_node)\n\n            # Attempt to connect to nearest node in opposite tree\n            other_nearest = min((n for n in tree_b if n.valid), key=lambda n: dist(n.position, new_node.position), default=None)\n            if other_nearest is not None:\n                connect_dist = dist(new_node.position, other_nearest.position)\n                if connect_dist <= self.base_step:\n                    # Check edge collision before connecting trees\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        path_cost_candidate = new_node.cost + connect_dist + other_nearest.cost\n                        if path_cost_candidate < c_best:\n                            c_best = path_cost_candidate\n                            success_state = True\n                            # Extract the full path from start to goal via new_node and other_nearest\n                            if tree_a is start_tree:\n                                best_path = extract_path(new_node, other_nearest)\n                            else:\n                                best_path = extract_path(other_nearest, new_node)\n\n                            # Prune nodes in both trees that cannot yield better path\n                            prune(start_tree, c_best)\n                            prune(goal_tree, c_best)\n\n            # Early stop if path found with sufficiently low cost\n            if success_state and c_best <= c_min * 1.05:  # within 5% of shortest distance\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm is an Enhanced Bidirectional RRT* with informed sampling and adaptive rewiring that improves planning efficiency, path quality, and robustness. It leverages bidirectional tree growth from start and goal positions, heuristic-informed sampling within an evolving ellipsoidal domain, adaptive step sizing to maneuver around obstacles, pruning of inefficient paths, and dynamic rewiring to optimize the tree connections for shortest path construction. The technique focuses on rapidly converging to high-quality paths and maintaining robustness in cluttered and high-dimensional spaces.",
     "planning_mechanism": "The planner alternately expands two trees (from start and goal) using samples biased by the currently best-found path cost, adapting step sizes near obstacles. Newly generated nodes are added only if they improve potential path cost, and neighbors are rewired for optimal costs. Successful connections between the two trees dynamically update the best path. Collision checks are rigorously applied to nodes and edges to maintain path validity.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Create rotation matrix C\n            rang = np.eye(dim)\n            M = np.outer(a1, rang[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(100):  # Attempt up to 100 times to sample valid point\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_scale = random.random() ** (1/dim)\n                x_ball *= radius_scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if no sample found in 100 tries\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        def rewire(tree_nodes, new_node):\n            near_nodes = [n for n in tree_nodes if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node as parent\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_from, tree_to, new_node):\n            # Find nearest node in tree_to\n            nearest_to = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_to.position)\n            connect_cost = new_node.cost + dist_between + nearest_to.cost\n            if connect_cost + 1e-9 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to.position, obstacles, is_3d):\n                    return True, connect_cost, new_node, nearest_to\n            return False, c_best, None, None\n\n        for iter_count in range(self.max_iter):\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve\n            if tentative_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius\n            rewire(tree_a, new_node)\n\n            # Try connect trees\n            connected, connect_cost, node_a, node_b = try_connect(tree_a, tree_b, new_node)\n            if connected:\n                c_best = connect_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Optional early break if very close to minimal path\n                if abs(c_best - c_min) < 1e-3:\n                    break\n\n        if success_state and extracted_path:\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return type(\"PlannerResult\", (), {})() if not extracted_path else \\\n               type(\"PlannerResult\", (), {\n                   \"success\": success_state,\n                   \"path\": extracted_path,\n                   \"nodes\": nodes,\n                   \"edges\": edges\n               })\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i, j = sorted(random.sample(range(len(new_path)), 2))\n            if j - i <= 1:\n                continue\n            p_i, p_j = new_path[i], new_path[j]\n            if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                continue\n            # Remove intermediate nodes between i and j\n            new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "A refined RRT*-Connect inspired planner that integrates bidirectional search with adaptive step sizing, goal biasing, informed heuristic sampling, dynamic rewiring radius, branch pruning, and incremental path smoothing for efficient, high-quality, and robust path planning in 2D/3D environments.",
     "planning_mechanism": "The planner simultaneously grows two trees from start and goal points, alternately expanding them using informed sampling restricted inside an ellipsoidal heuristic region biased by current best path cost. It adapts step sizes near obstacles and dynamically adjusts rewiring radius based on node density. Nodes are connected only after strict collision and edge checks. It attempts early tree connections to accelerate search, rewires locally for path cost reduction, prunes branches unlikely to improve solutions, and applies intermittent path smoothing to enhance path quality and smoothness within the iteration budget.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 4.5, goal_sample_rate: float = 0.12, rewire_base_radius: float = 18.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            # Check points along the path for obstacle proximity to adapt step size\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacles, but keep minimum 1.0\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            new_pos = tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n            return new_pos\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            # Rotation matrix to align x-axis with a_unit vector\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            r2_sq = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(r2_sq) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim -1))\n\n            for _ in range(100):\n                # Sample unit ball\n                x_ball = np.random.normal(0,1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback uniform sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            # Adaptive rewiring radius ~ gamma * (log(n)/n)^{1/d}\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _try_connect_nodes(from_node, to_node):\n            if self._is_edge_in_obstacle(from_node.position, to_node.position, obstacles, is_3d):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            # Remove nodes and descendants whose cost > cost_threshold (to prune search space)\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                # Disconnect node from parent\n                if node.parent:\n                    node.parent.remove_child(node)\n                # Disconnect children recursively\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) -1:\n                next_idx = len(path_in) -1\n                for j in range(len(path_in)-1, idx, -1):\n                    if not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) and _in_bounds(path_in[j]):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing & informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            # Prune expansions that can't beat current best\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius based on tree size\n            curr_rewire_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_rewire_radius]\n            for near_node in near_nodes:\n                if near_node is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try connect new_node in tree_a to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between + nearest_to_new.cost\n\n            # Only attempt if total cost could improve best known path\n            if total_cost + 1e-6 < c_best:\n                if _try_connect_nodes(new_node, nearest_to_new):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune both trees to nodes that can improve the best path cost\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 500 iterations if path found\n            if success and iteration % 500 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* inspired planner that grows two trees from the start and goal positions, alternately extending them with goal biasing and adaptive step sizing. It performs collision checks on nodes and edges before adding them. Nearby nodes are rewired for path cost improvement. The planner attempts to connect the two trees at every iteration to find a feasible, near-optimal, and smooth path efficiently.",
     "planning_mechanism": "A bidirectional incremental sampling approach that alternately grows start and goal trees toward randomly sampled points biased by the goal. Each new node undergoes collision checks, and rewiring locally improves path cost. The trees try to connect every iteration, reconstructing a smooth, high-quality path once connected while respecting map bounds and obstacles.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position           # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent               # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                        # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                        # Tuple[float, ...]\n        goal = map.goal                          # Tuple[float, ...]\n        obstacles = map.obstacles                # List of rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        def sample() -> Tuple[float, ...]:\n            # Goal biasing for start tree growth; uniform random otherwise\n            if random.random() < self.goal_sample_rate:\n                return goal\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            rand_point = sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step = self._adaptive_step(nearest.position, rand_point, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, rand_point, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + 1e-8 >= c_best:\n                # Prune expansions exceeding current best path cost\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in tree_a to improve path cost\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Attempt connection to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d) -> float:\n        base_step = self.step_size\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(base_step * 0.5, 1.0)\n        return base_step\n\n    def _in_bounds(self, pos, bounds) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0) -> bool:\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while True:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                next_idx = j\n                break\n            smoothed.append(path[next_idx])\n            if next_idx == len(path) - 1:\n                break\n            idx = next_idx\n        return smoothed",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid A*-influenced Bidirectional RRT with Dynamic Goal Biasing and Local Path Smoothing. It integrates the rapid exploration of bidirectional RRT with heuristic guidance and intermittent local smoothing to improve path quality and convergence speed. Dynamic goal biasing increases the chance of connecting trees as iterations progress while local smoothing refines paths incrementally to ensure smoothness and collision-free feasibility. This hybrid approach balances exploration, exploitation, and refinement for improved efficiency, robustness, path length, and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal locations bidirectionally. Sampling is guided by a gradually increasing probability to bias samples near the opposite tree's best node, promoting faster connections. New nodes are added after collision checks and edges rewiring around radius to optimize cost. After a tentative path connection between trees, segments of the path are locally smoothed by shortcutting collisions while maintaining feasibility. The process iterates until max iteration or connection success. The output is the best smoothed feasible path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        # Propagate cost update to children recursively\n        for child in self.children:\n            edge_cost = self.distance_to(child)\n            child.update_cost(new_cost + edge_cost)\n\n    def distance_to(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Helper function: sample with dynamic goal biasing\n        def biased_sample(iteration):\n            bias_max = 0.3\n            bias = min(bias_max, (iteration / self.max_iter) * bias_max)\n            if random.random() < bias and len(tree_goal) > 0:\n                # Sample near best node of goal tree to aid connection\n                best_goal_node = min(tree_goal, key=lambda n: n.cost)\n                noise = tuple(random.gauss(0, self.step_size*2) for _ in range(dim))\n                sample = tuple(\n                    max(0, min(bounds[d], best_goal_node.position[d] + noise[d]))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # Uniform random sample within bounds and free-space\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        neighbor.update_cost(new_cost)\n\n        def try_connect(tree_from, tree_to, new_node):\n            nearest = nearest_node(tree_to, new_node.position)\n            # Attempt to steer stepwise from nearest to new_node\n            from_pos = nearest.position\n            to_pos = new_node.position\n            full_dist = math.dist(from_pos, to_pos)\n            if full_dist == 0:  # same position\n                return None\n            step = min(self.step_size, full_dist)\n            new_pos = steer(from_pos, to_pos, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            connect_node.cost = nearest.cost + math.dist(from_pos, new_pos)\n\n            # Choose best parent in radius\n            neighbors = near_nodes(tree_to, connect_node.position, self.rewire_radius)\n            best_parent = nearest\n            min_cost = connect_node.cost\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, connect_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(nbr.position, connect_node.position, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = cost\n            connect_node.parent = best_parent\n            best_parent.children.append(connect_node)\n            connect_node.cost = min_cost\n            tree_to.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            rewire(tree_to, connect_node)\n\n            # Check if connecting node is close enough to new_node\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n            else:  # continue extending towards new_node recursively\n                return try_connect(tree_from, tree_to, connect_node)\n\n        def build_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            # Attempt local path smoothing by shortcutting line segments\n            import random\n            max_trials = max(10, len(path)//3)\n            refined = path[:]\n            for _ in range(max_trials):\n                if len(refined) <= 2:\n                    break\n                i = random.randint(0, len(refined) - 3)\n                j = random.randint(i + 2, len(refined) -1)\n                p_i = refined[i]\n                p_j = refined[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut is valid: remove intermediate nodes\n                    refined = refined[:i+1] + refined[j:]\n            return refined\n\n        for iteration in range(self.max_iter):\n            sample = biased_sample(iteration)\n            nearest_start = nearest_node(tree_start, sample)\n            new_pos = steer(nearest_start.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_start = Node(new_pos)\n            new_node_start.cost = nearest_start.cost + math.dist(nearest_start.position, new_pos)\n            new_node_start.parent = nearest_start\n            nearest_start.children.append(new_node_start)\n            tree_start.append(new_node_start)\n            nodes.append(new_node_start)\n            edges.append((nearest_start, new_node_start))\n            rewire(tree_start, new_node_start)\n\n            connected_node = try_connect(tree_start, tree_goal, new_node_start)\n            if connected_node:\n                # Connection established, extract path and shortcut it\n                path = build_path(new_node_start, connected_node)\n                smoothed_path = shortcut_path(path)\n                path_cost = sum(\n                    math.dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1)\n                )\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = smoothed_path\n                    success = True\n                    # Optional early termination on good solution\n                    if best_cost < math.dist(start_position, goal_position)*1.1:\n                        break\n\n            # Swap trees to balance growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner with Adaptive Step Sizing, Dynamic Rewiring, Branch Pruning, and Incremental Path Smoothing for Enhanced Efficiency and Path Quality",
     "planning_mechanism": "The planner grows two trees from start and goal positions alternately using informed sampling restricted to an ellipsoidal heuristic region guided by the best known path cost, integrating goal biasing. It employs adaptive step sizing near obstacles and dynamically adjusts rewiring radius based on node density. The algorithm rewires nodes locally to reduce path cost, prunes branches unlikely to yield better solutions, performs strict collision and edge checks before node/edge additions, and incrementally smooths the best found path to ensure robustness, improved success rate, and high-quality smooth paths.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0, goal_sample_rate: float = 0.15, rewire_base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            # If near obstacle, reduce step size adaptively\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            return tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sampling in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            val = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(val) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _valid_node_and_edge(from_pos, to_pos):\n            if not _in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                for j in range(len(path_in) - 1, idx, -1):\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) \n                        and _in_bounds(path_in[j])):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        # Initialize start and goal nodes costs\n        tree_start[0].cost = 0.0\n        tree_goal[0].cost = 0.0\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample with goal bias and informed sampling region\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _valid_node_and_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            if new_cost + c_min - 1e-9 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            curr_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_radius and n is not new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if _valid_node_and_edge(new_node.position, near.position):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect new_node in tree_a to nearest in tree_b\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_b.position)\n            total_path_cost = new_node.cost + dist_between + nearest_b.cost\n\n            if total_path_cost + 1e-9 < c_best:\n                if _valid_node_and_edge(new_node.position, nearest_b.position):\n                    c_best = total_path_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune trees to reduce search space\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 400 iterations if path found\n            if success and iteration % 400 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        # Final path smoothing\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "A hybrid bidirectional RRT* planner integrating informed sampling from Algorithm 2 and adaptive step sizing plus local rewiring from Algorithm 1, enhanced with pruning, node rejection, and path smoothing to boost planning efficiency, success rate, and path quality.",
     "planning_mechanism": "The planner grows two trees from start and goal positions alternately, using informed heuristic sampling constrained by the current best path cost to focus exploration. It adaptively adjusts step size near obstacles and prunes expansions unlikely to improve the current best path. Each new node undergoes collision and edge checks before insertion. Local rewiring optimizes path cost. Upon connecting both trees with valid edges, a smoothed, near-optimal path is extracted.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / norm_a1\n\n            # Create rotation matrix C aligning x-axis with vector a1\n            eye = np.eye(dim)\n            M = np.outer(a1, eye[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):  # sample up to 100 times to get a valid point\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                x_rand_clip = np.clip(x_rand, [0]*dim, np.array(bounds))\n                x_rand_tuple = tuple(x_rand_clip)\n                if in_bounds(x_rand_tuple):\n                    return x_rand_tuple\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            return tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            step_val = self.step_size\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step_val = max(self.step_size * 0.3, 1.0)\n                    break\n            return step_val\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while True:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not in_bounds(path[j]):\n                        continue\n                    if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        continue\n                    next_idx = j\n                    break\n                smoothed.append(path[next_idx])\n                if next_idx == len(path) - 1:\n                    break\n                idx = next_idx\n            return smoothed\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sampled_point = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sampled_point))\n            step = adaptive_step(nearest.position, sampled_point)\n            new_pos = steer(nearest.position, sampled_point, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune expansions that cannot improve best path cost\n            heuristic_cost = new_cost + math.dist(new_pos, goal)\n            if heuristic_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring to improve costs\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect both trees\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an enhanced RRT* variant with carefully tuned parameters and adaptive behaviors to significantly boost path planning efficiency, success rate, and path quality. It features adaptive neighbor radius shrinking, increased goal bias, dynamic step sizing, and path smoothing via shortcutting to refine the final path and reduce length, ensuring robust collision and edge-validity checks throughout the process.",
     "planning_mechanism": "The planner incrementally grows a tree from the start, samples points with a relatively high goal bias, steers towards samples using an adaptively optimized step size, selects the lowest-cost parent node within a dynamically decreasing neighbor radius, and rewires nearby nodes to improve path cost. It terminates early upon successfully connecting to the goal and applies smoothing heuristics to produce a shorter, obstacle-free path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive step size parameters\n        max_step = self.step_size\n        min_step = max(1.0, max_step * 0.3)\n\n        for i in range(self.max_iter):\n            # Adaptive goal bias: start high for fast goal pronaunce then slightly decay to avoid local minima\n            curr_goal_bias = self.goal_sample_rate * (1 - i / self.max_iter * 0.7) + 0.03\n\n            if random.random() < curr_goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            \n            # Adaptive step size smaller near goal for finer control, larger early on for exploration\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            dynamic_step = max(min_step, min(max_step, dist_to_goal * 0.5, dist))\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * dynamic_step for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n\n            # Collision check for node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Edge collision check - using finer resolution for better safety\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_position)\n\n            # Adaptive neighbor radius shrinks over iterations for efficiency and path refinement\n            radius = max(3.0, self.neighbor_radius * (1.0 - i / self.max_iter))\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent by minimal cost & collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs with updated node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal proximity threshold with margin, check goal connection feasibility\n            dist_to_goal = math.dist(new_position, goal_position)\n            goal_threshold = self.step_size * 1.1\n            if dist_to_goal <= goal_threshold:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.2)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Path smoothing via shortcutting with collision checks\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 150\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm combines bidirectional RRT* with informed sampling and adaptive step sizing to efficiently find high-quality, collision-free paths in 2D or 3D environments. It balances exploration and exploitation by sampling inside an informed ellipsoidal region based on the current best path cost and prunes nodes that cannot improve the solution. The planner rewires nearby nodes to optimize cost dynamically and alternates expansions between the start and goal trees to connect paths quickly.",
     "planning_mechanism": "The planner grows two trees from start and goal, samples points preferentially within an ellipsoidal informed subset reflecting the current best path, and expands trees adaptively while checking collisions. It rewires neighbors to minimize cost and prunes nodes unlikely to yield improvements. The path is updated whenever trees connect with lower cost, ensuring robust convergence toward an optimal path within map bounds.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start == goal:\n            root = Node(start)\n            return PlannerResult(True, [start], [root], [])\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def sample_informed():\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(s, obstacles, is_3d):\n                        return s\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best ** 2 - c_min ** 2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            check_steps = max(2, int(dist))\n            for i in range(1, check_steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / check_steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def rewire(tree, new_node, radius=15.0):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_occurred = True\n            while prune_occurred:\n                prune_occurred = False\n                to_remove = []\n                for node in tree[1:]:  # Do not prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_occurred = True\n\n        for i in range(self.max_iter):\n            curr_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = sample_informed()\n            nearest_node = nearest(curr_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            est_tot_cost = new_cost + math.dist(new_pos, goal)\n            if est_tot_cost >= c_best:\n                continue  # Discard expansions that cannot improve path\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(curr_tree, new_node)\n            prune(curr_tree)\n\n            other_near = nearest(other_tree, new_pos)\n            if self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d):\n                continue\n\n            total_cost = new_node.cost + other_near.cost + math.dist(new_node.position, other_near.position)\n            if total_cost < c_best:\n                c_best = total_cost\n                path_a = new_node.path_from_root()\n                path_b = other_near.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n                prune(tree_start)\n                prune(tree_goal)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Hybrid Anytime RRT* with Dynamic Lazy Collision Checking and Path Shortcutting. This planner integrates the asymptotic optimality of RRT* with lazy collision detection to reduce computational overhead. It includes dynamic adjustment of the neighbor radius based on tree size, adaptive step size scaling near goal for finer exploration, and incorporates an anytime replanning capability by iteratively improving path quality. After an initial feasible path is found, a shortcutting-based smoothing is applied on-the-fly to enhance path quality while maintaining collision safety, all aimed at improving efficiency, path smoothness, robustness, and success rate.",
     "planning_mechanism": "Planning mechanism: The planner grows a single tree incrementally using biased sampling towards the goal and free space. Each sampled point leads to lazy collision-checked rewiring within an adaptively computed neighbor radius, deferring collision checks for edges until necessary. When a path to the goal is found, early stopping allows the initial solution extraction and triggers a shortcutting smoothing procedure on the path during the search. The step size automatically shrinks near the goal to improve precision, and the planner continues to refine the path quality iteratively up to max iterations or timeout.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15, base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            return tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n\n        def sample():\n            # Goal biasing with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            # gamma * (log(n)/n)^{1/d}, gamma=self.base_radius\n            if n <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 25)\n\n        # Lazy collision checking cache for edges:\n        # keys = (parent.position, child.position), values = bool (True = free, False = collision)\n        edge_collision_cache = {}\n\n        def lazy_edge_collision_free(p1, p2):\n            key = (p1, p2)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            # Check node collision first (both ends)\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                edge_collision_cache[key] = False\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                edge_collision_cache[key] = False\n                return False\n            edge_collision_cache[key] = True\n            return True\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def extract_path(goal_node):\n            path_nodes = []\n            node = goal_node\n            while node:\n                path_nodes.append(node.position)\n                node = node.parent\n            return path_nodes[::-1]\n\n        def shortcut_path(path):\n            # Attempt shortcutting by random pairs in path\n            MAX_ATTEMPTS = 30\n            for _ in range(MAX_ATTEMPTS):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    # Remove intermediate nodes from i+1 to j-1\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            radius = adaptive_radius(n)\n\n            sample_point = sample()\n\n            # If near goal, reduce step size adaptively for precision\n            dist_to_goal = dist(sample_point, goal)\n            adaptive_step = self.step_size\n            if dist_to_goal < self.step_size * 3:\n                adaptive_step = max(0.5, self.step_size * (dist_to_goal / (self.step_size * 3)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda node: dist(node.position, sample_point))\n\n            new_pos = steer(nearest.position, sample_point, adaptive_step)\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy check edge collision between nearest and new_pos before adding node\n            if not lazy_edge_collision_free(nearest.position, new_pos):\n                continue\n\n            # Create new node connected to nearest\n            new_node = Node(new_pos)\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            new_node.update_parent(nearest, cost_to_new)\n\n            # Nearby nodes for rewiring\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            # Lazy rewiring with collision checks deferred until needed\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                # Only check edge collision if temp_cost better\n                if temp_cost < min_cost:\n                    if lazy_edge_collision_free(near_node.position, new_pos):\n                        new_node.update_parent(near_node, temp_cost)\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if lazy_edge_collision_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new_node connects to goal within step size and collision free\n            dist_new_to_goal = dist(new_node.position, goal)\n            if dist_new_to_goal <= adaptive_step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, resolution=0.3) == False:\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_new_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best goal solution\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n                    # Early stopping condition if path good enough: here continue to refine path further for anytime property\n\n            # Anytime improvement: attempt shortcutting on best path every N iterations after first solution\n            if success_state and iteration % 100 == 0 and best_goal_node:\n                raw_path = extract_path(best_goal_node)\n                shortcut_path_new = shortcut_path(raw_path)\n                if path_length(shortcut_path_new) + 1e-6 < best_cost:\n                    # Rebuild tree connections along shortcut path\n                    # For result return only path is updated; nodes/edges remain as exploration data\n                    best_cost = path_length(shortcut_path_new)\n                    extracted_path = shortcut_path_new\n\n        # Final path extraction if success but smoothing not performed in last shortcut step\n        if success_state and not extracted_path:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional nature and rewiring optimization of BI-RRT* with the adaptive goal bias, neighbor radius tuning, and path smoothing strategies of the optimized RRT*. It aims to balance rapid exploration, path quality, and robustness by growing two trees from start and goal with adaptive parameters, rewiring locally for optimal cost, and performing shortcut smoothing on the resulting path for efficiency and smoothness. It uses careful collision and edge checks, adaptive sampling, and rewiring to improve success rate and reduce search time.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with adaptive step size and neighbor radius, sampling both randomly and near the goal to guide exploration efficiently. Each extension rewires neighbors to minimize path cost. Whenever the trees can connect collision-free, the path is extracted and smoothed by shortcutting to improve quality and reduce length. Rigorous obstacle and edge collision checks ensure robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15      # Increased goal bias for guidance\n        self.initial_neighbor_radius = 18.0   # Start radius for rewiring\n        self.minimum_neighbor_radius = 5.0    # Minimum radius to keep rewiring efficient\n        self.smooth_trials = 120            # Shortcut smoothing trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                      # Tuple[int, ...]\n        dim = len(bounds)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacle descriptions\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        # Helper functions for sampling, nearest, near nodes, steering\n        def sample_point(iteration):\n            # Adaptive goal bias - sample goal sometimes to speed up convergence\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                # Occasionally bias samples near goal to speed connections\n                bias_prob = 0.1\n                if random.random() < bias_prob:\n                    radius = max(bounds[d]*0.1 for d in range(dim))\n                    return tuple(\n                        max(0, min(bounds[d], random.gauss(goal_position[d], radius)))\n                        for d in range(dim)\n                    )\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_connect_nodes(from_node, to_point):\n            # Steer from from_node toward to_point considering obstacles\n            new_pos = steer(from_node.position, to_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(from_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                return None\n            return new_pos\n\n        def add_node(tree, nodes_collection, edges_collection, new_pos, near_nodes_list):\n            # Select best parent to minimize cost\n            min_cost = math.dist(tree[0].position, new_pos) + 1e9   # large initial cost\n            best_parent = None\n            for near_node in near_nodes_list:\n                cost_candidate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes_collection.append(new_node)\n            edges_collection.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for near_node in near_nodes_list:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                    if near_node.parent:\n                        try:\n                            edges_collection.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.children.append(near_node)\n                    edges_collection.append((new_node, near_node))\n            return new_node\n\n        def connect_trees(tree_a, tree_b):\n            # Attempt to connect nearest nodes between two trees with edge checks and rewiring\n            # Return tuple(new_node_from_a, new_node_from_b) if connected else (None, None)\n\n            # Use adaptive radius for connections\n            radius = max(self.minimum_neighbor_radius, self.initial_neighbor_radius * (1 - iteration / self.max_iter))\n\n            for node_a in tree_a[-10:]:  # limit attempts to recent added nodes to reduce compute\n                near_b_nodes = near_nodes(tree_b, node_a.position, radius)\n                for node_b in near_b_nodes:\n                    if not self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d, resolution=0.5):\n                        return node_a, node_b\n            return None, None\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            # Alternate growing start and goal trees\n            tree_current, tree_other = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            sample = sample_point(iteration)\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_current, sample)\n            new_pos = try_connect_nodes(nearest_node, sample)\n            if new_pos is None:\n                continue\n\n            radius = max(self.minimum_neighbor_radius, self.initial_neighbor_radius * (1 - iteration / self.max_iter))\n            near_nodes_list = near_nodes(tree_current, new_pos, radius)\n\n            new_node = add_node(tree_current, nodes, edges, new_pos, near_nodes_list)\n            if new_node is None:\n                continue\n\n            # Try connecting opposite tree to new_node\n            nearest_in_other = nearest(tree_other, new_node.position)\n            connect_pos = try_connect_nodes(nearest_in_other, new_node.position)\n            if connect_pos is not None:\n                # Add connecting node to opposite tree\n                near_nodes_other = near_nodes(tree_other, connect_pos, radius)\n                connect_node = add_node(tree_other, nodes, edges, connect_pos, near_nodes_other)\n                if connect_node is not None:\n                    dist_between = math.dist(connect_node.position, new_node.position)\n                    if dist_between <= self.step_size * 1.5:\n                        # Connection successful, extract path\n                        path_from_start = new_node.path_from_root() if tree_current is tree_start else connect_node.path_from_root()\n                        path_from_goal = connect_node.path_from_root() if tree_current is tree_start else new_node.path_from_root()\n                        extracted_path = path_from_start + path_from_goal[::-1]\n                        success_state = True\n                        break\n\n            # Additionally attempt direct connects between trees to improve success rate\n            node_a, node_b = connect_trees(tree_start, tree_goal)\n            if node_a and node_b:\n                path_from_start = node_a.path_from_root()\n                path_from_goal = node_b.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1]\n                success_state = True\n                break\n\n        # Path smoothing by shortcutting after successful planning\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        max_trials = self.smooth_trials\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.5):\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "A bidirectional informed RRT* planner that grows two trees from start and goal positions using heuristic-based informed sampling within an ellipsoidal subset, adaptive step sizing based on obstacle proximity, and dynamic rewiring for path cost improvement. The planner performs rigorous collision checks before adding nodes and edges, prunes inefficient extensions, and applies post-processing smoothing to yield high-quality, robust, and efficient paths.",
     "planning_mechanism": "A planner that alternates incremental growth between start and goal trees, samples points biased towards promising regions delimited by the current best path cost, adapts expansion steps to avoid obstacles, rewires locally to optimize path costs, attempts early tree connections to find feasible paths quickly, and refines solutions by smoothing the final path.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import numpy as np\n        \n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n        all_nodes: List[Node] = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate expanding between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size based on obstacle proximity\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            # Check bounds and collisions for new node\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Calculate new cost and prune if no improvement possible\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position)\n            # Double check the new node position is collision free before connecting\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                continue\n\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nodes in tree_a within rewire radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node under new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in other tree\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Check edge collision\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    success_state = True\n\n                    # Optional pruning could be placed here to prune nodes outside best path ellipsoid\n\n        # Path smoothing to improve final solution\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import random\n        import math\n\n        if c_best == float('inf'):\n            # Uniform sampling in entire bounds if no solution found yet\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Compute rotation matrix C such that C * e1 = a1\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        r2_sq = c_best**2 - c_min**2\n        r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacle but maintain min step of 1.0\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "A refined hybrid informed bidirectional RRT*-Connect planner combining informed ellipsoidal sampling, adaptive step size adjustment near obstacles, efficient rewiring, goal biasing, and dynamic pruning to improve planning efficiency, path quality, and success rate. It adaptively balances exploration and exploitation by alternating tree growth from start and goal states and aggressively connects and rewires to approach optimality, followed by post-processing smoothing for robust, shorter paths.",
     "planning_mechanism": "The planner grows two trees bidirectionally using informed sampling concentrated in an ellipsoidal subset of the search space defined by the current best path cost, adaptively adjusting expansion steps near obstacles to prevent collisions. At each iteration, it alternates expansions between the start and goal trees, attempts early and frequent connections, and locally rewires nodes for cost improvements. It prunes branches that cannot improve the current best path cost to accelerate convergence and applies a smoothing procedure on the final path to improve smoothness and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.15, rewire_radius: float = 18.0,\n                 prune_threshold: float = 1e-6):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        # Helps prune nodes that cannot improve best cost\n        def can_improve_cost(node):\n            return node.cost + math.dist(node.position, goal_position if node in tree_start else start_position) < c_best - self.prune_threshold\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            min_step = self.base_step * 0.4\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(min_step, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal_position if tree_a == tree_start else start_position\n\n            # Sampling with goal bias and informed ellipsoidal sampling\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not all(0 <= new_position[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - self.prune_threshold >= c_best:\n                # Prune unpromising expansions\n                continue\n\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Near nodes for rewiring\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            # Rewire near nodes if cheaper path found via new_node\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + self.prune_threshold < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_btwn_trees = math.dist(new_node.position, nearest_other.position)\n            total_cost = new_node.cost + dist_btwn_trees + nearest_other.cost\n            if total_cost + self.prune_threshold < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune nodes that cannot improve new best cost\n                    # Remove far nodes in both trees with cost + heuristic \u2265 c_best\n                    def prune_tree(tree):\n                        pruned_nodes = []\n                        for node in tree[:]:  # copy to avoid iteration issues\n                            # heuristic cost to goal (or start if tree is goal tree)\n                            heuristic = math.dist(node.position, goal_position if tree == tree_start else start_position)\n                            if node.cost + heuristic >= c_best - self.prune_threshold and node != tree[0]:\n                                # Disconnect subtree\n                                if node.parent:\n                                    node.parent.remove_child(node)\n                                tree.remove(node)\n                                pruned_nodes.append(node)\n                        return pruned_nodes\n\n                    prune_tree(tree_start)\n                    prune_tree(tree_goal)\n\n        # Post-process: path smoothing\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        N = len(path)\n        while idx < N - 1:\n            next_idx = N - 1\n            for j in range(N - 1, idx, -1):\n                if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d) and all(0 <= path[j][d] <= bounds[d] for d in range(len(bounds))):\n                    next_idx = j\n                    break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Assumes obstacles are axis-aligned bounding boxes: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "An adaptive single-tree RRT* planner with informed sampling and goal biasing to efficiently explore the space and optimize path cost while maintaining collision-free conditions. The algorithm balances exploration and exploitation via adaptive neighbor radius, rewiring for path improvement, and early termination upon reaching the goal.",
     "planning_mechanism": "The planner samples points biased towards the goal and within an ellipsoidal informed subset after an initial path is found. It incrementally builds a tree by extending toward sampled points, connects new nodes optimally by selecting best parent from nearby nodes, rewires neighbors to reduce path cost, and stops early once the goal is reached, thus improving planning efficiency and path quality.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost to reach this node\n        self.children = []\n        self.valid = True               # For validity checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.1, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_in_bounds():\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def informed_sample(c_best):\n            c_min = dist(start_position, goal_position)\n            if c_best == float('inf') or c_best < c_min:\n                return sample_in_bounds()\n\n            dx = (goal_position[0] - start_position[0]) / c_min\n            dy = (goal_position[1] - start_position[1]) / c_min\n            if is_3d:\n                dz = (goal_position[2] - start_position[2]) / c_min\n\n            a = c_best / 2.0\n            b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n            while True:\n                if is_3d:\n                    x, y, z = (random.uniform(-1, 1) for _ in range(3))\n                    if x * x + y * y + z * z > 1:\n                        continue\n                    px = a * x\n                    py = b * y\n                    pz = b * z\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                        start_position[2] + (c_min/2)*dz + pz,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(3)):\n                        return sample\n                else:\n                    x, y = (random.uniform(-1, 1) for _ in range(2))\n                    if x * x + y * y > 1:\n                        continue\n                    px = a * x\n                    py = b * y\n                    sample = (\n                        start_position[0] + (c_min / 2) * dx + px,\n                        start_position[1] + (c_min / 2) * dy + py,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(2)):\n                        return sample\n\n        for _ in range(self.max_iter):\n            n = len(nodes)\n            dim = len(bounds)\n            gamma = self.base_neighbor_radius\n            r = min(gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 20)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif best_goal_cost == float('inf'):\n                sample = sample_in_bounds()\n            else:\n                sample = informed_sample(best_goal_cost)\n\n            nearest_node = min(nodes, key=lambda node: dist(node.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit_direction = tuple(d / dist_to_sample for d in direction)\n            step_size = min(self.step_size, dist_to_sample)\n            new_pos = tuple(nearest_node.position[d] + unit_direction[d]*step_size for d in range(dim))\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= r]\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                        near_node.parent.children.remove(near_node)\n                    except (ValueError, AttributeError):\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            dist_to_goal = dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        goal_node = Node(goal_position)\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        break\n\n        if success_state and goal_node:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid RRT*-PRM planner integrating fast informed sampling, dynamic rewiring, and roadmap connection to accelerate convergence and improve path quality and robustness. It balances exploration with exploitation by using adaptive sampling biases near the goal and promising nodes, dynamically adjusting neighbor radius, and connecting disjoint roadmap components to avoid local minima. Post-processing with path smoothing ensures output paths are short and smooth.",
     "planning_mechanism": "The planner incrementally builds a tree from the start node using RRT* principles, enhanced with adaptive, biased sampling strategies\u2014favoring samples near the goal or nodes with low cost\u2014to guide the search efficiently. It periodically attempts to connect newly added nodes to existing roadmap nodes within a dynamically scaled neighbor radius for shortened paths. Collision checks prevent invalid expansions. The tree rewires neighbors to reduce path costs continuously. Upon reaching the goal vicinity, it finalizes the path and applies a shortcut smoothing heuristic to optimize it.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision check flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15    # Probability of sampling the goal\n        self.bias_sample_rate = 0.20    # Probability of biased sample near promising nodes\n        self.neighbor_base_radius = 15.0\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Maintain a subset of promising nodes for biased sampling (nodes with low cost)\n        promising_nodes = [root]\n\n        for i in range(self.max_iter):\n            # Adaptive radius shrinks as iteration progresses\n            radius = max(5.0, self.neighbor_base_radius * (1.0 - i / self.max_iter))\n\n            # Sampling strategy: goal bias, biased toward promising nodes, or uniform random\n            sample = None\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_position\n            elif p < self.goal_sample_rate + self.bias_sample_rate and len(promising_nodes) > 0:\n                # Biased sampling: random neighborhood of a randomly picked promising node\n                base_node = random.choice(promising_nodes)\n                sample = self._sample_near_node(base_node.position, bounds, obstacles, is_3d,\n                                                radius=self.step_size*3, max_trials=30)\n                if sample is None:\n                    # fallback to uniform random\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step_dist = min(self.step_size, dist)\n            unit_dir = tuple(direction[d]/dist for d in range(dim))\n            new_pos = tuple(nearest_node.position[d] + unit_dir[d]*step_dist for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Find neighbors in radius for parent selection and rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + math.dist(near.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n\n            # Add new node\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Update promising nodes list on improvements near goal and low-cost nodes\n            if new_node.cost < 1.1 * (math.dist(start_position, goal_position)):\n                promising_nodes.append(new_node)\n                # Keep promising nodes list size tractable\n                if len(promising_nodes) > 50:\n                    promising_nodes = sorted(promising_nodes, key=lambda n: n.cost)[:40]\n\n            # Check if goal reachable with tolerance and edge check\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size * 1.1:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, resolution=0.3) \\\n                   and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        # If success, perform path smoothing by shortcuts\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, trials=self.smooth_trials)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_near_node(self, base_pos, bounds, obstacles, is_3d, radius=10.0, max_trials=20):\n        import random\n        import math\n        dim = len(bounds)\n        for _ in range(max_trials):\n            sample = tuple(base_pos[d] + random.uniform(-radius, radius) for d in range(dim))\n            # clamp in bounds\n            sample = tuple(max(0, min(bounds[d], sample[d])) for d in range(dim))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        for _ in range(trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # shortcut valid - remove intermediate points\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional growth and tree swapping of BI-RRT with the informed sampling, adaptive step sizing, rewiring, and pruning strategies of RRT*-Connect. It grows two trees simultaneously from the start and goal, utilizes heuristic-informed sampling within an ellipse shaped by the current best path cost to focus exploration, adapts step size near obstacles to enhance safety and efficiency, prunes nodes that cannot improve the solution, rewires locally to optimize path costs, and swaps trees iteratively to balance exploration. This approach improves planning efficiency, path quality, robustness, success rate, and reduces search time and path length in both 2D and 3D environments.",
     "planning_mechanism": "The planner samples points informed by the current best path cost to bias search toward promising regions. It expands trees bidirectionally with adaptive step sizes to avoid obstacles and improve safety. Upon adding new nodes, local rewiring optimizes paths by reducing costs, and pruning discards nodes unlikely to improve the best path. The two trees attempt connection on each iteration, with paths reconstructed and updated when successful, producing shorter, smoother, and more reliable paths efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success = False\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Informed sampling\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n\n            # Find nearest in tree_a and adaptive step size\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Check node feasibility\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve current best path\n            est_total_cost = cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes in tree_a\n            near_nodes = [n for n in tree_a if n is not new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                dist_new_to_near = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_new_to_near\n                if potential_cost < near.cost:\n                    # Check edge feasibility before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if near.parent is not None:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Rewire\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                path_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Construct full path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    best_path = path_a + path_b[::-1]\n                    success = True\n\n                    # Prune nodes in both trees that can't improve better than c_best\n                    self._prune_tree(tree_start, c_best, goal_pos, obstacles, is_3d)\n                    self._prune_tree(tree_goal, c_best, start_pos, obstacles, is_3d)\n\n            # Swap trees for next iteration\n            if i % 2 == 0:\n                tree_start, tree_goal = tree_a, tree_b\n            else:\n                tree_goal, tree_start = tree_a, tree_b\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float('inf'):\n            # Uniform random sample in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        c_best = max(c_best, c_min)  # Ensure c_best >= c_min\n        x_center_np = (np.array(start) + np.array(goal)) / 2\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Start and goal coincide\n            return tuple(start)\n        a1 = a1 / norm_a1\n\n        # Create orthonormal basis\n        id1 = np.zeros((dim,))\n        id1[0] = 1\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        if c_best * c_best - c_min * c_min < 0:\n            r2_val = 0\n        else:\n            r2_val = math.sqrt(c_best * c_best - c_min * c_min) / 2\n        L = np.diag([r1] + [r2_val] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_ball = np.linalg.norm(x_ball)\n            if norm_ball == 0:\n                continue\n            x_ball = x_ball / norm_ball\n            radius_sample = random.random() ** (1 / dim)\n            x_ball = x_ball * radius_sample\n            x_rand = C @ L @ x_ball + x_center_np\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step near obstacle but keep minimum 1.0 to avoid too small steps\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _prune_tree(self, tree, c_best, opposite_root_pos, obstacles, is_3d):\n        import math\n        # Remove nodes whose cost + heuristic to goal exceed c_best\n        to_remove = []\n        for node in tree:\n            heuristic = math.dist(node.position, opposite_root_pos)\n            if node.cost + heuristic >= c_best:\n                to_remove.append(node)\n        for node in to_remove:\n            # Avoid removing root nodes\n            if node.parent is None:\n                continue\n            # Disconnect node from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        # Remove children recursively\n        for c in list(node.children):\n            self._remove_subtree(c, tree)\n        if node in tree:\n            tree.remove(node)\n        node.children.clear()\n        node.parent = None",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm implements an enhanced Bidirectional RRT* planner with goal biasing, informed sampling, adaptive rewiring radius, and path smoothing to improve planning efficiency, path quality, robustness, and success rate. It dynamically expands two trees from start and goal, rewires nodes based on cost, and attempts connections while carefully avoiding obstacles. Once a path is found, it performs post-processing smoothing to reduce path length and increase smoothness.",
     "planning_mechanism": "The planner samples points preferentially near the line connecting start and goal (informed sampling), uses a goal bias to accelerate convergence, employs an adaptive radius for rewiring based on the number of nodes in each tree, and alternates tree expansions bidirectionally. It includes rigorous collision checks for nodes and edges. When connection occurs, the path is extracted and smoothed by shortcutting.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1   # Probability of sampling goal to bias search\n        self.rewire_constant = 30.0   # Constant factor for rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n\n            # Goal biasing: sample goal directly with some probability\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._informed_sample(bounds, obstacles, is_3d, start_position, goal_position)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a  \n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b is not None:\n                # Connection successful - reconstruct and smooth path\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                raw_path = path_a + path_b[::-1]\n                extracted_path = self._smooth_path(raw_path, obstacles, is_3d)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal):\n        # Samples inside an ellipsoidal informed region between start and goal to focus search and improve path quality\n        import random, math\n\n        dim = len(bounds)\n        c_best = math.dist(start, goal)\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        unit_vec = tuple((goal[i] - start[i]) / c_best if c_best > 0 else 0.0 for i in range(dim))\n\n        # Radii of ellipsoid (min radius is step_size)\n        radii = [c_best / 2 if i == 0 else math.sqrt(c_best**2 - self.step_size**2) / 2 for i in range(dim)]\n\n        # Sample random point in unit n-ball\n        while True:\n            # Sample in unit n-ball\n            point_ball = self._sample_unit_ball(dim)\n            # Scale by radii\n            scaled = tuple(point_ball[i] * radii[i] for i in range(dim))\n\n            # Rotate scaled point to align with the axis from start to goal\n            rotated = self._rotate_to_unit_vector(scaled, unit_vec)\n\n            sample_point = tuple(center[i] + rotated[i] for i in range(dim))\n            # Check bounds and obstacle free\n            if all(0 <= sample_point[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                return sample_point\n\n    def _sample_unit_ball(self, dim):\n        import random, math\n        # Marsaglia method for uniform distribution in n-ball\n        while True:\n            coords = [random.uniform(-1, 1) for _ in range(dim)]\n            length_sq = sum(x*x for x in coords)\n            if 0 < length_sq <= 1:\n                scale = random.random() ** (1.0/dim) / (length_sq ** 0.5)\n                return tuple(x * scale for x in coords)\n\n    def _rotate_to_unit_vector(self, vec, unit_vec):\n        # Rotate vec so that x-axis aligns with unit_vec in dim-dimensional space (dim=2 or 3)\n        # For 2D and 3D only\n        import math\n        dim = len(vec)\n        if dim == 2:\n            # Angle between x-axis and unit_vec\n            angle = math.atan2(unit_vec[1], unit_vec[0])\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n            x, y = vec\n            return (cos_a * x - sin_a * y, sin_a * x + cos_a * y)\n        elif dim == 3:\n            # Rotate using Rodrigues' rotation formula\n            # unit_vec is axis; rotation aligns x-axis to unit_vec\n            x_axis = (1, 0, 0)\n            v = unit_vec\n            # cross product x_axis x v\n            import numpy as np\n            a = np.array(x_axis)\n            b = np.array(v)\n            cross = np.cross(a, b)\n            dot = np.dot(a, b)\n            if np.linalg.norm(cross) < 1e-10:\n                return vec  # Already aligned or opposite\n            k = cross / np.linalg.norm(cross)\n            vec_np = np.array(vec)\n            cos_theta = dot\n            sin_theta = np.linalg.norm(cross)\n            rotated = (vec_np * cos_theta +\n                       np.cross(k, vec_np) * sin_theta +\n                       k * np.dot(k, vec_np) * (1 - cos_theta))\n            return tuple(rotated.tolist())\n        else:\n            # No rotation for other dims\n            return vec\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        if not tree:\n            return []\n        n = len(tree) + 1\n        radius = min(self.rewire_constant * (math.log(n) / n) ** 0.5, self.step_size * 5)  # Adaptive radius\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    if neighbor.parent.children and neighbor in neighbor.parent.children:\n                        neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        last_node = None\n\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor.parent.children and neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                last_node = connect_node\n                break\n\n            nearest = connect_node\n\n        return last_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) <= 2:\n            return path\n\n        smooth_path = path[:]\n        max_attempts = 100\n        attempt = 0\n\n        while attempt < max_attempts:\n            if len(smooth_path) <= 2:\n                break\n            i = random.randint(0, len(smooth_path) - 2)\n            j = random.randint(i + 1, len(smooth_path) - 1)\n\n            p1, p2 = smooth_path[i], smooth_path[j]\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                attempt += 1\n                continue\n\n            # Remove intermediate points between i and j\n            smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            attempt += 1\n\n        return smooth_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This is an optimized RRT* (Rapidly-exploring Random Tree Star) planner that improves path planning efficiency and path quality by introducing goal biasing, adaptive neighbor radius based on the iteration number, and a refined rewiring strategy. It ensures robustness and path smoothness by meticulous collision checking and node steering within bounds, balancing exploration and exploitation for faster convergence and higher success rates.",
     "planning_mechanism": "The planner samples points with a bias towards the goal, extends the tree by steering from the nearest node within a fixed step size, dynamically adjusts the neighborhood radius for selecting parents and rewiring, and rewire nodes for cost optimality while always checking for collision-free nodes and edges. The path is extracted once a connection to the goal is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1, \n                 neighbor_radius_initial: float = 15.0, neighbor_radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_initial = neighbor_radius_initial\n        self.neighbor_radius_min = neighbor_radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: list[tuple[float, ...]] = []\n        nodes: list[Node] = []\n        edges: list[tuple[Node, Node]] = []\n\n        root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(root)\n\n        def in_bounds(pos):\n            # Check if position lies within the map bounds (inclusive)\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        for i in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius decreasing with iteration count\n            neighbor_radius = max(\n                self.neighbor_radius_min,\n                self.neighbor_radius_initial * (1 - (i / self.max_iter))\n            )\n\n            # Sampling with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards sample with step size limit\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Find nearby nodes for parent selection and rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                # Check if path from near_node to new_position is collision free and cost less\n                dist_to_new = math.dist(near_node.position, new_position)\n                if dist_to_new == 0:\n                    continue\n                tentative_cost = near_node.cost + dist_to_new\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = near_node\n\n            new_node = Node(new_position)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: try to improve paths of neighbors through new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                dist_back = math.dist(new_node.position, near_node.position)\n                if dist_back == 0:\n                    continue\n                cost_through_new = new_node.cost + dist_back\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect directly to goal\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path from goal_node back to root\n                    path = []\n                    cur = goal_node\n                    while cur is not None:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "A simplified hybrid bidirectional informed RRT* planner combining the strengths of informed sampling, adaptive step sizing, dynamic rewiring, branch pruning, and incremental path smoothing to efficiently generate high-quality, smooth, and robust paths with improved success rate and reduced search time.",
     "planning_mechanism": "The planner alternately grows two trees from start and goal positions using an ellipsoidal informed sampling strategy constrained by the best known path cost. It adaptively determines step sizes near obstacles to ensure safety and efficiency. New nodes and edges undergo strict collision and edge feasibility checks. Local rewiring is dynamically performed based on neighborhood density to optimize path costs. Branch pruning removes nodes unlikely to improve solutions, and incremental smoothing refines the current best path periodically, balancing exploration and exploitation for optimal path discovery.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, rewire_base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a / length\n            M = np.outer(a_unit, np.eye(dim)[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            val = max(c_best_val ** 2 - c_min ** 2, 0)\n            r2 = math.sqrt(val) / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1 / dim)\n                x_ball *= scale\n                sampled = C @ L @ x_ball + center\n                if np.all((sampled >= 0) & (sampled <= np.array(bounds))):\n                    return tuple(sampled)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist_full = dist(from_pos, to_pos)\n            max_pts = max(5, int(dist_full))\n            for i in range(1, max_pts + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_pts for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.4, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            return tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n\n        def rewire_radius(n_nodes):\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            val = (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return min(gamma * val, self.step_size * 25)\n\n        def valid_new_node_and_edge(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def prune_nodes(tree_nodes, cost_threshold):\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def smooth_path(path_in: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                for j in range(len(path_in) - 1, idx, -1):\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) and in_bounds(path_in[j])):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx + 1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = informed_sample(c_best)\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not valid_new_node_and_edge(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            if new_cost + c_min - 1e-9 >= c_best:\n                continue\n\n            new_node = Node(new_pos, cost=new_cost)\n            new_node.parent = nearest\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            curr_radius = rewire_radius(len(tree_a))\n            near_nodes = [n for n in tree_a if n is not new_node and dist(n.position, new_node.position) <= curr_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if valid_new_node_and_edge(new_node.position, near.position):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_b.position)\n            total_cost = new_node.cost + dist_between + nearest_b.cost\n\n            if total_cost + 1e-9 < c_best:\n                if valid_new_node_and_edge(new_node.position, nearest_b.position):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    prune_nodes(tree_start, c_best)\n                    prune_nodes(tree_goal, c_best)\n\n            if success and i % 400 == 0 and len(best_path) > 3:\n                best_path = smooth_path(best_path)\n\n        if success and len(best_path) > 2:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d and len(obs) == 6:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            elif not is_3d and len(obs) == 4:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "The proposed algorithm is \"Bidirectional Anytime RRT*\", combining bidirectional search with anytime path improvement. It initially performs a fast path search using bidirectional RRT to quickly find a feasible path. Then it iteratively improves the path quality by rewiring and shortcutting, while also dynamically adjusting the search radius and step size. This approach enhances planning efficiency, path quality, success rate, and smoothness by balancing rapid exploration and continuous optimization.",
     "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal states using adaptive step sizes and radii. It tries to connect these trees quickly for a feasible solution. Upon first connection, it repeatedly refines the discovered path by local shortcutting and rewiring nearby nodes to lower total cost, enabling anytime improvements during available computation time. Collision checks are performed for both nodes and edges in all steps to ensure correctness and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # cumulative cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.base_radius = step_size * 4.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def collision_check(node_pos):\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_check(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # avoid duplicate connecting node\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def add_edge(p, c):\n            edges.append((p, c))\n            p.add_child(c)\n            nodes.append(c)\n\n        def try_extend(tree, point, radius, step):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, step)\n            if not collision_check(new_pos):\n                return None\n            if not edge_check(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent with minimum cost + edge cost and feasible edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if edge_check(nbr.position, new_pos):\n                    cost = nbr.cost + dist(nbr.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                if edge_check(new_node.position, nbr.position):\n                    new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost:\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.children.remove(nbr)\n                            except Exception:\n                                pass\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n            return new_node\n\n        def connect_trees(node_from, tree_to, radius, step):\n            nearest_node = nearest(tree_to, node_from.position)\n            cur = nearest_node\n            last_added = None\n            while True:\n                new_pos = steer(cur.position, node_from.position, step)\n                if not collision_check(new_pos):\n                    return None\n                if not edge_check(cur.position, new_pos):\n                    return None\n\n                # If new_pos is very close to node_from, connect directly\n                dist_to_target = dist(new_pos, node_from.position)\n                connect_direct = dist_to_target <= step\n\n                neighbors = near_nodes(tree_to, new_pos, radius)\n                min_cost = cur.cost + dist(cur.position, new_pos)\n                best_parent = cur\n                for nbr in neighbors:\n                    if edge_check(nbr.position, new_pos):\n                        cost = nbr.cost + dist(nbr.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                new_node.parent = best_parent\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    if edge_check(new_node.position, nbr.position):\n                        new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                        if new_cost < nbr.cost:\n                            if nbr.parent:\n                                try:\n                                    edges.remove((nbr.parent, nbr))\n                                    nbr.parent.children.remove(nbr)\n                                except Exception:\n                                    pass\n                            nbr.parent = new_node\n                            nbr.cost = new_cost\n                            new_node.add_child(nbr)\n                            edges.append((new_node, nbr))\n\n                if connect_direct:\n                    # final connection node to node_from\n                    if not collision_check(node_from.position):\n                        return None\n                    if not edge_check(new_node.position, node_from.position):\n                        return None\n                    last_node = Node(node_from.position)\n                    last_node.cost = new_node.cost + dist(new_node.position, node_from.position)\n                    new_node.add_child(last_node)\n                    last_node.parent = new_node\n                    tree_to.append(last_node)\n                    nodes.append(last_node)\n                    edges.append((new_node, last_node))\n                    return last_node\n\n                cur = new_node\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) <= 2:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n\n                p1, p2 = path[i], path[j]\n                if not edge_check(p1, p2):\n                    continue\n                # if edge is valid, shortcut path by removing intermediates\n                path = path[:i + 1] + path[j:]\n            return path\n\n        time_start = time.time()\n        radius = self.base_radius\n        step = self.base_step_size\n\n        for iter in range(1, self.max_iter+1):\n            # Adaptive step size & radius shrinking over iterations to refine path\n            if iter % 500 == 0:\n                radius = max(self.base_step_size * 2, radius * 0.85)\n                step = max(self.base_step_size * 0.5, step * 0.9)\n\n            # Sample a valid random point\n            while True:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if collision_check(rand_point):\n                    break\n\n            # Extend start tree towards sample\n            new_start_node = try_extend(start_tree, rand_point, radius, step)\n            if new_start_node is None:\n                # Swap trees and continue\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            # Try connect goal tree to new node\n            connected_node = connect_trees(new_start_node, goal_tree, radius, step)\n            if connected_node:\n                success_state = True\n                extracted_path = extract_path(new_start_node, connected_node)\n\n                # Perform anytime path improvement via shortcutting & rewiring limited by time\n                time_budget = 0.5  # seconds for refinement per run after success\n                t_ref_start = time.time()\n                while time.time() - t_ref_start < time_budget:\n                    # Shortcut the current path to smooth and shorten\n                    extracted_path = shortcut_path(extracted_path, max_attempts=20)\n\n                    # Try rewiring each node along the path locally\n                    for node in nodes:\n                        if node.parent is None:\n                            continue\n                        neighbors = near_nodes(nodes, node.position, radius)\n                        for nbr in neighbors:\n                            if nbr == node or nbr == node.parent:\n                                continue\n                            if edge_check(nbr.position, node.position):\n                                new_cost = nbr.cost + dist(nbr.position, node.position)\n                                if new_cost < node.cost:\n                                    # Rewire node to nbr\n                                    if node.parent:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                            node.parent.children.remove(node)\n                                        except Exception:\n                                            pass\n                                    node.parent = nbr\n                                    node.cost = new_cost\n                                    nbr.add_child(node)\n                                    edges.append((nbr, node))\n\n                    # Re-extract path after rewiring start and goal trees roots\n                    start_closest = nearest(start_tree, goal_position)\n                    goal_closest = nearest(goal_tree, start_position)\n                    extracted_path = extract_path(start_closest, goal_closest)\n\n                break\n\n            # Swap to grow other tree next iteration\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return type('PlannerResult', (), dict(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Informed Bidirectional RRT-Connect with Adaptive Step Sizing, Dynamic Rewiring, and Path Smoothing",
     "planning_mechanism": "The planner grows two trees from the start and goal positions. It performs informed sampling within an ellipsoidal subset biased by the current best path cost to focus exploration. Adaptive step sizing reduces step length near obstacles improving success in cluttered environments. Each extension checks for collision-free nodes and edges. Dynamic rewiring locally optimizes path costs by reconnecting nodes within a fixed radius. Trees attempt early connections to quickly find feasible paths and improve solution quality. Finally, post-processing smoothing refines the path for smoothness and shorter overall length. This hybrid approach combines rapid exploration, cost optimization, and robustness against obstacles.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        success_state = False\n        extracted_path = []\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best**2 - c_min**2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias for one tree and informed for the other\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire locally for optimization\n            rewire(tree_a, new_node)\n\n            # Attempt to connect trees\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n\n            if total_cost + 1e-6 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    success_state = True\n\n        # Path smoothing post-processing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        max_iter = 100\n        for _ in range(max_iter):\n            if len(smoothed) <= 2:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m1",
     "algorithm_description": "The algorithm is an enhanced bidirectional RRT-Connect variant that integrates heuristic-biased sampling towards the goal, adaptive step sizing, and path smoothing. It grows two trees simultaneously from the start and goal, attempts to connect them efficiently, and improves the path quality by shortcut smoothing.",
     "planning_mechanism": "The planner alternates growth of two RRT trees towards randomly sampled points with a goal bias to speed convergence, uses adaptive step sizes to efficiently explore open spaces, and attempts tree connections with rigorous collision checks. Upon successful connection, the final path is extracted and smoothed by shortcutting unnecessary nodes to improve path quality and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def path_cost_from_root(self):\n        cost = 0.0\n        node = self\n        while node.parent is not None:\n            cost += self._distance(node.position, node.parent.position)\n            node = node.parent\n        return cost\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, max_len):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_len:\n                return to_pos\n            ratio = max_len / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def try_extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            adaptive_step = self.adaptive_step_size(nearest_node.position, target_point, bounds)\n            new_pos = steer(nearest_node.position, target_point, adaptive_step)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(node_from, tree_to):\n            current = node_from\n            while True:\n                nearest_node = nearest(tree_to, current.position)\n                if self._is_edge_in_obstacle(current.position, nearest_node.position, obstacles, is_3d):\n                    return None  # No path between them\n                dist = math.dist(current.position, nearest_node.position)\n                if dist <= self.step_size:\n                    # Connect directly\n                    return nearest_node\n                new_pos = steer(nearest_node.position, current.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                nearest_node = new_node\n                current = current\n\n        def extract_path(meet_node_a, meet_node_b):\n            path_a = meet_node_a.path_from_root()\n            path_b = meet_node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by skipping intermediate nodes when direct line is collision free\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate tree growing\n            new_node_start = try_extend(start_tree, rnd_point)\n            if new_node_start:\n                new_node_goal = connect_trees(new_node_start, goal_tree)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_path(new_node_start, new_node_goal)\n                    extracted_path = shortcut_path(extracted_path)\n                    break\n\n            new_node_goal = try_extend(goal_tree, rnd_point)\n            if new_node_goal:\n                new_node_start = connect_trees(new_node_goal, start_tree)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_path(new_node_start, new_node_goal)\n                    extracted_path = shortcut_path(extracted_path)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def adaptive_step_size(self, from_pos, to_pos, bounds, min_step=1.0, max_step=7.0):\n        \"\"\"\n        Adaptive step size: increase step if free space is likely large,\n        reduce if close to boundary or obstacles (not explicitly checking obstacles here for speed).\n        \"\"\"\n        import math\n\n        dist_to_goal = math.dist(from_pos, to_pos)\n        # Reduce step size near map boundaries\n        margin = 5.0\n        for i, coord in enumerate(from_pos):\n            if coord < margin or coord > bounds[i] - margin:\n                return max(min_step, self.step_size * 0.5)\n        # Adaptive step proportional to distance, bounded\n        adaptive_step = min(max_step, max(min_step, dist_to_goal, self.step_size))\n        return adaptive_step\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m2",
     "algorithm_description": "This planner is a hybrid bidirectional RRT*-based algorithm that combines informed elliptical sampling, adaptive step sizing near obstacles, aggressive pruning, and rewiring to efficiently find high-quality collision-free paths. It grows two trees from start and goal, samples within an ellipsoid informed by the current best path cost, and rewires nodes locally for cost improvement. The planner prunes nodes that cannot yield better solutions, ensuring focused search and faster convergence with smooth and robust paths.",
     "planning_mechanism": "The planner alternately grows start and goal trees by sampling informed points in the ellipsoidal subset that can improve the current best path. Each expansion respects adaptive step sizes near obstacles and bounds. Rewiring connects nodes for cost improvements. When the trees connect, the best path is updated and aggressive pruning removes suboptimal branches, accelerating convergence and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(True, [start], nodes, edges)\n\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # fallback uniform random valid sample\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal edges, nodes\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                to_remove = []\n                for node in tree[1:]:  # never prune root\n                    h = math.dist(node.position, goal)\n                    if node.cost + h >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = informed_sample()\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample_point))\n\n            step = adaptive_step(nearest_node.position, sample_point)\n            new_position = steer(nearest_node.position, sample_point, step)\n\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            est_cost_total = new_cost + math.dist(new_position, goal)\n            if est_cost_total + 1e-8 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune(tree_a)\n\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost + 1e-8 < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = nearest_other.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                prune(tree_start)\n                prune(tree_goal)\n\n                if c_best <= c_min * 1.03:  # Early stop for near-optimal path\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": null
}
{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* planner that efficiently grows start and goal trees by incrementally steering towards random samples. It performs collision checks for nodes and edges, rewires neighbors within a radius to optimize path cost, and attempts to connect the two trees to find a feasible path. The algorithm focuses on balancing planning efficiency, path quality, and robustness through straightforward rewiring and early connection attempts.",
     "planning_mechanism": "The planner alternates expanding between two trees from start and goal, samples points uniformly within bounds, steers nodes by a fixed step size, checks collisions before adding nodes and edges, and rewires local neighbors to improve cost. Once the trees connect, a path is extracted by combining paths from both trees.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position                # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                    # Node or None\n        self.cost = cost                        # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                       # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                    # Tuple[int, ...] (W,H) or (W,H,D)\n        start_pos = map.start                # Tuple[float, ...]\n        goal_pos = map.goal                  # Tuple[float, ...]\n        obstacles = map.obstacles            # Rectangles or cuboids\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        final_path: List[Tuple[float, ...]] = []\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.rewire_radius]\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            rnd_point = sample_free()\n\n            nearest_node = nearest(tree_a, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire\n            neighbors = near_nodes(tree_a, new_pos)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges.append((new_node, neighbor))\n\n            # Attempt connection between trees\n            nearest_to_new = nearest(tree_b, new_node.position)\n            dist_between = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between + nearest_to_new.cost\n\n            # Connect if edge is collision free\n            if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                success_state = True\n                path_start = new_node.path_from_root()\n                path_goal = nearest_to_new.path_from_root()\n                final_path = path_start + path_goal[::-1]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=self._smooth_path(final_path, obstacles, is_3d, bounds) if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if any((p < 0 or p > bounds[d]) for d, p in enumerate(path[j])):\n                    continue\n                next_idx = j\n                break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed",
     "objective": null,
     "other_inf": null
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is named \"Adaptive Informed Bidirectional RRT* (AIBiRRT*)\". It combines bidirectional search with an informed sampling strategy that progressively focuses the random sampling within an ellipsoidal region defined by the current best path cost. This narrowing steerable sampling significantly improves planning efficiency and path quality by concentrating exploration on more promising areas. The algorithm grows two trees from start and goal, rewires nearby nodes to optimize paths dynamically, and adapts its search radius and step size based on progress, balancing exploration and exploitation. Additionally, it incorporates a post-success shortcutting step for path smoothness and length reduction.",
     "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal states. At each iteration, sampling is biased by an informed ellipsoidal region once a solution is found, focusing exploration towards the current best path cost. Each sampled point is used to extend one tree toward it and connect the other tree towards the new node, ensuring collision-free node placements and edges. Rewiring nearby nodes reduces path cost locally. The search radius and step size adaptively shrink to refine paths over time. Once start and goal trees connect, a shortcutting process iteratively smooths and shortens the path to improve quality before returning the final solution.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # cumulative cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def reset_children(self):\n        self.children = []\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.base_radius = step_size * 4.0\n        self.min_radius = step_size * 1.2\n        self.min_step = step_size * 0.5\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math, time\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize\n        start_tree = [Node(start_position, cost=0.0)]\n        goal_tree = [Node(goal_position, cost=0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        best_cost = math.inf\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, center, radius):\n            return [n for n in tree if dist(n.position, center) <= radius]\n\n        def collision_check(pos):\n            return not self._is_in_obstacle(pos, obstacles, is_3d)\n\n        def edge_check(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def add_edge(parent, child):\n            parent.add_child(child)\n            edges.append((parent, child))\n            nodes.append(child)\n\n        def informed_sample(c_min, start_pos, goal_pos):\n            # Sample inside the prolate hyperspheroid defined by start, goal, and c_min cost\n            # If no feasible path found yet, sample uniformly in bounds\n            if not math.isfinite(c_min):\n                # uniform random sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Midpoint and rotation matrix to transform unit ball sample into ellipsoid\n            center = tuple((start_pos[i] + goal_pos[i]) * 0.5 for i in range(dim))\n            # Long axis vector from start to goal\n            a1 = tuple(goal_pos[i] - start_pos[i] for i in range(dim))\n            c_max = dist(start_pos, goal_pos)\n            if c_max == 0:\n                return center\n            r1 = c_min / 2.0\n            if r1 >= c_max / 2.0:\n                r1 = c_max / 2.0  # Clamp max radius to half dist\n            # Radii for ellipsoid: r1 along a1 axis, others smaller\n            rad = [r1] + [math.sqrt(r1**2 - (c_max / 2.0) ** 2) if r1**2 > (c_max / 2.0) ** 2 else r1 * 0.5 for _ in range(dim - 1)]\n\n            # Sample unit ball in dimension dim\n            while True:\n                # Sample random point inside unit ball\n                sample = [random.gauss(0, 1) for _ in range(dim)]\n                norm = math.sqrt(sum(x ** 2 for x in sample))\n                if norm == 0:\n                    continue\n                unit_sample = tuple(x / norm * (random.random() ** (1.0/dim)) for x in sample)\n                # Scale by radii\n                scaled = tuple(unit_sample[i] * rad[i] for i in range(dim))\n                # Construct rotation matrix that aligns a1 with x-axis\n                # For arbitrary dim, only approximate by aligning first coordinate axis\n                # Use Householder reflection or skip rotation for simplicity in arbitrary dim\n                # Here, approximate by adding scaled vector to center directly\n                point = tuple(center[i] + scaled[i] for i in range(dim))\n\n                # Clamp to bounds\n                inside_bounds = all(0 <= point[d] <= bounds[d] for d in range(dim))\n                if inside_bounds and collision_check(point):\n                    return point\n\n        def try_extend(tree, point, radius, step):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, step)\n            if not collision_check(new_pos):\n                return None\n            if not edge_check(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if edge_check(nbr.position, new_pos):\n                    cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                    if cost_candidate < min_cost:\n                        min_cost = cost_candidate\n                        best_parent = nbr\n\n            new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                if edge_check(new_node.position, nbr.position):\n                    new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost:\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.children.remove(nbr)\n                            except Exception:\n                                pass\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n            return new_node\n\n        def connect_trees(node_from, tree_to, radius, step):\n            nearest_node = nearest(tree_to, node_from.position)\n            cur = nearest_node\n            last_added = None\n\n            while True:\n                new_pos = steer(cur.position, node_from.position, step)\n                if not collision_check(new_pos):\n                    return None\n                if not edge_check(cur.position, new_pos):\n                    return None\n\n                dist_to_target = dist(new_pos, node_from.position)\n                connect_direct = dist_to_target <= step\n\n                neighbors = near_nodes(tree_to, new_pos, radius)\n                min_cost = cur.cost + dist(cur.position, new_pos)\n                best_parent = cur\n                for nbr in neighbors:\n                    if edge_check(nbr.position, new_pos):\n                        cost_candidate = nbr.cost + dist(nbr.position, new_pos)\n                        if cost_candidate < min_cost:\n                            min_cost = cost_candidate\n                            best_parent = nbr\n\n                new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n                best_parent.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    if edge_check(new_node.position, nbr.position):\n                        new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                        if new_cost < nbr.cost:\n                            if nbr.parent:\n                                try:\n                                    edges.remove((nbr.parent, nbr))\n                                    nbr.parent.children.remove(nbr)\n                                except Exception:\n                                    pass\n                            nbr.parent = new_node\n                            nbr.cost = new_cost\n                            new_node.add_child(nbr)\n                            edges.append((new_node, nbr))\n\n                if connect_direct:\n                    # Final direct connection to node_from\n                    if not collision_check(node_from.position):\n                        return None\n                    if not edge_check(new_node.position, node_from.position):\n                        return None\n                    final_node = Node(node_from.position,\n                                      parent=new_node,\n                                      cost=new_node.cost + dist(new_node.position, node_from.position))\n                    new_node.add_child(final_node)\n                    tree_to.append(final_node)\n                    nodes.append(final_node)\n                    edges.append((new_node, final_node))\n                    return final_node\n\n                cur = new_node\n\n        def shortcut_path(path, max_attempts=50):\n            if len(path) <= 2:\n                return path\n            attempts = 0\n            while attempts < max_attempts:\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p1, p2 = path[i], path[j]\n                if edge_check(p1, p2):\n                    # Shortcut by removing intermediates\n                    path = path[:i + 1] + path[j:]\n                    attempts = 0  # reset attempts to try to improve more\n                else:\n                    attempts += 1\n            return path\n\n        # Variables for adaptive shrinking\n        radius = self.base_radius\n        step = self.step_size\n\n        tree_swap = False  # To alternate trees\n\n        for it in range(1, self.max_iter + 1):\n            # Adapt radius and step size for refinement after success\n            if success_state:\n                # Shrink radius and step size slowly with lower bounds\n                radius = max(self.min_radius, radius * 0.97)\n                step = max(self.min_step, step * 0.98)\n\n            # Informed sampling after having a solution\n            c_min = best_cost\n            sampled_point = informed_sample(c_min, start_position, goal_position)\n\n            # Choose which tree to extend\n            tree_a, tree_b = (start_tree, goal_tree) if not tree_swap else (goal_tree, start_tree)\n            tree_swap = not tree_swap\n\n            new_node_a = try_extend(tree_a, sampled_point, radius, step)\n            if new_node_a is None:\n                continue\n\n            connected_node_b = connect_trees(new_node_a, tree_b, radius, step)\n            if connected_node_b is not None:\n                # Path found, extract and update best cost/path\n                path = extract_path(new_node_a, connected_node_b)\n                cost_path = 0.0\n                for k in range(1, len(path)):\n                    cost_path += dist(path[k-1], path[k])\n                if cost_path < best_cost:\n                    best_cost = cost_path\n                    success_state = True\n                    extracted_path = path\n\n                # Local shortcutting refinement after finding solution\n                extracted_path = shortcut_path(extracted_path, max_attempts=80)\n\n                # Rewiring nodes near path for cost improvement\n                # Sample nodes near path points with radius\n                neighborhood_radius = radius * 1.2\n                for node_on_path_pos in extracted_path:\n                    neighbors = near_nodes(nodes, node_on_path_pos, neighborhood_radius)\n                    for n in neighbors:\n                        if n.parent is None:\n                            continue\n                        # For each neighbor, try to reconnect to better parent if possible\n                        candidate_parents = near_nodes(nodes, n.position, neighborhood_radius)\n                        for cp in candidate_parents:\n                            if cp == n or cp == n.parent:\n                                continue\n                            if edge_check(cp.position, n.position) and (cp.cost + dist(cp.position, n.position)) < n.cost:\n                                # Rewire n to cp\n                                try:\n                                    edges.remove((n.parent, n))\n                                    n.parent.children.remove(n)\n                                except Exception:\n                                    pass\n                                n.parent = cp\n                                n.cost = cp.cost + dist(cp.position, n.position)\n                                cp.add_child(n)\n                                edges.append((cp, n))\n\n                # Re-extract path after rewiring\n                # Find closest nodes in each tree to start and goal\n                closest_start = nearest(start_tree, goal_position)\n                closest_goal = nearest(goal_tree, start_position)\n                extracted_path = extract_path(closest_start, closest_goal)\n\n        return type('PlannerResult', (), dict(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": null
}
