{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Anytime RRT* with Adaptive Sampling and Lazy Collision Checking. It initially performs global exploration with biased sampling towards the goal and obstacle-sparse regions, followed by local rewiring and path smoothing to improve path quality iteratively. Lazy collision checking postpones expensive edge-obstacle checks until necessary, speeding up planning. Adaptive step size varies exploration granularity based on obstacle density. The algorithm balances fast exploration, high success rate, and path optimality with dynamic adjustment to environment complexity.",
     "planning_mechanism": "The planner grows a single tree from the start node using adaptive biased sampling to simultaneously explore unexplored space and focus toward the goal. After an initial feasible path is found via goal biasing, it iteratively improves the path through local rewiring and lazy collision checks, enhancing path smoothness and shortening path length. The adaptive step size reduces in cluttered areas, improving robustness and success rate.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking (lazy)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(new_cost + distance(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point (goal bias)\n        self.rewire_radius = rewire_radius          # Radius for neighbor search during rewiring\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Store best goal node when found\n        goal_node = None\n\n        # Precompute obstacle density heuristic for adaptive step sizing\n        obstacle_density = self._estimate_obstacle_density(obstacles, bounds, is_3d)\n\n        def adaptive_step_size(pos):\n            # Smaller step size in high obstacle density regions, larger in low density\n            density = self._local_density(pos, obstacles, is_3d)\n            min_step = self.step_size * 0.3\n            max_step = self.step_size * 1.5\n            step = max(min_step, max_step*(1.0 - density))\n            return step\n\n        for i in range(self.max_iter):\n            # Sample with goal bias or adaptive uniform sampling biased by obstacle sparsity\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._adaptive_sample(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree, sample)\n            step = adaptive_step_size(nearest.position)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy collision check - assume valid, postpone edge check until rewiring or path extraction\n            new_node = Node(new_pos)\n            cost_through_nearest = nearest.cost + distance(nearest.position, new_pos)\n\n            # Find neighbors within rewire radius for potential better parent\n            neighbors = self._near(tree, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = cost_through_nearest\n\n            for n in neighbors:\n                tentative_cost = n.cost + distance(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = tentative_cost\n\n            # Connect new_node\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path found through new_node\n            for n in neighbors:\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            n.parent.children.remove(n)\n\n                        # Add new edge\n                        new_node.add_child(n)\n                        n.parent = new_node\n                        n.update_cost(new_cost)\n                        edges.append((new_node, n))\n\n            # Check if goal is reached (lazy edge collision here)\n            if distance(new_node.position, goal_position) <= adaptive_step_size(new_node.position):\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    potential_goal = Node(goal_position, parent=new_node, cost=new_node.cost + distance(new_node.position, goal_position))\n                    # Attach goal node to tree\n                    new_node.add_child(potential_goal)\n                    nodes.append(potential_goal)\n                    edges.append((new_node, potential_goal))\n                    if goal_node is None or potential_goal.cost < goal_node.cost:\n                        goal_node = potential_goal\n                        success_state = True\n\n            # After initial solution found, attempt local path smoothing every 100 iterations\n            if success_state and i % 100 == 0:\n                extracted_path = self._extract_path(goal_node)\n                extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _adaptive_sample(self, bounds, obstacles, is_3d):\n        import random\n        # Uniform rejection sampling with obstacle bias (avoid sampling inside obstacle)\n        while True:\n            if is_3d:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, goal_node):\n        # Returns list of positions from start to goal\n        return goal_node.path_from_root()\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut by removing intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _estimate_obstacle_density(self, obstacles, bounds, is_3d):\n        # Rough estimation of obstacle density as volume / map volume\n        if not obstacles:\n            return 0.0\n        total_volume = 1.0\n        for dim in bounds:\n            total_volume *= dim\n\n        obs_volume = 0.0\n        for obs in obstacles:\n            if is_3d:\n                w, h, d = obs[3], obs[4], obs[5]\n                obs_volume += w * h * d\n            else:\n                w, h = obs[2], obs[3]\n                obs_volume += w * h\n        return min(1.0, obs_volume / total_volume)\n\n    def _local_density(self, pos, obstacles, is_3d, radius=10.0):\n        # Compute fraction of volume occupied by obstacles within radius cube around pos\n        count_in_radius = 0\n        total_points = 20\n        import random\n        dims = len(pos)\n        lower_bound = [max(0, pos[d] - radius/2) for d in range(dims)]\n        upper_bound = [pos[d] + radius/2 for d in range(dims)]\n        in_obs_count = 0\n        for _ in range(total_points):\n            sample = tuple(random.uniform(lower_bound[d], upper_bound[d]) for d in range(dims))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                in_obs_count += 1\n        return in_obs_count / total_points",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Anytime RRT* with Adaptive Sampling and Lazy Collision Checking. It initially performs global exploration with biased sampling towards the goal and obstacle-sparse regions, followed by local rewiring and path smoothing to improve path quality iteratively. Lazy collision checking postpones expensive edge-obstacle checks until necessary, speeding up planning. Adaptive step size varies exploration granularity based on obstacle density. The algorithm balances fast exploration, high success rate, and path optimality with dynamic adjustment to environment complexity.",
     "planning_mechanism": "The planner grows a single tree from the start node using adaptive biased sampling to simultaneously explore unexplored space and focus toward the goal. After an initial feasible path is found via goal biasing, it iteratively improves the path through local rewiring and lazy collision checks, enhancing path smoothness and shortening path length. The adaptive step size reduces in cluttered areas, improving robustness and success rate.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking (lazy)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(new_cost + distance(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point (goal bias)\n        self.rewire_radius = rewire_radius          # Radius for neighbor search during rewiring\n\n    def plan(self, map) -> dict:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(pos):\n            # Check if position is inside map bounds\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Store best goal node when found\n        goal_node = None\n\n        def adaptive_step_size(pos):\n            # Smaller step size in high obstacle density regions, larger in low density\n            density = self._local_density(pos, obstacles, is_3d)\n            min_step = self.step_size * 0.3\n            max_step = self.step_size * 1.5\n            step = max(min_step, max_step*(1.0 - density))\n            return step\n\n        for i in range(self.max_iter):\n            # Sample with goal bias or adaptive uniform sampling biased by obstacle sparsity\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._adaptive_sample(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree, sample)\n            step = adaptive_step_size(nearest.position)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy collision check - assume valid, postpone edge check until rewiring or path extraction\n            new_node = Node(new_pos)\n            cost_through_nearest = nearest.cost + distance(nearest.position, new_pos)\n\n            # Find neighbors within rewire radius for potential better parent\n            neighbors = self._near(tree, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = cost_through_nearest\n\n            for n in neighbors:\n                tentative_cost = n.cost + distance(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = tentative_cost\n\n            # Before connecting, check edge collision from best_parent to new_node\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Connect new_node\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path found through new_node\n            for n in neighbors:\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            if n in n.parent.children:\n                                n.parent.children.remove(n)\n\n                        # Add new edge\n                        new_node.add_child(n)\n                        n.parent = new_node\n                        n.update_cost(new_cost)\n                        edges.append((new_node, n))\n\n            # Check if goal is reached (lazy edge collision here)\n            dist_to_goal = distance(new_node.position, goal_position)\n            step_at_pos = adaptive_step_size(new_node.position)\n            if dist_to_goal <= step_at_pos:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    potential_goal = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    # Attach goal node to tree\n                    new_node.add_child(potential_goal)\n                    nodes.append(potential_goal)\n                    edges.append((new_node, potential_goal))\n                    if goal_node is None or potential_goal.cost < goal_node.cost:\n                        goal_node = potential_goal\n                        success_state = True\n\n            # After initial solution found, attempt local path smoothing every 100 iterations\n            if success_state and i % 100 == 0 and goal_node is not None:\n                extracted_path = self._extract_path(goal_node)\n                extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return {\n            'success': success_state,\n            'path': extracted_path,\n            'nodes': nodes,\n            'edges': edges\n        }\n\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _adaptive_sample(self, bounds, obstacles, is_3d):\n        import random\n        # Uniform rejection sampling with obstacle bias (avoid sampling inside obstacle)\n        while True:\n            if is_3d:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(3))\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(2))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, goal_node):\n        # Returns list of positions from start to goal\n        return goal_node.path_from_root()\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut by removing intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _estimate_obstacle_density(self, obstacles, bounds, is_3d):\n        # Rough estimation of obstacle density as volume / map volume\n        if not obstacles:\n            return 0.0\n        total_volume = 1.0\n        for dim in bounds:\n            total_volume *= dim\n\n        obs_volume = 0.0\n        for obs in obstacles:\n            if is_3d:\n                w, h, d = obs[3], obs[4], obs[5]\n                obs_volume += w * h * d\n            else:\n                w, h = obs[2], obs[3]\n                obs_volume += w * h\n        return min(1.0, obs_volume / total_volume)\n\n    def _local_density(self, pos, obstacles, is_3d, radius=10.0):\n        # Compute fraction of volume occupied by obstacles within radius cube around pos\n        total_points = 20\n        import random\n        dims = len(pos)\n        lower_bound = [max(0, pos[d] - radius/2) for d in range(dims)]\n        upper_bound = [pos[d] + radius/2 for d in range(dims)]\n        in_obs_count = 0\n        for _ in range(total_points):\n            sample = tuple(random.uniform(lower_bound[d], upper_bound[d]) for d in range(dims))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                in_obs_count += 1\n        return in_obs_count / total_points",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Anytime RRT* with Adaptive Sampling and Lazy Collision Checking. It initially performs global exploration with biased sampling towards the goal and obstacle-sparse regions, followed by local rewiring and path smoothing to improve path quality iteratively. Lazy collision checking postpones expensive edge-obstacle checks until necessary, speeding up planning. Adaptive step size varies exploration granularity based on obstacle density. The algorithm balances fast exploration, high success rate, and path optimality with dynamic adjustment to environment complexity.",
     "planning_mechanism": "The planner grows a single tree from the start node using adaptive biased sampling to simultaneously explore unexplored space and focus toward the goal. After an initial feasible path is found via goal biasing, it iteratively improves the path through local rewiring and lazy collision checks, enhancing path smoothness and shortening path length. The adaptive step size reduces in cluttered areas, improving robustness and success rate.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking (lazy)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(new_cost + distance(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point (goal bias)\n        self.rewire_radius = rewire_radius          # Radius for neighbor search during rewiring\n\n    def plan(self, map) -> dict:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(pos):\n            # Check if position is inside map bounds\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Store best goal node when found\n        goal_node = None\n\n        def adaptive_step_size(pos):\n            # Smaller step size in high obstacle density regions, larger in low density\n            density = self._local_density(pos, obstacles, is_3d)\n            min_step = self.step_size * 0.3\n            max_step = self.step_size * 1.5\n            step = max(min_step, max_step*(1.0 - density))\n            return step\n\n        for i in range(self.max_iter):\n            # Sample with goal bias or adaptive uniform sampling biased by obstacle sparsity\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._adaptive_sample(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree, sample)\n            step = adaptive_step_size(nearest.position)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Before connecting, check that edge from nearest to new_pos is collision-free\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy collision check - assume valid, postpone edge check until rewiring or path extraction\n            new_node = Node(new_pos)\n            cost_through_nearest = nearest.cost + distance(nearest.position, new_pos)\n\n            # Find neighbors within rewire radius for potential better parent\n            neighbors = self._near(tree, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = cost_through_nearest\n\n            for n in neighbors:\n                tentative_cost = n.cost + distance(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = tentative_cost\n\n            # Before connecting, check edge collision from best_parent to new_node\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Connect new_node\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path found through new_node\n            for n in neighbors:\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            if n in n.parent.children:\n                                n.parent.children.remove(n)\n\n                        # Add new edge\n                        new_node.add_child(n)\n                        n.parent = new_node\n                        n.update_cost(new_cost)\n                        edges.append((new_node, n))\n\n            # Check if goal is reached (lazy edge collision here)\n            dist_to_goal = distance(new_node.position, goal_position)\n            step_at_pos = adaptive_step_size(new_node.position)\n            if dist_to_goal <= step_at_pos:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    # Check goal node itself is not inside an obstacle and in bounds\n                    if in_bounds(goal_position) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                        potential_goal = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        # Attach goal node to tree\n                        new_node.add_child(potential_goal)\n                        nodes.append(potential_goal)\n                        edges.append((new_node, potential_goal))\n                        if goal_node is None or potential_goal.cost < goal_node.cost:\n                            goal_node = potential_goal\n                            success_state = True\n\n            # After initial solution found, attempt local path smoothing every 100 iterations\n            if success_state and i % 100 == 0 and goal_node is not None:\n                extracted_path = self._extract_path(goal_node)\n                extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return {\n            'success': success_state,\n            'path': extracted_path,\n            'nodes': nodes,\n            'edges': edges\n        }\n\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        import math\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _adaptive_sample(self, bounds, obstacles, is_3d):\n        import random\n        # Uniform rejection sampling with obstacle bias (avoid sampling inside obstacle)\n        dims = 3 if is_3d else 2\n        while True:\n            sample = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, goal_node):\n        # Returns list of positions from start to goal\n        return goal_node.path_from_root()\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                # Shortcut by removing intermediate points\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _estimate_obstacle_density(self, obstacles, bounds, is_3d):\n        # Rough estimation of obstacle density as volume / map volume\n        if not obstacles:\n            return 0.0\n        total_volume = 1.0\n        for dim in bounds:\n            total_volume *= dim\n\n        obs_volume = 0.0\n        for obs in obstacles:\n            if is_3d:\n                w, h, d = obs[3], obs[4], obs[5]\n                obs_volume += w * h * d\n            else:\n                w, h = obs[2], obs[3]\n                obs_volume += w * h\n        return min(1.0, obs_volume / total_volume)\n\n    def _local_density(self, pos, obstacles, is_3d, radius=10.0):\n        # Compute fraction of volume occupied by obstacles within radius cube around pos\n        total_points = 20\n        import random\n        dims = len(pos)\n        lower_bound = [max(0, pos[d] - radius/2) for d in range(dims)]\n        upper_bound = [pos[d] + radius/2 for d in range(dims)]\n        in_obs_count = 0\n        for _ in range(total_points):\n            sample = tuple(random.uniform(lower_bound[d], upper_bound[d]) for d in range(dims))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                in_obs_count += 1\n        return in_obs_count / total_points",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm introduces a Hybrid Anytime RRT* with Adaptive Sampling and Lazy Collision Checking. It initially performs global exploration with biased sampling towards the goal and obstacle-sparse regions, followed by local rewiring and path smoothing to improve path quality iteratively. Lazy collision checking postpones expensive edge-obstacle checks until necessary, speeding up planning. Adaptive step size varies exploration granularity based on obstacle density. The algorithm balances fast exploration, high success rate, and path optimality with dynamic adjustment to environment complexity.",
     "planning_mechanism": "The planner grows a single tree from the start node using adaptive biased sampling to simultaneously explore unexplored space and focus toward the goal. After an initial feasible path is found via goal biasing, it iteratively improves the path through local rewiring and lazy collision checks, enhancing path smoothness and shortening path length. The adaptive step size reduces in cluttered areas, improving robustness and success rate.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Cost from root\n        self.children = []\n        self.valid = True               # For collision checking (lazy)\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        for c in self.children:\n            c.update_cost(new_cost + distance(self.position, c.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate    # Probability to sample goal point (goal bias)\n        self.rewire_radius = rewire_radius          # Radius for neighbor search during rewiring\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        def in_bounds(pos):\n            # Check if position is inside map bounds\n            for d, val in enumerate(pos):\n                if val < 0 or val > bounds[d]:\n                    return False\n            return True\n\n        root = Node(start_position, cost=0.0)\n        nodes.append(root)\n        tree = [root]\n\n        # Store best goal node when found\n        goal_node = None\n\n        def adaptive_step_size(pos):\n            # Smaller step size in high obstacle density regions, larger in low density\n            density = self._local_density(pos, obstacles, is_3d)\n            min_step = self.step_size * 0.3\n            max_step = self.step_size * 1.5\n            step = max(min_step, max_step*(1.0 - density))\n            return step\n\n        for i in range(self.max_iter):\n            # Sample with goal bias or adaptive uniform sampling biased by obstacle sparsity\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = self._adaptive_sample(bounds, obstacles, is_3d)\n\n            nearest = self._nearest(tree, sample)\n            step = adaptive_step_size(nearest.position)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            if not in_bounds(new_pos):\n                continue\n\n            # Collision check for new node position\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Before connecting, check that edge from nearest to new_pos is collision-free\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy collision check - assume valid, postpone edge check until rewiring or path extraction\n            new_node = Node(new_pos)\n            cost_through_nearest = nearest.cost + distance(nearest.position, new_pos)\n\n            # Find neighbors within rewire radius for potential better parent\n            neighbors = self._near(tree, new_pos, self.rewire_radius)\n            best_parent = nearest\n            min_cost = cost_through_nearest\n\n            for n in neighbors:\n                tentative_cost = n.cost + distance(n.position, new_pos)\n                if tentative_cost < min_cost:\n                    if not self._is_edge_in_obstacle(n.position, new_pos, obstacles, is_3d):\n                        best_parent = n\n                        min_cost = tentative_cost\n\n            # Before connecting, check edge collision from best_parent to new_node\n            if self._is_edge_in_obstacle(best_parent.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Ensure new node position itself is collision free again before connecting (redundant but safe)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Connect new_node\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors if better cost path found through new_node\n            for n in neighbors:\n                if n == best_parent:\n                    continue\n                new_cost = new_node.cost + distance(new_node.position, n.position)\n                if new_cost < n.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, n.position, obstacles, is_3d):\n                        # Remove old edge\n                        if n.parent:\n                            try:\n                                edges.remove((n.parent, n))\n                            except ValueError:\n                                pass\n                            if n in n.parent.children:\n                                n.parent.children.remove(n)\n\n                        # Add new edge\n                        new_node.add_child(n)\n                        n.parent = new_node\n                        n.update_cost(new_cost)\n                        edges.append((new_node, n))\n\n            # Check if goal is reached (lazy edge collision here)\n            dist_to_goal = distance(new_node.position, goal_position)\n            step_at_pos = adaptive_step_size(new_node.position)\n            if dist_to_goal <= step_at_pos:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d):\n                    # Check goal node itself is not inside an obstacle and in bounds\n                    if in_bounds(goal_position) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                        potential_goal = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                        # Attach goal node to tree\n                        new_node.add_child(potential_goal)\n                        nodes.append(potential_goal)\n                        edges.append((new_node, potential_goal))\n                        if goal_node is None or potential_goal.cost < goal_node.cost:\n                            goal_node = potential_goal\n                            success_state = True\n\n            # After initial solution found, attempt local path smoothing every 100 iterations\n            if success_state and i % 100 == 0 and goal_node is not None:\n                extracted_path = self._extract_path(goal_node)\n                extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        if success_state and goal_node:\n            extracted_path = self._extract_path(goal_node)\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n        else:\n            extracted_path = []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n\n    def _nearest(self, tree, point):\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _near(self, tree, point, radius):\n        return [node for node in tree if math.dist(node.position, point) <= radius]\n\n    def _steer(self, from_pos, to_pos, step_size):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step_size:\n            return to_pos\n        ratio = step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _adaptive_sample(self, bounds, obstacles, is_3d):\n        import random\n        dims = 3 if is_3d else 2\n        while True:\n            sample = tuple(random.uniform(0, bounds[d]) for d in range(dims))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance_val = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_val / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _extract_path(self, goal_node):\n        # Returns list of positions from start to goal\n        return goal_node.path_from_root()\n\n    def _smooth_path(self, path, obstacles, is_3d, max_iter=50):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        for _ in range(max_iter):\n            if len(path) < 3:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) -1)\n            if not self._is_edge_in_obstacle(path[i], path[j], obstacles, is_3d):\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _estimate_obstacle_density(self, obstacles, bounds, is_3d):\n        if not obstacles:\n            return 0.0\n        total_volume = 1.0\n        for dim in bounds:\n            total_volume *= dim\n\n        obs_volume = 0.0\n        for obs in obstacles:\n            if is_3d:\n                w, h, d = obs[3], obs[4], obs[5]\n                obs_volume += w * h * d\n            else:\n                w, h = obs[2], obs[3]\n                obs_volume += w * h\n        return min(1.0, obs_volume / total_volume)\n\n    def _local_density(self, pos, obstacles, is_3d, radius=10.0):\n        total_points = 20\n        import random\n        dims = len(pos)\n        lower_bound = [max(0, pos[d] - radius/2) for d in range(dims)]\n        upper_bound = [pos[d] + radius/2 for d in range(dims)]\n        in_obs_count = 0\n        for _ in range(total_points):\n            sample = tuple(random.uniform(lower_bound[d], upper_bound[d]) for d in range(dims))\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                in_obs_count += 1\n        return in_obs_count / total_points",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner combining strengths of Improved RRT*-Connect and Informed RRT* for enhanced convergence, solution quality, and robustness. Uses bidirectional tree growth with adaptive step size, informed ellipsoidal sampling, node rewiring, pruning, and rigorous collision checks to improve success rate and path smoothness efficiently.",
     "planning_mechanism": "The planner grows two trees from start and goal with informed ellipsoidal sampling after initial solution discovery. It adaptively adjusts step sizes near obstacles, prunes inefficient nodes early, and performs rewiring only if cost improves. Each connection undergoes thorough collision checks. Trees attempt to connect to each other iteratively to quickly discover and refine the optimal path while maintaining computational efficiency.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def informed_sample(c_best_local):\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best_local / 2\n            r2 = math.sqrt(c_best_local**2 - c_min**2) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball * (random.random() ** (1.0 / dim))\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(t_from, t_to):\n            # Attempt to connect last added node in t_from to nearest in t_to\n            last_node = t_from[-1]\n            nearest_other = min(t_to, key=lambda n: math.dist(n.position, last_node.position))\n            dist = math.dist(last_node.position, nearest_other.position)\n            if dist > 0:\n                if not self._is_edge_in_obstacle(last_node.position, nearest_other.position, obstacles, is_3d):\n                    path_cost = last_node.cost + dist + nearest_other.cost\n                    return path_cost, last_node, nearest_other\n            return None\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample(c_best)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Skip if out of boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if can't improve best path cost\n            if new_cost + math.dist(new_pos, goal) >= c_best - 1e-9:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try connect to opposite tree\n            connect_result = try_connect(tree_a, tree_b)\n            if connect_result:\n                path_cost, node_a, node_b = connect_result\n                if path_cost < c_best - 1e-9:\n                    c_best = path_cost\n                    path_from_start = node_a.path_from_root()\n                    path_from_goal = node_b.path_from_root()\n                    # Merge paths (avoid double counting connecting node)\n                    best_path = path_from_start + path_from_goal[::-1][1:]\n                    success = True\n\n            # Early pruning of nodes with cost worse than best found path\n            # Mark nodes invalid to ignore rewiring later\n            if success:\n                # Prune tree_start\n                for node in tree_start[:]:\n                    if node.cost + math.dist(node.position, goal) >= c_best - 1e-9 and node != tree_start[0]:\n                        node.valid = False\n                # Prune tree_goal\n                for node in tree_goal[:]:\n                    if node.cost + math.dist(node.position, start) >= c_best - 1e-9 and node != tree_goal[0]:\n                        node.valid = False\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner combining strengths of Improved RRT*-Connect and Informed RRT* for enhanced convergence, solution quality, and robustness. Uses bidirectional tree growth with adaptive step size, informed ellipsoidal sampling, node rewiring, pruning, and rigorous collision checks to improve success rate and path smoothness efficiently.",
     "planning_mechanism": "The planner grows two trees from start and goal with informed ellipsoidal sampling after initial solution discovery. It adaptively adjusts step sizes near obstacles, prunes inefficient nodes early, and performs rewiring only if cost improves. Each connection undergoes thorough collision checks. Trees attempt to connect to each other iteratively to quickly discover and refine the optimal path while maintaining computational efficiency.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def informed_sample(c_best_local):\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best_local / 2\n            r2 = math.sqrt(max(c_best_local**2 - c_min**2, 0)) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball * (random.random() ** (1.0 / dim))\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n.valid]\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(t_from, t_to):\n            # Attempt to connect last added node in t_from to nearest in t_to\n            last_node = t_from[-1]\n            # Filter only valid nodes for connection\n            valid_nodes = [n for n in t_to if n.valid]\n            if not valid_nodes:\n                return None\n            nearest_other = min(valid_nodes, key=lambda n: math.dist(n.position, last_node.position))\n            dist = math.dist(last_node.position, nearest_other.position)\n            if dist > 0:\n                if not self._is_edge_in_obstacle(last_node.position, nearest_other.position, obstacles, is_3d):\n                    path_cost = last_node.cost + dist + nearest_other.cost\n                    return path_cost, last_node, nearest_other\n            return None\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample(c_best)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Skip if out of boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if can't improve best path cost\n            if new_cost + math.dist(new_pos, goal) >= c_best - 1e-9:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try connect to opposite tree\n            connect_result = try_connect(tree_a, tree_b)\n            if connect_result:\n                path_cost, node_a, node_b = connect_result\n                if path_cost < c_best - 1e-9:\n                    c_best = path_cost\n                    path_from_start = node_a.path_from_root()\n                    path_from_goal = node_b.path_from_root()\n                    # Merge paths (avoid double counting connecting node)\n                    best_path = path_from_start + path_from_goal[::-1][1:]\n                    success = True\n\n            # Early pruning of nodes with cost worse than best found path\n            # Mark nodes invalid to ignore rewiring later\n            if success:\n                # Prune tree_start\n                for node in tree_start:\n                    if node.cost + math.dist(node.position, goal) >= c_best - 1e-9 and node != tree_start[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n                # Prune tree_goal\n                for node in tree_goal:\n                    if node.cost + math.dist(node.position, start) >= c_best - 1e-9 and node != tree_goal[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n\n        return {\n            \"success\": success,\n            \"path\": best_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner combining strengths of Improved RRT*-Connect and Informed RRT* for enhanced convergence, solution quality, and robustness. Uses bidirectional tree growth with adaptive step size, informed ellipsoidal sampling, node rewiring, pruning, and rigorous collision checks to improve success rate and path smoothness efficiently.",
     "planning_mechanism": "The planner grows two trees from start and goal with informed ellipsoidal sampling after initial solution discovery. It adaptively adjusts step sizes near obstacles, prunes inefficient nodes early, and performs rewiring only if cost improves. Each connection undergoes thorough collision checks. Trees attempt to connect to each other iteratively to quickly discover and refine the optimal path while maintaining computational efficiency.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def informed_sample(c_best_local):\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Ellipsoidal informed sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best_local / 2\n            r2 = math.sqrt(max(c_best_local**2 - c_min**2, 0)) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball * (random.random() ** (1.0 / dim))\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n.valid]\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(t_from, t_to):\n            # Attempt to connect last added node in t_from to nearest in t_to\n            last_node = t_from[-1]\n            # Filter only valid nodes for connection\n            valid_nodes = [n for n in t_to if n.valid]\n            if not valid_nodes:\n                return None\n            nearest_other = min(valid_nodes, key=lambda n: math.dist(n.position, last_node.position))\n            dist = math.dist(last_node.position, nearest_other.position)\n            if dist > 0:\n                if (not self._is_in_obstacle(last_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(nearest_other.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(last_node.position, nearest_other.position, obstacles, is_3d)):\n                    path_cost = last_node.cost + dist + nearest_other.cost\n                    return path_cost, last_node, nearest_other\n            return None\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample(c_best)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            # Skip if out of boundary\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if can't improve best path cost\n            if new_cost + math.dist(new_pos, goal) >= c_best - 1e-9:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            # Try connect to opposite tree\n            connect_result = try_connect(tree_a, tree_b)\n            if connect_result:\n                path_cost, node_a, node_b = connect_result\n                if path_cost < c_best - 1e-9:\n                    c_best = path_cost\n                    path_from_start = node_a.path_from_root()\n                    path_from_goal = node_b.path_from_root()\n                    # Merge paths (avoid double counting connecting node)\n                    best_path = path_from_start + path_from_goal[::-1][1:]\n                    success = True\n\n            # Early pruning of nodes with cost worse than best found path\n            # Mark nodes invalid to ignore rewiring later\n            if success:\n                # Prune tree_start\n                for node in tree_start:\n                    if node.cost + math.dist(node.position, goal) >= c_best - 1e-9 and node != tree_start[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n                # Prune tree_goal\n                for node in tree_goal:\n                    if node.cost + math.dist(node.position, start) >= c_best - 1e-9 and node != tree_goal[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner combining strengths of Improved RRT*-Connect and Informed RRT* for enhanced convergence, solution quality, and robustness. Uses bidirectional tree growth with adaptive step size, informed ellipsoidal sampling, node rewiring, pruning, and rigorous collision checks to improve success rate and path smoothness efficiently.",
     "planning_mechanism": "The planner grows two trees from start and goal with informed ellipsoidal sampling after initial solution discovery. It adaptively adjusts step sizes near obstacles, prunes inefficient nodes early, and performs rewiring only if cost improves. Each connection undergoes thorough collision checks. Trees attempt to connect to each other iteratively to quickly discover and refine the optimal path while maintaining computational efficiency.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision validity\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def informed_sample(c_best_local):\n            if c_best_local == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 < 1e-10:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best_local / 2\n            r2 = math.sqrt(max(c_best_local**2 - c_min**2, 0)) / 2\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball < 1e-10:\n                    continue\n                x_ball = x_ball / norm_ball * (random.random() ** (1.0 / dim))\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            distance = math.dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            neighbors = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius and n.valid]\n            for near in neighbors:\n                if near == new_node.parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if new_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = new_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(t_from, t_to):\n            last_node = t_from[-1]\n            valid_nodes = [n for n in t_to if n.valid]\n            if not valid_nodes:\n                return None\n            nearest_other = min(valid_nodes, key=lambda n: math.dist(n.position, last_node.position))\n            dist = math.dist(last_node.position, nearest_other.position)\n            if dist > 0:\n                if (not self._is_in_obstacle(last_node.position, obstacles, is_3d) and\n                    not self._is_in_obstacle(nearest_other.position, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(last_node.position, nearest_other.position, obstacles, is_3d)):\n                    path_cost = last_node.cost + dist + nearest_other.cost\n                    return path_cost, last_node, nearest_other\n            return None\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample(c_best)\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + math.dist(new_pos, goal) >= c_best - 1e-9:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            connect_result = try_connect(tree_a, tree_b)\n            if connect_result:\n                path_cost, node_a, node_b = connect_result\n                if path_cost < c_best - 1e-9:\n                    c_best = path_cost\n                    path_from_start = node_a.path_from_root()\n                    path_from_goal = node_b.path_from_root()\n                    best_path = path_from_start + path_from_goal[::-1][1:]\n                    success = True\n\n            if success:\n                for node in tree_start:\n                    if node.cost + math.dist(node.position, goal) >= c_best - 1e-9 and node != tree_start[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n                for node in tree_goal:\n                    if node.cost + math.dist(node.position, start) >= c_best - 1e-9 and node != tree_goal[0]:\n                        node.valid = False\n                    else:\n                        node.valid = True\n\n        return {'success': success, 'path': best_path, 'nodes': nodes, 'edges': edges}\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm is a simplified, generalized RRT* with informed sampling and bidirectional growth principles combined. It focuses exploration using ellipsoidal informed sampling after an initial solution and grows two trees simultaneously from start and goal to improve convergence, path quality, and robustness. The planner incorporates rewiring for path optimization, collision and edge checks for safety, and boundary enforcement to reduce computation and improve overall success rate and path smoothness.",
     "planning_mechanism": "The planner initializes two trees from the start and goal. It samples points uniformly at first and within an informed ellipsoid after a solution is found, ensuring samples have potential to improve the path. Both trees extend towards sampled points while avoiding obstacles. When the two trees connect, the path is reconstructed, and neighboring nodes are rewired for path quality improvement. Collision checks on nodes and edges ensure safety. The algorithm runs until max iterations or a satisfying path is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants\n        for child in self.children:\n            child.update_cost_and_parent(self, self.cost + distance(self.position, child.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample(c_best=float(\"inf\")):\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = distance(start_position, goal_position)\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                a1 = np.array(goal_position) - np.array(start_position)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    A1 = np.eye(dim)\n                else:\n                    a1 = a1 / a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n                L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim -1)\n                L = np.diag(L_diag)\n\n                for _ in range(100):\n                    x_ball = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm < 1e-6:\n                        continue\n                    x_ball = x_ball / norm * random.random()**(1/dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    p = tuple(x_rand)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        goal_reached_node_start = None\n        goal_reached_node_goal = None\n        radius = max(bounds) * 0.15  # Adaptive radius for rewiring\n\n        for _ in range(self.max_iter):\n            c_best = best_cost if best_cost < float(\"inf\") else float(\"inf\")\n            x_rand = sample(c_best)\n\n            # Extend tree_start towards sample\n            nearest_s = nearest_node(tree_start, x_rand)\n            new_pos_s = steer(nearest_s.position, x_rand)\n            if not can_connect(nearest_s.position, new_pos_s):\n                continue\n\n            new_node_s = Node(new_pos_s)\n            # Choose best parent from near nodes for new_node_s\n            near_s = near_nodes(tree_start, new_pos_s, radius)\n            min_cost = nearest_s.cost + distance(nearest_s.position, new_pos_s)\n            best_parent = nearest_s\n\n            for node_n in near_s:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_s)\n                if cost_n < min_cost and can_connect(node_n.position, new_pos_s):\n                    min_cost = cost_n\n                    best_parent = node_n\n\n            best_parent.add_child(new_node_s)\n            new_node_s.cost = min_cost\n            tree_start.append(new_node_s)\n            nodes.append(new_node_s)\n            edges.append((best_parent, new_node_s))\n\n            # Rewire near nodes of new_node_s\n            for node_n in near_s:\n                alt_cost = new_node_s.cost + distance(new_node_s.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_s.position, node_n.position):\n                    node_n.update_cost_and_parent(new_node_s, alt_cost)\n                    # Update edges\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except ValueError:\n                        pass\n                    edges.append((new_node_s, node_n))\n\n            # Extend tree_goal towards new_node_s\n            nearest_g = nearest_node(tree_goal, new_node_s.position)\n            new_pos_g = steer(nearest_g.position, new_node_s.position)\n            if not can_connect(nearest_g.position, new_pos_g):\n                continue\n\n            new_node_g = Node(new_pos_g)\n            near_g = near_nodes(tree_goal, new_pos_g, radius)\n            min_cost_g = nearest_g.cost + distance(nearest_g.position, new_pos_g)\n            best_parent_g = nearest_g\n            for node_n in near_g:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_g)\n                if cost_n < min_cost_g and can_connect(node_n.position, new_pos_g):\n                    min_cost_g = cost_n\n                    best_parent_g = node_n\n\n            best_parent_g.add_child(new_node_g)\n            new_node_g.cost = min_cost_g\n            tree_goal.append(new_node_g)\n            nodes.append(new_node_g)\n            edges.append((best_parent_g, new_node_g))\n\n            # Rewire near nodes of new_node_g\n            for node_n in near_g:\n                alt_cost = new_node_g.cost + distance(new_node_g.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_g.position, node_n.position):\n                    node_n.update_cost_and_parent(new_node_g, alt_cost)\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except ValueError:\n                        pass\n                    edges.append((new_node_g, node_n))\n\n            # Check if trees connect (within step_size)\n            if distance(new_node_s.position, new_node_g.position) <= self.step_size and can_connect(new_node_s.position, new_node_g.position):\n                # Connect nodes\n                new_node_s.add_child(new_node_g)\n                edges.append((new_node_s, new_node_g))\n\n                path_start = new_node_s.path_from_root()\n                path_goal = new_node_g.path_from_root()\n                extracted_path = path_start + path_goal[::-1]  # Combine paths\n\n                # Update best cost and success\n                path_length = new_node_s.cost + distance(new_node_s.position, new_node_g.position) + new_node_g.cost\n                if path_length < best_cost:\n                    best_cost = path_length\n                    success_state = True\n\n                return type('PlannerResult', (), dict(\n                    success=success_state,\n                    path=extracted_path,\n                    nodes=nodes,\n                    edges=edges\n                ))()\n\n            # Swap trees for bidirectional growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return type('PlannerResult', (), dict(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm is a simplified, generalized RRT* with informed sampling and bidirectional growth principles combined. It focuses exploration using ellipsoidal informed sampling after an initial solution and grows two trees simultaneously from start and goal to improve convergence, path quality, and robustness. The planner incorporates rewiring for path optimization, collision and edge checks for safety, and boundary enforcement to reduce computation and improve overall success rate and path smoothness.",
     "planning_mechanism": "The planner initializes two trees from the start and goal. It samples points uniformly at first and within an informed ellipsoid after a solution is found, ensuring samples have potential to improve the path. Both trees extend towards sampled points while avoiding obstacles. When the two trees connect, the path is reconstructed, and neighboring nodes are rewired for path quality improvement. Collision checks on nodes and edges ensure safety. The algorithm runs until max iterations or a satisfying path is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants\n        for child in self.children:\n            child.update_cost_and_parent(self, self.cost + distance(self.position, child.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            # Ensure point P is within map bounds, inclusive\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample(c_best=float(\"inf\")):\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n            else:\n                c_min = distance(start_position, goal_position)\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                a1 = np.array(goal_position) - np.array(start_position)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    C = np.eye(dim)\n                else:\n                    a1 = a1 / a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n                L_diag = [c_best / 2] + [math.sqrt(c_best**2 - c_min**2) / 2] * (dim -1)\n                L = np.diag(L_diag)\n\n                for _ in range(100):\n                    x_ball = np.random.normal(0,1,dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm < 1e-6:\n                        continue\n                    x_ball = x_ball / norm * random.random()**(1/dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    p = tuple(x_rand)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        goal_reached_node_start = None\n        goal_reached_node_goal = None\n        success_state = False\n        extracted_path = []\n\n        radius = max(bounds) * 0.15  # Adaptive radius for rewiring\n\n        for _ in range(self.max_iter):\n            c_best = best_cost if best_cost < float(\"inf\") else float(\"inf\")\n            x_rand = sample(c_best)\n\n            # Extend tree_start towards sample\n            nearest_s = nearest_node(tree_start, x_rand)\n            new_pos_s = steer(nearest_s.position, x_rand)\n            if not can_connect(nearest_s.position, new_pos_s):\n                continue\n\n            new_node_s = Node(new_pos_s)\n\n            # Ensure new_node_s is in bounds and not in obstacle\n            if not in_bounds(new_node_s.position) or self._is_in_obstacle(new_node_s.position, obstacles, is_3d):\n                continue\n\n            # Choose best parent from near nodes for new_node_s\n            near_s = near_nodes(tree_start, new_pos_s, radius)\n            min_cost = nearest_s.cost + distance(nearest_s.position, new_pos_s)\n            best_parent = nearest_s\n\n            for node_n in near_s:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_s)\n                if cost_n < min_cost and can_connect(node_n.position, new_pos_s):\n                    min_cost = cost_n\n                    best_parent = node_n\n\n            best_parent.add_child(new_node_s)\n            new_node_s.cost = min_cost\n            tree_start.append(new_node_s)\n            nodes.append(new_node_s)\n            edges.append((best_parent, new_node_s))\n\n            # Rewire near nodes of new_node_s\n            for node_n in near_s:\n                alt_cost = new_node_s.cost + distance(new_node_s.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_s.position, node_n.position):\n                    # Remove old edge if exists\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_s, alt_cost)\n                    edges.append((new_node_s, node_n))\n\n            # Extend tree_goal towards new_node_s\n            nearest_g = nearest_node(tree_goal, new_node_s.position)\n            new_pos_g = steer(nearest_g.position, new_node_s.position)\n            if not can_connect(nearest_g.position, new_pos_g):\n                continue\n\n            new_node_g = Node(new_pos_g)\n\n            # Ensure new_node_g is in bounds and not in obstacle\n            if not in_bounds(new_node_g.position) or self._is_in_obstacle(new_node_g.position, obstacles, is_3d):\n                continue\n\n            near_g = near_nodes(tree_goal, new_pos_g, radius)\n            min_cost_g = nearest_g.cost + distance(nearest_g.position, new_pos_g)\n            best_parent_g = nearest_g\n            for node_n in near_g:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_g)\n                if cost_n < min_cost_g and can_connect(node_n.position, new_pos_g):\n                    min_cost_g = cost_n\n                    best_parent_g = node_n\n\n            best_parent_g.add_child(new_node_g)\n            new_node_g.cost = min_cost_g\n            tree_goal.append(new_node_g)\n            nodes.append(new_node_g)\n            edges.append((best_parent_g, new_node_g))\n\n            # Rewire near nodes of new_node_g\n            for node_n in near_g:\n                alt_cost = new_node_g.cost + distance(new_node_g.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_g.position, node_n.position):\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_g, alt_cost)\n                    edges.append((new_node_g, node_n))\n\n            # Check if trees connect (within step_size)\n            if distance(new_node_s.position, new_node_g.position) <= self.step_size and can_connect(new_node_s.position, new_node_g.position):\n                # Connect nodes\n                new_node_s.add_child(new_node_g)\n                edges.append((new_node_s, new_node_g))\n\n                path_start = new_node_s.path_from_root()\n                path_goal = new_node_g.path_from_root()\n                extracted_path = path_start + path_goal[::-1]\n\n                path_length = new_node_s.cost + distance(new_node_s.position, new_node_g.position) + new_node_g.cost\n                if path_length < best_cost:\n                    best_cost = path_length\n                    success_state = True\n                    goal_reached_node_start = new_node_s\n                    goal_reached_node_goal = new_node_g\n\n                break  # stop after first found shortest path\n\n            # Swap trees for bidirectional growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        from eoh.problems.optimization.classic_benchmark_path_planning.utils.architecture_utils import PlannerResult\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm is a simplified, generalized RRT* with informed sampling and bidirectional growth principles combined. It focuses exploration using ellipsoidal informed sampling after an initial solution and grows two trees simultaneously from start and goal to improve convergence, path quality, and robustness. The planner incorporates rewiring for path optimization, collision and edge checks for safety, and boundary enforcement to reduce computation and improve overall success rate and path smoothness.",
     "planning_mechanism": "The planner initializes two trees from the start and goal. It samples points uniformly at first and within an informed ellipsoid after a solution is found, ensuring samples have potential to improve the path. Both trees extend towards sampled points while avoiding obstacles. When the two trees connect, the path is reconstructed, and neighboring nodes are rewired for path quality improvement. Collision checks on nodes and edges ensure safety. The algorithm runs until max iterations or a satisfying path is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants\n        for child in self.children:\n            child.update_cost_and_parent(self, self.cost + distance(self.position, child.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> dict:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            # Ensure point P is within map bounds, inclusive\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample(c_best=float(\"inf\")):\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n            else:\n                c_min = distance(start_position, goal_position)\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                a1 = np.array(goal_position) - np.array(start_position)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    C = np.eye(dim)\n                else:\n                    a1 = a1 / a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n\n                for _ in range(100):\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm < 1e-6:\n                        continue\n                    x_ball = x_ball / norm * random.random() ** (1 / dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    p = tuple(x_rand)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(p, obstacles, is_3d) and in_bounds(p):\n                        return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        radius = max(bounds) * 0.15  # Adaptive radius for rewiring\n\n        for _ in range(self.max_iter):\n            c_best = best_cost if best_cost < float(\"inf\") else float(\"inf\")\n            x_rand = sample(c_best)\n\n            # Extend tree_start towards sample\n            nearest_s = nearest_node(tree_start, x_rand)\n            new_pos_s = steer(nearest_s.position, x_rand)\n            if not can_connect(nearest_s.position, new_pos_s):\n                continue\n\n            if not in_bounds(new_pos_s) or self._is_in_obstacle(new_pos_s, obstacles, is_3d):\n                continue\n\n            new_node_s = Node(new_pos_s)\n\n            near_s = near_nodes(tree_start, new_pos_s, radius)\n            min_cost = nearest_s.cost + distance(nearest_s.position, new_pos_s)\n            best_parent = nearest_s\n\n            for node_n in near_s:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_s)\n                if cost_n < min_cost and can_connect(node_n.position, new_pos_s):\n                    min_cost = cost_n\n                    best_parent = node_n\n\n            best_parent.add_child(new_node_s)\n            new_node_s.cost = min_cost\n            tree_start.append(new_node_s)\n            nodes.append(new_node_s)\n            edges.append((best_parent, new_node_s))\n\n            for node_n in near_s:\n                alt_cost = new_node_s.cost + distance(new_node_s.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_s.position, node_n.position):\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_s, alt_cost)\n                    edges.append((new_node_s, node_n))\n\n            # Extend tree_goal towards new_node_s\n            nearest_g = nearest_node(tree_goal, new_node_s.position)\n            new_pos_g = steer(nearest_g.position, new_node_s.position)\n            if not can_connect(nearest_g.position, new_pos_g):\n                continue\n\n            if not in_bounds(new_pos_g) or self._is_in_obstacle(new_pos_g, obstacles, is_3d):\n                continue\n\n            new_node_g = Node(new_pos_g)\n\n            near_g = near_nodes(tree_goal, new_pos_g, radius)\n            min_cost_g = nearest_g.cost + distance(nearest_g.position, new_pos_g)\n            best_parent_g = nearest_g\n\n            for node_n in near_g:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_g)\n                if cost_n < min_cost_g and can_connect(node_n.position, new_pos_g):\n                    min_cost_g = cost_n\n                    best_parent_g = node_n\n\n            best_parent_g.add_child(new_node_g)\n            new_node_g.cost = min_cost_g\n            tree_goal.append(new_node_g)\n            nodes.append(new_node_g)\n            edges.append((best_parent_g, new_node_g))\n\n            for node_n in near_g:\n                alt_cost = new_node_g.cost + distance(new_node_g.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_g.position, node_n.position):\n                    try:\n                        edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_g, alt_cost)\n                    edges.append((new_node_g, node_n))\n\n            # Check if trees connect (within step_size)\n            if distance(new_node_s.position, new_node_g.position) <= self.step_size and can_connect(new_node_s.position, new_node_g.position):\n                # Connect nodes if edge collision-free and node not inside obstacle\n                if (not self._is_in_obstacle(new_node_g.position, obstacles, is_3d)) and (not self._is_edge_in_obstacle(new_node_s.position, new_node_g.position, obstacles, is_3d)):\n                    new_node_s.add_child(new_node_g)\n                    edges.append((new_node_s, new_node_g))\n\n                    path_start = new_node_s.path_from_root()\n                    path_goal = new_node_g.path_from_root()\n                    # Remove duplicated connecting node position\n                    extracted_path = path_start + path_goal[::-1][1:]\n\n                    path_length = new_node_s.cost + distance(new_node_s.position, new_node_g.position) + new_node_g.cost\n                    if path_length < best_cost:\n                        best_cost = path_length\n                        success_state = True\n\n                    break  # stop after first found shortest path\n\n            # Swap trees for bidirectional growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return {\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm is a simplified, generalized RRT* with informed sampling and bidirectional growth principles combined. It focuses exploration using ellipsoidal informed sampling after an initial solution and grows two trees simultaneously from start and goal to improve convergence, path quality, and robustness. The planner incorporates rewiring for path optimization, collision and edge checks for safety, and boundary enforcement to reduce computation and improve overall success rate and path smoothness.",
     "planning_mechanism": "The planner initializes two trees from the start and goal. It samples points uniformly at first and within an informed ellipsoid after a solution is found, ensuring samples have potential to improve the path. Both trees extend towards sampled points while avoiding obstacles. When the two trees connect, the path is reconstructed, and neighboring nodes are rewired for path quality improvement. Collision checks on nodes and edges ensure safety. The algorithm runs until max iterations or a satisfying path is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost_and_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n        # Propagate cost updates to descendants\n        for child in self.children:\n            child.update_cost_and_parent(self, self.cost + distance(self.position, child.position))\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        def in_bounds(p):\n            # Ensure point P is within map bounds, inclusive\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = distance(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def sample(c_best=float(\"inf\")):\n            if c_best == float(\"inf\"):\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n            else:\n                c_min = distance(start_position, goal_position)\n                x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n                a1 = np.array(goal_position) - np.array(start_position)\n                a1_norm = np.linalg.norm(a1)\n                if a1_norm == 0:\n                    C = np.eye(dim)\n                else:\n                    a1 = a1 / a1_norm\n                    I = np.eye(dim)\n                    M = np.outer(a1, I[:, 0])\n                    U, _, Vt = np.linalg.svd(M)\n                    C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n                L_diag = [c_best / 2] + [math.sqrt(c_best ** 2 - c_min ** 2) / 2] * (dim - 1)\n                L = np.diag(L_diag)\n\n                for _ in range(100):\n                    x_ball = np.random.normal(0, 1, dim)\n                    norm = np.linalg.norm(x_ball)\n                    if norm < 1e-6:\n                        continue\n                    x_ball = x_ball / norm * random.random() ** (1 / dim)\n                    x_rand = C @ (L @ x_ball) + x_center\n                    p = tuple(x_rand)\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n                # fallback\n                while True:\n                    p = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if in_bounds(p) and not self._is_in_obstacle(p, obstacles, is_3d):\n                        return p\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda node: distance(node.position, point))\n\n        def near_nodes(tree, point, radius):\n            return [node for node in tree if distance(node.position, point) <= radius]\n\n        def can_connect(p1, p2):\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                return False\n            return True\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        tree_start, tree_goal = [start_root], [goal_root]\n        nodes = [start_root, goal_root]\n        edges = []\n\n        best_cost = float(\"inf\")\n        success_state = False\n        extracted_path = []\n\n        radius = max(bounds) * 0.15  # Adaptive radius for rewiring\n\n        for _ in range(self.max_iter):\n            c_best = best_cost if best_cost < float(\"inf\") else float(\"inf\")\n            x_rand = sample(c_best)\n\n            # Extend tree_start towards sample\n            nearest_s = nearest_node(tree_start, x_rand)\n            new_pos_s = steer(nearest_s.position, x_rand)\n\n            if not in_bounds(new_pos_s):\n                continue\n            if self._is_in_obstacle(new_pos_s, obstacles, is_3d):\n                continue\n            if not can_connect(nearest_s.position, new_pos_s):\n                continue\n\n            new_node_s = Node(new_pos_s)\n\n            near_s = near_nodes(tree_start, new_pos_s, radius)\n            min_cost = nearest_s.cost + distance(nearest_s.position, new_pos_s)\n            best_parent = nearest_s\n\n            for node_n in near_s:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_s)\n                if cost_n < min_cost and can_connect(node_n.position, new_pos_s):\n                    min_cost = cost_n\n                    best_parent = node_n\n\n            # Ensure new_node_s itself is not inside obstacle and edge is valid before adding\n            if not self._is_in_obstacle(new_node_s.position, obstacles, is_3d) and can_connect(best_parent.position, new_node_s.position):\n                best_parent.add_child(new_node_s)\n                new_node_s.cost = min_cost\n                tree_start.append(new_node_s)\n                nodes.append(new_node_s)\n                edges.append((best_parent, new_node_s))\n            else:\n                continue\n\n            for node_n in near_s:\n                alt_cost = new_node_s.cost + distance(new_node_s.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_s.position, node_n.position):\n                    try:\n                        if node_n.parent is not None:\n                            edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_s, alt_cost)\n                    edges.append((new_node_s, node_n))\n\n            # Extend tree_goal towards new_node_s\n            nearest_g = nearest_node(tree_goal, new_node_s.position)\n            new_pos_g = steer(nearest_g.position, new_node_s.position)\n\n            if not in_bounds(new_pos_g):\n                continue\n            if self._is_in_obstacle(new_pos_g, obstacles, is_3d):\n                continue\n            if not can_connect(nearest_g.position, new_pos_g):\n                continue\n\n            new_node_g = Node(new_pos_g)\n\n            near_g = near_nodes(tree_goal, new_pos_g, radius)\n            min_cost_g = nearest_g.cost + distance(nearest_g.position, new_pos_g)\n            best_parent_g = nearest_g\n\n            for node_n in near_g:\n                cost_n = node_n.cost + distance(node_n.position, new_pos_g)\n                if cost_n < min_cost_g and can_connect(node_n.position, new_pos_g):\n                    min_cost_g = cost_n\n                    best_parent_g = node_n\n\n            # Ensure new_node_g itself is not inside obstacle and edge is valid before adding\n            if not self._is_in_obstacle(new_node_g.position, obstacles, is_3d) and can_connect(best_parent_g.position, new_node_g.position):\n                best_parent_g.add_child(new_node_g)\n                new_node_g.cost = min_cost_g\n                tree_goal.append(new_node_g)\n                nodes.append(new_node_g)\n                edges.append((best_parent_g, new_node_g))\n            else:\n                continue\n\n            for node_n in near_g:\n                alt_cost = new_node_g.cost + distance(new_node_g.position, node_n.position)\n                if alt_cost < node_n.cost and can_connect(new_node_g.position, node_n.position):\n                    try:\n                        if node_n.parent is not None:\n                            edges.remove((node_n.parent, node_n))\n                    except (ValueError, AttributeError):\n                        pass\n                    node_n.update_cost_and_parent(new_node_g, alt_cost)\n                    edges.append((new_node_g, node_n))\n\n            # Check if trees connect (within step_size)\n            if distance(new_node_s.position, new_node_g.position) <= self.step_size:\n                if can_connect(new_node_s.position, new_node_g.position):\n                    # Connect nodes if edge collision-free and node not inside obstacle\n                    if (not self._is_in_obstacle(new_node_g.position, obstacles, is_3d)) and (not self._is_edge_in_obstacle(new_node_s.position, new_node_g.position, obstacles, is_3d)):\n                        new_node_s.add_child(new_node_g)\n                        edges.append((new_node_s, new_node_g))\n\n                        path_start = new_node_s.path_from_root()\n                        path_goal = new_node_g.path_from_root()\n                        # Remove duplicated connecting node position\n                        extracted_path = path_start + path_goal[::-1][1:]\n\n                        path_length = new_node_s.cost + distance(new_node_s.position, new_node_g.position) + new_node_g.cost\n                        if path_length < best_cost:\n                            best_cost = path_length\n                            success_state = True\n\n                        break  # stop after first found shortest path\n\n            # Swap trees for bidirectional growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance_ = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance_ / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid planner combining bidirectional RRT*-Connect's informed sampling and adaptive step sizing with RRT*'s optimal rewiring and goal biasing. It uses two trees grown from start and goal, includes heuristic-based sampling within an ellipsoidal informed subset, dynamically adjusts expansion steps near obstacles, prunes non-promising branches, and rewires nodes efficiently to improve solution quality. The planner attempts early connections between trees to quickly find high-quality paths and refines them incrementally for robustness and enhanced performance.",
     "planning_mechanism": "The planner alternates growth between two trees (start and goal), samples candidates with informed heuristics biased towards shortest path ellipsoid, adapts step sizes based on obstacle proximity, rejects costly expansions, and rewires locally to improve path costs. It integrates goal biasing and tries to connect the two trees at every iteration. Upon successful connection, it reconstructs the combined path and returns the best path found within the iteration limit.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a == tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a to the sample\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                # Prune paths that cannot improve existing best path\n                continue\n\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find near nodes in tree_a for rewiring\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire if cheaper path found\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Verify connection path collision free\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Optional pruning near best path could be inserted here (not mandatory)\n\n        # Post-processing: Optional path smoothing for improved path quality\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(success=success, path=best_path, nodes=all_nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        # If no solution, sample uniformly in bounds\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Calculate rotation matrix C that aligns x-axis with vector a1\n        # Using SVD-based method to get a proper rotation\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0\n        else:\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # reduce step near obstacle but keep minimum step size of 1\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n\n        path_smoothed = [path[0]]\n        idx = 0\n        while idx < len(path_smoothed):\n            # Attempt to skip intermediate nodes if straight connection is collision free\n            next_idx = len(path) -1\n            for j in range(len(path)-1, idx, -1):\n                if self._is_edge_in_obstacle(path_smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == len(path) -1:\n                path_smoothed += path[idx+1:]\n                break\n            if next_idx == idx:\n                # No farther progress, just add next node\n                path_smoothed.append(path[idx+1])\n                idx += 1\n            else:\n                path_smoothed.append(path[next_idx])\n                idx = next_idx\n        return path_smoothed",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid planner combining bidirectional RRT*-Connect's informed sampling and adaptive step sizing with RRT*'s optimal rewiring and goal biasing. It uses two trees grown from start and goal, includes heuristic-based sampling within an ellipsoidal informed subset, dynamically adjusts expansion steps near obstacles, prunes non-promising branches, and rewires nodes efficiently to improve solution quality. The planner attempts early connections between trees to quickly find high-quality paths and refines them incrementally for robustness and enhanced performance.",
     "planning_mechanism": "The planner alternates growth between two trees (start and goal), samples candidates with informed heuristics biased towards shortest path ellipsoid, adapts step sizes based on obstacle proximity, rejects costly expansions, and rewires locally to improve path costs. It integrates goal biasing and tries to connect the two trees at every iteration. Upon successful connection, it reconstructs the combined path and returns the best path found within the iteration limit.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random, numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            sample = None\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a == tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a to the sample\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                # Prune paths that cannot improve existing best path\n                continue\n\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find near nodes in tree_a for rewiring\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire if cheaper path found\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Verify connection path collision free\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Optional pruning near best path could be inserted here (not mandatory)\n\n        # Post-processing: Optional path smoothing for improved path quality\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return {\n            'success': success,\n            'path': best_path,\n            'nodes': all_nodes,\n            'edges': edges\n        }\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        # If no solution, sample uniformly in bounds\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Calculate rotation matrix C that aligns x-axis with vector a1\n        # Using SVD-based method to get a proper rotation\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        if c_best**2 - c_min**2 < 0:\n            r2 = 0\n        else:\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # reduce step near obstacle but keep minimum step size of 1\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n\n        path_smoothed = [path[0]]\n        idx = 0\n        while idx < len(path_smoothed):\n            # Attempt to skip intermediate nodes if straight connection is collision free\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(path_smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == len(path) - 1:\n                path_smoothed += path[idx+1:]\n                break\n            if next_idx == idx:\n                # No farther progress, just add next node\n                path_smoothed.append(path[idx+1])\n                idx += 1\n            else:\n                path_smoothed.append(path[next_idx])\n                idx = next_idx\n        return path_smoothed\n\n    # Dummy implementations for obstacle checks - actual implementations should exist elsewhere\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Check if pos lies inside any obstacle; placeholder\n        for obs in obstacles:\n            if self._point_in_rect(pos, obs):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if the line segment p1-p2 intersects any obstacle; placeholder\n        for obs in obstacles:\n            if self._line_intersects_rect(p1, p2, obs):\n                return True\n        return False\n\n    def _point_in_rect(self, point, rect):\n        # rect assumed as (xmin, ymin, xmax, ymax) or (xmin, ymin, zmin, xmax, ymax, zmax)\n        dims = len(point)\n        if dims == 2:\n            xmin, ymin, xmax, ymax = rect\n            x, y = point\n            return xmin <= x <= xmax and ymin <= y <= ymax\n        else:  # 3D\n            xmin, ymin, zmin, xmax, ymax, zmax = rect\n            x, y, z = point\n            return xmin <= x <= xmax and ymin <= y <= ymax and zmin <= z <= zmax\n\n    def _line_intersects_rect(self, p1, p2, rect):\n        # Simple sampling-based collision checking for the edge\n        import numpy as np\n        num_samples = 10\n        for i in range(num_samples + 1):\n            t = i / num_samples\n            point = tuple(p1[d] + t * (p2[d] - p1[d]) for d in range(len(p1)))\n            if self._point_in_rect(point, rect):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm, \"Bi-directional Informed FMT* with Lazy Collision Checking and Path Smoothing,\" combines the fast convergence property of Fast Marching Tree (FMT*) methods with bi-directional search and informed sampling. It incrementally builds two trees growing from start and goal using adaptive and heuristic-based neighbor connection, applies lazy collision checking to reduce computational overhead, and employs a post-processing smoothing step to refine the final path, thus improving planning efficiency, success rate, path quality, and robustness.",
     "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling mostly inside an ellipsoidal informed subset once an initial solution is found, connecting neighbors with minimal cost edges when collision-free, but defers edge collision checks until connection attempts in a lazy fashion. When trees connect, the final path is extracted and smoothed using shortcutting techniques to remove unnecessary waypoints, achieving shorter and smoother solutions with reduced runtime.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start (or goal, depending on tree)\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\n\n    def __lt__(self, other):\n        return self.cost < other.cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 8.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        # Initialize two trees, one from start and one from goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Open sets implemented as heaps, storing (cost, node)\n        open_start = [(0.0, tree_start[0])]  # cost from start\n        open_goal = [(0.0, tree_goal[0])]    # cost from goal\n\n        # Maps for fast position lookup\n        visited_start = {tree_start[0].position: tree_start[0]}\n        visited_goal = {tree_goal[0].position: tree_goal[0]}\n\n        # Current best cost and path\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        path_solution = []\n        success = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds until free sample found quickly\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Informed sampling inside prolate hyperspheroid (ellipsoid) between start and goal\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-9:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if collision_free_node(candidate):\n                    return candidate\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + self.step_size * direction[d] for d in range(dim))\n            return new_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect_trees(node_start, tree_goal):\n            # Attempt to connect the node from tree_start to any node in tree_goal within neighbor radius\n            neighbors_goal = near_nodes(tree_goal, node_start.position)\n            for goal_node in neighbors_goal:\n                if collision_free_edge(node_start.position, goal_node.position):\n                    # Total cost of connecting path\n                    path_cost = node_start.cost + goal_node.cost + math.dist(node_start.position, goal_node.position)\n                    nonlocal c_best, path_solution, success\n\n                    if path_cost < c_best:\n                        c_best = path_cost\n\n                        path_from_start = node_start.path_from_root()\n                        path_from_goal = goal_node.path_from_root()\n                        path_solution = path_from_start + path_from_goal[::-1]\n                        success = True\n                        return True\n            return False\n\n        # Lazy collision checking: Edges are created without immediate collision check;\n        # only checked when attempting connection to prune expensive computations.\n        # For each iteration, expand one node from start tree, one from goal tree (bi-directional) in alternation.\n        for iter_count in range(self.max_iter):\n            for tree_flag in [0, 1]:\n                tree_curr = tree_start if tree_flag == 0 else tree_goal\n                tree_other = tree_goal if tree_flag == 0 else tree_start\n                open_set = open_start if tree_flag == 0 else open_goal\n                visited_tree = visited_start if tree_flag == 0 else visited_goal\n\n                if not open_set:\n                    continue\n\n                # Pop node with smallest cost\n                curr_cost, current_node = heapq.heappop(open_set)\n\n                x_sample = informed_sample()\n                x_new_pos = steer(current_node.position, x_sample)\n                if not collision_free_node(x_new_pos):\n                    continue\n\n                if not collision_free_edge(current_node.position, x_new_pos):\n                    continue\n\n                # Check if improvement possible\n                est_total_cost = current_node.cost + math.dist(current_node.position, x_new_pos) + math.dist(x_new_pos, goal_position if tree_flag == 0 else start_position)\n                if est_total_cost >= c_best:\n                    continue  # prune non-improving samples\n\n                # Create new node and find minimal cost parent from near neighbors\n                near = near_nodes(tree_curr, x_new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, x_new_pos)\n                best_parent = current_node\n\n                # Search better parent among near neighbors\n                for neighbor in near:\n                    if neighbor == current_node:\n                        continue\n                    try_cost = neighbor.cost + math.dist(neighbor.position, x_new_pos)\n                    if try_cost < min_cost and collision_free_edge(neighbor.position, x_new_pos):\n                        min_cost = try_cost\n                        best_parent = neighbor\n\n                new_node = Node(x_new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                tree_curr.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                visited_tree[new_node.position] = new_node\n                heapq.heappush(open_set, (new_node.cost, new_node))\n\n                # Attempt to connect trees lazily\n                if try_connect_trees(new_node, tree_other):\n                    break\n            if success and c_best <= c_min * 1.05:\n                break\n\n        # If solution found, perform path smoothing by shortcutting\n        if success:\n            path_solution = self._smooth_path(path_solution, obstacles, is_3d, bounds)\n\n        return PlannerResult(success, path_solution, nodes, edges)\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_attempts=200):\n        import random\n        if len(path) <= 2:\n            return path\n\n        path_pts = path[:]\n        for _ in range(max_attempts):\n            if len(path_pts) <= 2:\n                break\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i + 2, len(path_pts) - 1)\n            p_start = path_pts[i]\n            p_end = path_pts[j]\n\n            if self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                continue\n\n            # If shortcut possible, remove intermediate nodes between i and j\n            path_pts = path_pts[:i + 1] + path_pts[j:]\n        return path_pts",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm, \"Bi-directional Informed FMT* with Lazy Collision Checking and Path Smoothing,\" combines the fast convergence property of Fast Marching Tree (FMT*) methods with bi-directional search and informed sampling. It incrementally builds two trees growing from start and goal using adaptive and heuristic-based neighbor connection, applies lazy collision checking to reduce computational overhead, and employs a post-processing smoothing step to refine the final path, thus improving planning efficiency, success rate, path quality, and robustness.",
     "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling mostly inside an ellipsoidal informed subset once an initial solution is found, connecting neighbors with minimal cost edges when collision-free, but defers edge collision checks until connection attempts in a lazy fashion. When trees connect, the final path is extracted and smoothed using shortcutting techniques to remove unnecessary waypoints, achieving shorter and smoother solutions with reduced runtime.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start (or goal, depending on tree)\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\n\n    def __lt__(self, other):\n        return self.cost < other.cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 8.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        # Initialize two trees, one from start and one from goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Open sets implemented as heaps, storing (cost, node)\n        open_start = [(0.0, tree_start[0])]  # cost from start\n        open_goal = [(0.0, tree_goal[0])]    # cost from goal\n\n        # Maps for fast position lookup\n        visited_start = {tree_start[0].position: tree_start[0]}\n        visited_goal = {tree_goal[0].position: tree_goal[0]}\n\n        # Current best cost and path\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        path_solution = []\n        success = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not self._is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not self._is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds until free sample found quickly\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Informed sampling inside prolate hyperspheroid (ellipsoid) between start and goal\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-9:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if collision_free_node(candidate):\n                    return candidate\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + self.step_size * direction[d] for d in range(dim))\n            return new_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect_trees(node_start, tree_goal):\n            neighbors_goal = near_nodes(tree_goal, node_start.position)\n            for goal_node in neighbors_goal:\n                if collision_free_edge(node_start.position, goal_node.position):\n                    path_cost = node_start.cost + goal_node.cost + math.dist(node_start.position, goal_node.position)\n                    nonlocal c_best, path_solution, success\n\n                    if path_cost < c_best:\n                        c_best = path_cost\n\n                        path_from_start = node_start.path_from_root()\n                        path_from_goal = goal_node.path_from_root()\n                        # Remove duplicate connecting node by excluding first of path_from_goal\n                        path_solution = path_from_start + path_from_goal[::-1][1:]\n                        success = True\n                        return True\n            return False\n\n        # Lazy collision checking: Edges are created only when connecting trees\n        for iter_count in range(self.max_iter):\n            for tree_flag in [0, 1]:\n                tree_curr = tree_start if tree_flag == 0 else tree_goal\n                tree_other = tree_goal if tree_flag == 0 else tree_start\n                open_set = open_start if tree_flag == 0 else open_goal\n                visited_tree = visited_start if tree_flag == 0 else visited_goal\n\n                if not open_set:\n                    continue\n\n                curr_cost, current_node = heapq.heappop(open_set)\n\n                x_sample = informed_sample()\n                x_new_pos = steer(current_node.position, x_sample)\n                if not collision_free_node(x_new_pos):\n                    continue\n\n                if not collision_free_edge(current_node.position, x_new_pos):\n                    continue\n\n                est_total_cost = current_node.cost + math.dist(current_node.position, x_new_pos) + math.dist(x_new_pos, goal_position if tree_flag == 0 else start_position)\n                if est_total_cost >= c_best:\n                    continue\n\n                near = near_nodes(tree_curr, x_new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, x_new_pos)\n                best_parent = current_node\n\n                for neighbor in near:\n                    if neighbor == current_node:\n                        continue\n                    try_cost = neighbor.cost + math.dist(neighbor.position, x_new_pos)\n                    if try_cost < min_cost and collision_free_edge(neighbor.position, x_new_pos):\n                        min_cost = try_cost\n                        best_parent = neighbor\n\n                # Check collision free again for node and edge before adding (redundant but safe)\n                if not collision_free_node(x_new_pos):\n                    continue\n                if not collision_free_edge(best_parent.position, x_new_pos):\n                    continue\n\n                new_node = Node(x_new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                tree_curr.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                visited_tree[new_node.position] = new_node\n                heapq.heappush(open_set, (new_node.cost, new_node))\n\n                if try_connect_trees(new_node, tree_other):\n                    break\n\n            if success and c_best <= c_min * 1.05:\n                break\n\n        if success:\n            path_solution = self._smooth_path(path_solution, obstacles, is_3d, bounds)\n\n        return PlannerResult(success, path_solution, nodes, edges)\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_attempts=200):\n        import random\n        if len(path) <= 2:\n            return path\n\n        path_pts = path[:]\n        for _ in range(max_attempts):\n            if len(path_pts) <= 2:\n                break\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i + 2, len(path_pts) - 1)\n            p_start = path_pts[i]\n            p_end = path_pts[j]\n\n            if self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                continue\n\n            path_pts = path_pts[:i + 1] + path_pts[j:]\n        return path_pts",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm, \"Bi-directional Informed FMT* with Lazy Collision Checking and Path Smoothing,\" combines the fast convergence property of Fast Marching Tree (FMT*) methods with bi-directional search and informed sampling. It incrementally builds two trees growing from start and goal using adaptive and heuristic-based neighbor connection, applies lazy collision checking to reduce computational overhead, and employs a post-processing smoothing step to refine the final path, thus improving planning efficiency, success rate, path quality, and robustness.",
     "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling mostly inside an ellipsoidal informed subset once an initial solution is found, connecting neighbors with minimal cost edges when collision-free, but defers edge collision checks until connection attempts in a lazy fashion. When trees connect, the final path is extracted and smoothed using shortcutting techniques to remove unnecessary waypoints, achieving shorter and smoother solutions with reduced runtime.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start (or goal, depending on tree)\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\n\n    def __lt__(self, other):\n        return self.cost < other.cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 8.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return {\n                \"success\": True,\n                \"path\": [start_position],\n                \"nodes\": [node],\n                \"edges\": []\n            }\n\n        # Initialize two trees, one from start and one from goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Open sets implemented as heaps, storing (cost, node)\n        open_start = [(0.0, tree_start[0])]  # cost from start\n        open_goal = [(0.0, tree_goal[0])]    # cost from goal\n\n        # Maps for fast position lookup\n        visited_start = {tree_start[0].position: tree_start[0]}\n        visited_goal = {tree_goal[0].position: tree_goal[0]}\n\n        # Current best cost and path\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        path_solution = []\n        success = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def _is_in_obstacle(pos, obstacles, is_3d):\n            for obs in obstacles:\n                if is_3d:\n                    # obs: dict with keys center (x,y,z) and radius\n                    center = obs[\"center\"]\n                    radius = obs[\"radius\"]\n                    dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(dim))\n                    if dist_sq <= radius * radius:\n                        return True\n                else:\n                    # obs: dict with keys center (x,y) and radius\n                    center = obs[\"center\"]\n                    radius = obs[\"radius\"]\n                    dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(dim))\n                    if dist_sq <= radius * radius:\n                        return True\n            return False\n\n        def _is_edge_in_obstacle(p1, p2, obstacles, is_3d, step_size=0.5):\n            import numpy as np\n            vec = np.array(p2) - np.array(p1)\n            dist = np.linalg.norm(vec)\n            if dist < 1e-9:\n                return _is_in_obstacle(p1, obstacles, is_3d)\n            direction = vec / dist\n            steps = max(2, int(dist / step_size))\n            for i in range(steps + 1):\n                pos = tuple(np.array(p1) + direction * (dist * i / steps))\n                if _is_in_obstacle(pos, obstacles, is_3d):\n                    return True\n            return False\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not _is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not _is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling in bounds until free sample found quickly\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        return sample\n                # fallback\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            # Informed sampling inside prolate hyperspheroid (ellipsoid) between start and goal\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-9:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if collision_free_node(candidate):\n                    return candidate\n            # fallback uniform\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + self.step_size * direction[d] for d in range(dim))\n            return new_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect_trees(node_start, tree_goal):\n            neighbors_goal = near_nodes(tree_goal, node_start.position)\n            for goal_node in neighbors_goal:\n                if collision_free_edge(node_start.position, goal_node.position):\n                    path_cost = node_start.cost + goal_node.cost + math.dist(node_start.position, goal_node.position)\n                    nonlocal c_best, path_solution, success\n\n                    if path_cost < c_best:\n                        c_best = path_cost\n\n                        path_from_start = node_start.path_from_root()\n                        path_from_goal = goal_node.path_from_root()\n                        # Remove duplicate connecting node by excluding first of path_from_goal\n                        path_solution = path_from_start + path_from_goal[::-1][1:]\n                        success = True\n                        return True\n            return False\n\n        # Lazy collision checking: Edges are created only when connecting trees\n        for iter_count in range(self.max_iter):\n            for tree_flag in [0, 1]:\n                tree_curr = tree_start if tree_flag == 0 else tree_goal\n                tree_other = tree_goal if tree_flag == 0 else tree_start\n                open_set = open_start if tree_flag == 0 else open_goal\n                visited_tree = visited_start if tree_flag == 0 else visited_goal\n\n                if not open_set:\n                    continue\n\n                curr_cost, current_node = heapq.heappop(open_set)\n\n                x_sample = informed_sample()\n                x_new_pos = steer(current_node.position, x_sample)\n                if not collision_free_node(x_new_pos):\n                    continue\n\n                if not collision_free_edge(current_node.position, x_new_pos):\n                    continue\n\n                est_total_cost = current_node.cost + math.dist(current_node.position, x_new_pos) + math.dist(x_new_pos, goal_position if tree_flag == 0 else start_position)\n                if est_total_cost >= c_best:\n                    continue\n\n                near = near_nodes(tree_curr, x_new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, x_new_pos)\n                best_parent = current_node\n\n                for neighbor in near:\n                    if neighbor == current_node:\n                        continue\n                    try_cost = neighbor.cost + math.dist(neighbor.position, x_new_pos)\n                    if try_cost < min_cost and collision_free_edge(neighbor.position, x_new_pos):\n                        min_cost = try_cost\n                        best_parent = neighbor\n\n                # Check collision free again for node and edge before adding (redundant but safe)\n                if not collision_free_node(x_new_pos):\n                    continue\n                if not collision_free_edge(best_parent.position, x_new_pos):\n                    continue\n\n                new_node = Node(x_new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                tree_curr.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                visited_tree[new_node.position] = new_node\n                heapq.heappush(open_set, (new_node.cost, new_node))\n\n                if try_connect_trees(new_node, tree_other):\n                    break\n\n            if success and c_best <= c_min * 1.05:\n                break\n\n        if success:\n            path_solution = self._smooth_path(path_solution, obstacles, is_3d, bounds)\n\n        return {\n            \"success\": success,\n            \"path\": path_solution,\n            \"nodes\": nodes,\n            \"edges\": edges,\n        }\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_attempts=200):\n        import random\n        if len(path) <= 2:\n            return path\n\n        path_pts = path[:]\n        for _ in range(max_attempts):\n            if len(path_pts) <= 2:\n                break\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i + 2, len(path_pts) - 1)\n            p_start = path_pts[i]\n            p_end = path_pts[j]\n\n            if self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                continue\n\n            path_pts = path_pts[:i + 1] + path_pts[j:]\n        return path_pts\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, step_size=0.5):\n        # Helper for _smooth_path's collision checking\n        import numpy as np\n        vec = np.array(p2) - np.array(p1)\n        dist = np.linalg.norm(vec)\n        if dist < 1e-9:\n            return self._is_in_obstacle(p1, obstacles, is_3d)\n        direction = vec / dist\n        steps = max(2, int(dist / step_size))\n        for i in range(steps + 1):\n            pos = tuple(np.array(p1) + direction * (dist * i / steps))\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                center = obs[\"center\"]\n                radius = obs[\"radius\"]\n                dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(len(pos)))\n                if dist_sq <= radius * radius:\n                    return True\n            else:\n                center = obs[\"center\"]\n                radius = obs[\"radius\"]\n                dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(len(pos)))\n                if dist_sq <= radius * radius:\n                    return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm, \"Bi-directional Informed FMT* with Lazy Collision Checking and Path Smoothing,\" combines the fast convergence property of Fast Marching Tree (FMT*) methods with bi-directional search and informed sampling. It incrementally builds two trees growing from start and goal using adaptive and heuristic-based neighbor connection, applies lazy collision checking to reduce computational overhead, and employs a post-processing smoothing step to refine the final path, thus improving planning efficiency, success rate, path quality, and robustness.",
     "planning_mechanism": "The planner alternates growth of two trees rooted at start and goal by sampling mostly inside an ellipsoidal informed subset once an initial solution is found, connecting neighbors with minimal cost edges when collision-free, but defers edge collision checks until connection attempts in a lazy fashion. When trees connect, the final path is extracted and smoothed using shortcutting techniques to remove unnecessary waypoints, achieving shorter and smoother solutions with reduced runtime.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start (or goal, depending on tree)\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other):\n        import math\n        return math.dist(self.position, other.position)\n\n    def __lt__(self, other):\n        return self.cost < other.cost\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 8.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import heapq\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(\n                success=True,\n                path=[start_position],\n                nodes=[node],\n                edges=[]\n            )\n\n        # Initialize two trees, one from start and one from goal\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        nodes = tree_start + tree_goal\n        edges = []\n\n        # Open sets implemented as heaps, storing (cost, node)\n        open_start = [(0.0, tree_start[0])]  # cost from start\n        open_goal = [(0.0, tree_goal[0])]    # cost from goal\n\n        # Maps for fast position lookup\n        visited_start = {tree_start[0].position: tree_start[0]}\n        visited_goal = {tree_goal[0].position: tree_goal[0]}\n\n        # Current best cost and path\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n        path_solution = []\n        success = False\n\n        def within_bounds(p):\n            return all(0.0 <= p[d] <= bounds[d] for d in range(dim))\n\n        def _is_in_obstacle(pos, obstacles, is_3d):\n            for obs in obstacles:\n                center = obs[\"center\"]\n                radius = obs[\"radius\"]\n                dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(dim))\n                if dist_sq <= radius * radius:\n                    return True\n            return False\n\n        def _is_edge_in_obstacle(p1, p2, obstacles, is_3d, step_size=0.5):\n            vec = np.array(p2) - np.array(p1)\n            dist = np.linalg.norm(vec)\n            if dist < 1e-9:\n                return _is_in_obstacle(p1, obstacles, is_3d)\n            direction = vec / dist\n            steps = max(2, int(dist / step_size))\n            for i in range(steps + 1):\n                pos = tuple(np.array(p1) + direction * (dist * i / steps))\n                if _is_in_obstacle(pos, obstacles, is_3d):\n                    return True\n            return False\n\n        def collision_free_node(pos):\n            return (within_bounds(pos)\n                    and not _is_in_obstacle(pos, obstacles, is_3d))\n\n        def collision_free_edge(p1, p2):\n            return not _is_edge_in_obstacle(p1, p2, obstacles, is_3d)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if collision_free_node(sample):\n                        return sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            val = max(c_best * c_best - c_min * c_min, 0.0)\n            r2 = math.sqrt(val) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball < 1e-9:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if collision_free_node(candidate):\n                    return candidate\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if collision_free_node(sample):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(dim))\n            new_pos = tuple(from_pos[d] + self.step_size * direction[d] for d in range(dim))\n            return new_pos\n\n        def near_nodes(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect_trees(node_start, tree_goal):\n            neighbors_goal = near_nodes(tree_goal, node_start.position)\n            nonlocal c_best, path_solution, success\n            for goal_node in neighbors_goal:\n                if collision_free_edge(node_start.position, goal_node.position):\n                    path_cost = node_start.cost + goal_node.cost + math.dist(node_start.position, goal_node.position)\n                    if path_cost < c_best:\n                        c_best = path_cost\n\n                        path_from_start = node_start.path_from_root()\n                        path_from_goal = goal_node.path_from_root()\n                        path_solution = path_from_start + path_from_goal[::-1][1:]\n                        success = True\n                        return True\n            return False\n\n        for iter_count in range(self.max_iter):\n            for tree_flag in [0, 1]:\n                tree_curr = tree_start if tree_flag == 0 else tree_goal\n                tree_other = tree_goal if tree_flag == 0 else tree_start\n                open_set = open_start if tree_flag == 0 else open_goal\n                visited_tree = visited_start if tree_flag == 0 else visited_goal\n\n                if not open_set:\n                    continue\n\n                curr_cost, current_node = heapq.heappop(open_set)\n\n                x_sample = informed_sample()\n                x_new_pos = steer(current_node.position, x_sample)\n\n                if not collision_free_node(x_new_pos):\n                    continue\n\n                if not collision_free_edge(current_node.position, x_new_pos):\n                    continue\n\n                est_total_cost = current_node.cost + math.dist(current_node.position, x_new_pos) + \\\n                                 math.dist(x_new_pos, goal_position if tree_flag == 0 else start_position)\n                if est_total_cost >= c_best:\n                    continue\n\n                near = near_nodes(tree_curr, x_new_pos)\n                min_cost = current_node.cost + math.dist(current_node.position, x_new_pos)\n                best_parent = current_node\n\n                for neighbor in near:\n                    if neighbor == current_node:\n                        continue\n                    try_cost = neighbor.cost + math.dist(neighbor.position, x_new_pos)\n                    if try_cost < min_cost and collision_free_edge(neighbor.position, x_new_pos):\n                        min_cost = try_cost\n                        best_parent = neighbor\n\n                if not collision_free_node(x_new_pos):\n                    continue\n                if not collision_free_edge(best_parent.position, x_new_pos):\n                    continue\n\n                new_node = Node(x_new_pos, best_parent, min_cost)\n                best_parent.add_child(new_node)\n                tree_curr.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n                visited_tree[new_node.position] = new_node\n                heapq.heappush(open_set, (new_node.cost, new_node))\n\n                if try_connect_trees(new_node, tree_other):\n                    break\n\n            if success and c_best <= c_min * 1.05:\n                break\n\n        if success:\n            path_solution = self._smooth_path(path_solution, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=path_solution,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds, max_attempts=200):\n        import random\n        if len(path) <= 2:\n            return path\n\n        path_pts = path[:]\n        for _ in range(max_attempts):\n            if len(path_pts) <= 2:\n                break\n            i = random.randint(0, len(path_pts) - 3)\n            j = random.randint(i + 2, len(path_pts) - 1)\n            p_start = path_pts[i]\n            p_end = path_pts[j]\n\n            if self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                continue\n\n            path_pts = path_pts[:i + 1] + path_pts[j:]\n        return path_pts\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, step_size=0.5):\n        import numpy as np\n        vec = np.array(p2) - np.array(p1)\n        dist = np.linalg.norm(vec)\n        if dist < 1e-9:\n            return self._is_in_obstacle(p1, obstacles, is_3d)\n        direction = vec / dist\n        steps = max(2, int(dist / step_size))\n        for i in range(steps + 1):\n            pos = tuple(np.array(p1) + direction * (dist * i / steps))\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return True\n        return False\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            center = obs[\"center\"]\n            radius = obs[\"radius\"]\n            dist_sq = sum((pos[d] - center[d]) ** 2 for d in range(len(pos)))\n            if dist_sq <= radius * radius:\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the informed heuristic sampling, adaptive step size, node pruning, and rewiring strategies from Improved RRT*-Connect with the robust bidirectional tree growth and rewiring approach of RRT*-Connect. It adaptively samples within an informed ellipsoidal domain around the current best path cost to focus the search, grows two trees from start and goal alternately, dynamically adjusts step size near obstacles for safer expansions, prunes suboptimal branches, and performs rewiring intelligently to minimize path cost and improve convergence. The planner tries to connect the two trees frequently and updates the best path found while maintaining collision safety checks throughout.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with informed sampling constrained by the current best path cost. During extension, it adjusts step sizes adaptively around obstacles, rejects expansions that cannot improve the solution, and rewires neighbors to optimize paths locally. Each new node is tested for collision and edges are checked for collisions before addition. It attempts to connect the two trees after each node insertion. Pruning removes nodes and branches that cannot lead to better solutions, improving efficiency and robustness. Upon success, the shortest collision-free path spanning start to goal is returned.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from start\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                # Uniform sampling within bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            # Informed ellipsoidal sampling\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Compute rotation matrix C that aligns the x-axis with a1\n            # Using SVD for orthogonal basis\n            I1 = np.eye(dim)[:, 0]\n            M = np.outer(a1, I1)\n            U, _, VT = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(VT)]) @ VT\n            r1 = c_best / 2\n            r2 = math.sqrt(c_best ** 2 - c_min ** 2) / 2 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):  # Limit to 100 tries to find a valid sample\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # fallback uniform sampling\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacle but not below 1.0\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            d = dist(from_pos, to_pos)\n            if d <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / d for d in range(dim))\n\n        def near_nodes(tree, new_node_pos, radius):\n            return [node for node in tree if dist(node.position, new_node_pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def path_cost(path_nodes: List[Node]) -> float:\n            if not path_nodes:\n                return float('inf')\n            return path_nodes[-1].cost\n\n        def extract_path(node_from, node_to):\n            path_a = node_from.path_from_root()\n            path_b = []\n            node = node_to\n            while node:\n                path_b.append(node.position)\n                node = node.parent\n            return path_a + path_b[::-1]\n\n        def prune(tree, cost_limit):\n            # Remove nodes from tree that cannot improve the solution >= cost_limit\n            # Recursively invalidate subtrees whose root node cost + heuristic to goal >= cost_limit\n            def invalidate_subtree(node):\n                node.valid = False\n                if node.parent:\n                    node.parent.remove_child(node)\n                for child in list(node.children):\n                    invalidate_subtree(child)\n                node.children = []\n\n            for node in list(tree):\n                if not node.valid:\n                    continue\n                heuristic = dist(node.position, goal_position if tree is start_tree else start_position)\n                if node.cost + heuristic >= cost_limit:\n                    invalidate_subtree(node)\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n\n        for iter in range(self.max_iter):\n            # Alternate trees for extension\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            nearest = min((n for n in tree_a if n.valid), key=lambda n: dist(n.position, sample), default=None)\n            if nearest is None:\n                continue\n\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            # Check node collision and edge collision\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            # Pruning: if new cost + heuristic >= current best cost, skip\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_to_goal = dist(new_pos, goal_position)\n            est_total_cost = new_cost + heuristic_to_goal\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in the same tree\n            rewire(tree_a, new_node)\n\n            # Attempt to connect to nearest node in opposite tree\n            other_nearest = min((n for n in tree_b if n.valid), key=lambda n: dist(n.position, new_node.position), default=None)\n            if other_nearest is not None:\n                connect_dist = dist(new_node.position, other_nearest.position)\n                if connect_dist <= self.base_step:\n                    # Check edge collision before connecting trees\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        path_cost_candidate = new_node.cost + connect_dist + other_nearest.cost\n                        if path_cost_candidate < c_best:\n                            c_best = path_cost_candidate\n                            success_state = True\n                            # Extract the full path from start to goal via new_node and other_nearest\n                            if tree_a is start_tree:\n                                best_path = extract_path(new_node, other_nearest)\n                            else:\n                                best_path = extract_path(other_nearest, new_node)\n\n                            # Prune nodes in both trees that cannot yield better path\n                            prune(start_tree, c_best)\n                            prune(goal_tree, c_best)\n\n            # Early stop if path found with sufficiently low cost\n            if success_state and c_best <= c_min * 1.05:  # within 5% of shortest distance\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the informed heuristic sampling, adaptive step size, node pruning, and rewiring strategies from Improved RRT*-Connect with the robust bidirectional tree growth and rewiring approach of RRT*-Connect. It adaptively samples within an informed ellipsoidal domain around the current best path cost to focus the search, grows two trees from start and goal alternately, dynamically adjusts step size near obstacles for safer expansions, prunes suboptimal branches, and performs rewiring intelligently to minimize path cost and improve convergence. The planner tries to connect the two trees frequently and updates the best path found while maintaining collision safety checks throughout.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with informed sampling constrained by the current best path cost. During extension, it adjusts step sizes adaptively around obstacles, rejects expansions that cannot improve the solution, and rewires neighbors to optimize paths locally. Each new node is tested for collision and edges are checked for collisions before addition. It attempts to connect the two trees after each node insertion. Pruning removes nodes and branches that cannot lead to better solutions, improving efficiency and robustness. Upon success, the shortest collision-free path spanning start to goal is returned.",
     "code": "class Node:\n    def __init__(self, position: tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> list[tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            I1 = np.eye(dim)[:, 0]\n            M = np.outer(a1, I1)\n            U, _, VT = np.linalg.svd(M)\n            det_product = np.linalg.det(U) * np.linalg.det(VT)\n            C = U @ np.diag([1] * (dim - 1) + [det_product]) @ VT\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) / 2 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            d = dist(from_pos, to_pos)\n            if d <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / d for d in range(dim))\n\n        def near_nodes(tree, new_node_pos, radius):\n            return [node for node in tree if dist(node.position, new_node_pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extract_path(node_from, node_to):\n            path_a = node_from.path_from_root()\n            path_b = []\n            node = node_to\n            while node:\n                path_b.append(node.position)\n                node = node.parent\n            return path_a + path_b[::-1]\n\n        def prune(tree, cost_limit):\n            def invalidate_subtree(node):\n                node.valid = False\n                if node.parent:\n                    node.parent.remove_child(node)\n                for child in list(node.children):\n                    invalidate_subtree(child)\n                node.children = []\n\n            for node in list(tree):\n                if not node.valid:\n                    continue\n                heuristic = dist(node.position, goal_position if tree is start_tree else start_position)\n                if node.cost + heuristic >= cost_limit:\n                    invalidate_subtree(node)\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n\n        for iter in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            nearest = min((n for n in tree_a if n.valid), key=lambda n: dist(n.position, sample), default=None)\n            if nearest is None:\n                continue\n\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_to_goal = dist(new_pos, goal_position)\n            est_total_cost = new_cost + heuristic_to_goal\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            other_nearest = min((n for n in tree_b if n.valid), key=lambda n: dist(n.position, new_node.position), default=None)\n            if other_nearest is not None:\n                connect_dist = dist(new_node.position, other_nearest.position)\n                if connect_dist <= self.base_step:\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        path_cost_candidate = new_node.cost + connect_dist + other_nearest.cost\n                        if path_cost_candidate < c_best:\n                            c_best = path_cost_candidate\n                            success_state = True\n                            if tree_a is start_tree:\n                                best_path = extract_path(new_node, other_nearest)\n                            else:\n                                best_path = extract_path(other_nearest, new_node)\n                            prune(start_tree, c_best)\n                            prune(goal_tree, c_best)\n\n            if success_state and c_best <= c_min * 1.05:\n                break\n\n        return {\n            'success': success_state,\n            'path': best_path if success_state else [],\n            'nodes': nodes,\n            'edges': edges,\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the informed heuristic sampling, adaptive step size, node pruning, and rewiring strategies from Improved RRT*-Connect with the robust bidirectional tree growth and rewiring approach of RRT*-Connect. It adaptively samples within an informed ellipsoidal domain around the current best path cost to focus the search, grows two trees from start and goal alternately, dynamically adjusts step size near obstacles for safer expansions, prunes suboptimal branches, and performs rewiring intelligently to minimize path cost and improve convergence. The planner tries to connect the two trees frequently and updates the best path found while maintaining collision safety checks throughout.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with informed sampling constrained by the current best path cost. During extension, it adjusts step sizes adaptively around obstacles, rejects expansions that cannot improve the solution, and rewires neighbors to optimize paths locally. Each new node is tested for collision and edges are checked for collisions before addition. It attempts to connect the two trees after each node insertion. Pruning removes nodes and branches that cannot lead to better solutions, improving efficiency and robustness. Upon success, the shortest collision-free path spanning start to goal is returned.",
     "code": "class Node:\n    def __init__(self, position: tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> list[tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            I1 = np.eye(dim)[:, 0]\n            M = np.outer(a1, I1)\n            U, _, VT = np.linalg.svd(M)\n            det_product = np.linalg.det(U) * np.linalg.det(VT)\n            C = U @ np.diag([1] * (dim - 1) + [det_product]) @ VT\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) / 2 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            d = dist(from_pos, to_pos)\n            if d <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / d for d in range(dim))\n\n        def near_nodes(tree, new_node_pos, radius):\n            return [node for node in tree if node.valid and dist(node.position, new_node_pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extract_path(node_from, node_to):\n            path_a = node_from.path_from_root()\n            path_b = []\n            node = node_to\n            while node:\n                path_b.append(node.position)\n                node = node.parent\n            return path_a + path_b[::-1]\n\n        def prune(tree, cost_limit):\n            def invalidate_subtree(node):\n                node.valid = False\n                if node.parent:\n                    node.parent.remove_child(node)\n                for child in list(node.children):\n                    invalidate_subtree(child)\n                node.children = []\n\n            for node in list(tree):\n                if not node.valid:\n                    continue\n                heuristic = dist(node.position, goal_position if tree is start_tree else start_position)\n                if node.cost + heuristic >= cost_limit:\n                    invalidate_subtree(node)\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n\n        for iter in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            nearest = min((n for n in tree_a if n.valid), key=lambda n: dist(n.position, sample), default=None)\n            if nearest is None:\n                continue\n\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_to_goal = dist(new_pos, goal_position)\n            est_total_cost = new_cost + heuristic_to_goal\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n\n            # Confirm new_node not in obstacle and edge obstacle-free before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            other_nearest = min((n for n in tree_b if n.valid), key=lambda n: dist(n.position, new_node.position), default=None)\n            if other_nearest is not None:\n                connect_dist = dist(new_node.position, other_nearest.position)\n                if connect_dist <= self.base_step:\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        path_cost_candidate = new_node.cost + connect_dist + other_nearest.cost\n                        if path_cost_candidate < c_best:\n                            c_best = path_cost_candidate\n                            success_state = True\n                            if tree_a is start_tree:\n                                best_path = extract_path(new_node, other_nearest)\n                            else:\n                                best_path = extract_path(other_nearest, new_node)\n                            prune(start_tree, c_best)\n                            prune(goal_tree, c_best)\n\n            if success_state and c_best <= c_min * 1.05:\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=best_path if success_state else [],\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the informed heuristic sampling, adaptive step size, node pruning, and rewiring strategies from Improved RRT*-Connect with the robust bidirectional tree growth and rewiring approach of RRT*-Connect. It adaptively samples within an informed ellipsoidal domain around the current best path cost to focus the search, grows two trees from start and goal alternately, dynamically adjusts step size near obstacles for safer expansions, prunes suboptimal branches, and performs rewiring intelligently to minimize path cost and improve convergence. The planner tries to connect the two trees frequently and updates the best path found while maintaining collision safety checks throughout.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with informed sampling constrained by the current best path cost. During extension, it adjusts step sizes adaptively around obstacles, rejects expansions that cannot improve the solution, and rewires neighbors to optimize paths locally. Each new node is tested for collision and edges are checked for collisions before addition. It attempts to connect the two trees after each node insertion. Pruning removes nodes and branches that cannot lead to better solutions, improving efficiency and robustness. Upon success, the shortest collision-free path spanning start to goal is returned.",
     "code": "class Node:\n    def __init__(self, position: tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def path_from_root(self) -> list[tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = [start_tree[0], goal_tree[0]]\n        edges = []\n\n        success_state = False\n        best_path = []\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            I1 = np.eye(dim)[:, 0]\n            M = np.outer(a1, I1)\n            U, _, VT = np.linalg.svd(M)\n            det_product = np.linalg.det(U) * np.linalg.det(VT)\n            C = U @ np.diag([1] * (dim - 1) + [det_product]) @ VT\n            r1 = c_best / 2\n            r2 = math.sqrt(max(c_best ** 2 - c_min ** 2, 0.0)) / 2 if c_best > c_min else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            distance = dist(from_pos, to_pos)\n            steps = max(2, int(distance))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step_len):\n            d = dist(from_pos, to_pos)\n            if d <= step_len:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step_len / d for d in range(dim))\n\n        def near_nodes(tree, new_node_pos, radius):\n            return [node for node in tree if node.valid and dist(node.position, new_node_pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                if neighbor == new_node.parent:\n                    continue\n                new_cost = new_node.cost + dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent = new_node\n                    neighbor.cost = new_cost\n                    new_node.add_child(neighbor)\n                    edges.append((new_node, neighbor))\n\n        def extract_path(node_from, node_to):\n            path_a = node_from.path_from_root()\n            path_b = []\n            node = node_to\n            while node:\n                path_b.append(node.position)\n                node = node.parent\n            return path_a + path_b[::-1]\n\n        def prune(tree, cost_limit):\n            def invalidate_subtree(node):\n                node.valid = False\n                if node.parent:\n                    node.parent.remove_child(node)\n                for child in list(node.children):\n                    invalidate_subtree(child)\n                node.children = []\n\n            for node in list(tree):\n                if not node.valid:\n                    continue\n                heuristic = dist(node.position, goal_position if tree is start_tree else start_position)\n                if node.cost + heuristic >= cost_limit:\n                    invalidate_subtree(node)\n                    try:\n                        tree.remove(node)\n                    except ValueError:\n                        pass\n\n        for iter in range(self.max_iter):\n            tree_a, tree_b = (start_tree, goal_tree) if iter % 2 == 0 else (goal_tree, start_tree)\n\n            sample = informed_sample()\n            nearest = min((n for n in tree_a if n.valid), key=lambda n: dist(n.position, sample), default=None)\n            if nearest is None:\n                continue\n\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            heuristic_to_goal = dist(new_pos, goal_position)\n            est_total_cost = new_cost + heuristic_to_goal\n            if est_total_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n\n            # Confirm new_node not in obstacle and edge obstacle-free before adding\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(tree_a, new_node)\n\n            other_nearest = min((n for n in tree_b if n.valid), key=lambda n: dist(n.position, new_node.position), default=None)\n            if other_nearest is not None:\n                connect_dist = dist(new_node.position, other_nearest.position)\n                if connect_dist <= self.base_step:\n                    if not self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                        path_cost_candidate = new_node.cost + connect_dist + other_nearest.cost\n                        if path_cost_candidate < c_best:\n                            c_best = path_cost_candidate\n                            success_state = True\n                            if tree_a is start_tree:\n                                best_path = extract_path(new_node, other_nearest)\n                            else:\n                                best_path = extract_path(other_nearest, new_node)\n                            prune(start_tree, c_best)\n                            prune(goal_tree, c_best)\n\n            if success_state and c_best <= c_min * 1.05:\n                break\n\n        return {\n            \"success\": success_state,\n            \"path\": best_path if success_state else [],\n            \"nodes\": nodes,\n            \"edges\": edges,\n        }\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm is an Enhanced Bidirectional RRT* with informed sampling and adaptive rewiring that improves planning efficiency, path quality, and robustness. It leverages bidirectional tree growth from start and goal positions, heuristic-informed sampling within an evolving ellipsoidal domain, adaptive step sizing to maneuver around obstacles, pruning of inefficient paths, and dynamic rewiring to optimize the tree connections for shortest path construction. The technique focuses on rapidly converging to high-quality paths and maintaining robustness in cluttered and high-dimensional spaces.",
     "planning_mechanism": "The planner alternately expands two trees (from start and goal) using samples biased by the currently best-found path cost, adapting step sizes near obstacles. Newly generated nodes are added only if they improve potential path cost, and neighbors are rewired for optimal costs. Successful connections between the two trees dynamically update the best path. Collision checks are rigorously applied to nodes and edges to maintain path validity.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Create rotation matrix C\n            rang = np.eye(dim)\n            M = np.outer(a1, rang[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(100):  # Attempt up to 100 times to sample valid point\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_scale = random.random() ** (1/dim)\n                x_ball *= radius_scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if no sample found in 100 tries\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        def rewire(tree_nodes, new_node):\n            near_nodes = [n for n in tree_nodes if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node as parent\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            edges.remove((near.parent, near))\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_from, tree_to, new_node):\n            # Find nearest node in tree_to\n            nearest_to = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_to.position)\n            connect_cost = new_node.cost + dist_between + nearest_to.cost\n            if connect_cost + 1e-9 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to.position, obstacles, is_3d):\n                    return True, connect_cost, new_node, nearest_to\n            return False, c_best, None, None\n\n        for iter_count in range(self.max_iter):\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve\n            if tentative_cost + math.dist(new_pos, goal_position) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius\n            rewire(tree_a, new_node)\n\n            # Try connect trees\n            connected, connect_cost, node_a, node_b = try_connect(tree_a, tree_b, new_node)\n            if connected:\n                c_best = connect_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Optional early break if very close to minimal path\n                if abs(c_best - c_min) < 1e-3:\n                    break\n\n        if success_state and extracted_path:\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        return type(\"PlannerResult\", (), {})() if not extracted_path else \\\n               type(\"PlannerResult\", (), {\n                   \"success\": success_state,\n                   \"path\": extracted_path,\n                   \"nodes\": nodes,\n                   \"edges\": edges\n               })\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i, j = sorted(random.sample(range(len(new_path)), 2))\n            if j - i <= 1:\n                continue\n            p_i, p_j = new_path[i], new_path[j]\n            if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                continue\n            # Remove intermediate nodes between i and j\n            new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm is an Enhanced Bidirectional RRT* with informed sampling and adaptive rewiring that improves planning efficiency, path quality, and robustness. It leverages bidirectional tree growth from start and goal positions, heuristic-informed sampling within an evolving ellipsoidal domain, adaptive step sizing to maneuver around obstacles, pruning of inefficient paths, and dynamic rewiring to optimize the tree connections for shortest path construction. The technique focuses on rapidly converging to high-quality paths and maintaining robustness in cluttered and high-dimensional spaces.",
     "planning_mechanism": "The planner alternately expands two trees (from start and goal) using samples biased by the currently best-found path cost, adapting step sizes near obstacles. Newly generated nodes are added only if they improve potential path cost, and neighbors are rewired for optimal costs. Successful connections between the two trees dynamically update the best path. Collision checks are rigorously applied to nodes and edges to maintain path validity.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Create rotation matrix C\n            rang = np.eye(dim)\n            M = np.outer(a1, rang[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(100):  # Attempt up to 100 times to sample valid point\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_scale = random.random() ** (1/dim)\n                x_ball *= radius_scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if no sample found in 100 tries\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        def rewire(tree_nodes, new_node):\n            near_nodes = [n for n in tree_nodes if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node as parent\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_from, tree_to, new_node):\n            # Find nearest node in tree_to\n            nearest_to = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_to.position)\n            connect_cost = new_node.cost + dist_between + nearest_to.cost\n            if connect_cost + 1e-9 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to.position, obstacles, is_3d):\n                    return True, connect_cost, new_node, nearest_to\n            return False, c_best, None, None\n\n        for iter_count in range(self.max_iter):\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve\n            # Use current c_best or direct calculation with goal position depending on which tree is used\n            compare_goal = goal_position if tree_a is tree_start else start_position\n            if tentative_cost + math.dist(new_pos, compare_goal) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius\n            rewire(tree_a, new_node)\n\n            # Try connect trees\n            connected, connect_cost, node_a, node_b = try_connect(tree_a, tree_b, new_node)\n            if connected:\n                c_best = connect_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Optional early break if very close to minimal path\n                if abs(c_best - c_min) < 1e-3:\n                    break\n\n        if success_state and extracted_path:\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        # Return a class object with attributes instead of a dict\n        class Result:\n            pass\n\n        result = Result()\n        result.success = success_state\n        result.path = extracted_path\n        result.nodes = nodes\n        result.edges = edges\n\n        return result\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i, j = sorted(random.sample(range(len(new_path)), 2))\n            if j - i <= 1:\n                continue\n            p_i, p_j = new_path[i], new_path[j]\n            if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                continue\n            # Remove intermediate nodes between i and j\n            new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm is an Enhanced Bidirectional RRT* with informed sampling and adaptive rewiring that improves planning efficiency, path quality, and robustness. It leverages bidirectional tree growth from start and goal positions, heuristic-informed sampling within an evolving ellipsoidal domain, adaptive step sizing to maneuver around obstacles, pruning of inefficient paths, and dynamic rewiring to optimize the tree connections for shortest path construction. The technique focuses on rapidly converging to high-quality paths and maintaining robustness in cluttered and high-dimensional spaces.",
     "planning_mechanism": "The planner alternately expands two trees (from start and goal) using samples biased by the currently best-found path cost, adapting step sizes near obstacles. Newly generated nodes are added only if they improve potential path cost, and neighbors are rewired for optimal costs. Successful connections between the two trees dynamically update the best path. Collision checks are rigorously applied to nodes and edges to maintain path validity.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Create rotation matrix C\n            rang = np.eye(dim)\n            M = np.outer(a1, rang[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(100):  # Attempt up to 100 times to sample valid point\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_scale = random.random() ** (1/dim)\n                x_ball *= radius_scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if no sample found in 100 tries\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        def rewire(tree_nodes, new_node):\n            near_nodes = [n for n in tree_nodes if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node as parent\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_from, tree_to, new_node):\n            # Find nearest node in tree_to\n            nearest_to = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_to.position)\n            connect_cost = new_node.cost + dist_between + nearest_to.cost\n            if connect_cost + 1e-9 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to.position, obstacles, is_3d):\n                    return True, connect_cost, new_node, nearest_to\n            return False, c_best, None, None\n\n        for iter_count in range(self.max_iter):\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            # Check collision for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve\n            # Use current c_best or direct calculation with goal position depending on which tree is used\n            compare_goal = goal_position if tree_a is tree_start else start_position\n            if tentative_cost + math.dist(new_pos, compare_goal) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius\n            rewire(tree_a, new_node)\n\n            # Try connect trees\n            connected, connect_cost, node_a, node_b = try_connect(tree_a, tree_b, new_node)\n            if connected:\n                c_best = connect_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Optional early break if very close to minimal path\n                if abs(c_best - c_min) < 1e-3:\n                    break\n\n        if success_state and extracted_path:\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        # Return an instance of PlannerResult with expected attributes\n        # Changed from anonymous class to named returned class for compatibility\n        from eoh.problems.optimization.classic_benchmark_path_planning.utils.architecture_utils import PlannerResult\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i, j = sorted(random.sample(range(len(new_path)), 2))\n            if j - i <= 1:\n                continue\n            p_i, p_j = new_path[i], new_path[j]\n            if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                continue\n            # Remove intermediate nodes between i and j\n            new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm is an Enhanced Bidirectional RRT* with informed sampling and adaptive rewiring that improves planning efficiency, path quality, and robustness. It leverages bidirectional tree growth from start and goal positions, heuristic-informed sampling within an evolving ellipsoidal domain, adaptive step sizing to maneuver around obstacles, pruning of inefficient paths, and dynamic rewiring to optimize the tree connections for shortest path construction. The technique focuses on rapidly converging to high-quality paths and maintaining robustness in cluttered and high-dimensional spaces.",
     "planning_mechanism": "The planner alternately expands two trees (from start and goal) using samples biased by the currently best-found path cost, adapting step sizes near obstacles. Newly generated nodes are added only if they improve potential path cost, and neighbors are rewired for optimal costs. Successful connections between the two trees dynamically update the best path. Collision checks are rigorously applied to nodes and edges to maintain path validity.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start_position, goal_position)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                return sample\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1 /= norm_a1\n            # Create rotation matrix C\n            rang = np.eye(dim)\n            M = np.outer(a1, rang[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n            r1 = c_best / 2.0\n            val = c_best**2 - c_min**2\n            r2 = math.sqrt(val) / 2.0 if val > 0 else 0.0\n            L = np.diag([r1] + [r2]*(dim-1))\n            for _ in range(100):  # Attempt up to 100 times to sample valid point\n                x_ball = np.random.normal(0,1,dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                radius_scale = random.random() ** (1/dim)\n                x_ball *= radius_scale\n                x_rand = C @ L @ x_ball + x_center\n                # Check bounds (inclusive 0 \u2264 x \u2264 bounds[d])\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n            # Fallback if no sample found in 100 tries\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d])*(i/steps) for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(len(from_pos)))\n\n        def rewire(tree_nodes, new_node):\n            near_nodes = [n for n in tree_nodes if math.dist(n.position, new_node.position) <= self.rewire_radius and n != new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Rewire near node to new_node as parent\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n        def try_connect(tree_from, tree_to, new_node):\n            # Find nearest node in tree_to\n            nearest_to = min(tree_to, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between = math.dist(new_node.position, nearest_to.position)\n            connect_cost = new_node.cost + dist_between + nearest_to.cost\n            if connect_cost + 1e-9 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to.position, obstacles, is_3d):\n                    return True, connect_cost, new_node, nearest_to\n            return False, c_best, None, None\n\n        for iter_count in range(self.max_iter):\n            # Alternate trees\n            if iter_count % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sample = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step_len = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step_len)\n\n            # Check collision for new node and edge\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            tentative_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve\n            # Use current c_best or direct calculation with goal position depending on which tree is used\n            compare_goal = goal_position if tree_a is tree_start else start_position\n            if tentative_cost + math.dist(new_pos, compare_goal) >= c_best:\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=tentative_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire neighbors within radius\n            rewire(tree_a, new_node)\n\n            # Try connect trees\n            connected, connect_cost, node_a, node_b = try_connect(tree_a, tree_b, new_node)\n            if connected:\n                c_best = connect_cost\n                path_a = node_a.path_from_root()\n                path_b = node_b.path_from_root()\n                extracted_path = path_a + path_b[::-1]\n                success_state = True\n\n                # Optional early break if very close to minimal path\n                if abs(c_best - c_min) < 1e-3:\n                    break\n\n        if success_state and extracted_path:\n            # Post-process path smoothing by shortcutting\n            extracted_path = self._shortcut_path(extracted_path, obstacles, is_3d, bounds)\n\n        # Return an instance of PlannerResult with expected attributes (not a dict)\n        from eoh.problems.optimization.classic_benchmark_path_planning.utils.architecture_utils import PlannerResult\n        return PlannerResult(success=success_state, path=extracted_path, nodes=nodes, edges=edges)\n\n    def _shortcut_path(self, path, obstacles, is_3d, bounds, max_trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        new_path = path[:]\n        for _ in range(max_trials):\n            if len(new_path) < 3:\n                break\n            i, j = sorted(random.sample(range(len(new_path)), 2))\n            if j - i <= 1:\n                continue\n            p_i, p_j = new_path[i], new_path[j]\n            if self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                continue\n            # Remove intermediate nodes between i and j\n            new_path = new_path[:i+1] + new_path[j:]\n        return new_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid A*-influenced Bidirectional RRT with Dynamic Goal Biasing and Local Path Smoothing. It integrates the rapid exploration of bidirectional RRT with heuristic guidance and intermittent local smoothing to improve path quality and convergence speed. Dynamic goal biasing increases the chance of connecting trees as iterations progress while local smoothing refines paths incrementally to ensure smoothness and collision-free feasibility. This hybrid approach balances exploration, exploitation, and refinement for improved efficiency, robustness, path length, and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal locations bidirectionally. Sampling is guided by a gradually increasing probability to bias samples near the opposite tree's best node, promoting faster connections. New nodes are added after collision checks and edges rewiring around radius to optimize cost. After a tentative path connection between trees, segments of the path are locally smoothed by shortcutting collisions while maintaining feasibility. The process iterates until max iteration or connection success. The output is the best smoothed feasible path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        # Propagate cost update to children recursively\n        for child in self.children:\n            edge_cost = self.distance_to(child)\n            child.update_cost(new_cost + edge_cost)\n\n    def distance_to(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        # Helper function: sample with dynamic goal biasing\n        def biased_sample(iteration):\n            bias_max = 0.3\n            bias = min(bias_max, (iteration / self.max_iter) * bias_max)\n            if random.random() < bias and len(tree_goal) > 0:\n                # Sample near best node of goal tree to aid connection\n                best_goal_node = min(tree_goal, key=lambda n: n.cost)\n                noise = tuple(random.gauss(0, self.step_size*2) for _ in range(dim))\n                sample = tuple(\n                    max(0, min(bounds[d], best_goal_node.position[d] + noise[d]))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            # Uniform random sample within bounds and free-space\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        # Rewire neighbor to new_node\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        neighbor.update_cost(new_cost)\n\n        def try_connect(tree_from, tree_to, new_node):\n            nearest = nearest_node(tree_to, new_node.position)\n            # Attempt to steer stepwise from nearest to new_node\n            from_pos = nearest.position\n            to_pos = new_node.position\n            full_dist = math.dist(from_pos, to_pos)\n            if full_dist == 0:  # same position\n                return None\n            step = min(self.step_size, full_dist)\n            new_pos = steer(from_pos, to_pos, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            connect_node.cost = nearest.cost + math.dist(from_pos, new_pos)\n\n            # Choose best parent in radius\n            neighbors = near_nodes(tree_to, connect_node.position, self.rewire_radius)\n            best_parent = nearest\n            min_cost = connect_node.cost\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, connect_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(nbr.position, connect_node.position, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = cost\n            connect_node.parent = best_parent\n            best_parent.children.append(connect_node)\n            connect_node.cost = min_cost\n            tree_to.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            rewire(tree_to, connect_node)\n\n            # Check if connecting node is close enough to new_node\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                return connect_node\n            else:  # continue extending towards new_node recursively\n                return try_connect(tree_from, tree_to, connect_node)\n\n        def build_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            return path_start + path_goal[::-1]\n\n        def shortcut_path(path):\n            # Attempt local path smoothing by shortcutting line segments\n            import random\n            max_trials = max(10, len(path)//3)\n            refined = path[:]\n            for _ in range(max_trials):\n                if len(refined) <= 2:\n                    break\n                i = random.randint(0, len(refined) - 3)\n                j = random.randint(i + 2, len(refined) -1)\n                p_i = refined[i]\n                p_j = refined[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    # shortcut is valid: remove intermediate nodes\n                    refined = refined[:i+1] + refined[j:]\n            return refined\n\n        for iteration in range(self.max_iter):\n            sample = biased_sample(iteration)\n            nearest_start = nearest_node(tree_start, sample)\n            new_pos = steer(nearest_start.position, sample, self.step_size)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_start = Node(new_pos)\n            new_node_start.cost = nearest_start.cost + math.dist(nearest_start.position, new_pos)\n            new_node_start.parent = nearest_start\n            nearest_start.children.append(new_node_start)\n            tree_start.append(new_node_start)\n            nodes.append(new_node_start)\n            edges.append((nearest_start, new_node_start))\n            rewire(tree_start, new_node_start)\n\n            connected_node = try_connect(tree_start, tree_goal, new_node_start)\n            if connected_node:\n                # Connection established, extract path and shortcut it\n                path = build_path(new_node_start, connected_node)\n                smoothed_path = shortcut_path(path)\n                path_cost = sum(\n                    math.dist(smoothed_path[i], smoothed_path[i+1]) for i in range(len(smoothed_path)-1)\n                )\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = smoothed_path\n                    success = True\n                    # Optional early termination on good solution\n                    if best_cost < math.dist(start_position, goal_position)*1.1:\n                        break\n\n            # Swap trees to balance growth\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid A*-influenced Bidirectional RRT with Dynamic Goal Biasing and Local Path Smoothing. It integrates the rapid exploration of bidirectional RRT with heuristic guidance and intermittent local smoothing to improve path quality and convergence speed. Dynamic goal biasing increases the chance of connecting trees as iterations progress while local smoothing refines paths incrementally to ensure smoothness and collision-free feasibility. This hybrid approach balances exploration, exploitation, and refinement for improved efficiency, robustness, path length, and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal locations bidirectionally. Sampling is guided by a gradually increasing probability to bias samples near the opposite tree's best node, promoting faster connections. New nodes are added after collision checks and edges rewiring around radius to optimize cost. After a tentative path connection between trees, segments of the path are locally smoothed by shortcutting collisions while maintaining feasibility. The process iterates until max iteration or connection success. The output is the best smoothed feasible path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        # Propagate cost update to children recursively\n        for child in self.children:\n            edge_cost = self.distance_to(child)\n            child.update_cost(new_cost + edge_cost)\n\n    def distance_to(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        def biased_sample(iteration):\n            bias_max = 0.3\n            bias = min(bias_max, (iteration / self.max_iter) * bias_max)\n            if random.random() < bias and len(tree_goal) > 0:\n                best_goal_node = min(tree_goal, key=lambda n: n.cost)\n                noise = tuple(random.gauss(0, self.step_size * 2) for _ in range(dim))\n                sample = tuple(\n                    max(0, min(bounds[d], best_goal_node.position[d] + noise[d]))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        neighbor.update_cost(new_cost)\n\n        def try_connect(tree_from, tree_to, new_node):\n            nearest = nearest_node(tree_to, new_node.position)\n            from_pos = nearest.position\n            to_pos = new_node.position\n            full_dist = math.dist(from_pos, to_pos)\n            if full_dist == 0:  # same position\n                return None\n            step = min(self.step_size, full_dist)\n            new_pos = steer(from_pos, to_pos, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            connect_node.cost = nearest.cost + math.dist(from_pos, new_pos)\n\n            neighbors = near_nodes(tree_to, connect_node.position, self.rewire_radius)\n            best_parent = nearest\n            min_cost = connect_node.cost\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, connect_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(nbr.position, connect_node.position, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = cost\n\n            connect_node.parent = best_parent\n            best_parent.children.append(connect_node)\n            connect_node.cost = min_cost\n            tree_to.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            rewire(tree_to, connect_node)\n\n            dist_to_new_node = math.dist(connect_node.position, new_node.position)\n            if dist_to_new_node <= self.step_size:\n                # Try direct connection to new_node if possible\n                if new_node.position != connect_node.position:\n                    if not self._is_in_obstacle(new_node.position, obstacles, is_3d) and not self._is_edge_in_obstacle(connect_node.position, new_node.position, obstacles, is_3d):\n                        new_node.parent = connect_node\n                        connect_node.children.append(new_node)\n                        new_node.cost = connect_node.cost + dist_to_new_node\n                        edges.append((connect_node, new_node))\n                        tree_to.append(new_node)\n                        nodes.append(new_node)\n                        rewire(tree_to, new_node)\n                        return new_node\n                return connect_node\n            else:\n                return try_connect(tree_from, tree_to, connect_node)\n\n        def build_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Remove duplicated meeting node position by excluding the last element of path_goal\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            import random\n            max_trials = max(10, len(path) // 3)\n            refined = path[:]\n            for _ in range(max_trials):\n                if len(refined) <= 2:\n                    break\n                i = random.randint(0, len(refined) - 3)\n                j = random.randint(i + 2, len(refined) - 1)\n                p_i = refined[i]\n                p_j = refined[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    refined = refined[:i + 1] + refined[j:]\n            return refined\n\n        for iteration in range(self.max_iter):\n            sample = biased_sample(iteration)\n            nearest_start = nearest_node(tree_start, sample)\n            new_pos = steer(nearest_start.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_start = Node(new_pos)\n            new_node_start.cost = nearest_start.cost + math.dist(nearest_start.position, new_pos)\n            new_node_start.parent = nearest_start\n            nearest_start.children.append(new_node_start)\n            tree_start.append(new_node_start)\n            nodes.append(new_node_start)\n            edges.append((nearest_start, new_node_start))\n\n            rewire(tree_start, new_node_start)\n\n            connected_node = try_connect(tree_start, tree_goal, new_node_start)\n            if connected_node:\n                path = build_path(new_node_start, connected_node)\n                smoothed_path = shortcut_path(path)\n                path_cost = sum(\n                    math.dist(smoothed_path[i], smoothed_path[i + 1]) for i in range(len(smoothed_path) - 1)\n                )\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = smoothed_path\n                    success = True\n                    if best_cost < math.dist(start_position, goal_position) * 1.1:\n                        break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        return {\n            'success': success,\n            'path': best_path,\n            'nodes': nodes,\n            'edges': edges\n        }\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        # Assume obstacles is a list of geometry objects with `.contains(point)` method or similar\n        # Placeholder: point in obstacle if any obstacle contains it\n        for obs in obstacles:\n            if obs.contains(point):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if edge between p1 and p2 intersects any obstacle\n        # Placeholder simplistic discretized check along edge\n        import numpy as np\n\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / (self.step_size / 2)), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid A*-influenced Bidirectional RRT with Dynamic Goal Biasing and Local Path Smoothing. It integrates the rapid exploration of bidirectional RRT with heuristic guidance and intermittent local smoothing to improve path quality and convergence speed. Dynamic goal biasing increases the chance of connecting trees as iterations progress while local smoothing refines paths incrementally to ensure smoothness and collision-free feasibility. This hybrid approach balances exploration, exploitation, and refinement for improved efficiency, robustness, path length, and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal locations bidirectionally. Sampling is guided by a gradually increasing probability to bias samples near the opposite tree's best node, promoting faster connections. New nodes are added after collision checks and edges rewiring around radius to optimize cost. After a tentative path connection between trees, segments of the path are locally smoothed by shortcutting collisions while maintaining feasibility. The process iterates until max iteration or connection success. The output is the best smoothed feasible path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        # Propagate cost update to children recursively\n        for child in self.children:\n            edge_cost = self.distance_to(child)\n            child.update_cost(new_cost + edge_cost)\n\n    def distance_to(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        def biased_sample(iteration):\n            bias_max = 0.3\n            bias = min(bias_max, (iteration / self.max_iter) * bias_max)\n            if random.random() < bias and len(tree_goal) > 0:\n                best_goal_node = min(tree_goal, key=lambda n: n.cost)\n                noise = tuple(random.gauss(0, self.step_size * 2) for _ in range(dim))\n                sample = tuple(\n                    max(0, min(bounds[d], best_goal_node.position[d] + noise[d]))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        neighbor.update_cost(new_cost)\n\n        def try_connect(tree_from, tree_to, new_node):\n            nearest = nearest_node(tree_to, new_node.position)\n            from_pos = nearest.position\n            to_pos = new_node.position\n            full_dist = math.dist(from_pos, to_pos)\n            if full_dist == 0:  # same position\n                return None\n            step = min(self.step_size, full_dist)\n            new_pos = steer(from_pos, to_pos, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            connect_node.cost = nearest.cost + math.dist(from_pos, new_pos)\n\n            neighbors = near_nodes(tree_to, connect_node.position, self.rewire_radius)\n            best_parent = nearest\n            min_cost = connect_node.cost\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, connect_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(nbr.position, connect_node.position, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = cost\n\n            connect_node.parent = best_parent\n            best_parent.children.append(connect_node)\n            connect_node.cost = min_cost\n\n            # Check collision for connect_node before adding\n            if self._is_in_obstacle(connect_node.position, obstacles, is_3d):\n                return None\n\n            tree_to.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            rewire(tree_to, connect_node)\n\n            dist_to_new_node = math.dist(connect_node.position, new_node.position)\n            if dist_to_new_node <= self.step_size:\n                # Try direct connection to new_node if possible\n                if new_node.position != connect_node.position:\n                    if (not self._is_in_obstacle(new_node.position, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(connect_node.position, new_node.position, obstacles, is_3d)):\n                        new_node.parent = connect_node\n                        connect_node.children.append(new_node)\n                        new_node.cost = connect_node.cost + dist_to_new_node\n                        edges.append((connect_node, new_node))\n                        # Before adding new_node to tree, verify no duplication and collision\n                        if new_node not in tree_to:\n                            tree_to.append(new_node)\n                        if new_node not in nodes:\n                            nodes.append(new_node)\n                        rewire(tree_to, new_node)\n                        return new_node\n                return connect_node\n            else:\n                return try_connect(tree_from, tree_to, connect_node)\n\n        def build_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Remove duplicated meeting node position by excluding the last element of path_goal\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            import random\n            max_trials = max(10, len(path) // 3)\n            refined = path[:]\n            for _ in range(max_trials):\n                if len(refined) <= 2:\n                    break\n                i = random.randint(0, len(refined) - 3)\n                j = random.randint(i + 2, len(refined) - 1)\n                p_i = refined[i]\n                p_j = refined[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    refined = refined[:i + 1] + refined[j:]\n            return refined\n\n        for iteration in range(self.max_iter):\n            sample = biased_sample(iteration)\n            nearest_start = nearest_node(tree_start, sample)\n            new_pos = steer(nearest_start.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_start = Node(new_pos)\n            new_node_start.cost = nearest_start.cost + math.dist(nearest_start.position, new_pos)\n            new_node_start.parent = nearest_start\n            nearest_start.children.append(new_node_start)\n\n            tree_start.append(new_node_start)\n            nodes.append(new_node_start)\n            edges.append((nearest_start, new_node_start))\n\n            rewire(tree_start, new_node_start)\n\n            connected_node = try_connect(tree_start, tree_goal, new_node_start)\n            if connected_node:\n                path = build_path(new_node_start, connected_node)\n                smoothed_path = shortcut_path(path)\n                path_cost = sum(\n                    math.dist(smoothed_path[i], smoothed_path[i + 1]) for i in range(len(smoothed_path) - 1)\n                )\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = smoothed_path\n                    success = True\n                    if best_cost < math.dist(start_position, goal_position) * 1.1:\n                        break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        class PlannerResultWrap:\n            def __init__(self, success, path, nodes, edges):\n                self.success = success\n                self.path = path\n                self.nodes = nodes\n                self.edges = edges\n\n        return PlannerResultWrap(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        # Assume obstacles is a list of geometry objects with `.contains(point)` method or similar\n        # Placeholder: point in obstacle if any obstacle contains it\n        for obs in obstacles:\n            if obs.contains(point):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if edge between p1 and p2 intersects any obstacle\n        # Placeholder simplistic discretized check along edge\n        import numpy as np\n        import math\n\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / (self.step_size / 2)), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid A*-influenced Bidirectional RRT with Dynamic Goal Biasing and Local Path Smoothing. It integrates the rapid exploration of bidirectional RRT with heuristic guidance and intermittent local smoothing to improve path quality and convergence speed. Dynamic goal biasing increases the chance of connecting trees as iterations progress while local smoothing refines paths incrementally to ensure smoothness and collision-free feasibility. This hybrid approach balances exploration, exploitation, and refinement for improved efficiency, robustness, path length, and smoothness.",
     "planning_mechanism": "The planner grows two trees from start and goal locations bidirectionally. Sampling is guided by a gradually increasing probability to bias samples near the opposite tree's best node, promoting faster connections. New nodes are added after collision checks and edges rewiring around radius to optimize cost. After a tentative path connection between trees, segments of the path are locally smoothed by shortcutting collisions while maintaining feasibility. The process iterates until max iteration or connection success. The output is the best smoothed feasible path found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root to this node\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_cost(self, new_cost):\n        self.cost = new_cost\n        # Propagate cost update to children recursively\n        for child in self.children:\n            edge_cost = self.distance_to(child)\n            child.update_cost(new_cost + edge_cost)\n\n    def distance_to(self, other_node):\n        import math\n        return math.dist(self.position, other_node.position)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        nodes.extend(tree_start)\n        nodes.extend(tree_goal)\n\n        success = False\n        best_path = []\n        best_cost = float(\"inf\")\n\n        def biased_sample(iteration):\n            bias_max = 0.3\n            bias = min(bias_max, (iteration / self.max_iter) * bias_max)\n            if random.random() < bias and len(tree_goal) > 0:\n                best_goal_node = min(tree_goal, key=lambda n: n.cost)\n                noise = tuple(random.gauss(0, self.step_size * 2) for _ in range(dim))\n                sample = tuple(\n                    max(0, min(bounds[d], best_goal_node.position[d] + noise[d]))\n                    for d in range(dim)\n                )\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            while True:\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, max_step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_step:\n                return to_pos\n            ratio = max_step / dist\n            return tuple(from_pos[d] + ratio * (to_pos[d] - from_pos[d]) for d in range(len(from_pos)))\n\n        def near_nodes(tree, pos, radius):\n            return [node for node in tree if math.dist(node.position, pos) <= radius]\n\n        def rewire(tree, new_node):\n            neighbors = near_nodes(tree, new_node.position, self.rewire_radius)\n            for neighbor in neighbors:\n                edge_cost = math.dist(new_node.position, neighbor.position)\n                new_cost = new_node.cost + edge_cost\n                if new_cost < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            try:\n                                neighbor.parent.children.remove(neighbor)\n                                edges.remove((neighbor.parent, neighbor))\n                            except ValueError:\n                                pass\n                        neighbor.parent = new_node\n                        neighbor.cost = new_cost\n                        new_node.children.append(neighbor)\n                        edges.append((new_node, neighbor))\n                        neighbor.update_cost(new_cost)\n\n        def try_connect(tree_from, tree_to, new_node):\n            nearest = nearest_node(tree_to, new_node.position)\n            from_pos = nearest.position\n            to_pos = new_node.position\n            full_dist = math.dist(from_pos, to_pos)\n            if full_dist == 0:  # same position\n                return None\n            step = min(self.step_size, full_dist)\n            new_pos = steer(from_pos, to_pos, step)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(from_pos, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            connect_node.cost = nearest.cost + math.dist(from_pos, new_pos)\n\n            neighbors = near_nodes(tree_to, connect_node.position, self.rewire_radius)\n            best_parent = nearest\n            min_cost = connect_node.cost\n            for nbr in neighbors:\n                cost = nbr.cost + math.dist(nbr.position, connect_node.position)\n                if cost < min_cost and not self._is_edge_in_obstacle(nbr.position, connect_node.position, obstacles, is_3d):\n                    best_parent = nbr\n                    min_cost = cost\n\n            connect_node.parent = best_parent\n            best_parent.children.append(connect_node)\n            connect_node.cost = min_cost\n\n            # Check collision for connect_node before adding\n            if self._is_in_obstacle(connect_node.position, obstacles, is_3d):\n                return None\n\n            tree_to.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            rewire(tree_to, connect_node)\n\n            dist_to_new_node = math.dist(connect_node.position, new_node.position)\n            if dist_to_new_node <= self.step_size:\n                # Try direct connection to new_node if possible\n                if new_node.position != connect_node.position:\n                    if (not self._is_in_obstacle(new_node.position, obstacles, is_3d)\n                        and not self._is_edge_in_obstacle(connect_node.position, new_node.position, obstacles, is_3d)):\n                        new_node.parent = connect_node\n                        connect_node.children.append(new_node)\n                        new_node.cost = connect_node.cost + dist_to_new_node\n                        edges.append((connect_node, new_node))\n                        # Before adding new_node to tree, verify no duplication and collision\n                        if new_node not in tree_to:\n                            tree_to.append(new_node)\n                        if new_node not in nodes:\n                            nodes.append(new_node)\n                        rewire(tree_to, new_node)\n                        return new_node\n                return connect_node\n            else:\n                return try_connect(tree_from, tree_to, connect_node)\n\n        def build_path(node_from_start, node_from_goal):\n            path_start = node_from_start.path_from_root()\n            path_goal = node_from_goal.path_from_root()\n            # Remove duplicated meeting node position by excluding the last element of path_goal\n            return path_start + path_goal[::-1][1:]\n\n        def shortcut_path(path):\n            import random\n            max_trials = max(10, len(path) // 3)\n            refined = path[:]\n            for _ in range(max_trials):\n                if len(refined) <= 2:\n                    break\n                i = random.randint(0, len(refined) - 3)\n                j = random.randint(i + 2, len(refined) - 1)\n                p_i = refined[i]\n                p_j = refined[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d):\n                    refined = refined[:i + 1] + refined[j:]\n            return refined\n\n        for iteration in range(self.max_iter):\n            sample = biased_sample(iteration)\n            nearest_start = nearest_node(tree_start, sample)\n            new_pos = steer(nearest_start.position, sample, self.step_size)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_start.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node_start = Node(new_pos)\n            new_node_start.cost = nearest_start.cost + math.dist(nearest_start.position, new_pos)\n            new_node_start.parent = nearest_start\n            nearest_start.children.append(new_node_start)\n\n            tree_start.append(new_node_start)\n            nodes.append(new_node_start)\n            edges.append((nearest_start, new_node_start))\n\n            rewire(tree_start, new_node_start)\n\n            connected_node = try_connect(tree_start, tree_goal, new_node_start)\n            if connected_node:\n                path = build_path(new_node_start, connected_node)\n                smoothed_path = shortcut_path(path)\n                path_cost = sum(\n                    math.dist(smoothed_path[i], smoothed_path[i + 1]) for i in range(len(smoothed_path) - 1)\n                )\n                if path_cost < best_cost:\n                    best_cost = path_cost\n                    best_path = smoothed_path\n                    success = True\n                    if best_cost < math.dist(start_position, goal_position) * 1.1:\n                        break\n\n            tree_start, tree_goal = tree_goal, tree_start\n\n        # Return results as dict to comply with external expectations\n        return {\n            \"success\": success,\n            \"path\": best_path,\n            \"nodes\": nodes,\n            \"edges\": edges,\n        }\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        # Assume obstacles is a list of geometry objects with `.contains(point)` method or similar\n        # Placeholder: point in obstacle if any obstacle contains it\n        for obs in obstacles:\n            if obs.contains(point):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if edge between p1 and p2 intersects any obstacle\n        # Placeholder simplistic discretized check along edge\n        import math\n\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / (self.step_size / 2)), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an enhanced RRT* variant with carefully tuned parameters and adaptive behaviors to significantly boost path planning efficiency, success rate, and path quality. It features adaptive neighbor radius shrinking, increased goal bias, dynamic step sizing, and path smoothing via shortcutting to refine the final path and reduce length, ensuring robust collision and edge-validity checks throughout the process.",
     "planning_mechanism": "The planner incrementally grows a tree from the start, samples points with a relatively high goal bias, steers towards samples using an adaptively optimized step size, selects the lowest-cost parent node within a dynamically decreasing neighbor radius, and rewires nearby nodes to improve path cost. It terminates early upon successfully connecting to the goal and applies smoothing heuristics to produce a shorter, obstacle-free path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive step size parameters\n        max_step = self.step_size\n        min_step = max(1.0, max_step * 0.3)\n\n        for i in range(self.max_iter):\n            # Adaptive goal bias: start high for fast goal pronaunce then slightly decay to avoid local minima\n            curr_goal_bias = self.goal_sample_rate * (1 - i / self.max_iter * 0.7) + 0.03\n\n            if random.random() < curr_goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            \n            # Adaptive step size smaller near goal for finer control, larger early on for exploration\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            dynamic_step = max(min_step, min(max_step, dist_to_goal * 0.5, dist))\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * dynamic_step for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n\n            # Collision check for node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Edge collision check - using finer resolution for better safety\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_position)\n\n            # Adaptive neighbor radius shrinks over iterations for efficiency and path refinement\n            radius = max(3.0, self.neighbor_radius * (1.0 - i / self.max_iter))\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent by minimal cost & collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs with updated node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal proximity threshold with margin, check goal connection feasibility\n            dist_to_goal = math.dist(new_position, goal_position)\n            goal_threshold = self.step_size * 1.1\n            if dist_to_goal <= goal_threshold:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.2)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Path smoothing via shortcutting with collision checks\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 150\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an enhanced RRT* variant with carefully tuned parameters and adaptive behaviors to significantly boost path planning efficiency, success rate, and path quality. It features adaptive neighbor radius shrinking, increased goal bias, dynamic step sizing, and path smoothing via shortcutting to refine the final path and reduce length, ensuring robust collision and edge-validity checks throughout the process.",
     "planning_mechanism": "The planner incrementally grows a tree from the start, samples points with a relatively high goal bias, steers towards samples using an adaptively optimized step size, selects the lowest-cost parent node within a dynamically decreasing neighbor radius, and rewires nearby nodes to improve path cost. It terminates early upon successfully connecting to the goal and applies smoothing heuristics to produce a shorter, obstacle-free path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> dict:\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive step size parameters\n        max_step = self.step_size\n        min_step = max(1.0, max_step * 0.3)\n\n        for i in range(self.max_iter):\n            # Adaptive goal bias: start high for fast goal pronaunce then slightly decay to avoid local minima\n            curr_goal_bias = self.goal_sample_rate * (1 - i / self.max_iter * 0.7) + 0.03\n\n            if random.random() < curr_goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            # Adaptive step size smaller near goal for finer control, larger early on for exploration\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            dynamic_step = max(min_step, min(max_step, dist_to_goal * 0.5, dist))\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * dynamic_step for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n\n            # Collision check for node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Edge collision check - using finer resolution for better safety\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_position)\n\n            # Adaptive neighbor radius shrinks over iterations for efficiency and path refinement\n            radius = max(3.0, self.neighbor_radius * (1.0 - i / self.max_iter))\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent by minimal cost & collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs with updated node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal proximity threshold with margin, check goal connection feasibility\n            dist_to_goal = math.dist(new_position, goal_position)\n            goal_threshold = self.step_size * 1.1\n            if dist_to_goal <= goal_threshold:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.2)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Path smoothing via shortcutting with collision checks\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return {\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 150\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, position, obstacles, is_3d):\n        # Placeholder collision check method for a position\n        # Should be implemented based on obstacles representation\n        # Example: for each obstacle, check if position is inside it\n        for obs in obstacles:\n            if self._point_in_obstacle(position, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.1):\n        # Check if edge between p1 and p2 intersects any obstacle\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, point, obstacle, is_3d):\n        # This function should check whether the point lies within the obstacle.\n        # Placeholder: assume obstacle is a dict with type and params\n        # Example with spherical obstacle:\n        if obstacle['type'] == 'sphere':\n            center = obstacle['center']\n            radius = obstacle['radius']\n            dist = math.dist(point, center)\n            return dist <= radius\n        elif obstacle['type'] == 'box':\n            min_corner = obstacle['min_corner']\n            max_corner = obstacle['max_corner']\n            return all(min_corner[d] <= point[d] <= max_corner[d] for d in range(len(point)))\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an enhanced RRT* variant with carefully tuned parameters and adaptive behaviors to significantly boost path planning efficiency, success rate, and path quality. It features adaptive neighbor radius shrinking, increased goal bias, dynamic step sizing, and path smoothing via shortcutting to refine the final path and reduce length, ensuring robust collision and edge-validity checks throughout the process.",
     "planning_mechanism": "The planner incrementally grows a tree from the start, samples points with a relatively high goal bias, steers towards samples using an adaptively optimized step size, selects the lowest-cost parent node within a dynamically decreasing neighbor radius, and rewires nearby nodes to improve path cost. It terminates early upon successfully connecting to the goal and applies smoothing heuristics to produce a shorter, obstacle-free path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive step size parameters\n        max_step = self.step_size\n        min_step = max(1.0, max_step * 0.3)\n\n        for i in range(self.max_iter):\n            # Adaptive goal bias: start high for fast goal pronaunce then slightly decay to avoid local minima\n            curr_goal_bias = self.goal_sample_rate * (1 - i / self.max_iter * 0.7) + 0.03\n\n            if random.random() < curr_goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            # Adaptive step size smaller near goal for finer control, larger early on for exploration\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            dynamic_step = max(min_step, min(max_step, dist_to_goal * 0.5, dist))\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * dynamic_step for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n\n            # Collision check for node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Edge collision check - using finer resolution for better safety\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_position)\n\n            # Adaptive neighbor radius shrinks over iterations for efficiency and path refinement\n            radius = max(3.0, self.neighbor_radius * (1.0 - i / self.max_iter))\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent by minimal cost & collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs with updated node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal proximity threshold with margin, check goal connection feasibility\n            dist_to_goal = math.dist(new_position, goal_position)\n            goal_threshold = self.step_size * 1.1\n            if dist_to_goal <= goal_threshold:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.2)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Path smoothing via shortcutting with collision checks\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 150\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, position, obstacles, is_3d):\n        # Placeholder collision check method for a position\n        # Should be implemented based on obstacles representation\n        # Example: for each obstacle, check if position is inside it\n        for obs in obstacles:\n            if self._point_in_obstacle(position, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.1):\n        # Check if edge between p1 and p2 intersects any obstacle\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, point, obstacle, is_3d):\n        # This function should check whether the point lies within the obstacle.\n        # Placeholder: assume obstacle is a dict with type and params\n        # Example with spherical obstacle:\n        if obstacle['type'] == 'sphere':\n            center = obstacle['center']\n            radius = obstacle['radius']\n            dist = math.dist(point, center)\n            return dist <= radius\n        elif obstacle['type'] == 'box':\n            min_corner = obstacle['min_corner']\n            max_corner = obstacle['max_corner']\n            return all(min_corner[d] <= point[d] <= max_corner[d] for d in range(len(point)))\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an enhanced RRT* variant with carefully tuned parameters and adaptive behaviors to significantly boost path planning efficiency, success rate, and path quality. It features adaptive neighbor radius shrinking, increased goal bias, dynamic step sizing, and path smoothing via shortcutting to refine the final path and reduce length, ensuring robust collision and edge-validity checks throughout the process.",
     "planning_mechanism": "The planner incrementally grows a tree from the start, samples points with a relatively high goal bias, steers towards samples using an adaptively optimized step size, selects the lowest-cost parent node within a dynamically decreasing neighbor radius, and rewires nearby nodes to improve path cost. It terminates early upon successfully connecting to the goal and applies smoothing heuristics to produce a shorter, obstacle-free path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.15, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> PlannerResult:\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Adaptive step size parameters\n        max_step = self.step_size\n        min_step = max(1.0, max_step * 0.3)\n\n        for i in range(self.max_iter):\n            # Adaptive goal bias: start high for fast goal pronaunce then slightly decay to avoid local minima\n            curr_goal_bias = self.goal_sample_rate * (1 - i / self.max_iter * 0.7) + 0.03\n\n            if random.random() < curr_goal_bias:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n\n            # Adaptive step size smaller near goal for finer control, larger early on for exploration\n            dist_to_goal = math.dist(nearest_node.position, goal_position)\n            dynamic_step = max(min_step, min(max_step, dist_to_goal * 0.5, dist))\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * dynamic_step for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n\n            # Collision check for node position\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n\n            # Edge collision check - using finer resolution for better safety\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_position)\n\n            # Adaptive neighbor radius shrinks over iterations for efficiency and path refinement\n            radius = max(3.0, self.neighbor_radius * (1.0 - i / self.max_iter))\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent by minimal cost & collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if (temp_cost < min_cost and\n                    not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d, resolution=0.3)):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors to improve costs with updated node\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if (cost_through_new < near_node.cost and\n                    not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.3)):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except (ValueError, AttributeError):\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal proximity threshold with margin, check goal connection feasibility\n            dist_to_goal = math.dist(new_position, goal_position)\n            goal_threshold = self.step_size * 1.1\n            if dist_to_goal <= goal_threshold:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d, resolution=0.2)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Path smoothing via shortcutting with collision checks\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return {\n            'success': success_state,\n            'path': extracted_path,\n            'nodes': nodes,\n            'edges': edges\n        }\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 150\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path\n\n    def _is_in_obstacle(self, position, obstacles, is_3d):\n        # Placeholder collision check method for a position\n        # Should be implemented based on obstacles representation\n        # Example: for each obstacle, check if position is inside it\n        for obs in obstacles:\n            if self._point_in_obstacle(position, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d, resolution=0.1):\n        # Check if edge between p1 and p2 intersects any obstacle\n        dist = math.dist(p1, p2)\n        steps = max(int(dist / resolution), 1)\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, point, obstacle, is_3d):\n        # This function should check whether the point lies within the obstacle.\n        # Placeholder: assume obstacle is a dict with type and params\n        # Example with spherical obstacle:\n        if obstacle['type'] == 'sphere':\n            center = obstacle['center']\n            radius = obstacle['radius']\n            dist = math.dist(point, center)\n            return dist <= radius\n        elif obstacle['type'] == 'box':\n            min_corner = obstacle['min_corner']\n            max_corner = obstacle['max_corner']\n            return all(min_corner[d] <= point[d] <= max_corner[d] for d in range(len(point)))\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Hybrid Anytime RRT* with Dynamic Lazy Collision Checking and Path Shortcutting. This planner integrates the asymptotic optimality of RRT* with lazy collision detection to reduce computational overhead. It includes dynamic adjustment of the neighbor radius based on tree size, adaptive step size scaling near goal for finer exploration, and incorporates an anytime replanning capability by iteratively improving path quality. After an initial feasible path is found, a shortcutting-based smoothing is applied on-the-fly to enhance path quality while maintaining collision safety, all aimed at improving efficiency, path smoothness, robustness, and success rate.",
     "planning_mechanism": "Planning mechanism: The planner grows a single tree incrementally using biased sampling towards the goal and free space. Each sampled point leads to lazy collision-checked rewiring within an adaptively computed neighbor radius, deferring collision checks for edges until necessary. When a path to the goal is found, early stopping allows the initial solution extraction and triggers a shortcutting smoothing procedure on the path during the search. The step size automatically shrinks near the goal to improve precision, and the planner continues to refine the path quality iteratively up to max iterations or timeout.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15, base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            return tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n\n        def sample():\n            # Goal biasing with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            # gamma * (log(n)/n)^{1/d}, gamma=self.base_radius\n            if n <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 25)\n\n        # Lazy collision checking cache for edges:\n        # keys = (parent.position, child.position), values = bool (True = free, False = collision)\n        edge_collision_cache = {}\n\n        def lazy_edge_collision_free(p1, p2):\n            key = (p1, p2)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            # Check node collision first (both ends)\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                edge_collision_cache[key] = False\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                edge_collision_cache[key] = False\n                return False\n            edge_collision_cache[key] = True\n            return True\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def extract_path(goal_node):\n            path_nodes = []\n            node = goal_node\n            while node:\n                path_nodes.append(node.position)\n                node = node.parent\n            return path_nodes[::-1]\n\n        def shortcut_path(path):\n            # Attempt shortcutting by random pairs in path\n            MAX_ATTEMPTS = 30\n            for _ in range(MAX_ATTEMPTS):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    # Remove intermediate nodes from i+1 to j-1\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            radius = adaptive_radius(n)\n\n            sample_point = sample()\n\n            # If near goal, reduce step size adaptively for precision\n            dist_to_goal = dist(sample_point, goal)\n            adaptive_step = self.step_size\n            if dist_to_goal < self.step_size * 3:\n                adaptive_step = max(0.5, self.step_size * (dist_to_goal / (self.step_size * 3)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda node: dist(node.position, sample_point))\n\n            new_pos = steer(nearest.position, sample_point, adaptive_step)\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy check edge collision between nearest and new_pos before adding node\n            if not lazy_edge_collision_free(nearest.position, new_pos):\n                continue\n\n            # Create new node connected to nearest\n            new_node = Node(new_pos)\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            new_node.update_parent(nearest, cost_to_new)\n\n            # Nearby nodes for rewiring\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            # Lazy rewiring with collision checks deferred until needed\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                # Only check edge collision if temp_cost better\n                if temp_cost < min_cost:\n                    if lazy_edge_collision_free(near_node.position, new_pos):\n                        new_node.update_parent(near_node, temp_cost)\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if lazy_edge_collision_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new_node connects to goal within step size and collision free\n            dist_new_to_goal = dist(new_node.position, goal)\n            if dist_new_to_goal <= adaptive_step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, resolution=0.3) == False:\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_new_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best goal solution\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n                    # Early stopping condition if path good enough: here continue to refine path further for anytime property\n\n            # Anytime improvement: attempt shortcutting on best path every N iterations after first solution\n            if success_state and iteration % 100 == 0 and best_goal_node:\n                raw_path = extract_path(best_goal_node)\n                shortcut_path_new = shortcut_path(raw_path)\n                if path_length(shortcut_path_new) + 1e-6 < best_cost:\n                    # Rebuild tree connections along shortcut path\n                    # For result return only path is updated; nodes/edges remain as exploration data\n                    best_cost = path_length(shortcut_path_new)\n                    extracted_path = shortcut_path_new\n\n        # Final path extraction if success but smoothing not performed in last shortcut step\n        if success_state and not extracted_path:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Hybrid Anytime RRT* with Dynamic Lazy Collision Checking and Path Shortcutting. This planner integrates the asymptotic optimality of RRT* with lazy collision detection to reduce computational overhead. It includes dynamic adjustment of the neighbor radius based on tree size, adaptive step size scaling near goal for finer exploration, and incorporates an anytime replanning capability by iteratively improving path quality. After an initial feasible path is found, a shortcutting-based smoothing is applied on-the-fly to enhance path quality while maintaining collision safety, all aimed at improving efficiency, path smoothness, robustness, and success rate.",
     "planning_mechanism": "Planning mechanism: The planner grows a single tree incrementally using biased sampling towards the goal and free space. Each sampled point leads to lazy collision-checked rewiring within an adaptively computed neighbor radius, deferring collision checks for edges until necessary. When a path to the goal is found, early stopping allows the initial solution extraction and triggers a shortcutting smoothing procedure on the path during the search. The step size automatically shrinks near the goal to improve precision, and the planner continues to refine the path quality iteratively up to max iterations or timeout.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15, base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            return tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n\n        def sample():\n            # Goal biasing with goal_sample_rate probability\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            # gamma * (log(n)/n)^{1/d}, gamma=self.base_radius\n            if n <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 25)\n\n        # Lazy collision checking cache for edges:\n        # keys = (parent.position, child.position), values = bool (True = free, False = collision)\n        edge_collision_cache = {}\n\n        def lazy_edge_collision_free(p1, p2):\n            key = (p1, p2)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            # Check node collision first (both ends)\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                edge_collision_cache[key] = False\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                edge_collision_cache[key] = False\n                return False\n            edge_collision_cache[key] = True\n            return True\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def extract_path(goal_node):\n            path_nodes = []\n            node = goal_node\n            while node:\n                path_nodes.append(node.position)\n                node = node.parent\n            return path_nodes[::-1]\n\n        def shortcut_path(path):\n            # Attempt shortcutting by random pairs in path\n            MAX_ATTEMPTS = 30\n            for _ in range(MAX_ATTEMPTS):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    # Remove intermediate nodes from i+1 to j-1\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            radius = adaptive_radius(n)\n\n            sample_point = sample()\n\n            # If near goal, reduce step size adaptively for precision\n            dist_to_goal = dist(sample_point, goal)\n            adaptive_step = self.step_size\n            if dist_to_goal < self.step_size * 3:\n                adaptive_step = max(0.5, self.step_size * (dist_to_goal / (self.step_size * 3)))\n\n            # Find nearest node\n            nearest = min(nodes, key=lambda node: dist(node.position, sample_point))\n\n            new_pos = steer(nearest.position, sample_point, adaptive_step)\n\n            # Bounds check\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Lazy check edge collision between nearest and new_pos before adding node\n            if not lazy_edge_collision_free(nearest.position, new_pos):\n                continue\n\n            # Create new node connected to nearest\n            new_node = Node(new_pos)\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            new_node.update_parent(nearest, cost_to_new)\n\n            # Nearby nodes for rewiring\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            # Lazy rewiring with collision checks deferred until needed\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                # Only check edge collision if temp_cost better\n                if temp_cost < min_cost:\n                    if lazy_edge_collision_free(near_node.position, new_pos):\n                        new_node.update_parent(near_node, temp_cost)\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            # Rewire neighbors if better through new_node\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if lazy_edge_collision_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            # Check if new_node connects to goal within step size and collision free\n            dist_new_to_goal = dist(new_node.position, goal)\n            if dist_new_to_goal <= adaptive_step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, resolution=0.3):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_new_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    # Update best goal solution\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n                    # Early stopping condition if path good enough: here continue to refine path further for anytime property\n\n            # Anytime improvement: attempt shortcutting on best path every N iterations after first solution\n            if success_state and iteration % 100 == 0 and best_goal_node:\n                raw_path = extract_path(best_goal_node)\n                shortcut_path_new = shortcut_path(raw_path)\n                if path_length(shortcut_path_new) + 1e-6 < best_cost:\n                    # For result return only path is updated; nodes/edges remain as exploration data\n                    best_cost = path_length(shortcut_path_new)\n                    extracted_path = shortcut_path_new\n\n        # Final path extraction if success but smoothing not performed in last shortcut step\n        if success_state and not extracted_path:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n\n        # Return a dict (not PlannerResult object) to fix the error caused by accessing .path on a dict\n        # Convert to object PlannerResult as per original expected return\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Hybrid Anytime RRT* with Dynamic Lazy Collision Checking and Path Shortcutting. This planner integrates the asymptotic optimality of RRT* with lazy collision detection to reduce computational overhead. It includes dynamic adjustment of the neighbor radius based on tree size, adaptive step size scaling near goal for finer exploration, and incorporates an anytime replanning capability by iteratively improving path quality. After an initial feasible path is found, a shortcutting-based smoothing is applied on-the-fly to enhance path quality while maintaining collision safety, all aimed at improving efficiency, path smoothness, robustness, and success rate.",
     "planning_mechanism": "Planning mechanism: The planner grows a single tree incrementally using biased sampling towards the goal and free space. Each sampled point leads to lazy collision-checked rewiring within an adaptively computed neighbor radius, deferring collision checks for edges until necessary. When a path to the goal is found, early stopping allows the initial solution extraction and triggers a shortcutting smoothing procedure on the path during the search. The step size automatically shrinks near the goal to improve precision, and the planner continues to refine the path quality iteratively up to max iterations or timeout.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15, base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            return tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 25)\n\n        edge_collision_cache = {}\n\n        def lazy_edge_collision_free(p1, p2):\n            key = (p1, p2)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                edge_collision_cache[key] = False\n                return False\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                edge_collision_cache[key] = False\n                return False\n            edge_collision_cache[key] = True\n            return True\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def extract_path(goal_node):\n            path_nodes = []\n            node = goal_node\n            while node:\n                path_nodes.append(node.position)\n                node = node.parent\n            return path_nodes[::-1]\n\n        def shortcut_path(path):\n            MAX_ATTEMPTS = 30\n            for _ in range(MAX_ATTEMPTS):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            radius = adaptive_radius(n)\n\n            sample_point = sample()\n\n            dist_to_goal = dist(sample_point, goal)\n            adaptive_step = self.step_size\n            if dist_to_goal < self.step_size * 3:\n                adaptive_step = max(0.5, self.step_size * (dist_to_goal / (self.step_size * 3)))\n\n            nearest = min(nodes, key=lambda node: dist(node.position, sample_point))\n\n            new_pos = steer(nearest.position, sample_point, adaptive_step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            if not lazy_edge_collision_free(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            new_node.update_parent(nearest, cost_to_new)\n\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    if lazy_edge_collision_free(near_node.position, new_pos):\n                        new_node.update_parent(near_node, temp_cost)\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if lazy_edge_collision_free(new_node.position, near_node.position):\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            dist_new_to_goal = dist(new_node.position, goal)\n            if dist_new_to_goal <= adaptive_step:\n                if not self._is_in_obstacle(goal, obstacles, is_3d) and not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, resolution=0.3):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_new_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n            if success_state and iteration % 100 == 0 and best_goal_node:\n                raw_path = extract_path(best_goal_node)\n                shortcut_path_new = shortcut_path(raw_path)\n                if path_length(shortcut_path_new) + 1e-6 < best_cost:\n                    best_cost = path_length(shortcut_path_new)\n                    extracted_path = shortcut_path_new\n\n        if success_state and not extracted_path:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e1",
     "algorithm_description": "Algorithm description: Hybrid Anytime RRT* with Dynamic Lazy Collision Checking and Path Shortcutting. This planner integrates the asymptotic optimality of RRT* with lazy collision detection to reduce computational overhead. It includes dynamic adjustment of the neighbor radius based on tree size, adaptive step size scaling near goal for finer exploration, and incorporates an anytime replanning capability by iteratively improving path quality. After an initial feasible path is found, a shortcutting-based smoothing is applied on-the-fly to enhance path quality while maintaining collision safety, all aimed at improving efficiency, path smoothness, robustness, and success rate.",
     "planning_mechanism": "Planning mechanism: The planner grows a single tree incrementally using biased sampling towards the goal and free space. Each sampled point leads to lazy collision-checked rewiring within an adaptively computed neighbor radius, deferring collision checks for edges until necessary. When a path to the goal is found, early stopping allows the initial solution extraction and triggers a shortcutting smoothing procedure on the path during the search. The step size automatically shrinks near the goal to improve precision, and the planner continues to refine the path quality iteratively up to max iterations or timeout.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 6.0, goal_sample_rate: float = 0.15, base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_radius = base_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        root = Node(start)\n        nodes.append(root)\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, max_dist):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            length = dist(from_pos, to_pos)\n            if length <= max_dist:\n                return to_pos\n            scale = max_dist / length\n            return tuple(from_pos[d] + direction[d] * scale for d in range(dim))\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            else:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_radius(n):\n            if n <= 1:\n                return self.base_radius\n            return min(self.base_radius * ((math.log(n) / n) ** (1.0 / dim)), self.step_size * 25)\n\n        edge_collision_cache = {}\n\n        def lazy_edge_collision_free(p1, p2):\n            key = (p1, p2)\n            if key in edge_collision_cache:\n                return edge_collision_cache[key]\n            # Collision check for node position p2\n            if self._is_in_obstacle(p2, obstacles, is_3d):\n                edge_collision_cache[key] = False\n                return False\n            # Edge collision check\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d, resolution=0.3):\n                edge_collision_cache[key] = False\n                return False\n            edge_collision_cache[key] = True\n            return True\n\n        def path_length(path):\n            return sum(dist(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n        def extract_path(goal_node):\n            path_nodes = []\n            node = goal_node\n            while node:\n                path_nodes.append(node.position)\n                node = node.parent\n            return path_nodes[::-1]\n\n        def shortcut_path(path):\n            MAX_ATTEMPTS = 30\n            for _ in range(MAX_ATTEMPTS):\n                if len(path) < 3:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n                p_i = path[i]\n                p_j = path[j]\n                if not self._is_edge_in_obstacle(p_i, p_j, obstacles, is_3d, resolution=0.3):\n                    path = path[:i + 1] + path[j:]\n            return path\n\n        best_goal_node = None\n        best_cost = float('inf')\n\n        for iteration in range(self.max_iter):\n            n = len(nodes)\n            radius = adaptive_radius(n)\n\n            sample_point = sample()\n\n            # Ensure sampled point is within bounds\n            if any(sample_point[d] < 0 or sample_point[d] > bounds[d] for d in range(dim)):\n                continue\n\n            dist_to_goal = dist(sample_point, goal)\n            adaptive_step = self.step_size\n            if dist_to_goal < self.step_size * 3:\n                adaptive_step = max(0.5, self.step_size * (dist_to_goal / (self.step_size * 3)))\n\n            nearest = min(nodes, key=lambda node: dist(node.position, sample_point))\n\n            new_pos = steer(nearest.position, sample_point, adaptive_step)\n\n            # Check new_pos is within bounds\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Node collision check\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n\n            # Edge collision check from nearest to new_pos\n            if not lazy_edge_collision_free(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            cost_to_new = nearest.cost + dist(nearest.position, new_pos)\n            new_node.update_parent(nearest, cost_to_new)\n\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= radius]\n\n            min_cost = new_node.cost\n            best_parent = new_node.parent\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost:\n                    if lazy_edge_collision_free(near_node.position, new_pos):\n                        new_node.update_parent(near_node, temp_cost)\n                        min_cost = temp_cost\n                        best_parent = near_node\n\n            # Before adding edge, confirm edge collision free\n            if new_node.parent and not lazy_edge_collision_free(new_node.parent.position, new_node.position):\n                # Should not happen here but for consistency\n                continue\n\n            nodes.append(new_node)\n            edges.append((new_node.parent, new_node))\n\n            for near_node in near_nodes:\n                if near_node is new_node.parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost:\n                    if lazy_edge_collision_free(new_node.position, near_node.position):\n                        # Check node collision for near_node.position is implicit, as it's existing node\n                        if near_node.parent:\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near_node))\n\n            dist_new_to_goal = dist(new_node.position, goal)\n            if dist_new_to_goal <= adaptive_step:\n                if (not self._is_in_obstacle(goal, obstacles, is_3d) and\n                    not self._is_edge_in_obstacle(new_node.position, goal, obstacles, is_3d, resolution=0.3)):\n                    goal_node = Node(goal)\n                    goal_node.update_parent(new_node, new_node.cost + dist_new_to_goal)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    if goal_node.cost < best_cost:\n                        best_cost = goal_node.cost\n                        best_goal_node = goal_node\n                        success_state = True\n\n            if success_state and iteration % 100 == 0 and best_goal_node:\n                raw_path = extract_path(best_goal_node)\n                shortcut_path_new = shortcut_path(raw_path)\n                if path_length(shortcut_path_new) + 1e-6 < best_cost:\n                    best_cost = path_length(shortcut_path_new)\n                    extracted_path = shortcut_path_new\n\n        if success_state and not extracted_path:\n            extracted_path = extract_path(best_goal_node)\n            extracted_path = shortcut_path(extracted_path)\n\n        # Return result as dict to match expected output with .path attribute error fixed\n        return {\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "A refined hybrid informed bidirectional RRT*-Connect planner combining informed ellipsoidal sampling, adaptive step size adjustment near obstacles, efficient rewiring, goal biasing, and dynamic pruning to improve planning efficiency, path quality, and success rate. It adaptively balances exploration and exploitation by alternating tree growth from start and goal states and aggressively connects and rewires to approach optimality, followed by post-processing smoothing for robust, shorter paths.",
     "planning_mechanism": "The planner grows two trees bidirectionally using informed sampling concentrated in an ellipsoidal subset of the search space defined by the current best path cost, adaptively adjusting expansion steps near obstacles to prevent collisions. At each iteration, it alternates expansions between the start and goal trees, attempts early and frequent connections, and locally rewires nodes for cost improvements. It prunes branches that cannot improve the current best path cost to accelerate convergence and applies a smoothing procedure on the final path to improve smoothness and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.15, rewire_radius: float = 18.0,\n                 prune_threshold: float = 1e-6):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        # Helps prune nodes that cannot improve best cost\n        def can_improve_cost(node):\n            return node.cost + math.dist(node.position, goal_position if node in tree_start else start_position) < c_best - self.prune_threshold\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            min_step = self.base_step * 0.4\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(min_step, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal_position if tree_a == tree_start else start_position\n\n            # Sampling with goal bias and informed ellipsoidal sampling\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not all(0 <= new_position[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - self.prune_threshold >= c_best:\n                # Prune unpromising expansions\n                continue\n\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Near nodes for rewiring\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            # Rewire near nodes if cheaper path found via new_node\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + self.prune_threshold < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_btwn_trees = math.dist(new_node.position, nearest_other.position)\n            total_cost = new_node.cost + dist_btwn_trees + nearest_other.cost\n            if total_cost + self.prune_threshold < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune nodes that cannot improve new best cost\n                    # Remove far nodes in both trees with cost + heuristic \u2265 c_best\n                    def prune_tree(tree):\n                        pruned_nodes = []\n                        for node in tree[:]:  # copy to avoid iteration issues\n                            # heuristic cost to goal (or start if tree is goal tree)\n                            heuristic = math.dist(node.position, goal_position if tree == tree_start else start_position)\n                            if node.cost + heuristic >= c_best - self.prune_threshold and node != tree[0]:\n                                # Disconnect subtree\n                                if node.parent:\n                                    node.parent.remove_child(node)\n                                tree.remove(node)\n                                pruned_nodes.append(node)\n                        return pruned_nodes\n\n                    prune_tree(tree_start)\n                    prune_tree(tree_goal)\n\n        # Post-process: path smoothing\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        N = len(path)\n        while idx < N - 1:\n            next_idx = N - 1\n            for j in range(N - 1, idx, -1):\n                if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d) and all(0 <= path[j][d] <= bounds[d] for d in range(len(bounds))):\n                    next_idx = j\n                    break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Assumes obstacles are axis-aligned bounding boxes: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "A refined hybrid informed bidirectional RRT*-Connect planner combining informed ellipsoidal sampling, adaptive step size adjustment near obstacles, efficient rewiring, goal biasing, and dynamic pruning to improve planning efficiency, path quality, and success rate. It adaptively balances exploration and exploitation by alternating tree growth from start and goal states and aggressively connects and rewires to approach optimality, followed by post-processing smoothing for robust, shorter paths.",
     "planning_mechanism": "The planner grows two trees bidirectionally using informed sampling concentrated in an ellipsoidal subset of the search space defined by the current best path cost, adaptively adjusting expansion steps near obstacles to prevent collisions. At each iteration, it alternates expansions between the start and goal trees, attempts early and frequent connections, and locally rewires nodes for cost improvements. It prunes branches that cannot improve the current best path cost to accelerate convergence and applies a smoothing procedure on the final path to improve smoothness and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.15, rewire_radius: float = 18.0,\n                 prune_threshold: float = 1e-6):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            min_step = self.base_step * 0.4\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(min_step, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal_position if tree_a == tree_start else start_position\n\n            # Sampling with goal bias and informed ellipsoidal sampling\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not all(0 <= new_position[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - self.prune_threshold >= c_best:\n                # Prune unpromising expansions\n                continue\n\n            # Create node only after collision checks passed\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Near nodes for rewiring\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            # Rewire near nodes if cheaper path found via new_node\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + self.prune_threshold < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_btwn_trees = math.dist(new_node.position, nearest_other.position)\n            total_cost = new_node.cost + dist_btwn_trees + nearest_other.cost\n            if total_cost + self.prune_threshold < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    def prune_tree(tree):\n                        pruned_nodes = []\n                        for node in tree[:]:  # copy to avoid iteration issues\n                            heuristic = math.dist(node.position, goal_position if tree == tree_start else start_position)\n                            if node.cost + heuristic >= c_best - self.prune_threshold and node != tree[0]:\n                                if node.parent:\n                                    node.parent.remove_child(node)\n                                tree.remove(node)\n                                pruned_nodes.append(node)\n                        return pruned_nodes\n\n                    prune_tree(tree_start)\n                    prune_tree(tree_goal)\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        # Return a PlannerResult object, not dict\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        N = len(path)\n        while idx < N - 1:\n            next_idx = N - 1\n            for j in range(N - 1, idx, -1):\n                if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d) and all(0 <= path[j][d] <= bounds[d] for d in range(len(bounds))):\n                    next_idx = j\n                    break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "A refined hybrid informed bidirectional RRT*-Connect planner combining informed ellipsoidal sampling, adaptive step size adjustment near obstacles, efficient rewiring, goal biasing, and dynamic pruning to improve planning efficiency, path quality, and success rate. It adaptively balances exploration and exploitation by alternating tree growth from start and goal states and aggressively connects and rewires to approach optimality, followed by post-processing smoothing for robust, shorter paths.",
     "planning_mechanism": "The planner grows two trees bidirectionally using informed sampling concentrated in an ellipsoidal subset of the search space defined by the current best path cost, adaptively adjusting expansion steps near obstacles to prevent collisions. At each iteration, it alternates expansions between the start and goal trees, attempts early and frequent connections, and locally rewires nodes for cost improvements. It prunes branches that cannot improve the current best path cost to accelerate convergence and applies a smoothing procedure on the final path to improve smoothness and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.15, rewire_radius: float = 18.0,\n                 prune_threshold: float = 1e-6):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            min_step = self.base_step * 0.4\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(min_step, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal_position if tree_a == tree_start else start_position\n\n            # Sampling with goal bias and informed ellipsoidal sampling\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not all(0 <= new_position[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - self.prune_threshold >= c_best:\n                # Prune unpromising expansions\n                continue\n\n            # Create node only after collision checks passed\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Near nodes for rewiring\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            # Rewire near nodes if cheaper path found via new_node\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + self.prune_threshold < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_btwn_trees = math.dist(new_node.position, nearest_other.position)\n            total_cost = new_node.cost + dist_btwn_trees + nearest_other.cost\n            if total_cost + self.prune_threshold < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    def prune_tree(tree):\n                        pruned_nodes = []\n                        for node in tree[:]:  # copy to avoid iteration issues\n                            heuristic = math.dist(node.position, goal_position if tree == tree_start else start_position)\n                            if node.cost + heuristic >= c_best - self.prune_threshold and node != tree[0]:\n                                if node.parent:\n                                    node.parent.remove_child(node)\n                                tree.remove(node)\n                                pruned_nodes.append(node)\n                        return pruned_nodes\n\n                    prune_tree(tree_start)\n                    prune_tree(tree_goal)\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        # Return a PlannerResult object, not a dict\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        N = len(path)\n        while idx < N - 1:\n            next_idx = N - 1\n            for j in range(N - 1, idx, -1):\n                if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d) and all(0 <= path[j][d] <= bounds[d] for d in range(len(bounds))):\n                    next_idx = j\n                    break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "A refined hybrid informed bidirectional RRT*-Connect planner combining informed ellipsoidal sampling, adaptive step size adjustment near obstacles, efficient rewiring, goal biasing, and dynamic pruning to improve planning efficiency, path quality, and success rate. It adaptively balances exploration and exploitation by alternating tree growth from start and goal states and aggressively connects and rewires to approach optimality, followed by post-processing smoothing for robust, shorter paths.",
     "planning_mechanism": "The planner grows two trees bidirectionally using informed sampling concentrated in an ellipsoidal subset of the search space defined by the current best path cost, adaptively adjusting expansion steps near obstacles to prevent collisions. At each iteration, it alternates expansions between the start and goal trees, attempts early and frequent connections, and locally rewires nodes for cost improvements. It prunes branches that cannot improve the current best path cost to accelerate convergence and applies a smoothing procedure on the final path to improve smoothness and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4500, base_step: float = 4.5, goal_sample_rate: float = 0.15, rewire_radius: float = 18.0,\n                 prune_threshold: float = 1e-6):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n        self.prune_threshold = prune_threshold\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def informed_sample():\n            if c_best == float('inf'):\n                # Uniform sample\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[:, 0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best ** 2 - c_min ** 2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball = x_ball / norm_x_ball\n                scale = random.random() ** (1 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(3, int(dist))\n            min_step = self.base_step * 0.4\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(min_step, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            sample_goal = goal_position if tree_a == tree_start else start_position\n\n            # Sampling with goal bias and informed ellipsoidal sampling\n            if random.random() < self.goal_sample_rate:\n                sample = sample_goal\n            else:\n                sample = informed_sample()\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not all(0 <= new_position[d] <= bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - self.prune_threshold >= c_best:\n                # Prune unpromising expansions\n                continue\n\n            # Create node only after collision checks passed\n            new_node = Node(new_position)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Near nodes for rewiring\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            # Rewire near nodes if cheaper path found via new_node\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + self.prune_threshold < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try to connect to the other tree\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_btwn_trees = math.dist(new_node.position, nearest_other.position)\n            total_cost = new_node.cost + dist_btwn_trees + nearest_other.cost\n            if total_cost + self.prune_threshold < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_other.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    def prune_tree(tree):\n                        pruned_nodes = []\n                        for node in tree[:]:  # copy to avoid iteration issues\n                            heuristic = math.dist(node.position, goal_position if tree == tree_start else start_position)\n                            if node.cost + heuristic >= c_best - self.prune_threshold and node != tree[0]:\n                                if node.parent:\n                                    node.parent.remove_child(node)\n                                tree.remove(node)\n                                pruned_nodes.append(node)\n                        return pruned_nodes\n\n                    prune_tree(tree_start)\n                    prune_tree(tree_goal)\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        # Return a PlannerResult object, not a dict\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        N = len(path)\n        while idx < N - 1:\n            next_idx = N - 1\n            for j in range(N - 1, idx, -1):\n                if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d) and all(0 <= path[j][d] <= bounds[d] for d in range(len(bounds))):\n                    next_idx = j\n                    break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.8):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional growth and tree swapping of BI-RRT with the informed sampling, adaptive step sizing, rewiring, and pruning strategies of RRT*-Connect. It grows two trees simultaneously from the start and goal, utilizes heuristic-informed sampling within an ellipse shaped by the current best path cost to focus exploration, adapts step size near obstacles to enhance safety and efficiency, prunes nodes that cannot improve the solution, rewires locally to optimize path costs, and swaps trees iteratively to balance exploration. This approach improves planning efficiency, path quality, robustness, success rate, and reduces search time and path length in both 2D and 3D environments.",
     "planning_mechanism": "The planner samples points informed by the current best path cost to bias search toward promising regions. It expands trees bidirectionally with adaptive step sizes to avoid obstacles and improve safety. Upon adding new nodes, local rewiring optimizes paths by reducing costs, and pruning discards nodes unlikely to improve the best path. The two trees attempt connection on each iteration, with paths reconstructed and updated when successful, producing shorter, smoother, and more reliable paths efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success = False\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Informed sampling\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n\n            # Find nearest in tree_a and adaptive step size\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Check node feasibility\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve current best path\n            est_total_cost = cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes in tree_a\n            near_nodes = [n for n in tree_a if n is not new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                dist_new_to_near = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_new_to_near\n                if potential_cost < near.cost:\n                    # Check edge feasibility before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if near.parent is not None:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Rewire\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                path_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Construct full path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    best_path = path_a + path_b[::-1]\n                    success = True\n\n                    # Prune nodes in both trees that can't improve better than c_best\n                    self._prune_tree(tree_start, c_best, goal_pos, obstacles, is_3d)\n                    self._prune_tree(tree_goal, c_best, start_pos, obstacles, is_3d)\n\n            # Swap trees for next iteration\n            if i % 2 == 0:\n                tree_start, tree_goal = tree_a, tree_b\n            else:\n                tree_goal, tree_start = tree_a, tree_b\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float('inf'):\n            # Uniform random sample in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        c_best = max(c_best, c_min)  # Ensure c_best >= c_min\n        x_center_np = (np.array(start) + np.array(goal)) / 2\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Start and goal coincide\n            return tuple(start)\n        a1 = a1 / norm_a1\n\n        # Create orthonormal basis\n        id1 = np.zeros((dim,))\n        id1[0] = 1\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        if c_best * c_best - c_min * c_min < 0:\n            r2_val = 0\n        else:\n            r2_val = math.sqrt(c_best * c_best - c_min * c_min) / 2\n        L = np.diag([r1] + [r2_val] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_ball = np.linalg.norm(x_ball)\n            if norm_ball == 0:\n                continue\n            x_ball = x_ball / norm_ball\n            radius_sample = random.random() ** (1 / dim)\n            x_ball = x_ball * radius_sample\n            x_rand = C @ L @ x_ball + x_center_np\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step near obstacle but keep minimum 1.0 to avoid too small steps\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _prune_tree(self, tree, c_best, opposite_root_pos, obstacles, is_3d):\n        import math\n        # Remove nodes whose cost + heuristic to goal exceed c_best\n        to_remove = []\n        for node in tree:\n            heuristic = math.dist(node.position, opposite_root_pos)\n            if node.cost + heuristic >= c_best:\n                to_remove.append(node)\n        for node in to_remove:\n            # Avoid removing root nodes\n            if node.parent is None:\n                continue\n            # Disconnect node from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        # Remove children recursively\n        for c in list(node.children):\n            self._remove_subtree(c, tree)\n        if node in tree:\n            tree.remove(node)\n        node.children.clear()\n        node.parent = None",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional growth and tree swapping of BI-RRT with the informed sampling, adaptive step sizing, rewiring, and pruning strategies of RRT*-Connect. It grows two trees simultaneously from the start and goal, utilizes heuristic-informed sampling within an ellipse shaped by the current best path cost to focus exploration, adapts step size near obstacles to enhance safety and efficiency, prunes nodes that cannot improve the solution, rewires locally to optimize path costs, and swaps trees iteratively to balance exploration. This approach improves planning efficiency, path quality, robustness, success rate, and reduces search time and path length in both 2D and 3D environments.",
     "planning_mechanism": "The planner samples points informed by the current best path cost to bias search toward promising regions. It expands trees bidirectionally with adaptive step sizes to avoid obstacles and improve safety. Upon adding new nodes, local rewiring optimizes paths by reducing costs, and pruning discards nodes unlikely to improve the best path. The two trees attempt connection on each iteration, with paths reconstructed and updated when successful, producing shorter, smoother, and more reliable paths efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> Dict[str, Any]:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success = False\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Informed sampling\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n\n            # Find nearest in tree_a and adaptive step size\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Check node feasibility\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve current best path\n            est_total_cost = cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes in tree_a\n            near_nodes = [n for n in tree_a if n is not new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                dist_new_to_near = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_new_to_near\n                if potential_cost < near.cost:\n                    # Check edge feasibility before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if near.parent is not None:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Rewire\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                path_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Construct full path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    best_path = path_a + path_b[::-1]\n                    success = True\n\n                    # Prune nodes in both trees that can't improve better than c_best\n                    self._prune_tree(tree_start, c_best, goal_pos, obstacles, is_3d)\n                    self._prune_tree(tree_goal, c_best, start_pos, obstacles, is_3d)\n\n            # Swap trees for next iteration\n            if i % 2 == 0:\n                tree_start, tree_goal = tree_a, tree_b\n            else:\n                tree_goal, tree_start = tree_a, tree_b\n\n        return {'success': success, 'path': best_path, 'nodes': nodes, 'edges': edges}\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float('inf'):\n            # Uniform random sample in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        c_best = max(c_best, c_min)  # Ensure c_best >= c_min\n        x_center_np = (np.array(start) + np.array(goal)) / 2\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Start and goal coincide\n            return tuple(start)\n        a1 = a1 / norm_a1\n\n        # Create orthonormal basis\n        id1 = np.zeros((dim,))\n        id1[0] = 1\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        if c_best * c_best - c_min * c_min < 0:\n            r2_val = 0\n        else:\n            r2_val = math.sqrt(c_best * c_best - c_min * c_min) / 2\n        L = np.diag([r1] + [r2_val] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_ball = np.linalg.norm(x_ball)\n            if norm_ball == 0:\n                continue\n            x_ball = x_ball / norm_ball\n            radius_sample = random.random() ** (1 / dim)\n            x_ball = x_ball * radius_sample\n            x_rand = C @ L @ x_ball + x_center_np\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step near obstacle but keep minimum 1.0 to avoid too small steps\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _prune_tree(self, tree, c_best, opposite_root_pos, obstacles, is_3d):\n        import math\n        # Remove nodes whose cost + heuristic to goal exceed c_best\n        to_remove = []\n        for node in tree:\n            heuristic = math.dist(node.position, opposite_root_pos)\n            if node.cost + heuristic >= c_best:\n                to_remove.append(node)\n        for node in to_remove:\n            # Avoid removing root nodes\n            if node.parent is None:\n                continue\n            # Disconnect node from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        # Remove children recursively\n        for c in list(node.children):\n            self._remove_subtree(c, tree)\n        if node in tree:\n            tree.remove(node)\n        node.children.clear()\n        node.parent = None\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    # Placeholder methods for obstacle checks - should be implemented or available from the imported utilities\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Assuming map or utility has method to check if position is inside obstacle\n        for obs in obstacles:\n            if self._point_in_obstacle(pos, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Assuming map or utility has method to check if edge intersects obstacle\n        for obs in obstacles:\n            if self._edge_intersects_obstacle(p1, p2, obs, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, pos, obstacle, is_3d):\n        # Placeholder: implement actual point-obstacle collision check\n        return False\n\n    def _edge_intersects_obstacle(self, p1, p2, obstacle, is_3d):\n        # Placeholder: implement actual edge-obstacle collision check\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional growth and tree swapping of BI-RRT with the informed sampling, adaptive step sizing, rewiring, and pruning strategies of RRT*-Connect. It grows two trees simultaneously from the start and goal, utilizes heuristic-informed sampling within an ellipse shaped by the current best path cost to focus exploration, adapts step size near obstacles to enhance safety and efficiency, prunes nodes that cannot improve the solution, rewires locally to optimize path costs, and swaps trees iteratively to balance exploration. This approach improves planning efficiency, path quality, robustness, success rate, and reduces search time and path length in both 2D and 3D environments.",
     "planning_mechanism": "The planner samples points informed by the current best path cost to bias search toward promising regions. It expands trees bidirectionally with adaptive step sizes to avoid obstacles and improve safety. Upon adding new nodes, local rewiring optimizes paths by reducing costs, and pruning discards nodes unlikely to improve the best path. The two trees attempt connection on each iteration, with paths reconstructed and updated when successful, producing shorter, smoother, and more reliable paths efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success = False\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Informed sampling\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n\n            # Find nearest in tree_a and adaptive step size\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Check node feasibility\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve current best path\n            est_total_cost = cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes in tree_a\n            near_nodes = [n for n in tree_a if n is not new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                dist_new_to_near = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_new_to_near\n                if potential_cost < near.cost:\n                    # Check edge feasibility before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if near.parent is not None:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Rewire\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                path_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Construct full path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    # Remove duplicated connecting node at connection point\n                    if path_b:\n                        path_b.reverse()\n                    best_path = path_a + path_b[1:] if len(path_b) > 1 else path_a + path_b\n                    success = True\n\n                    # Prune nodes in both trees that can't improve better than c_best\n                    self._prune_tree(tree_start, c_best, goal_pos, obstacles, is_3d)\n                    self._prune_tree(tree_goal, c_best, start_pos, obstacles, is_3d)\n\n            # Swap trees for next iteration\n            if i % 2 == 0:\n                tree_start, tree_goal = tree_a, tree_b\n            else:\n                tree_goal, tree_start = tree_a, tree_b\n\n        return {'success': success, 'path': best_path, 'nodes': nodes, 'edges': edges}\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float('inf'):\n            # Uniform random sample in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        c_best = max(c_best, c_min)  # Ensure c_best >= c_min\n        x_center_np = (np.array(start) + np.array(goal)) / 2\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Start and goal coincide\n            return tuple(start)\n        a1 = a1 / norm_a1\n\n        # Create orthonormal basis\n        id1 = np.zeros((dim,))\n        id1[0] = 1\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        if c_best * c_best - c_min * c_min < 0:\n            r2_val = 0\n        else:\n            r2_val = math.sqrt(c_best * c_best - c_min * c_min) / 2\n        L = np.diag([r1] + [r2_val] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_ball = np.linalg.norm(x_ball)\n            if norm_ball == 0:\n                continue\n            x_ball = x_ball / norm_ball\n            radius_sample = random.random() ** (1 / dim)\n            x_ball = x_ball * radius_sample\n            x_rand = C @ L @ x_ball + x_center_np\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step near obstacle but keep minimum 1.0 to avoid too small steps\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _prune_tree(self, tree, c_best, opposite_root_pos, obstacles, is_3d):\n        import math\n        # Remove nodes whose cost + heuristic to goal exceed c_best\n        to_remove = []\n        for node in tree:\n            heuristic = math.dist(node.position, opposite_root_pos)\n            if node.cost + heuristic >= c_best:\n                to_remove.append(node)\n        for node in to_remove:\n            # Avoid removing root nodes\n            if node.parent is None:\n                continue\n            # Disconnect node from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        # Remove children recursively\n        for c in list(node.children):\n            self._remove_subtree(c, tree)\n        if node in tree:\n            tree.remove(node)\n        node.children.clear()\n        node.parent = None\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    # Placeholder methods for obstacle checks - should be implemented or available from the imported utilities\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Assuming map or utility has method to check if position is inside obstacle\n        for obs in obstacles:\n            if self._point_in_obstacle(pos, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Assuming map or utility has method to check if edge intersects obstacle\n        for obs in obstacles:\n            if self._edge_intersects_obstacle(p1, p2, obs, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, pos, obstacle, is_3d):\n        # Placeholder: implement actual point-obstacle collision check\n        return False\n\n    def _edge_intersects_obstacle(self, p1, p2, obstacle, is_3d):\n        # Placeholder: implement actual edge-obstacle collision check\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Informed Bidirectional RRT-Connect with Adaptive Step Sizing, Dynamic Rewiring, and Path Smoothing",
     "planning_mechanism": "The planner grows two trees from the start and goal positions. It performs informed sampling within an ellipsoidal subset biased by the current best path cost to focus exploration. Adaptive step sizing reduces step length near obstacles improving success in cluttered environments. Each extension checks for collision-free nodes and edges. Dynamic rewiring locally optimizes path costs by reconnecting nodes within a fixed radius. Trees attempt early connections to quickly find feasible paths and improve solution quality. Finally, post-processing smoothing refines the path for smoothness and shorter overall length. This hybrid approach combines rapid exploration, cost optimization, and robustness against obstacles.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> \"PlannerResult\":\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        success_state = False\n        extracted_path = []\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best**2 - c_min**2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias for one tree and informed for the other\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire locally for optimization\n            rewire(tree_a, new_node)\n\n            # Attempt to connect trees\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n\n            if total_cost + 1e-6 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    success_state = True\n\n        # Path smoothing post-processing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        max_iter = 100\n        for _ in range(max_iter):\n            if len(smoothed) <= 2:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Informed Bidirectional RRT-Connect with Adaptive Step Sizing, Dynamic Rewiring, and Path Smoothing",
     "planning_mechanism": "The planner grows two trees from the start and goal positions. It performs informed sampling within an ellipsoidal subset biased by the current best path cost to focus exploration. Adaptive step sizing reduces step length near obstacles improving success in cluttered environments. Each extension checks for collision-free nodes and edges. Dynamic rewiring locally optimizes path costs by reconnecting nodes within a fixed radius. Trees attempt early connections to quickly find feasible paths and improve solution quality. Finally, post-processing smoothing refines the path for smoothness and shorter overall length. This hybrid approach combines rapid exploration, cost optimization, and robustness against obstacles.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        success_state = False\n        extracted_path = []\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best**2 - c_min**2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias for one tree and informed for the other\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire locally for optimization\n            rewire(tree_a, new_node)\n\n            # Attempt to connect trees\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n\n            if total_cost + 1e-6 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    # Remove duplicated connection node in merged path\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n\n        # Path smoothing post-processing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return {\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": all_nodes,\n            \"edges\": edges\n        }\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        max_iter = 100\n        for _ in range(max_iter):\n            if len(smoothed) <= 2:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Informed Bidirectional RRT-Connect with Adaptive Step Sizing, Dynamic Rewiring, and Path Smoothing",
     "planning_mechanism": "The planner grows two trees from the start and goal positions. It performs informed sampling within an ellipsoidal subset biased by the current best path cost to focus exploration. Adaptive step sizing reduces step length near obstacles improving success in cluttered environments. Each extension checks for collision-free nodes and edges. Dynamic rewiring locally optimizes path costs by reconnecting nodes within a fixed radius. Trees attempt early connections to quickly find feasible paths and improve solution quality. Finally, post-processing smoothing refines the path for smoothness and shorter overall length. This hybrid approach combines rapid exploration, cost optimization, and robustness against obstacles.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        success_state = False\n        extracted_path = []\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best**2 - c_min**2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias for one tree and informed for the other\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire locally for optimization\n            rewire(tree_a, new_node)\n\n            # Attempt to connect trees\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n\n            if total_cost + 1e-6 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    # Remove duplicated connection node in merged path\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n\n        # Path smoothing post-processing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        # Return PlannerResult instead of dict to match expected interface\n        # However, user constraints say to only fix error, so wrap dict in an object with attributes\n\n        class PlannerResultWrapper:\n            def __init__(self, result_dict):\n                self.success = result_dict[\"success\"]\n                self.path = result_dict[\"path\"]\n                self.nodes = result_dict[\"nodes\"]\n                self.edges = result_dict[\"edges\"]\n\n        return PlannerResultWrapper({\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": all_nodes,\n            \"edges\": edges\n        })\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        max_iter = 100\n        for _ in range(max_iter):\n            if len(smoothed) <= 2:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Informed Bidirectional RRT-Connect with Adaptive Step Sizing, Dynamic Rewiring, and Path Smoothing",
     "planning_mechanism": "The planner grows two trees from the start and goal positions. It performs informed sampling within an ellipsoidal subset biased by the current best path cost to focus exploration. Adaptive step sizing reduces step length near obstacles improving success in cluttered environments. Each extension checks for collision-free nodes and edges. Dynamic rewiring locally optimizes path costs by reconnecting nodes within a fixed radius. Trees attempt early connections to quickly find feasible paths and improve solution quality. Finally, post-processing smoothing refines the path for smoothness and shorter overall length. This hybrid approach combines rapid exploration, cost optimization, and robustness against obstacles.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> object:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        success_state = False\n        extracted_path = []\n\n        def informed_sample(c_best, c_min):\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a1)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 /= length\n\n            I = np.eye(dim)\n            M = np.outer(a1, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            r2_sq = c_best**2 - c_min**2\n            r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            while True:\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                    return tuple(x_rand)\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            unit = tuple(d / dist for d in direction)\n            return tuple(from_pos[d] + unit[d] * step for d in range(dim))\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sampling with goal bias for one tree and informed for the other\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = informed_sample(c_best, c_min)\n\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = adaptive_step(nearest_node.position, sample)\n            new_position = steer(nearest_node.position, sample, step)\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire locally for optimization\n            rewire(tree_a, new_node)\n\n            # Attempt to connect trees\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n\n            if total_cost + 1e-6 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    # Remove duplicated connection node in merged path\n                    extracted_path = path_start + path_goal[-2::-1]\n                    success_state = True\n\n        # Path smoothing post-processing\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        class PlannerResultWrapper:\n            def __init__(self, result_dict):\n                self.success = result_dict[\"success\"]\n                self.path = result_dict[\"path\"]\n                self.nodes = result_dict[\"nodes\"]\n                self.edges = result_dict[\"edges\"]\n\n        return PlannerResultWrapper({\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": all_nodes,\n            \"edges\": edges\n        })\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        import random\n        if len(path) < 3:\n            return path\n        smoothed = path[:]\n        max_iter = 100\n        for _ in range(max_iter):\n            if len(smoothed) <= 2:\n                break\n            i = random.randint(0, len(smoothed) - 3)\n            j = random.randint(i + 2, len(smoothed) - 1)\n            if not self._is_edge_in_obstacle(smoothed[i], smoothed[j], obstacles, is_3d):\n                smoothed = smoothed[:i+1] + smoothed[j:]\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This planner is a hybrid bidirectional RRT*-based algorithm that combines informed elliptical sampling, adaptive step sizing near obstacles, aggressive pruning, and rewiring to efficiently find high-quality collision-free paths. It grows two trees from start and goal, samples within an ellipsoid informed by the current best path cost, and rewires nodes locally for cost improvement. The planner prunes nodes that cannot yield better solutions, ensuring focused search and faster convergence with smooth and robust paths.",
     "planning_mechanism": "The planner alternately grows start and goal trees by sampling informed points in the ellipsoidal subset that can improve the current best path. Each expansion respects adaptive step sizes near obstacles and bounds. Rewiring connects nodes for cost improvements. When the trees connect, the best path is updated and aggressive pruning removes suboptimal branches, accelerating convergence and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(True, [start], nodes, edges)\n\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # fallback uniform random valid sample\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal edges, nodes\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                to_remove = []\n                for node in tree[1:]:  # never prune root\n                    h = math.dist(node.position, goal)\n                    if node.cost + h >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = informed_sample()\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample_point))\n\n            step = adaptive_step(nearest_node.position, sample_point)\n            new_position = steer(nearest_node.position, sample_point, step)\n\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            est_cost_total = new_cost + math.dist(new_position, goal)\n            if est_cost_total + 1e-8 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune(tree_a)\n\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost + 1e-8 < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = nearest_other.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                prune(tree_start)\n                prune(tree_goal)\n\n                if c_best <= c_min * 1.03:  # Early stop for near-optimal path\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This planner is a hybrid bidirectional RRT*-based algorithm that combines informed elliptical sampling, adaptive step sizing near obstacles, aggressive pruning, and rewiring to efficiently find high-quality collision-free paths. It grows two trees from start and goal, samples within an ellipsoid informed by the current best path cost, and rewires nodes locally for cost improvement. The planner prunes nodes that cannot yield better solutions, ensuring focused search and faster convergence with smooth and robust paths.",
     "planning_mechanism": "The planner alternately grows start and goal trees by sampling informed points in the ellipsoidal subset that can improve the current best path. Each expansion respects adaptive step sizes near obstacles and bounds. Rewiring connects nodes for cost improvements. When the trees connect, the best path is updated and aggressive pruning removes suboptimal branches, accelerating convergence and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        # Dummy placeholder for collision check with obstacles\n        # Should be replaced by actual collision check logic\n        for obs in obstacles:\n            if is_3d:\n                # Assuming obs defined by ((xmin, ymin, zmin), (xmax, ymax, zmax))\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(3)):\n                    return True\n            else:\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(2)):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Discretize edge and check each point\n        dist = math.dist(p1, p2)\n        steps = max(2, int(dist))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(True, [start], nodes, edges)\n\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        def informed_sample():\n            nonlocal c_best\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # fallback uniform random valid sample\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal edges, nodes, c_best\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                to_remove = []\n                for node in tree[1:]:  # never prune root\n                    h = math.dist(node.position, goal)\n                    if node.cost + h >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = informed_sample()\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample_point))\n\n            step = adaptive_step(nearest_node.position, sample_point)\n            new_position = steer(nearest_node.position, sample_point, step)\n\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            est_cost_total = new_cost + math.dist(new_position, goal)\n            if est_cost_total + 1e-8 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune(tree_a)\n\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost + 1e-8 < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = nearest_other.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                prune(tree_start)\n                prune(tree_goal)\n\n                if c_best <= c_min * 1.03:  # Early stop for near-optimal path\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This planner is a hybrid bidirectional RRT*-based algorithm that combines informed elliptical sampling, adaptive step sizing near obstacles, aggressive pruning, and rewiring to efficiently find high-quality collision-free paths. It grows two trees from start and goal, samples within an ellipsoid informed by the current best path cost, and rewires nodes locally for cost improvement. The planner prunes nodes that cannot yield better solutions, ensuring focused search and faster convergence with smooth and robust paths.",
     "planning_mechanism": "The planner alternately grows start and goal trees by sampling informed points in the ellipsoidal subset that can improve the current best path. Each expansion respects adaptive step sizes near obstacles and bounds. Rewiring connects nodes for cost improvements. When the trees connect, the best path is updated and aggressive pruning removes suboptimal branches, accelerating convergence and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(3)):\n                    return True\n            else:\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(2)):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        dist = math.dist(p1, p2)\n        steps = max(2, int(dist))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(True, [start], nodes, edges)\n\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        def informed_sample():\n            nonlocal c_best\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal edges, nodes, c_best\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                to_remove = []\n                for node in tree[1:]:\n                    h = math.dist(node.position, goal)\n                    if node.cost + h >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = informed_sample()\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample_point))\n\n            step = adaptive_step(nearest_node.position, sample_point)\n            new_position = steer(nearest_node.position, sample_point, step)\n\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            est_cost_total = new_cost + math.dist(new_position, goal)\n            if est_cost_total + 1e-8 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune(tree_a)\n\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost + 1e-8 < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = nearest_other.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                prune(tree_start)\n                prune(tree_goal)\n\n                if c_best <= c_min * 1.03:\n                    break\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m2",
     "algorithm_description": "This planner is a hybrid bidirectional RRT*-based algorithm that combines informed elliptical sampling, adaptive step sizing near obstacles, aggressive pruning, and rewiring to efficiently find high-quality collision-free paths. It grows two trees from start and goal, samples within an ellipsoid informed by the current best path cost, and rewires nodes locally for cost improvement. The planner prunes nodes that cannot yield better solutions, ensuring focused search and faster convergence with smooth and robust paths.",
     "planning_mechanism": "The planner alternately grows start and goal trees by sampling informed points in the ellipsoidal subset that can improve the current best path. Each expansion respects adaptive step sizes near obstacles and bounds. Rewiring connects nodes for cost improvements. When the trees connect, the best path is updated and aggressive pruning removes suboptimal branches, accelerating convergence and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, rewire_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def _is_in_obstacle(self, point, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(3)):\n                    return True\n            else:\n                if all(obs[0][d] <= point[d] <= obs[1][d] for d in range(2)):\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        dist = math.dist(p1, p2)\n        steps = max(2, int(dist))\n        for i in range(steps + 1):\n            interp = tuple(p1[d] + (p2[d] - p1[d]) * i / steps for d in range(len(p1)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def plan(self, map) -> PlannerResult:\n        import math, random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        if c_min == 0:\n            return PlannerResult(True, [start], nodes, edges)\n\n        c_best = float(\"inf\")\n        best_path = []\n        success = False\n\n        def informed_sample():\n            nonlocal c_best\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best / 2.0\n            r2 = math.sqrt(max(c_best**2 - c_min**2, 0)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            while True:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps_check for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if n != new_node and math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost + 1e-8 < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent is not None:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal edges, nodes, c_best\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                to_remove = []\n                for node in tree[1:]:\n                    h = math.dist(node.position, goal)\n                    if node.cost + h >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample_point = informed_sample()\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample_point))\n\n            step = adaptive_step(nearest_node.position, sample_point)\n            new_position = steer(nearest_node.position, sample_point, step)\n\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            est_cost_total = new_cost + math.dist(new_position, goal)\n            if est_cost_total + 1e-8 >= c_best:\n                continue\n\n            new_node = Node(new_position, parent=nearest_node, cost=new_cost)\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(tree_a, new_node)\n            prune(tree_a)\n\n            nearest_other = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if self._is_edge_in_obstacle(new_node.position, nearest_other.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + nearest_other.cost + math.dist(new_node.position, nearest_other.position)\n            if connect_cost + 1e-8 < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = nearest_other.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                prune(tree_start)\n                prune(tree_goal)\n\n                if c_best <= c_min * 1.03:\n                    break\n\n        return {\n            \"success\": success,\n            \"path\": best_path,\n            \"nodes\": nodes,\n            \"edges\": edges\n        }",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
