{
     "operator": "e1",
     "algorithm_description": "An Efficient Guided Batch Informed Sampling Planner (EGBISP) combining batch processing, informed sampling, and dynamic adaptive parameters. It grows a single tree by sampling in batches biased towards informed subsets after initial solutions, uses dynamic step size and neighbor radius adapted per batch based on improvement, applies lazy collision checking with early pruning, and performs inter-batch local rewiring and path smoothing. This planner aims to improve convergence speed, path quality, and robustness, while reducing computation time by leveraging batch expansions and focused sampling.",
     "planning_mechanism": "EGBISP",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position          # Tuple[float, ...]\n        self.parent = parent              # Node or None\n        self.cost = cost                  # Path cost from start\n        self.children = []                # List[Node]\n        self.valid = True                 # For collision checking etc.\n\n    def distance(self, other_pos) -> float:\n        return math.dist(self.position, other_pos)\n\n    def path_to_root(self) -> list:\n        node = self\n        path = []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, batch_size: int = 20, step_size_max: float = 3.0, step_size_min: float = 0.5,\n                 neighbor_radius_max: float = 7.0, neighbor_radius_min: float = 2.0, smoothing_interval: int = 10):\n        self.max_iter = max_iter\n        self.batch_size = batch_size\n        self.step_size_max = step_size_max\n        self.step_size_min = step_size_min\n        self.neighbor_radius_max = neighbor_radius_max\n        self.neighbor_radius_min = neighbor_radius_min\n        self.smoothing_interval = smoothing_interval\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        nodes = []\n        edges = []\n        success_state = False\n        extracted_path = []\n\n        start_node = Node(start_position)\n        nodes.append(start_node)\n\n        c_best = float('inf')      # Best path cost found\n        last_improvement_iter = 0  # Iteration of last c_best improvement\n\n        def adaptive_params(iteration):\n            # Adapt parameters based on progress since last improvement\n            progress = (iteration - last_improvement_iter) / max(1, self.max_iter)\n            step = max(self.step_size_min, self.step_size_max * (1 - progress))\n            radius = max(self.neighbor_radius_min, self.neighbor_radius_max * (1 - progress))\n            return step, radius\n\n        def sample_uniform():\n            return tuple(random.uniform(0, b) for b in bounds)\n\n        def sample_informed():\n            c_min = math.dist(start_position, goal_position)\n            if c_min == 0 or c_best == float('inf'):\n                return sample_uniform()\n\n            center = tuple((s + g) / 2 for s, g in zip(start_position, goal_position))\n            direction = tuple(g - s for s, g in zip(start_position, goal_position))\n            length = math.dist(start_position, goal_position)\n            if length == 0:\n                return sample_uniform()\n\n            unit_dir = tuple(d / length for d in direction)\n            a = c_best / 2\n            if dim == 2:\n                b = math.sqrt(max(a*a - (c_min*c_min)/4, 0.0))\n                while True:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        break\n                sample_ellipse = (a * x, b * y)\n                cos_theta, sin_theta = unit_dir[0], unit_dir[1]\n                sample_rotated = (cos_theta * sample_ellipse[0] - sin_theta * sample_ellipse[1],\n                                  sin_theta * sample_ellipse[0] + cos_theta * sample_ellipse[1])\n                sample_point = tuple(center[i] + sample_rotated[i] for i in range(2))\n                return self._clip_to_bounds(sample_point, bounds)\n            else:\n                b = math.sqrt(max(a*a - (c_min*c_min)/4, 0.0))\n                while True:\n                    x, y, z = random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y + z*z <= 1:\n                        break\n                sample_unit = (a * x, b * y, b * z)\n\n                def orthonormal_basis(v):\n                    if abs(v[0]) < abs(v[1]):\n                        inv_len = 1.0 / math.sqrt(v[1]*v[1] + v[2]*v[2]) if (v[1]*v[1] + v[2]*v[2])>0 else 1\n                        u1 = (0.0, -v[2]*inv_len, v[1]*inv_len)\n                    else:\n                        inv_len = 1.0 / math.sqrt(v[0]*v[0] + v[2]*v[2]) if (v[0]*v[0] + v[2]*v[2])>0 else 1\n                        u1 = (-v[2]*inv_len, 0.0, v[0]*inv_len)\n                    u2 = (\n                        v[1]*u1[2] - v[2]*u1[1],\n                        v[2]*u1[0] - v[0]*u1[2],\n                        v[0]*u1[1] - v[1]*u1[0]\n                    )\n                    return u1, u2\n\n                u1, u2 = orthonormal_basis(unit_dir)\n                rotated = (\n                    unit_dir[0]*sample_unit[0] + u1[0]*sample_unit[1] + u2[0]*sample_unit[2],\n                    unit_dir[1]*sample_unit[0] + u1[1]*sample_unit[1] + u2[1]*sample_unit[2],\n                    unit_dir[2]*sample_unit[0] + u1[2]*sample_unit[1] + u2[2]*sample_unit[2]\n                )\n                sample_point = tuple(center[i] + rotated[i] for i in range(3))\n                return self._clip_to_bounds(sample_point, bounds)\n\n        def sample_point(iteration):\n            # After first solution, sample inside ellipsoid with 85% probability, else uniform\n            if c_best < float('inf'):\n                if random.random() < 0.85:\n                    return sample_informed()\n            return sample_uniform()\n\n        def _clip_to_bounds(sample, bounds):\n            return tuple(max(0, min(s, b)) for s,b in zip(sample,bounds))\n\n        def nearest_node(nodes_list, point):\n            return min(nodes_list, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step):\n            vec = tuple(t - f for f, t in zip(from_pos, to_pos))\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(f + ratio * (t - f) for f, t in zip(from_pos, to_pos))\n\n        def collision_check(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(int(dist / 0.5), 1)\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(dim))\n                for obs in obstacles:\n                    if is_3d:\n                        x, y, z, w, h, d = obs\n                        px, py, pz = interp\n                        if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                            return True\n                    else:\n                        x, y, w, h = obs\n                        px, py = interp\n                        if x <= px <= x + w and y <= py <= y + h:\n                            return True\n            return False\n\n        def find_near(nodes_list, new_node_pos, radius):\n            radius_sq = radius * radius\n            result = []\n            if dim == 2:\n                nx, ny = new_node_pos[0], new_node_pos[1]\n                for n in nodes_list:\n                    dx = n.position[0] - nx\n                    dy = n.position[1] - ny\n                    if dx*dx + dy*dy <= radius_sq:\n                        result.append(n)\n            else:\n                nx, ny, nz = new_node_pos\n                for n in nodes_list:\n                    dx = n.position[0] - nx\n                    dy = n.position[1] - ny\n                    dz = n.position[2] - nz\n                    if dx*dx + dy*dy + dz*dz <= radius_sq:\n                        result.append(n)\n            return result\n\n        def local_rewire(new_nodes, neighbor_radius):\n            # Rewire nodes inside the current batch for cost improvement\n            for node in new_nodes:\n                neighbors = find_near(new_nodes + nodes, node.position, neighbor_radius)\n                for neighbor in neighbors:\n                    if neighbor == node or neighbor.parent == node:\n                        continue\n                    cost_to_neighbor = node.cost + node.distance(neighbor.position)\n                    if cost_to_neighbor + 1e-9 < neighbor.cost and not collision_check(node.position, neighbor.position):\n                        if neighbor.parent:\n                            neighbor.parent.children.remove(neighbor)\n                        neighbor.parent = node\n                        neighbor.cost = cost_to_neighbor\n                        node.children.append(neighbor)\n\n        def shortcut_smooth(path):\n            if len(path) <= 2:\n                return path\n            smoothed_path = [path[0]]\n            i = 0\n            while i < len(path) - 1:\n                j = len(path) - 1\n                while j > i + 1:\n                    if not collision_check(path[i], path[j]):\n                        break\n                    j -= 1\n                smoothed_path.append(path[j])\n                i = j\n            return smoothed_path\n\n        iteration = 0\n        while iteration < self.max_iter:\n            step_size, neighbor_radius = adaptive_params(iteration)\n\n            batch_samples = [sample_point(iteration) for _ in range(self.batch_size)]\n            batch_new_nodes = []\n\n            for sample_pt in batch_samples:\n                nearest = nearest_node(nodes, sample_pt)\n                new_pos = steer(nearest.position, sample_pt, step_size)\n                if collision_check(nearest.position, new_pos):\n                    continue\n\n                # Select best parent from near nodes (including nearest)\n                near_nodes = find_near(nodes, new_pos, neighbor_radius)\n                min_cost = nearest.cost + nearest.distance(new_pos)\n                min_parent = nearest\n                for near in near_nodes:\n                    if near == nearest:\n                        continue\n                    cost = near.cost + near.distance(new_pos)\n                    if cost + 1e-9 < min_cost and not collision_check(near.position, new_pos):\n                        min_cost = cost\n                        min_parent = near\n\n                new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n                min_parent.children.append(new_node)\n                nodes.append(new_node)\n                edges.append((min_parent, new_node))\n                batch_new_nodes.append(new_node)\n\n                # If close enough to goal and can connect with no collision\n                dist_to_goal = new_node.distance(goal_position)\n                if dist_to_goal <= step_size and not collision_check(new_node.position, goal_position):\n                    goal_node = Node(goal_position, parent=new_node, cost=new_node.cost + dist_to_goal)\n                    new_node.children.append(goal_node)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n\n                    if goal_node.cost < c_best:\n                        c_best = goal_node.cost\n                        success_state = True\n                        extracted_path = goal_node.path_to_root()\n                        last_improvement_iter = iteration\n\n            # Local rewiring within expanded batch + existing nodes\n            if batch_new_nodes:\n                local_rewire(batch_new_nodes, neighbor_radius)\n\n            # Periodically smooth path if found\n            if success_state and iteration % self.smoothing_interval == 0 and extracted_path:\n                extracted_path = shortcut_smooth(extracted_path)\n\n                # Early termination: path cost close to minimum possible\n                c_min = math.dist(start_position, goal_position)\n                if c_best <= 1.03 * c_min:\n                    break\n\n            iteration += 1\n\n        if success_state and not extracted_path:\n            # Fallback: extract best path from goal node if available\n            goal_nodes = [n for n in nodes if n.position == goal_position]\n            if goal_nodes:\n                best_goal_node = min(goal_nodes, key=lambda n: n.cost)\n                extracted_path = best_goal_node.path_to_root()\n                extracted_path = shortcut_smooth(extracted_path)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "A combined and optimized path planner that integrates bidirectional RRT* with goal biasing, adaptive rewiring, dynamic step size adjustment, and enhanced path smoothing using shortcutting. This planner balances exploration and exploitation by growing two trees from start and goal, rewiring to improve path costs, connecting trees efficiently, and applying post-processing smoothing to yield higher quality, smoother, and shorter paths with better success and reduced planning time. (Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.)",
     "planning_mechanism": "Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_init: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> 'PlannerResult':\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            # Alternate goal bias location with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=15):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(n1, n2):\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_smooth(path, iterations=30):\n            # Attempt shortcut smoothing by skipping intermediate points if direct path is obstacle free\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if j >= len(smoothed):\n                    continue\n                if not is_edge_in_obstacle(smoothed[i], smoothed[j]):\n                    # Remove intermediate points between i and j\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        step_size = self.step_size_init\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate extension between the two trees\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample, step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node, cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n\n                success_state = True\n\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes_all = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes_all = tree_goal + tree_start\n\n                # Apply shortcut smoothing for improved path smoothness and length\n                path = shortcut_smooth(path, iterations=50)\n\n                edges = [(node.parent, node) for node in nodes_all if node.parent]\n                extracted_path = path\n                break\n\n            # Optional dynamic step size adaptation (gradually increase up to max)\n            if iter_count % 500 == 0 and iter_count > 0:\n                step_size = min(step_size * 1.1, self.step_size_init * 3)\n\n        if not success_state:\n            nodes_all = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes_all if node.parent]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes_all,\n            edges=edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "A combined and optimized path planner that integrates bidirectional RRT* with goal biasing, adaptive rewiring, dynamic step size adjustment, and enhanced path smoothing using shortcutting. This planner balances exploration and exploitation by growing two trees from start and goal, rewiring to improve path costs, connecting trees efficiently, and applying post-processing smoothing to yield higher quality, smoother, and shorter paths with better success and reduced planning time. (Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.)",
     "planning_mechanism": "Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_init: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> dict:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            # Alternate goal bias location with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=15):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(n1, n2):\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_smooth(path, iterations=30):\n            # Attempt shortcut smoothing by skipping intermediate points if direct path is obstacle free\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if j >= len(smoothed):\n                    continue\n                if not is_edge_in_obstacle(smoothed[i], smoothed[j]):\n                    # Remove intermediate points between i and j\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        step_size = self.step_size_init\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate extension between the two trees\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample, step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node, cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n\n                success_state = True\n\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes_all = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes_all = tree_goal + tree_start\n\n                # Apply shortcut smoothing for improved path smoothness and length\n                path = shortcut_smooth(path, iterations=50)\n\n                edges = [(node.parent, node) for node in nodes_all if node.parent]\n                extracted_path = path\n                break\n\n            # Optional dynamic step size adaptation (gradually increase up to max)\n            if iter_count % 500 == 0 and iter_count > 0:\n                step_size = min(step_size * 1.1, self.step_size_init * 3)\n\n        if not success_state:\n            nodes_all = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes_all if node.parent]\n\n        return {\n            \"success\": success_state,\n            \"path\": extracted_path,\n            \"nodes\": nodes_all,\n            \"edges\": edges\n        }",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "A combined and optimized path planner that integrates bidirectional RRT* with goal biasing, adaptive rewiring, dynamic step size adjustment, and enhanced path smoothing using shortcutting. This planner balances exploration and exploitation by growing two trees from start and goal, rewiring to improve path costs, connecting trees efficiently, and applying post-processing smoothing to yield higher quality, smoother, and shorter paths with better success and reduced planning time. (Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.)",
     "planning_mechanism": "Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_init: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> dict:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            # Alternate goal bias location with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=15):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(n1, n2):\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_smooth(path, iterations=30):\n            # Attempt shortcut smoothing by skipping intermediate points if direct path is obstacle free\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if j >= len(smoothed):\n                    continue\n                if not is_edge_in_obstacle(smoothed[i], smoothed[j]):\n                    # Remove intermediate points between i and j\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        step_size = self.step_size_init\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate extension between the two trees\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample, step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node, cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n\n                success_state = True\n\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes_all = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes_all = tree_goal + tree_start\n\n                # Apply shortcut smoothing for improved path smoothness and length\n                path = shortcut_smooth(path, iterations=50)\n\n                edges = [(node.parent, node) for node in nodes_all if node.parent]\n                extracted_path = path\n                break\n\n            # Optional dynamic step size adaptation (gradually increase up to max)\n            if iter_count % 500 == 0 and iter_count > 0:\n                step_size = min(step_size * 1.1, self.step_size_init * 3)\n\n        if not success_state:\n            nodes_all = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes_all if node.parent]\n\n        class PlanResult:\n            def __init__(self, success, path, nodes, edges):\n                self.success = success\n                self.path = path\n                self.nodes = nodes\n                self.edges = edges\n\n        return PlanResult(\n            success_state,\n            extracted_path,\n            nodes_all,\n            edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
{
     "operator": "m1",
     "algorithm_description": "A combined and optimized path planner that integrates bidirectional RRT* with goal biasing, adaptive rewiring, dynamic step size adjustment, and enhanced path smoothing using shortcutting. This planner balances exploration and exploitation by growing two trees from start and goal, rewiring to improve path costs, connecting trees efficiently, and applying post-processing smoothing to yield higher quality, smoother, and shorter paths with better success and reduced planning time. (Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.)",
     "planning_mechanism": "Initialization of two bidirectional trees from start and goal positions; adaptive sampling with goal bias; nearest neighbor search and dynamic steering with collision checks; rewiring neighbors within a radius for asymptotic optimality; attempts to connect the two trees when close; upon successful connection, extracts and improves the path via shortcut smoothing; iterative process halts when a path is found or max iterations reached.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def distance(self, other: 'Node') -> float:\n        return math.dist(self.position, other.position)\n\n    def path_from_root(self) -> list:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size_init: float = 1.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size_init = step_size_init\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map: 'Map') -> object:\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = 3 if is_3d else 2\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n\n        def sample_point():\n            # Alternate goal bias location with probability\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            return tuple(random.uniform(0, bounds[i]) for i in range(dim))\n\n        def nearest_node(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos, step_size):\n            vec = [t - f for f, t in zip(from_pos, to_pos)]\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step_size:\n                return to_pos\n            scale = step_size / dist\n            return tuple(f + scale * d for f, d in zip(from_pos, vec))\n\n        def is_in_obstacle(pos):\n            for obs in obstacles:\n                if is_3d:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n                else:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n            return False\n\n        def is_edge_in_obstacle(from_pos, to_pos, steps=15):\n            for i in range(steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d]-from_pos[d]) * i / steps for d in range(dim))\n                if is_in_obstacle(interp):\n                    return True\n            return False\n\n        def find_neighbors(tree, pos):\n            return [node for node in tree if math.dist(node.position, pos) <= self.neighbor_radius]\n\n        def try_connect(n1, n2):\n            if is_edge_in_obstacle(n1.position, n2.position):\n                return False\n            return True\n\n        def rewire(tree, new_node, neighbors):\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost < neighbor.cost and not is_edge_in_obstacle(new_node.position, neighbor.position):\n                    # Rewire neighbor to new_node\n                    if neighbor.parent:\n                        try:\n                            neighbor.parent.children.remove(neighbor)\n                        except ValueError:\n                            pass\n                    neighbor.parent = new_node\n                    neighbor.cost = potential_cost\n                    new_node.children.append(neighbor)\n\n        def reconstruct_full_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            if path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            else:\n                return path_start + path_goal\n\n        def shortcut_smooth(path, iterations=30):\n            # Attempt shortcut smoothing by skipping intermediate points if direct path is obstacle free\n            if len(path) <= 2:\n                return path\n            smoothed = path[:]\n            for _ in range(iterations):\n                if len(smoothed) <= 2:\n                    break\n                i = random.randint(0, len(smoothed) - 2)\n                j = random.randint(i + 2, len(smoothed) - 1)\n                if j >= len(smoothed):\n                    continue\n                if not is_edge_in_obstacle(smoothed[i], smoothed[j]):\n                    # Remove intermediate points between i and j\n                    smoothed = smoothed[:i+1] + smoothed[j:]\n            return smoothed\n\n        success_state = False\n        extracted_path = []\n        edges = []\n\n        step_size = self.step_size_init\n\n        for iter_count in range(self.max_iter):\n            sample = sample_point()\n\n            # Alternate extension between the two trees\n            tree_from, tree_to = (tree_start, tree_goal) if iter_count % 2 == 0 else (tree_goal, tree_start)\n\n            nearest = nearest_node(tree_from, sample)\n            new_pos = steer(nearest.position, sample, step_size)\n            if is_in_obstacle(new_pos) or is_edge_in_obstacle(nearest.position, new_pos):\n                continue\n\n            new_node = Node(new_pos)\n            neighbors = find_neighbors(tree_from, new_pos)\n\n            best_parent = nearest\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            for neighbor in neighbors:\n                temp_cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if temp_cost < min_cost and not is_edge_in_obstacle(neighbor.position, new_pos):\n                    best_parent = neighbor\n                    min_cost = temp_cost\n\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree_from.append(new_node)\n\n            rewire(tree_from, new_node, neighbors)\n\n            # Attempt to connect to opposite tree\n            nearest_to = nearest_node(tree_to, new_node.position)\n            dist_to = math.dist(new_node.position, nearest_to.position)\n            if dist_to <= step_size and try_connect(new_node, nearest_to):\n                # Connect trees\n                connect_node = Node(nearest_to.position, parent=new_node, cost=new_node.cost + dist_to)\n                new_node.children.append(connect_node)\n                tree_from.append(connect_node)\n\n                success_state = True\n\n                if tree_from is tree_start:\n                    path = reconstruct_full_path(connect_node, nearest_to)\n                    nodes_all = tree_start + tree_goal\n                else:\n                    path = reconstruct_full_path(nearest_to, connect_node)\n                    nodes_all = tree_goal + tree_start\n\n                # Apply shortcut smoothing for improved path smoothness and length\n                path = shortcut_smooth(path, iterations=50)\n\n                edges = [(node.parent, node) for node in nodes_all if node.parent]\n                extracted_path = path\n                break\n\n            # Optional dynamic step size adaptation (gradually increase up to max)\n            if iter_count % 500 == 0 and iter_count > 0:\n                step_size = min(step_size * 1.1, self.step_size_init * 3)\n\n        if not success_state:\n            nodes_all = tree_start + tree_goal\n            edges = [(node.parent, node) for node in nodes_all if node.parent]\n\n        class PlanResult:\n            def __init__(self, success, path, nodes, edges):\n                self.success = success\n                self.path = path\n                self.nodes = nodes\n                self.edges = edges\n\n        return PlanResult(\n            success_state,\n            extracted_path,\n            nodes_all,\n            edges\n        )",
     "objective": null,
     "other_inf": {
          "Traceback": "Traceback (most recent call last):\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 99, in evaluate\n    fitness, results = self.__evaluate_path(planning_module)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\run.py\", line 69, in __evaluate_path\n    result, avg_result = self.benchmarker.run(planner.plan)\n  File \"c:\\workspace\\eoh_path_planning\\eoh\\src\\eoh\\problems\\optimization\\classic_benchmark_path_planning\\utils\\benchmark.py\", line 37, in run\n    path = output.path\nAttributeError: 'dict' object has no attribute 'path'\n"
     }
}
