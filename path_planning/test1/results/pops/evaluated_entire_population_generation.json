[{"map_id": 0, "success_rate": 1.0, "time_avg": 0.009652423858642577, "num_nodes_avg": 111.8, "path_length_avg": 200.0838797630454}, {"map_id": 1, "success_rate": 1.0, "time_avg": 0.014416956901550293, "num_nodes_avg": 226.8, "path_length_avg": 301.3556500440429}, {"map_id": 2, "success_rate": 1.0, "time_avg": 0.02934415340423584, "num_nodes_avg": 341.7, "path_length_avg": 162.85047186078538}]
{
     "operator": "e2",
     "algorithm_description": "The hybrid planner combines the asymptotic optimality and bidirectional growth of BI-RRT* with the informed sampling, adaptive step sizing, node rejection, and pruning strategies from Improved RRT*-Connect. By integrating heuristic elliptical sampling for focused exploration, adaptive step adjustments near obstacles to maintain collision safety, and rewiring for cost optimization, it robustly searches the free space. The planner simultaneously grows two trees from start and goal, alternates sampling from an informed set when possible to improve convergence speed, aggressively prunes suboptimal branches, and attempts to connect the trees for fast discovery of high-quality paths.",
     "planning_mechanism": "The planner performs bidirectional RRT*-style growth with informed heuristic sampling within the current best path cost ellipse. Each expansion adapts step size based on nearby obstacles, rejects nodes that cannot improve the solution, and rewires neighbors for cost efficiency. When trees connect successfully, the best path is updated. The alternating growth of start and goal trees plus pruning accelerates search and enhances path quality and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_a = [Node(start)]\n        tree_b = [Node(goal)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        if c_min == 0:  # Start == Goal\n            return PlannerResult(True, [start], nodes, edges)\n\n        def informed_sample():\n            if c_best == float(\"inf\"):\n                while True:\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n            # Informed sampling inside an ellipsoid defined by start, goal, c_best, and c_min\n            x_center = np.array([(s + g) / 2.0 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 < 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(max(0.0, c_best**2 - c_min**2)) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ L @ (x_ball * scale) + x_center\n                candidate = tuple(np.clip(x_rand, [0]*dim, np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.3, 1.0)\n            return self.base_step\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            # Prune nodes where cost + heuristic exceeds current best path cost\n            nonlocal edges, nodes\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # Never prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            main_tree, other_tree = (tree_a, tree_b) if i % 2 == 0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal)\n            if est_total_cost >= c_best:\n                # Prune by ignoring expansion that cannot improve best path\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            # Attempt to connect new_node to the other tree\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connect_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connect_cost < c_best:\n                c_best = connect_cost\n                path_a = new_node.path_from_root()\n                path_b = other_nearest.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n\n                # Aggressively prune both trees by c_best\n                prune(tree_a)\n                prune(tree_b)\n\n                # Early exit if solution is good enough (optional)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 31258.82349,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 5.141939425468445,
               "num_nodes_avg": 2306.4,
               "path_length_avg": 154.2503621041932,
               "success_improvement": 0.0,
               "time_improvement": -53170.965933229934,
               "length_improvement": 22.90715159718602,
               "objective_score": -15946.708349649543
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 4.733148503303528,
               "num_nodes_avg": 2789.4,
               "path_length_avg": 259.2117263996173,
               "success_improvement": 0.0,
               "time_improvement": -32730.42694533241,
               "length_improvement": 13.984779657612615,
               "objective_score": -9816.3311276682
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 5.410043072700501,
               "num_nodes_avg": 2536.3,
               "path_length_avg": 120.71782418764846,
               "success_improvement": 0.0,
               "time_improvement": -18336.528047592466,
               "length_improvement": 25.87198378470435,
               "objective_score": -5495.784017520798
          }
     ]
}
{
     "operator": "m2",
     "algorithm_description": "This algorithm is an optimized version of RRT*, specifically tuned for improved planning efficiency, path quality, robustness, success rate, and path smoothness by adjusting parameters such as step size, goal bias, and neighbor radius. It incrementally builds and rewires a tree rooted at the start position, always performing collision and obstacle intersection checks, while ensuring samples remain within bounds.",
     "planning_mechanism": "The planner samples points with an adaptive goal bias, finds the nearest node, steers toward the sample with a carefully chosen step size, selects the lowest-cost parent among neighbors within an adaptively tuned radius, and rewires neighbors to improve the path iteratively. The process terminates upon reaching the goal or exhausting iterations, returning a smooth, optimized path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 4.0, goal_sample_rate: float = 0.1, neighbor_radius: float = 12.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                   # Tuple[int, ...]\n        dim = len(bounds)\n        start_position = map.start          # Tuple[float, ...]\n        goal_position = map.goal            # Tuple[float, ...]\n        obstacles = map.obstacles           # List of obstacle descriptions\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        for i in range(self.max_iter):\n            # Goal biasing with increased rate to accelerate goal reaching\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Compute direction and Limit step_size\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            length = min(self.step_size, dist)\n            unit_dir = tuple(d / dist for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit_dir[d] * length for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n            # Collision checks\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n\n            # Find neighbors according to adaptive radius reduced over time (improves efficiency)\n            radius = self.neighbor_radius * (1.0 - i / self.max_iter) + 3.0\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= radius]\n\n            # Choose best parent minimizing cost\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + math.dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors for path quality improvement\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Goal check with improved step size tolerance and obstacle checks\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size * 1.2:\n                if not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    break\n\n        if success_state:\n            path = []\n            node = nodes[-1]\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n            # Optional: Path smoothing using shortcut heuristic\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        max_trials = 100\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            # Check if direct edge is collision free\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d):\n                # Remove intermediate points between i and j\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": 2116.54822,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.25391206741333006,
               "num_nodes_avg": 414.8,
               "path_length_avg": 166.86145382751903,
               "success_improvement": 0.0,
               "time_improvement": -2530.5523993953348,
               "length_improvement": 16.604249165335506,
               "objective_score": -755.8448699855334
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.5644539594650269,
               "num_nodes_avg": 1141.2,
               "path_length_avg": 221.74677084348986,
               "success_improvement": 0.0,
               "time_improvement": -3815.2087595151906,
               "length_improvement": 26.416919406992452,
               "objective_score": -1139.2792439731586
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.25168962478637696,
               "num_nodes_avg": 672.5,
               "path_length_avg": 114.88430352297128,
               "success_improvement": 0.0,
               "time_improvement": -757.7164292974472,
               "length_improvement": 29.454116890013392,
               "objective_score": -221.4241054112315
          }
     ]
}
{
     "operator": "e1",
     "algorithm_description": "The algorithm is an improved Bidirectional Informed RRT* (Inverse RRT*) planner that combines the efficiency of bidirectional search with heuristic-guided sampling to focus exploration within an informed ellipsoidal subset of the configuration space. It incrementally rewires the tree to improve path quality and shortens the path length by considering optimal parent choices for each new node. Obstacles are rigorously checked to ensure collision-free nodes and edges. This enhances planning efficiency, success rate, and path smoothness.",
     "planning_mechanism": "The planner simultaneously grows two trees rooted at the start and goal positions, biased by heuristic sampling within an ellipsoidal informed subset defined by the current best solution cost. Each extension step involves connecting the trees by extending one tree toward a sampled informed point, then extending the other tree toward the new node. The planner rewires locally for path optimality and terminates early upon a successful connection, extracting the smoothest available path.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius  # radius for rewiring neighborhood\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        start_tree = [Node(start_position, None, 0.0)]\n        goal_tree = [Node(goal_position, None, 0.0)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        best_cost = float(\"inf\")\n        best_path = []\n        success_state = False\n\n        def distance(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            dist = distance(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            ratio = step / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(dim))\n\n        def path_cost(node):\n            c = 0.0\n            while node.parent is not None:\n                c += distance(node.position, node.parent.position)\n                node = node.parent\n            return c\n\n        def backtrace_path(node):\n            path = []\n            while node:\n                path.append(node.position)\n                node = node.parent\n            return path[::-1]\n\n        def informed_sample(c_best):\n            \"\"\"Upper bound c_best defines an ellipsoidal region to bias sampling.\"\"\"\n            if not math.isfinite(c_best):\n                # No solution yet, sample uniformly\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Compute unit vector in direction start->goal\n            c_min = distance(start_position, goal_position)\n            if c_min == 0:\n                return start_position  # trivial\n\n            center = tuple((start_position[i] + goal_position[i]) / 2.0 for i in range(dim))\n\n            # Alignment unit vector (a1)\n            a1 = tuple((goal_position[i] - start_position[i]) / c_min for i in range(dim))\n\n            # Create orthonormal basis using Gram-Schmidt\n            # Only needed for dim=2 or 3, simple case:\n\n            import numpy as np\n\n            if dim == 2:\n                # In 2D, a1_perp is perpendicular to a1:\n                a1_perp = (-a1[1], a1[0])\n                basis = np.array([a1, a1_perp])\n            elif dim == 3:\n                a1_np = np.array(a1)\n                # Arbitrary vector not parallel to a1_np\n                if abs(a1_np[0]) < 0.9:\n                    v = np.array([1, 0, 0])\n                else:\n                    v = np.array([0, 1, 0])\n                a2 = v - (np.dot(v, a1_np)) * a1_np\n                a2 /= np.linalg.norm(a2)\n                a3 = np.cross(a1_np, a2)\n                basis = np.vstack((a1_np, a2, a3))\n            else:\n                # fallback: uniform sample\n                if is_3d:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(3))\n                else:\n                    return tuple(random.uniform(0, bounds[i]) for i in range(2))\n\n            # Radii of the ellipsoid along each axis:\n            r1 = c_best / 2.0\n            r_other = math.sqrt(c_best**2 - c_min**2) / 2.0 if c_best > c_min else 0.0\n            radii = [r1] + [r_other] * (dim - 1)\n\n            # Sample random point in unit ball\n            while True:\n                # Sample point in unit ball for given dim\n                if dim == 2:\n                    x, y = random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y <= 1:\n                        rnd_ball = np.array([x, y])\n                        break\n                else:\n                    x, y, z = random.uniform(-1,1), random.uniform(-1,1), random.uniform(-1,1)\n                    if x*x + y*y + z*z <= 1:\n                        rnd_ball = np.array([x, y, z])\n                        break\n\n            # Stretch point along ellipsoid axes:\n            rnd_diagonal = np.diag(radii)\n            scaled = rnd_diagonal @ rnd_ball\n\n            # Transform back to world frame:\n            sample_np = basis.T @ scaled + np.array(center)\n\n            sample = tuple(float(sample_np[i]) for i in range(dim))\n\n            # Clamp sample inside bounds:\n            clamped = tuple(\n                max(0.0, min(sample[i], bounds[i])) for i in range(dim)\n            )\n            return clamped\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: distance(n.position, point))\n\n        def near(tree, point, radius):\n            return [n for n in tree if distance(n.position, point) <= radius]\n\n        def collision_free(pos):\n            if self._is_in_obstacle(pos, obstacles, is_3d):\n                return False\n            if not all(0 <= pos[i] <= bounds[i] for i in range(dim)):\n                return False\n            return True\n\n        def collision_free_edge(from_p, to_p):\n            return not self._is_edge_in_obstacle(from_p, to_p, obstacles, is_3d)\n\n        def try_extend(tree_a, tree_b, sample, best_cost_local):\n            nearest_node = nearest(tree_a, sample)\n            new_pos = steer(nearest_node.position, sample, self.step_size)\n\n            if not collision_free(new_pos):\n                return None\n\n            if not collision_free_edge(nearest_node.position, new_pos):\n                return None\n\n            # Choose parent with minimal cost in neighbor radius (rewiring prep)\n            neighbors = near(tree_a, new_pos, self.neighbor_radius)\n            min_cost = nearest_node.cost + distance(nearest_node.position, new_pos)\n            min_parent = nearest_node\n\n            for nb in neighbors:\n                if collision_free_edge(nb.position, new_pos):\n                    cost_through_nb = nb.cost + distance(nb.position, new_pos)\n                    if cost_through_nb < min_cost:\n                        min_cost = cost_through_nb\n                        min_parent = nb\n\n            new_node = Node(new_pos, parent=min_parent, cost=min_cost)\n            min_parent.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((min_parent, new_node))\n\n            # Rewiring neighbors to new_node if beneficial\n            for nb in neighbors:\n                if nb is min_parent:\n                    continue\n                cost_through_new = new_node.cost + distance(new_node.position, nb.position)\n                if cost_through_new < nb.cost and collision_free_edge(new_node.position, nb.position):\n                    # Rewire\n                    if nb.parent:\n                        nb.parent.remove_child(nb)\n                    nb.parent = new_node\n                    nb.cost = cost_through_new\n                    new_node.add_child(nb)\n                    # edges update\n                    # Remove old edge and add new edge\n                    try:\n                        edges.remove((nb.parent, nb))\n                    except Exception:\n                        pass\n                    edges.append((new_node, nb))\n\n            # Try to connect tree_b to new_node directly\n            connect_node = nearest(tree_b, new_node.position)\n            if distance(connect_node.position, new_node.position) <= self.step_size:\n                if collision_free_edge(connect_node.position, new_node.position):\n                    # Connect by making connect_node the parent of new_node or vice versa\n                    # Choose direction to minimize cost path\n                    connect_cost = connect_node.cost + distance(connect_node.position, new_node.position)\n                    new_cost = new_node.cost + distance(new_node.position, connect_node.position)\n\n                    if connect_cost < new_cost:\n                        # connect_node -> new_node\n                        new_node.parent.remove_child(new_node)\n                        new_node.parent = connect_node\n                        new_node.cost = connect_cost\n                        connect_node.add_child(new_node)\n                    else:\n                        # new_node -> connect_node\n                        if connect_node.parent:\n                            connect_node.parent.remove_child(connect_node)\n                        connect_node.parent = new_node\n                        connect_node.cost = new_cost\n                        new_node.add_child(connect_node)\n\n                    # Update nodes and edges accordingly\n                    # Remove old edges involving connect_node parent if rewired above\n                    edges.append((new_node, connect_node) if connect_cost > new_cost else (connect_node, new_node))\n                    return new_node, connect_node\n\n            else:\n                # Attempt incremental connection from connect_node to new_node\n                current = connect_node\n                last = None\n                while distance(current.position, new_node.position) > self.step_size:\n                    new_p = steer(current.position, new_node.position, self.step_size)\n                    if not collision_free(new_p) or not collision_free_edge(current.position, new_p):\n                        break\n                    intermediate = Node(new_p, parent=current, cost=current.cost + distance(current.position, new_p))\n                    current.add_child(intermediate)\n                    tree_b.append(intermediate)\n                    nodes.append(intermediate)\n                    edges.append((current, intermediate))\n\n                    last = current\n                    current = intermediate\n                else:\n                    # Final connect\n                    if collision_free_edge(current.position, new_node.position):\n                        if current.parent:\n                            current.parent.remove_child(current)\n                        current.parent = new_node\n                        current.cost = new_node.cost + distance(new_node.position, current.position)\n                        new_node.add_child(current)\n                        edges.append((new_node, current))\n                        return new_node, current\n\n            return None\n\n        c_best = float(\"inf\")\n\n        for itr in range(self.max_iter):\n            s = informed_sample(c_best)\n\n            # Extend start_tree towards sample\n            result = try_extend(start_tree, goal_tree, s, c_best)\n            if result:\n                n_start, n_goal = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Extend goal_tree towards sample\n            result = try_extend(goal_tree, start_tree, s, c_best)\n            if result:\n                n_goal, n_start = result\n                path_start = backtrace_path(n_start)\n                path_goal = backtrace_path(n_goal)\n                candidate_path = path_start[:-1] + path_goal[::-1]\n                candidate_cost = 0.0\n                for i in range(len(candidate_path) - 1):\n                    candidate_cost += distance(candidate_path[i], candidate_path[i+1])\n\n                if candidate_cost < c_best:\n                    c_best = candidate_cost\n                    best_path = candidate_path\n                    success_state = True\n\n            # Early termination if path found with cost close to direct distance:\n            if success_state and c_best <= distance(start_position, goal_position) * 1.01:\n                break\n\n        extracted_path = best_path if success_state else []\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges,\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 71244.98359,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.08393318653106689,
               "num_nodes_avg": 139.9,
               "path_length_avg": 113.65247525554082,
               "success_improvement": 0.0,
               "time_improvement": -769.5555412842224,
               "length_improvement": 43.19758523768294,
               "objective_score": -222.2271453377301
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 26.41049716472626,
               "num_nodes_avg": 3265.9,
               "path_length_avg": 89.09022823701214,
               "success_improvement": 0.0,
               "time_improvement": -183090.5120135739,
               "length_improvement": 70.43684821439662,
               "objective_score": -54913.06623442929
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 15.803206944465638,
               "num_nodes_avg": 1863.2,
               "path_length_avg": 26.6995063258948,
               "success_improvement": 0.0,
               "time_improvement": -53754.70395674949,
               "length_improvement": 83.60489471057893,
               "objective_score": -16109.69020808273
          }
     ]
}
{
     "operator": "e2",
     "algorithm_description": "A hybrid planner combining bidirectional RRT*-Connect's informed sampling and adaptive step sizing with RRT*'s optimal rewiring and goal biasing. It uses two trees grown from start and goal, includes heuristic-based sampling within an ellipsoidal informed subset, dynamically adjusts expansion steps near obstacles, prunes non-promising branches, and rewires nodes efficiently to improve solution quality. The planner attempts early connections between trees to quickly find high-quality paths and refines them incrementally for robustness and enhanced performance.",
     "planning_mechanism": "The planner alternates growth between two trees (start and goal), samples candidates with informed heuristics biased towards shortest path ellipsoid, adapts step sizes based on obstacle proximity, rejects costly expansions, and rewires locally to improve path costs. It integrates goal biasing and tries to connect the two trees at every iteration. Upon successful connection, it reconstructs the combined path and returns the best path found within the iteration limit.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> dict:\n        import math, random, numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a == tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a to the sample\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                # Prune paths that cannot improve existing best path\n                continue\n\n            new_node = Node(new_position)\n            # Ensure child's position is not in obstacle before connecting\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                continue\n\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Find near nodes in tree_a for rewiring\n            near_nodes = [n for n in tree_a if math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                if near_node == new_node:\n                    continue\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire if cheaper path found\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Verify connection path collision free\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Optional pruning near best path could be inserted here (not mandatory)\n\n        # Post-processing: Optional path smoothing for improved path quality\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        # If no solution, sample uniformly in bounds\n        if c_best == float('inf'):\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Calculate rotation matrix C that aligns x-axis with vector a1\n        # Using SVD-based method to get a proper rotation\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        r2_sq = c_best**2 - c_min**2\n        r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n        L = np.diag([r1] + [r2] * (dim -1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps+1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # reduce step near obstacle but keep minimum step size of 1\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path, obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n\n        path_smoothed = [path[0]]\n        idx = 0\n        while idx < len(path_smoothed):\n            # Attempt to skip intermediate nodes if straight connection is collision free\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(path_smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == len(path) - 1:\n                path_smoothed += path[idx+1:]\n                break\n            if next_idx == idx:\n                # No farther progress, just add next node\n                path_smoothed.append(path[idx+1])\n                idx += 1\n            else:\n                path_smoothed.append(path[next_idx])\n                idx = next_idx\n        return path_smoothed\n\n    # Dummy implementations for obstacle checks - actual implementations should exist elsewhere\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Check if pos lies inside any obstacle; placeholder\n        for obs in obstacles:\n            if self._point_in_rect(pos, obs):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Check if the line segment p1-p2 intersects any obstacle; placeholder\n        for obs in obstacles:\n            if self._line_intersects_rect(p1, p2, obs):\n                return True\n        return False\n\n    def _point_in_rect(self, point, rect):\n        # rect assumed as (xmin, ymin, xmax, ymax) or (xmin, ymin, zmin, xmax, ymax, zmax)\n        dims = len(point)\n        if dims == 2:\n            xmin, ymin, xmax, ymax = rect\n            x, y = point\n            return xmin <= x <= xmax and ymin <= y <= ymax\n        else:  # 3D\n            xmin, ymin, zmin, xmax, ymax, zmax = rect\n            x, y, z = point\n            return xmin <= x <= xmax and ymin <= y <= ymax and zmin <= z <= zmax\n\n    def _line_intersects_rect(self, p1, p2, rect):\n        # Simple sampling-based collision checking for the edge\n        import numpy as np\n        num_samples = 10\n        for i in range(num_samples + 1):\n            t = i / num_samples\n            point = tuple(p1[d] + t * (p2[d] - p1[d]) for d in range(len(p1)))\n            if self._point_in_rect(point, rect):\n                return True\n        return False",
     "objective": 31465.51903,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 8.487454676628113,
               "num_nodes_avg": 4.9,
               "path_length_avg": 138.84358021507737,
               "success_improvement": 0.0,
               "time_improvement": -87830.81200043473,
               "length_improvement": 30.60731310313128,
               "objective_score": -26343.122137509792
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 1.8722915172576904,
               "num_nodes_avg": 7.1,
               "path_length_avg": 93.033084549548,
               "success_improvement": 0.0,
               "time_improvement": -12886.73173571295,
               "length_improvement": 69.12847509713148,
               "objective_score": -3852.1938256944586
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 1.2877106666564941,
               "num_nodes_avg": 13.0,
               "path_length_avg": 30.223865024651694,
               "success_improvement": 0.0,
               "time_improvement": -4288.304030848655,
               "length_improvement": 81.44072615860215,
               "objective_score": -1270.203064022876
          }
     ]
}
{
     "operator": "m1",
     "algorithm_description": "This planner integrates bidirectional RRT* growth with informed elliptical sampling and adaptive step sizing, enhanced by heuristic-driven node rejection, rewiring for cost minimization, and aggressive pruning. It alternates expansions between start and goal trees, opportunistically attempts tree connection, and carefully maintains collision-free nodes and edges. The planner aims for rapid convergence to high-quality, smooth paths with improved efficiency and robustness.",
     "planning_mechanism": "It generates samples inside the ellipsoidal informed subset defined by the current best cost; expands trees adaptively near obstacles; rewires neighbors to optimize path costs; prunes nodes that cannot improve the solution; and promptly updates and returns the best found path, ensuring all new nodes and edges pass collision checks and remain within map bounds.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position                  # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                      # Node or None\n        self.cost = cost                          # Path cost\n        self.children = []\n        self.valid = True                         # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                          # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start                  # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal                    # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles                    # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start_position == goal_position:\n            node = Node(start_position)\n            return PlannerResult(True, [start_position], [node], [])\n\n        tree_a = [Node(start_position)]\n        tree_b = [Node(goal_position)]\n        nodes = [tree_a[0], tree_b[0]]\n        edges = []\n\n        c_best = float('inf')\n        c_min = math.dist(start_position, goal_position)\n        success = False\n        best_path: List[Tuple[float, ...]] = []\n\n        def informed_sample() -> Tuple[float, ...]:\n            if c_best == float(\"inf\"):\n                # Uniform random sample inside bounds & collision-free\n                for _ in range(100):\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(sample, obstacles, is_3d):\n                        return sample\n                # fallback if no free sample found fast enough\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s,g in zip(start_position, goal_position)])\n            a1 = np.array(goal_position) - np.array(start_position)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1]*(dim-1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best**2 - c_min**2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)):\n                    if not self._is_in_obstacle(candidate, obstacles, is_3d):\n                        return candidate\n            # fallback uniform sampling inside bounds if failure\n            for _ in range(100):\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(sample, obstacles, is_3d):\n                    return sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos) -> float:\n            dist = math.dist(from_pos, to_pos)\n            steps_check = max(2, int(dist))\n            for i in range(1, steps_check + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps_check) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.3, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step) -> Tuple[float, ...]:\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def rewire(tree, new_node):\n            near_nodes = [n for n in tree if math.dist(n.position, new_node.position) <= self.rewire_radius]\n            for neighbor in near_nodes:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_flag = True\n            while prune_flag:\n                prune_flag = False\n                remove_nodes = []\n                for node in tree[1:]:  # never prune root\n                    h_cost = math.dist(node.position, goal_position)\n                    if node.cost + h_cost >= c_best:\n                        remove_nodes.append(node)\n                if not remove_nodes:\n                    break\n                for node in remove_nodes:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_flag = True\n\n        for i in range(self.max_iter):\n            main_tree, other_tree = (tree_a, tree_b) if i%2==0 else (tree_b, tree_a)\n\n            sample = informed_sample()\n            nearest = min(main_tree, key=lambda n: math.dist(n.position, sample))\n\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            est_total_cost = new_cost + math.dist(new_pos, goal_position)\n            if est_total_cost >= c_best:\n                continue  # prune non-improving expansion\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            main_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            rewire(main_tree, new_node)\n            prune(main_tree)\n\n            other_nearest = min(other_tree, key=lambda n: math.dist(n.position, new_node.position))\n            if self._is_edge_in_obstacle(new_node.position, other_nearest.position, obstacles, is_3d):\n                continue\n\n            connection_cost = new_node.cost + other_nearest.cost + math.dist(new_node.position, other_nearest.position)\n            if connection_cost < c_best:\n                c_best = connection_cost\n                path_from_a = new_node.path_from_root()\n                path_from_b = other_nearest.path_from_root()\n                best_path = path_from_a + path_from_b[::-1]\n                success = True\n                prune(tree_a)\n                prune(tree_b)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x,y,z,w,h,d = obs\n                px,py,pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x,y,w,h = obs\n                px,py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i/steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 31003.29177,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 4.937959551811218,
               "num_nodes_avg": 2292.6,
               "path_length_avg": 158.15569516447223,
               "success_improvement": 0.0,
               "time_improvement": -51057.71565905566,
               "length_improvement": 20.95530366975476,
               "objective_score": -15313.123636982747
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 4.726552891731262,
               "num_nodes_avg": 2795.5,
               "path_length_avg": 260.4220472040613,
               "success_improvement": 0.0,
               "time_improvement": -32684.677959486744,
               "length_improvement": 13.583154267722925,
               "objective_score": -9802.686756992478
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 5.793317031860352,
               "num_nodes_avg": 2556.2,
               "path_length_avg": 119.55481531647267,
               "success_improvement": 0.0,
               "time_improvement": -19642.66202896855,
               "length_improvement": 26.586141292439425,
               "objective_score": -5887.481380432077
          }
     ]
}
{
     "operator": "m2",
     "algorithm_description": "An enhanced RRT* variant with adaptive parameters and informed sampling to improve path planning efficiency, path quality, and robustness. The algorithm incorporates goal biasing, adaptive neighbor radius based on the number of nodes, heuristic pruning by sampling within an informed ellipsoidal region, and early stopping to reduce search time and improve success rate. It maintains collision and edge checks ensuring safety and correctness.",
     "planning_mechanism": "The planner incrementally samples points biased toward the goal and within an informed ellipsoidal subset to focus the search. It connects nodes with collision-free edges, rewires to optimize paths, and dynamically adjusts the neighbor radius based on the explored tree size to balance exploration and exploitation. Early termination occurs when the goal is connected, thus reducing unnecessary iterations.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 6.0, goal_sample_rate: float = 0.1, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def heuristic(p):\n            # Euclidean heuristic to goal\n            return dist(p, goal_position)\n\n        def sample_in_bounds():\n            if is_3d:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]),\n                        random.uniform(0, bounds[2]))\n            else:\n                return (random.uniform(0, bounds[0]),\n                        random.uniform(0, bounds[1]))\n\n        def informed_sample(c_best):\n            # Sample inside ellipsoid only if c_best < inf\n            if c_best == float('inf'):\n                return sample_in_bounds()\n\n            # Define ellipsoid parameters\n            c_min = dist(start_position, goal_position)\n            if c_best < c_min:\n                c_best = c_min\n\n            # Unit vector from start to goal\n            dx = (goal_position[0] - start_position[0]) / c_min\n            dy = (goal_position[1] - start_position[1]) / c_min\n            if is_3d:\n                dz = (goal_position[2] - start_position[2]) / c_min\n\n            # Radii of the ellipsoid\n            a = c_best / 2.0\n            if is_3d:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n                c = b\n            else:\n                b = math.sqrt(c_best**2 - c_min**2) / 2.0\n\n            from random import uniform\n            import math as m\n\n            while True:\n                # Sample random point in unit ball\n                if is_3d:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    z = uniform(-1, 1)\n                    if x * x + y * y + z * z > 1:\n                        continue\n                    # Scale to ellipsoid\n                    px = a*x\n                    py = b*y\n                    pz = c*z\n                    # Rotate and translate\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                        start_position[2] + (c_min/2)*dz + pz,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(3)):\n                        return sample\n                else:\n                    x = uniform(-1, 1)\n                    y = uniform(-1, 1)\n                    if x*x + y*y > 1:\n                        continue\n                    px = a*x\n                    py = b*y\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(2)):\n                        return sample\n\n        for i in range(self.max_iter):\n            # Adaptive neighbor radius: gamma * (log(n)/n)^{1/d} with gamma ~ base_neighbor_radius\n            n = len(nodes)\n            dim = len(bounds)\n            gamma = self.base_neighbor_radius\n            r = min(gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 20)\n\n            # Goal biasing + informed sampling after initial solution found\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif best_goal_cost == float('inf'):\n                sample = sample_in_bounds()\n            else:\n                sample = informed_sample(best_goal_cost)\n\n            # Nearest node\n            nearest_node = min(nodes, key=lambda n: dist(n.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            step = min(self.step_size, dist_to_sample)\n            new_position = tuple(nearest_node.position[d] + unit[d] * step for d in range(dim))\n\n            # Check bounds\n            if any(new_position[d] < 0 or new_position[d] > bounds[d] for d in range(dim)):\n                continue\n\n            # Collision checks for node and edge\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_position)\n            near_nodes = [n for n in nodes if dist(n.position, new_position) <= r]\n\n            # Choose best parent among near nodes\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_position)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring neighbors to new_node if cheaper path found\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                    except ValueError:\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect to goal closer than previous best\n            dist_to_goal = dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)\n                    and not self._is_in_obstacle(goal_position, obstacles, is_3d)):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        goal_node = Node(goal_position)\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        # Early exit after connecting goal for efficiency\n                        break\n\n        if success_state and goal_node:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 623.91658,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.034694790840148926,
               "num_nodes_avg": 180.9,
               "path_length_avg": 189.07139379721863,
               "success_improvement": 0.0,
               "time_improvement": -259.44122790550625,
               "length_improvement": 5.503934639246591,
               "objective_score": -76.73158144380255
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.22140061855316162,
               "num_nodes_avg": 740.6,
               "path_length_avg": 306.5156055242495,
               "success_improvement": 0.0,
               "time_improvement": -1435.6959174189792,
               "length_improvement": -1.712247797395705,
               "objective_score": -431.05122478517285
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.14426853656768798,
               "num_nodes_avg": 551.6,
               "path_length_avg": 151.78324040380903,
               "success_improvement": 0.0,
               "time_improvement": -391.64320599163295,
               "length_improvement": 6.795946815823351,
               "objective_score": -116.13377243432521
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "The algorithm is a simplified and generalized bidirectional RRT* (BI-RRT*) path planner that builds two trees growing from start and goal positions respectively, incrementally searching for an optimal path in a given environment with obstacles. It samples free points within the map bounds, extends trees toward sampled points while rewiring nearby nodes to minimize path cost, and attempts to connect the two trees when close enough, returning an optimized feasible path.",
     "planning_mechanism": "The planner iteratively samples collision-free points within the environment, extends the nearest node in one tree towards this sample with a fixed step size, rewires nearby nodes to improve path cost, then attempts to connect the other tree to the newly added node. Collision checks on nodes and edges ensure path validity. Upon connecting the two trees, the final path is constructed by concatenating paths from both trees and returned along with the explored nodes and edges.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]; 2D or 3D coordinate\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost from root to this node\n        self.children = []\n        self.valid = True               # Validity flag for collision checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, neighbor_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.neighbor_radius = neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success = False\n        path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_pos)\n        goal_root = Node(goal_pos)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for _ in range(self.max_iter):\n            sample = self._sample_free(bounds, obstacles, is_3d)\n            new_node_a = self._extend_and_rewire(tree_a, sample, obstacles, is_3d, nodes, edges)\n            if new_node_a is None:\n                continue\n\n            new_node_b = self._connect_and_rewire(tree_b, new_node_a, obstacles, is_3d, nodes, edges)\n            if new_node_b:\n                success = True\n                path_a = new_node_a.path_from_root()\n                path_b = new_node_b.path_from_root()\n                path = path_a + path_b[::-1]\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(success=success, path=path, nodes=nodes, edges=edges)\n\n    def _sample_free(self, bounds, obstacles, is_3d):\n        import random\n        while True:\n            p = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n            if not self._is_in_obstacle(p, obstacles, is_3d):\n                return p\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        r = self.neighbor_radius\n        return [node for node in tree if math.dist(node.position, position) <= r]\n\n    def _extend_and_rewire(self, tree, sample, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, sample)\n        new_pos = self._steer(nearest.position, sample)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        neighbors = self._near_nodes(tree, new_pos)\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        new_node = Node(new_pos, parent=best_parent, cost=min_cost)\n        best_parent.add_child(new_node)\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    edges.remove((neighbor.parent, neighbor))\n                    neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, target_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, target_node.position)\n        current_pos = nearest.position\n\n        while True:\n            new_pos = self._steer(current_pos, target_node.position)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or self._is_edge_in_obstacle(current_pos, new_pos, obstacles, is_3d):\n                return None\n\n            neighbors = self._near_nodes(tree, new_pos)\n            min_cost = self._nearest(tree, current_pos).cost + math.dist(current_pos, new_pos)\n            best_parent = self._nearest(tree, current_pos)\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            connect_node = Node(new_pos, parent=best_parent, cost=min_cost)\n            best_parent.add_child(connect_node)\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        edges.remove((neighbor.parent, neighbor))\n                        neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, target_node.position) <= self.step_size:\n                return connect_node\n\n            current_pos = connect_node.position\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 15.44831,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.008229565620422364,
               "num_nodes_avg": 52.3,
               "path_length_avg": 154.7943637949193,
               "success_improvement": 0.0,
               "time_improvement": 14.740942369063248,
               "length_improvement": 22.63526478083162,
               "objective_score": 8.949335666885299
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03801658153533936,
               "num_nodes_avg": 239.4,
               "path_length_avg": 232.41204773470093,
               "success_improvement": 0.0,
               "time_improvement": -163.69352280751656,
               "length_improvement": 22.877819712112878,
               "objective_score": -44.53249289983239
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.01417546272277832,
               "num_nodes_avg": 117.1,
               "path_length_avg": 125.17394587738166,
               "success_improvement": 0.0,
               "time_improvement": 51.692377941521784,
               "length_improvement": 23.135656625921193,
               "objective_score": 20.134844707640774
          }
     ]
}
{
     "operator": "m2",
     "algorithm_description": "A refined RRT*-Connect inspired planner that integrates bidirectional search with adaptive step sizing, goal biasing, informed heuristic sampling, dynamic rewiring radius, branch pruning, and incremental path smoothing for efficient, high-quality, and robust path planning in 2D/3D environments.",
     "planning_mechanism": "The planner simultaneously grows two trees from start and goal points, alternately expanding them using informed sampling restricted inside an ellipsoidal heuristic region biased by current best path cost. It adapts step sizes near obstacles and dynamically adjusts rewiring radius based on node density. Nodes are connected only after strict collision and edge checks. It attempts early tree connections to accelerate search, rewires locally for path cost reduction, prunes branches unlikely to improve solutions, and applies intermittent path smoothing to enhance path quality and smoothness within the iteration budget.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 4.5, goal_sample_rate: float = 0.12, rewire_base_radius: float = 18.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = dim == 3\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            # Check points along the path for obstacle proximity to adapt step size\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    # Reduce step near obstacles, but keep minimum 1.0\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            new_pos = tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n            return new_pos\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sample in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            # Rotation matrix to align x-axis with a_unit vector\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            r2_sq = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(r2_sq) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim -1))\n\n            for _ in range(100):\n                # Sample unit ball\n                x_ball = np.random.normal(0,1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback uniform sample\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            # Adaptive rewiring radius ~ gamma * (log(n)/n)^{1/d}\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _try_connect_nodes(from_node, to_node):\n            if self._is_edge_in_obstacle(from_node.position, to_node.position, obstacles, is_3d):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            # Remove nodes and descendants whose cost > cost_threshold (to prune search space)\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                # Disconnect node from parent\n                if node.parent:\n                    node.parent.remove_child(node)\n                # Disconnect children recursively\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) -1:\n                next_idx = len(path_in) -1\n                for j in range(len(path_in)-1, idx, -1):\n                    if not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) and _in_bounds(path_in[j]):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Goal biasing & informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            # Prune expansions that can't beat current best\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Adaptive rewiring radius based on tree size\n            curr_rewire_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_rewire_radius]\n            for near_node in near_nodes:\n                if near_node is new_node:\n                    continue\n                potential_cost = new_node.cost + dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node to new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            try:\n                                edges.remove((near_node.parent, near_node))\n                            except ValueError:\n                                pass\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Try connect new_node in tree_a to nearest node in tree_b\n            nearest_to_new = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between + nearest_to_new.cost\n\n            # Only attempt if total cost could improve best known path\n            if total_cost + 1e-6 < c_best:\n                if _try_connect_nodes(new_node, nearest_to_new):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune both trees to nodes that can improve the best path cost\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 500 iterations if path found\n            if success and iteration % 500 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": 17508.66314,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 1.970580530166626,
               "num_nodes_avg": 888.1,
               "path_length_avg": 160.88313224173535,
               "success_improvement": 0.0,
               "time_improvement": -20315.39574955786,
               "length_improvement": 19.592156833291394,
               "objective_score": -6090.7002935007
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 3.728665590286255,
               "num_nodes_avg": 2668.8,
               "path_length_avg": 234.32515379280804,
               "success_improvement": 0.0,
               "time_improvement": -25763.055676370248,
               "length_improvement": 22.242986398774466,
               "objective_score": -7724.468105631319
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 3.6472797632217406,
               "num_nodes_avg": 2934.6,
               "path_length_avg": 119.67619978901351,
               "success_improvement": 0.0,
               "time_improvement": -12329.323528193027,
               "length_improvement": 26.511603913975694,
               "objective_score": -3693.494737675113
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* inspired planner that grows two trees from the start and goal positions, alternately extending them with goal biasing and adaptive step sizing. It performs collision checks on nodes and edges before adding them. Nearby nodes are rewired for path cost improvement. The planner attempts to connect the two trees at every iteration to find a feasible, near-optimal, and smooth path efficiently.",
     "planning_mechanism": "A bidirectional incremental sampling approach that alternately grows start and goal trees toward randomly sampled points biased by the goal. Each new node undergoes collision checks, and rewiring locally improves path cost. The trees try to connect every iteration, reconstructing a smooth, high-quality path once connected while respecting map bounds and obstacles.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position           # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent               # Node or None\n        self.cost = cost                   # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                  # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=10.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                        # Tuple[int, ...]: (W,H) or (W,H,D)\n        start = map.start                        # Tuple[float, ...]\n        goal = map.goal                          # Tuple[float, ...]\n        obstacles = map.obstacles                # List of rectangular blocks\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n        success = False\n\n        def sample() -> Tuple[float, ...]:\n            # Goal biasing for start tree growth; uniform random otherwise\n            if random.random() < self.goal_sample_rate:\n                return goal\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            rand_point = sample()\n\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, rand_point))\n            step = self._adaptive_step(nearest.position, rand_point, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, rand_point, step)\n\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            if new_cost + 1e-8 >= c_best:\n                # Prune expansions exceeding current best path cost\n                continue\n\n            new_node = Node(new_pos, parent=nearest, cost=new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire nearby nodes in tree_a to improve path cost\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Attempt connection to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = self._smooth_path(best_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _steer(self, from_pos: Tuple[float, ...], to_pos: Tuple[float, ...], step: float) -> Tuple[float, ...]:\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n        new_pos = tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d) -> float:\n        base_step = self.step_size\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return max(base_step * 0.5, 1.0)\n        return base_step\n\n    def _in_bounds(self, pos, bounds) -> bool:\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d) -> bool:\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0) -> bool:\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds) -> List[Tuple[float, ...]]:\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while True:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                next_idx = j\n                break\n            smoothed.append(path[next_idx])\n            if next_idx == len(path) - 1:\n                break\n            idx = next_idx\n        return smoothed",
     "objective": 14698.73309,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 2.2550732851028443,
               "num_nodes_avg": 2881.5,
               "path_length_avg": 150.2908476159304,
               "success_improvement": 0.0,
               "time_improvement": -23262.766887652775,
               "length_improvement": 24.886078881558923,
               "objective_score": -6973.852850519521
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 2.5137412548065186,
               "num_nodes_avg": 3415.1,
               "path_length_avg": 224.9319970260605,
               "success_improvement": 0.0,
               "time_improvement": -17336.00450478013,
               "length_improvement": 25.359953598617825,
               "objective_score": -5195.729360714315
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 2.5090816497802733,
               "num_nodes_avg": 3345.2,
               "path_length_avg": 113.92078839710514,
               "success_improvement": 0.0,
               "time_improvement": -8450.533440907127,
               "length_improvement": 30.045773220422934,
               "objective_score": -2529.150877628054
          }
     ]
}
{
     "operator": "e2",
     "algorithm_description": "Hybrid Bidirectional Informed RRT* Planner with Adaptive Step Sizing, Dynamic Rewiring, Branch Pruning, and Incremental Path Smoothing for Enhanced Efficiency and Path Quality",
     "planning_mechanism": "The planner grows two trees from start and goal positions alternately using informed sampling restricted to an ellipsoidal heuristic region guided by the best known path cost, integrating goal biasing. It employs adaptive step sizing near obstacles and dynamically adjusts rewiring radius based on node density. The algorithm rewires nodes locally to reduce path cost, prunes branches unlikely to yield better solutions, performs strict collision and edge checks before node/edge additions, and incrementally smooths the best found path to ensure robustness, improved success rate, and high-quality smooth paths.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, base_step: float = 5.0, goal_sample_rate: float = 0.15, rewire_base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.base_step = base_step\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size                  # Tuple[int, ...]\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # List of obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_position)]\n        tree_goal = [Node(goal_position)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path = []\n\n        dist_start_goal = math.dist(start_position, goal_position)\n        c_min = dist_start_goal\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def _in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def _adaptive_step(from_pos, to_pos):\n            dist_full = dist(from_pos, to_pos)\n            max_check_points = max(5, int(dist_full))\n            # If near obstacle, reduce step size adaptively\n            for i in range(1, max_check_points + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_check_points for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.base_step * 0.4, 1.0)\n            return self.base_step\n\n        def _steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            return tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n\n        def _informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                # Uniform sampling in bounds\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            x_center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a_vec = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a_vec)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a_vec / length\n\n            I = np.eye(dim)\n            M = np.outer(a_unit, I[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1]*(dim-1) + [np.linalg.det(U)*np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            val = max(c_best_val**2 - c_min**2, 0)\n            r2 = math.sqrt(val) / 2.0\n\n            L = np.diag([r1] + [r2]*(dim-1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1/dim)\n                x_ball *= scale\n                x_rand = C @ L @ x_ball + x_center\n                if np.all((x_rand >= 0) & (x_rand <= np.array(bounds))):\n                    return tuple(x_rand)\n            # Fallback\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def _rewire_radius(n_nodes):\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            return min(gamma * ((math.log(n_nodes) / n_nodes) ** (1/dim)), self.base_step * 25)\n\n        def _valid_node_and_edge(from_pos, to_pos):\n            if not _in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def _prune_nodes(tree_nodes, cost_threshold):\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def _smooth_path(path_in):\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                for j in range(len(path_in) - 1, idx, -1):\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) \n                        and _in_bounds(path_in[j])):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx+1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        # Initialize start and goal nodes costs\n        tree_start[0].cost = 0.0\n        tree_goal[0].cost = 0.0\n\n        for iteration in range(self.max_iter):\n            # Alternate trees for expansion\n            tree_a, tree_b = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample with goal bias and informed sampling region\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = _informed_sample(c_best)\n\n            # Nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: dist(n.position, sample))\n            step_size = _adaptive_step(nearest_node.position, sample)\n            new_pos = _steer(nearest_node.position, sample, step_size)\n\n            if not _valid_node_and_edge(nearest_node.position, new_pos):\n                continue\n\n            new_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            if new_cost + c_min - 1e-9 >= c_best:\n                continue\n\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            curr_radius = _rewire_radius(len(tree_a))\n\n            # Rewire neighbors in tree_a\n            near_nodes = [n for n in tree_a if dist(n.position, new_node.position) <= curr_radius and n is not new_node]\n            for near in near_nodes:\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if _valid_node_and_edge(new_node.position, near.position):\n                        if near.parent:\n                            near.parent.remove_child(near)\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect new_node in tree_a to nearest in tree_b\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_b.position)\n            total_path_cost = new_node.cost + dist_between + nearest_b.cost\n\n            if total_path_cost + 1e-9 < c_best:\n                if _valid_node_and_edge(new_node.position, nearest_b.position):\n                    c_best = total_path_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    # Prune trees to reduce search space\n                    _prune_nodes(tree_start, c_best)\n                    _prune_nodes(tree_goal, c_best)\n\n            # Incremental smoothing every 400 iterations if path found\n            if success and iteration % 400 == 0 and len(best_path) > 3:\n                best_path = _smooth_path(best_path)\n\n        # Final path smoothing\n        if success and len(best_path) > 2:\n            best_path = _smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                if len(obs) == 6:\n                    x, y, z, w, h, d = obs\n                    px, py, pz = pos\n                    if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                        return True\n            else:\n                if len(obs) == 4:\n                    x, y, w, h = obs\n                    px, py = pos\n                    if x <= px <= x + w and y <= py <= y + h:\n                        return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": 17423.34785,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 2.0039466381073,
               "num_nodes_avg": 754.7,
               "path_length_avg": 158.9066197858871,
               "success_improvement": 0.0,
               "time_improvement": -20661.071700275657,
               "length_improvement": 20.579998761481207,
               "objective_score": -6194.205510330401
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 3.752269744873047,
               "num_nodes_avg": 2709.9,
               "path_length_avg": 235.2432028075281,
               "success_improvement": 0.0,
               "time_improvement": -25926.780620184523,
               "length_improvement": 21.938346676709898,
               "objective_score": -7773.646516720014
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 3.4142481803894045,
               "num_nodes_avg": 2891.6,
               "path_length_avg": 121.63826340464034,
               "success_improvement": 0.0,
               "time_improvement": -11535.190606305092,
               "length_improvement": 25.306778657280017,
               "objective_score": -3455.4958261600714
          }
     ]
}
{
     "operator": "m1",
     "algorithm_description": "A hybrid bidirectional RRT* planner integrating informed sampling from Algorithm 2 and adaptive step sizing plus local rewiring from Algorithm 1, enhanced with pruning, node rejection, and path smoothing to boost planning efficiency, success rate, and path quality.",
     "planning_mechanism": "The planner grows two trees from start and goal positions alternately, using informed heuristic sampling constrained by the current best path cost to focus exploration. It adaptively adjusts step size near obstacles and prunes expansions unlikely to improve the current best path. Each new node undergoes collision and edge checks before insertion. Local rewiring optimizes path cost. Upon connecting both trees with valid edges, a smoothed, near-optimal path is extracted.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]: 2D or 3D coordinates\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision status\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        node, path = self, []\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0, goal_sample_rate: float = 0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n        self.goal_sample_rate = goal_sample_rate\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_min = math.dist(start, goal)\n        c_best = float('inf')\n        best_path = []\n        success = False\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample():\n            if random.random() < self.goal_sample_rate:\n                return goal\n            if c_best == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a1 = a1 / norm_a1\n\n            # Create rotation matrix C aligning x-axis with vector a1\n            eye = np.eye(dim)\n            M = np.outer(a1, eye[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best / 2.0\n            if c_best**2 - c_min**2 <= 0:\n                r2 = 0.0\n            else:\n                r2 = math.sqrt(c_best**2 - c_min**2) / 2.0\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):  # sample up to 100 times to get a valid point\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1.0 / dim)\n                x_ball = x_ball * scale\n                x_rand = C @ L @ x_ball + x_center\n                x_rand_clip = np.clip(x_rand, [0]*dim, np.array(bounds))\n                x_rand_tuple = tuple(x_rand_clip)\n                if in_bounds(x_rand_tuple):\n                    return x_rand_tuple\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            direction = tuple((to_pos[d] - from_pos[d]) / dist for d in range(len(from_pos)))\n            return tuple(from_pos[d] + direction[d] * step for d in range(len(from_pos)))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            steps = max(2, int(dist))\n            step_val = self.step_size\n            for i in range(1, steps + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    step_val = max(self.step_size * 0.3, 1.0)\n                    break\n            return step_val\n\n        def smooth_path(path):\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            idx = 0\n            while True:\n                next_idx = len(path) - 1\n                for j in range(len(path) - 1, idx, -1):\n                    if not in_bounds(path[j]):\n                        continue\n                    if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        continue\n                    next_idx = j\n                    break\n                smoothed.append(path[next_idx])\n                if next_idx == len(path) - 1:\n                    break\n                idx = next_idx\n            return smoothed\n\n        for i in range(self.max_iter):\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            sampled_point = informed_sample()\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sampled_point))\n            step = adaptive_step(nearest.position, sampled_point)\n            new_pos = steer(nearest.position, sampled_point, step)\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune expansions that cannot improve best path cost\n            heuristic_cost = new_cost + math.dist(new_pos, goal)\n            if heuristic_cost >= c_best:\n                continue\n\n            new_node = Node(new_pos, nearest, new_cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Local rewiring to improve costs\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near.position)\n                if potential_cost + 1e-8 < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            # Try connect both trees\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_pos))\n            dist_btwn = math.dist(nearest_b.position, new_pos)\n            total_cost = new_node.cost + dist_btwn + nearest_b.cost\n            if total_cost + 1e-8 < c_best:\n                if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n        if success and len(best_path) > 2:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 16137.02705,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 2.5810898542404175,
               "num_nodes_avg": 2094.8,
               "path_length_avg": 151.77689065690328,
               "success_improvement": 0.0,
               "time_improvement": -26640.32856451247,
               "length_improvement": 24.143368852778615,
               "objective_score": -7987.269895583185
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 2.6184764385223387,
               "num_nodes_avg": 2665.2,
               "path_length_avg": 232.55277351067917,
               "success_improvement": 0.0,
               "time_improvement": -18062.476702977223,
               "length_improvement": 22.83112213867841,
               "objective_score": -5414.176786465431
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 2.7108699321746825,
               "num_nodes_avg": 2621.2,
               "path_length_avg": 114.98911993316067,
               "success_improvement": 0.0,
               "time_improvement": -9138.194385200315,
               "length_improvement": 29.389753299910325,
               "objective_score": -2735.5803649001123
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "This algorithm combines bidirectional RRT* with informed sampling and adaptive step sizing to efficiently find high-quality, collision-free paths in 2D or 3D environments. It balances exploration and exploitation by sampling inside an informed ellipsoidal region based on the current best path cost and prunes nodes that cannot improve the solution. The planner rewires nearby nodes to optimize cost dynamically and alternates expansions between the start and goal trees to connect paths quickly.",
     "planning_mechanism": "The planner grows two trees from start and goal, samples points preferentially within an ellipsoidal informed subset reflecting the current best path, and expands trees adaptively while checking collisions. It rewires neighbors to minimize cost and prunes nodes unlikely to yield improvements. The path is updated whenever trees connect with lower cost, ensuring robust convergence toward an optimal path within map bounds.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # For collision checks\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start = map.start\n        goal = map.goal\n        obstacles = map.obstacles\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        if start == goal:\n            root = Node(start)\n            return PlannerResult(True, [start], [root], [])\n\n        tree_start = [Node(start)]\n        tree_goal = [Node(goal)]\n        nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        c_best = float(\"inf\")\n        c_min = math.dist(start, goal)\n        success = False\n        best_path = []\n\n        def sample_informed():\n            if c_best == float(\"inf\"):\n                for _ in range(100):\n                    s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                    if not self._is_in_obstacle(s, obstacles, is_3d):\n                        return s\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            x_center = np.array([(s + g) * 0.5 for s, g in zip(start, goal)])\n            a1 = np.array(goal) - np.array(start)\n            norm_a1 = np.linalg.norm(a1)\n            if norm_a1 == 0:\n                return tuple(x_center)\n\n            a1_unit = a1 / norm_a1\n            I = np.eye(dim)\n            M = np.outer(a1_unit, I[0])\n            U, _, Vt = np.linalg.svd(M, full_matrices=True)\n            det = np.linalg.det(U) * np.linalg.det(Vt)\n            C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n            r1 = c_best * 0.5\n            val = max(c_best ** 2 - c_min ** 2, 0.0)\n            r2 = math.sqrt(val) * 0.5\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_x_ball = np.linalg.norm(x_ball)\n                if norm_x_ball == 0:\n                    continue\n                x_ball /= norm_x_ball\n                scale = random.random() ** (1.0 / dim)\n                x_rand = C @ (L @ (x_ball * scale)) + x_center\n                candidate = tuple(np.clip(x_rand, np.zeros(dim), np.array(bounds)))\n                if all(0 <= candidate[d] <= bounds[d] for d in range(dim)) and not self._is_in_obstacle(candidate, obstacles, is_3d):\n                    return candidate\n            for _ in range(100):\n                s = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(s, obstacles, is_3d):\n                    return s\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def steer(from_pos, to_pos, step):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= step:\n                return to_pos\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * step / dist for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            check_steps = max(2, int(dist))\n            for i in range(1, check_steps+1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / check_steps) for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size*0.3, 1.0)\n            return self.step_size\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if math.dist(n.position, pos) <= radius]\n\n        def rewire(tree, new_node, radius=15.0):\n            neighbors = near_nodes(tree, new_node.position, radius)\n            for neighbor in neighbors:\n                new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        neighbor.parent.remove_child(neighbor)\n                        if (neighbor.parent, neighbor) in edges:\n                            edges.remove((neighbor.parent, neighbor))\n                    new_node.add_child(neighbor)\n                    neighbor.cost = new_cost\n                    if (new_node, neighbor) not in edges:\n                        edges.append((new_node, neighbor))\n\n        def prune(tree):\n            nonlocal nodes, edges\n            prune_occurred = True\n            while prune_occurred:\n                prune_occurred = False\n                to_remove = []\n                for node in tree[1:]:  # Do not prune root\n                    h_cost = math.dist(node.position, goal)\n                    if node.cost + h_cost >= c_best:\n                        to_remove.append(node)\n                if not to_remove:\n                    break\n                for node in to_remove:\n                    if node.parent:\n                        node.parent.remove_child(node)\n                        if (node.parent, node) in edges:\n                            edges.remove((node.parent, node))\n                    for ch in node.children[:]:\n                        node.remove_child(ch)\n                    if node in tree:\n                        tree.remove(node)\n                    if node in nodes:\n                        nodes.remove(node)\n                    prune_occurred = True\n\n        for i in range(self.max_iter):\n            curr_tree, other_tree = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            sample = sample_informed()\n            nearest_node = nearest(curr_tree, sample)\n            step = adaptive_step(nearest_node.position, sample)\n            new_pos = steer(nearest_node.position, sample, step)\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            est_tot_cost = new_cost + math.dist(new_pos, goal)\n            if est_tot_cost >= c_best:\n                continue  # Discard expansions that cannot improve path\n\n            new_node = Node(new_pos, nearest_node, new_cost)\n            nearest_node.add_child(new_node)\n            curr_tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            rewire(curr_tree, new_node)\n            prune(curr_tree)\n\n            other_near = nearest(other_tree, new_pos)\n            if self._is_edge_in_obstacle(new_node.position, other_near.position, obstacles, is_3d):\n                continue\n\n            total_cost = new_node.cost + other_near.cost + math.dist(new_node.position, other_near.position)\n            if total_cost < c_best:\n                c_best = total_cost\n                path_a = new_node.path_from_root()\n                path_b = other_near.path_from_root()\n                best_path = path_a + path_b[::-1]\n                success = True\n                prune(tree_start)\n                prune(tree_goal)\n                if c_best <= c_min * 1.05:\n                    break\n\n        return PlannerResult(success, best_path, nodes, edges)\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 31366.25511,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 5.059916830062866,
               "num_nodes_avg": 2317.2,
               "path_length_avg": 156.00261761957682,
               "success_improvement": 0.0,
               "time_improvement": -52321.20429193878,
               "length_improvement": 22.03139113239555,
               "objective_score": -15691.955009355155
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 4.770031833648682,
               "num_nodes_avg": 2754.0,
               "path_length_avg": 254.64024606805137,
               "success_improvement": 0.0,
               "time_improvement": -32986.25992449036,
               "length_improvement": 15.501751491689003,
               "objective_score": -9892.77762704877
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 5.689538669586182,
               "num_nodes_avg": 2664.5,
               "path_length_avg": 120.68598190294082,
               "success_improvement": 0.0,
               "time_improvement": -19289.002610533295,
               "length_improvement": 25.891536865726344,
               "objective_score": -5781.522475786844
          }
     ]
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional nature and rewiring optimization of BI-RRT* with the adaptive goal bias, neighbor radius tuning, and path smoothing strategies of the optimized RRT*. It aims to balance rapid exploration, path quality, and robustness by growing two trees from start and goal with adaptive parameters, rewiring locally for optimal cost, and performing shortcut smoothing on the resulting path for efficiency and smoothness. It uses careful collision and edge checks, adaptive sampling, and rewiring to improve success rate and reduce search time.",
     "planning_mechanism": "The planner iteratively grows two trees bidirectionally with adaptive step size and neighbor radius, sampling both randomly and near the goal to guide exploration efficiently. Each extension rewires neighbors to minimize path cost. Whenever the trees can connect collision-free, the path is extracted and smoothed by shortcutting to improve quality and reduce length. Rigorous obstacle and edge collision checks ensure robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15      # Increased goal bias for guidance\n        self.initial_neighbor_radius = 18.0   # Start radius for rewiring\n        self.minimum_neighbor_radius = 5.0    # Minimum radius to keep rewiring efficient\n        self.smooth_trials = 120            # Shortcut smoothing trials\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size                      # Tuple[int, ...]\n        dim = len(bounds)\n        start_position = map.start             # Tuple[float, ...]\n        goal_position = map.goal               # Tuple[float, ...]\n        obstacles = map.obstacles              # List of obstacle descriptions\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n\n        tree_start = [start_root]\n        tree_goal = [goal_root]\n\n        nodes.extend([start_root, goal_root])\n\n        # Helper functions for sampling, nearest, near nodes, steering\n        def sample_point(iteration):\n            # Adaptive goal bias - sample goal sometimes to speed up convergence\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            else:\n                # Occasionally bias samples near goal to speed connections\n                bias_prob = 0.1\n                if random.random() < bias_prob:\n                    radius = max(bounds[d]*0.1 for d in range(dim))\n                    return tuple(\n                        max(0, min(bounds[d], random.gauss(goal_position[d], radius)))\n                        for d in range(dim)\n                    )\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position, radius):\n            return [node for node in tree if math.dist(node.position, position) <= radius]\n\n        def try_connect_nodes(from_node, to_point):\n            # Steer from from_node toward to_point considering obstacles\n            new_pos = steer(from_node.position, to_point)\n            if not in_bounds(new_pos):\n                return None\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(from_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                return None\n            return new_pos\n\n        def add_node(tree, nodes_collection, edges_collection, new_pos, near_nodes_list):\n            # Select best parent to minimize cost\n            min_cost = math.dist(tree[0].position, new_pos) + 1e9   # large initial cost\n            best_parent = None\n            for near_node in near_nodes_list:\n                cost_candidate = near_node.cost + math.dist(near_node.position, new_pos)\n                if cost_candidate < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d, resolution=0.5):\n                    min_cost = cost_candidate\n                    best_parent = near_node\n            if best_parent is None:\n                return None\n\n            new_node = Node(new_pos)\n            new_node.parent = best_parent\n            new_node.cost = min_cost\n            best_parent.children.append(new_node)\n            tree.append(new_node)\n            nodes_collection.append(new_node)\n            edges_collection.append((best_parent, new_node))\n\n            # Rewire neighbors if beneficial\n            for near_node in near_nodes_list:\n                if near_node is best_parent:\n                    continue\n                new_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if new_cost < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d, resolution=0.5):\n                    if near_node.parent:\n                        try:\n                            edges_collection.remove((near_node.parent, near_node))\n                        except ValueError:\n                            pass\n                        try:\n                            near_node.parent.children.remove(near_node)\n                        except ValueError:\n                            pass\n                    near_node.parent = new_node\n                    near_node.cost = new_cost\n                    new_node.children.append(near_node)\n                    edges_collection.append((new_node, near_node))\n            return new_node\n\n        def connect_trees(tree_a, tree_b):\n            # Attempt to connect nearest nodes between two trees with edge checks and rewiring\n            # Return tuple(new_node_from_a, new_node_from_b) if connected else (None, None)\n\n            # Use adaptive radius for connections\n            radius = max(self.minimum_neighbor_radius, self.initial_neighbor_radius * (1 - iteration / self.max_iter))\n\n            for node_a in tree_a[-10:]:  # limit attempts to recent added nodes to reduce compute\n                near_b_nodes = near_nodes(tree_b, node_a.position, radius)\n                for node_b in near_b_nodes:\n                    if not self._is_edge_in_obstacle(node_a.position, node_b.position, obstacles, is_3d, resolution=0.5):\n                        return node_a, node_b\n            return None, None\n\n        # Main loop\n        for iteration in range(self.max_iter):\n            # Alternate growing start and goal trees\n            tree_current, tree_other = (tree_start, tree_goal) if iteration % 2 == 0 else (tree_goal, tree_start)\n\n            sample = sample_point(iteration)\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = nearest(tree_current, sample)\n            new_pos = try_connect_nodes(nearest_node, sample)\n            if new_pos is None:\n                continue\n\n            radius = max(self.minimum_neighbor_radius, self.initial_neighbor_radius * (1 - iteration / self.max_iter))\n            near_nodes_list = near_nodes(tree_current, new_pos, radius)\n\n            new_node = add_node(tree_current, nodes, edges, new_pos, near_nodes_list)\n            if new_node is None:\n                continue\n\n            # Try connecting opposite tree to new_node\n            nearest_in_other = nearest(tree_other, new_node.position)\n            connect_pos = try_connect_nodes(nearest_in_other, new_node.position)\n            if connect_pos is not None:\n                # Add connecting node to opposite tree\n                near_nodes_other = near_nodes(tree_other, connect_pos, radius)\n                connect_node = add_node(tree_other, nodes, edges, connect_pos, near_nodes_other)\n                if connect_node is not None:\n                    dist_between = math.dist(connect_node.position, new_node.position)\n                    if dist_between <= self.step_size * 1.5:\n                        # Connection successful, extract path\n                        path_from_start = new_node.path_from_root() if tree_current is tree_start else connect_node.path_from_root()\n                        path_from_goal = connect_node.path_from_root() if tree_current is tree_start else new_node.path_from_root()\n                        extracted_path = path_from_start + path_from_goal[::-1]\n                        success_state = True\n                        break\n\n            # Additionally attempt direct connects between trees to improve success rate\n            node_a, node_b = connect_trees(tree_start, tree_goal)\n            if node_a and node_b:\n                path_from_start = node_a.path_from_root()\n                path_from_goal = node_b.path_from_root()\n                extracted_path = path_from_start + path_from_goal[::-1]\n                success_state = True\n                break\n\n        # Path smoothing by shortcutting after successful planning\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) < 3:\n            return path\n        path = path[:]\n        max_trials = self.smooth_trials\n        for _ in range(max_trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n\n            p_start = path[i]\n            p_end = path[j]\n\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.5):\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": 563.97687,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.07689383029937744,
               "num_nodes_avg": 122.9,
               "path_length_avg": 163.9204223777056,
               "success_improvement": 0.0,
               "time_improvement": -696.6271625186488,
               "length_improvement": 18.074148416237893,
               "objective_score": -205.37331907234704
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.1650343656539917,
               "num_nodes_avg": 288.5,
               "path_length_avg": 209.21786104768753,
               "success_improvement": 0.0,
               "time_improvement": -1044.7239995303387,
               "length_improvement": 30.574435549122597,
               "objective_score": -307.30231274927706
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.08734161853790283,
               "num_nodes_avg": 130.8,
               "path_length_avg": 97.77152694068681,
               "success_improvement": 0.0,
               "time_improvement": -197.6457263384366,
               "length_improvement": 39.962392602541584,
               "objective_score": -51.301239381022654
          }
     ]
}
{
     "operator": "m1",
     "algorithm_description": "A bidirectional informed RRT* planner that grows two trees from start and goal positions using heuristic-based informed sampling within an ellipsoidal subset, adaptive step sizing based on obstacle proximity, and dynamic rewiring for path cost improvement. The planner performs rigorous collision checks before adding nodes and edges, prunes inefficient extensions, and applies post-processing smoothing to yield high-quality, robust, and efficient paths.",
     "planning_mechanism": "A planner that alternates incremental growth between start and goal trees, samples points biased towards promising regions delimited by the current best path cost, adapts expansion steps to avoid obstacles, rewires locally to optimize path costs, attempts early tree connections to find feasible paths quickly, and refines solutions by smoothing the final path.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1, rewire_radius: float=15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import numpy as np\n        \n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start: List[Node] = [Node(start_position)]\n        tree_goal: List[Node] = [Node(goal_position)]\n        all_nodes: List[Node] = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        extracted_path: List[Tuple[float, ...]] = []\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate expanding between trees\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            # Sample point with goal bias and informed sampling\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position if tree_a is tree_start else start_position\n            else:\n                sample = self._informed_sample(start_position, goal_position, c_best, c_min, bounds, dim)\n\n            # Find nearest node in tree_a\n            nearest_node = min(tree_a, key=lambda n: math.dist(n.position, sample))\n\n            # Adaptive step size based on obstacle proximity\n            step = self._adaptive_step(nearest_node.position, sample, obstacles, is_3d)\n            new_position = self._steer(nearest_node.position, sample, step)\n\n            # Check bounds and collisions for new node\n            if not self._in_bounds(new_position, bounds):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Calculate new cost and prune if no improvement possible\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            if new_cost + c_min - 1e-6 >= c_best:\n                continue\n\n            new_node = Node(new_position)\n            # Double check the new node position is collision free before connecting\n            if self._is_in_obstacle(new_node.position, obstacles, is_3d):\n                continue\n\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire nodes in tree_a within rewire radius\n            near_nodes = [n for n in tree_a if n != new_node and math.dist(n.position, new_position) <= self.rewire_radius]\n            for near_node in near_nodes:\n                potential_cost = new_node.cost + math.dist(new_node.position, near_node.position)\n                if potential_cost + 1e-6 < near_node.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                        # Rewire near_node under new_node\n                        if near_node.parent:\n                            near_node.parent.remove_child(near_node)\n                            if (near_node.parent, near_node) in edges:\n                                edges.remove((near_node.parent, near_node))\n                        near_node.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near_node))\n\n            # Attempt to connect new_node to nearest node in other tree\n            nearest_to_new = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n            dist_between_trees = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between_trees + nearest_to_new.cost\n            if total_cost + 1e-6 < c_best:\n                # Check edge collision\n                if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_to_new.path_from_root()\n                    extracted_path = path_start + path_goal[::-1]\n                    success_state = True\n\n                    # Optional pruning could be placed here to prune nodes outside best path ellipsoid\n\n        # Path smoothing to improve final solution\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._smooth_path(extracted_path, obstacles, is_3d, bounds)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np\n        import random\n        import math\n\n        if c_best == float('inf'):\n            # Uniform sampling in entire bounds if no solution found yet\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        x_center = np.array([(s + g) / 2 for s, g in zip(start, goal)])\n        a1 = np.array(goal) - np.array(start)\n        length = np.linalg.norm(a1)\n        if length == 0:\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        a1 = a1 / length\n\n        # Compute rotation matrix C such that C * e1 = a1\n        I = np.eye(dim)\n        M = np.outer(a1, I[0])\n        U, _, Vt = np.linalg.svd(M)\n        C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n        r1 = c_best / 2.0\n        r2_sq = c_best**2 - c_min**2\n        r2 = math.sqrt(max(r2_sq, 0)) / 2.0 if r2_sq >= 0 else 0.0\n        L = np.diag([r1] + [r2] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_x_ball = np.linalg.norm(x_ball)\n            if norm_x_ball == 0:\n                continue\n            x_ball = x_ball / norm_x_ball\n            scale = random.random() ** (1/dim)\n            x_ball = x_ball * scale\n            x_rand = C @ L @ x_ball + x_center\n\n            in_bounds = True\n            for d in range(dim):\n                if x_rand[d] < 0 or x_rand[d] > bounds[d]:\n                    in_bounds = False\n                    break\n            if in_bounds:\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / steps for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step size near obstacle but maintain min step of 1.0\n                return max(self.base_step * 0.4, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        direction = tuple(to_pos[d] - from_pos[d] for d in range(len(from_pos)))\n        unit = tuple(d / dist for d in direction)\n        new_pos = tuple(from_pos[d] + unit[d] * step for d in range(len(from_pos)))\n        return new_pos\n\n    def _in_bounds(self, pos, bounds):\n        for d in range(len(bounds)):\n            if pos[d] < 0 or pos[d] > bounds[d]:\n                return False\n        return True\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        if len(path) < 3:\n            return path\n\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if not self._in_bounds(path[j], bounds):\n                    continue\n                next_idx = j\n                break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        dist = math.dist(from_pos, to_pos)\n        steps = max(1, int(dist / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 16562.45164,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 1.3538647174835206,
               "num_nodes_avg": 539.2,
               "path_length_avg": 161.55962216093243,
               "success_improvement": 0.0,
               "time_improvement": -13926.163141098476,
               "length_improvement": 19.254053673757387,
               "objective_score": -4173.998131594791
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 4.022277879714966,
               "num_nodes_avg": 2366.8,
               "path_length_avg": 223.50036658662253,
               "success_improvement": 0.0,
               "time_improvement": -27799.631712726,
               "length_improvement": 25.835017012636683,
               "objective_score": -8334.722510415273
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 4.000256752967834,
               "num_nodes_avg": 2612.9,
               "path_length_avg": 114.5478418728766,
               "success_improvement": 0.0,
               "time_improvement": -13532.210470895356,
               "length_improvement": 29.66072461196234,
               "objective_score": -4053.730996346214
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "An adaptive single-tree RRT* planner with informed sampling and goal biasing to efficiently explore the space and optimize path cost while maintaining collision-free conditions. The algorithm balances exploration and exploitation via adaptive neighbor radius, rewiring for path improvement, and early termination upon reaching the goal.",
     "planning_mechanism": "The planner samples points biased towards the goal and within an ellipsoidal informed subset after an initial path is found. It incrementally builds a tree by extending toward sampled points, connects new nodes optimally by selecting best parent from nearby nodes, rewires neighbors to reduce path cost, and stops early once the goal is reached, thus improving planning efficiency and path quality.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D or 3D\n        self.parent = parent            # Parent Node or None\n        self.cost = cost                # Cost to reach this node\n        self.children = []\n        self.valid = True               # For validity checks\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 4000, step_size: float = 5.0, goal_sample_rate: float = 0.1, base_neighbor_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.base_neighbor_radius = base_neighbor_radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math\n        import random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        best_goal_cost = float('inf')\n        goal_node = None\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def sample_in_bounds():\n            return tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n\n        def informed_sample(c_best):\n            c_min = dist(start_position, goal_position)\n            if c_best == float('inf') or c_best < c_min:\n                return sample_in_bounds()\n\n            dx = (goal_position[0] - start_position[0]) / c_min\n            dy = (goal_position[1] - start_position[1]) / c_min\n            if is_3d:\n                dz = (goal_position[2] - start_position[2]) / c_min\n\n            a = c_best / 2.0\n            b = math.sqrt(c_best ** 2 - c_min ** 2) / 2.0\n\n            while True:\n                if is_3d:\n                    x, y, z = (random.uniform(-1, 1) for _ in range(3))\n                    if x * x + y * y + z * z > 1:\n                        continue\n                    px = a * x\n                    py = b * y\n                    pz = b * z\n                    sample = (\n                        start_position[0] + (c_min/2)*dx + px,\n                        start_position[1] + (c_min/2)*dy + py,\n                        start_position[2] + (c_min/2)*dz + pz,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(3)):\n                        return sample\n                else:\n                    x, y = (random.uniform(-1, 1) for _ in range(2))\n                    if x * x + y * y > 1:\n                        continue\n                    px = a * x\n                    py = b * y\n                    sample = (\n                        start_position[0] + (c_min / 2) * dx + px,\n                        start_position[1] + (c_min / 2) * dy + py,\n                    )\n                    if all(0 <= sample[d] <= bounds[d] for d in range(2)):\n                        return sample\n\n        for _ in range(self.max_iter):\n            n = len(nodes)\n            dim = len(bounds)\n            gamma = self.base_neighbor_radius\n            r = min(gamma * ((math.log(n + 1) / (n + 1)) ** (1 / dim)), self.step_size * 20)\n\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            elif best_goal_cost == float('inf'):\n                sample = sample_in_bounds()\n            else:\n                sample = informed_sample(best_goal_cost)\n\n            nearest_node = min(nodes, key=lambda node: dist(node.position, sample))\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit_direction = tuple(d / dist_to_sample for d in direction)\n            step_size = min(self.step_size, dist_to_sample)\n            new_pos = tuple(nearest_node.position[d] + unit_direction[d]*step_size for d in range(dim))\n\n            if any(new_pos[d] < 0 or new_pos[d] > bounds[d] for d in range(dim)):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_node = Node(new_pos)\n            near_nodes = [node for node in nodes if dist(node.position, new_pos) <= r]\n\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near_node in near_nodes:\n                temp_cost = near_node.cost + dist(near_node.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_pos, obstacles, is_3d):\n                    min_cost = temp_cost\n                    best_parent = near_node\n\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for near_node in near_nodes:\n                if near_node is best_parent:\n                    continue\n                cost_through_new = new_node.cost + dist(new_node.position, near_node.position)\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    try:\n                        edges.remove((near_node.parent, near_node))\n                        near_node.parent.children.remove(near_node)\n                    except (ValueError, AttributeError):\n                        pass\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            dist_to_goal = dist(new_pos, goal_position)\n            if dist_to_goal <= self.step_size:\n                if not self._is_edge_in_obstacle(new_pos, goal_position, obstacles, is_3d) and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_cost = new_node.cost + dist_to_goal\n                    if goal_cost < best_goal_cost:\n                        best_goal_cost = goal_cost\n                        goal_node = Node(goal_position)\n                        goal_node.update_parent(new_node, goal_cost)\n                        nodes.append(goal_node)\n                        edges.append((new_node, goal_node))\n                        success_state = True\n                        break\n\n        if success_state and goal_node:\n            path = []\n            node = goal_node\n            while node:\n                path.append(node.position)\n                node = node.parent\n            extracted_path = path[::-1]\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 1057.72485,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.05420300960540771,
               "num_nodes_avg": 258.5,
               "path_length_avg": 195.6174078830838,
               "success_improvement": 0.0,
               "time_improvement": -461.548170689536,
               "length_improvement": 2.2322997161246128,
               "objective_score": -138.01799126363588
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.38426053524017334,
               "num_nodes_avg": 957.8,
               "path_length_avg": 305.69487982316457,
               "success_improvement": 0.0,
               "time_improvement": -2565.3373375823353,
               "length_improvement": -1.4399032433895034,
               "objective_score": -769.8891819233785
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.17789881229400634,
               "num_nodes_avg": 498.2,
               "path_length_avg": 146.09963278799526,
               "success_improvement": 0.0,
               "time_improvement": -506.24959883261295,
               "length_improvement": 10.286024278216255,
               "objective_score": -149.81767479414063
          }
     ]
}
{
     "operator": "e1",
     "algorithm_description": "This algorithm is a Hybrid RRT*-PRM planner integrating fast informed sampling, dynamic rewiring, and roadmap connection to accelerate convergence and improve path quality and robustness. It balances exploration with exploitation by using adaptive sampling biases near the goal and promising nodes, dynamically adjusting neighbor radius, and connecting disjoint roadmap components to avoid local minima. Post-processing with path smoothing ensures output paths are short and smooth.",
     "planning_mechanism": "The planner incrementally builds a tree from the start node using RRT* principles, enhanced with adaptive, biased sampling strategies\u2014favoring samples near the goal or nodes with low cost\u2014to guide the search efficiently. It periodically attempts to connect newly added nodes to existing roadmap nodes within a dynamically scaled neighbor radius for shortened paths. Collision checks prevent invalid expansions. The tree rewires neighbors to reduce path costs continuously. Upon reaching the goal vicinity, it finalizes the path and applies a shortcut smoothing heuristic to optimize it.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True               # Collision check flag\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            try:\n                self.parent.children.remove(self)\n            except ValueError:\n                pass\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.children.append(self)\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int=5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.15    # Probability of sampling the goal\n        self.bias_sample_rate = 0.20    # Probability of biased sample near promising nodes\n        self.neighbor_base_radius = 15.0\n        self.smooth_trials = 120\n\n    def plan(self, map) -> 'PlannerResult':\n        import random\n        import math\n\n        bounds = map.size\n        dim = len(bounds)\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n        is_3d = (dim == 3)\n\n        def in_bounds(p):\n            return all(0 <= p[d] <= bounds[d] for d in range(dim))\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        root = Node(start_position)\n        nodes.append(root)\n\n        # Maintain a subset of promising nodes for biased sampling (nodes with low cost)\n        promising_nodes = [root]\n\n        for i in range(self.max_iter):\n            # Adaptive radius shrinks as iteration progresses\n            radius = max(5.0, self.neighbor_base_radius * (1.0 - i / self.max_iter))\n\n            # Sampling strategy: goal bias, biased toward promising nodes, or uniform random\n            sample = None\n            p = random.random()\n            if p < self.goal_sample_rate:\n                sample = goal_position\n            elif p < self.goal_sample_rate + self.bias_sample_rate and len(promising_nodes) > 0:\n                # Biased sampling: random neighborhood of a randomly picked promising node\n                base_node = random.choice(promising_nodes)\n                sample = self._sample_near_node(base_node.position, bounds, obstacles, is_3d,\n                                                radius=self.step_size*3, max_trials=30)\n                if sample is None:\n                    # fallback to uniform random\n                    sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist = math.dist(nearest_node.position, sample)\n            if dist == 0:\n                continue\n            step_dist = min(self.step_size, dist)\n            unit_dir = tuple(direction[d]/dist for d in range(dim))\n            new_pos = tuple(nearest_node.position[d] + unit_dir[d]*step_dist for d in range(dim))\n\n            if not in_bounds(new_pos):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d, resolution=0.3):\n                continue\n\n            new_node = Node(new_pos)\n\n            # Find neighbors in radius for parent selection and rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_pos) <= radius]\n\n            # Choose best parent minimizing cost + collision-free edge\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for near in near_nodes:\n                temp_cost = near.cost + math.dist(near.position, new_pos)\n                if temp_cost < min_cost and not self._is_edge_in_obstacle(near.position, new_pos, obstacles, is_3d, resolution=0.3):\n                    min_cost = temp_cost\n                    best_parent = near\n\n            new_node.update_parent(best_parent, min_cost)\n\n            # Add new node\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors for better costs\n            for near in near_nodes:\n                if near == best_parent:\n                    continue\n                cost_through_new = new_node.cost + math.dist(new_node.position, near.position)\n                if cost_through_new < near.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d, resolution=0.3):\n                        try:\n                            edges.remove((near.parent, near))\n                        except ValueError:\n                            pass\n                        near.update_parent(new_node, cost_through_new)\n                        edges.append((new_node, near))\n\n            # Update promising nodes list on improvements near goal and low-cost nodes\n            if new_node.cost < 1.1 * (math.dist(start_position, goal_position)):\n                promising_nodes.append(new_node)\n                # Keep promising nodes list size tractable\n                if len(promising_nodes) > 50:\n                    promising_nodes = sorted(promising_nodes, key=lambda n: n.cost)[:40]\n\n            # Check if goal reachable with tolerance and edge check\n            dist_to_goal = math.dist(new_node.position, goal_position)\n            if dist_to_goal <= self.step_size * 1.1:\n                if not self._is_edge_in_obstacle(new_node.position, goal_position, obstacles, is_3d, resolution=0.3) \\\n                   and not self._is_in_obstacle(goal_position, obstacles, is_3d):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n                    extracted_path = goal_node.path_from_root()\n                    break\n\n        # If success, perform path smoothing by shortcuts\n        if success_state and len(extracted_path) > 2:\n            extracted_path = self._shortcut_smooth(extracted_path, obstacles, is_3d, trials=self.smooth_trials)\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _sample_near_node(self, base_pos, bounds, obstacles, is_3d, radius=10.0, max_trials=20):\n        import random\n        import math\n        dim = len(bounds)\n        for _ in range(max_trials):\n            sample = tuple(base_pos[d] + random.uniform(-radius, radius) for d in range(dim))\n            # clamp in bounds\n            sample = tuple(max(0, min(bounds[d], sample[d])) for d in range(dim))\n            if not self._is_in_obstacle(sample, obstacles, is_3d):\n                return sample\n        return None\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _shortcut_smooth(self, path, obstacles, is_3d, trials=100):\n        import random\n        if len(path) < 3:\n            return path\n        for _ in range(trials):\n            if len(path) <= 2:\n                break\n            i = random.randint(0, len(path) - 3)\n            j = random.randint(i + 2, len(path) - 1)\n            p_start = path[i]\n            p_end = path[j]\n            if not self._is_edge_in_obstacle(p_start, p_end, obstacles, is_3d, resolution=0.3):\n                # shortcut valid - remove intermediate points\n                path = path[:i+1] + path[j:]\n        return path",
     "objective": 3409.08787,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.3506051778793335,
               "num_nodes_avg": 427.8,
               "path_length_avg": 158.8067430302588,
               "success_improvement": 0.0,
               "time_improvement": -3532.3019276179944,
               "length_improvement": 20.62991620397912,
               "objective_score": -1055.5645950446024
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 1.0019539833068847,
               "num_nodes_avg": 1529.5,
               "path_length_avg": 223.2041553079148,
               "success_improvement": 0.0,
               "time_improvement": -6849.829913129184,
               "length_improvement": 25.933309936185474,
               "objective_score": -2049.762311951518
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.33193111419677734,
               "num_nodes_avg": 674.7,
               "path_length_avg": 117.34303407628109,
               "success_improvement": 0.0,
               "time_improvement": -1031.1660950793112,
               "length_improvement": 27.94430821386066,
               "objective_score": -303.7609668810212
          }
     ]
}
{
     "operator": "e2",
     "algorithm_description": "This hybrid planner combines the bidirectional growth and tree swapping of BI-RRT with the informed sampling, adaptive step sizing, rewiring, and pruning strategies of RRT*-Connect. It grows two trees simultaneously from the start and goal, utilizes heuristic-informed sampling within an ellipse shaped by the current best path cost to focus exploration, adapts step size near obstacles to enhance safety and efficiency, prunes nodes that cannot improve the solution, rewires locally to optimize path costs, and swaps trees iteratively to balance exploration. This approach improves planning efficiency, path quality, robustness, success rate, and reduces search time and path length in both 2D and 3D environments.",
     "planning_mechanism": "The planner samples points informed by the current best path cost to bias search toward promising regions. It expands trees bidirectionally with adaptive step sizes to avoid obstacles and improve safety. Upon adding new nodes, local rewiring optimizes paths by reducing costs, and pruning discards nodes unlikely to improve the best path. The two trees attempt connection on each iteration, with paths reconstructed and updated when successful, producing shorter, smoother, and more reliable paths efficiently.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...]\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def remove_child(self, child):\n        if child in self.children:\n            self.children.remove(child)\n            child.parent = None\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.base_step = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math, random, numpy as np\n\n        bounds = map.size\n        start_pos = map.start\n        goal_pos = map.goal\n        obstacles = map.obstacles\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        # Initialize trees\n        root_start = Node(start_pos, cost=0.0)\n        root_goal = Node(goal_pos, cost=0.0)\n        tree_start = [root_start]\n        tree_goal = [root_goal]\n\n        nodes = [root_start, root_goal]\n        edges = []\n\n        success = False\n        best_path = []\n        c_min = math.dist(start_pos, goal_pos)\n        c_best = float('inf')\n\n        for i in range(self.max_iter):\n            # Alternate trees\n            if i % 2 == 0:\n                tree_a, tree_b = tree_start, tree_goal\n            else:\n                tree_a, tree_b = tree_goal, tree_start\n\n            # Informed sampling\n            sample = self._informed_sample(start_pos, goal_pos, c_best, c_min, bounds, dim)\n\n            # Find nearest in tree_a and adaptive step size\n            nearest = min(tree_a, key=lambda n: math.dist(n.position, sample))\n            step = self._adaptive_step(nearest.position, sample, obstacles, is_3d)\n            new_pos = self._steer(nearest.position, sample, step)\n\n            # Check node feasibility\n            if not self._in_bounds(new_pos, bounds):\n                continue\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                continue\n\n            cost = nearest.cost + math.dist(nearest.position, new_pos)\n            # Prune if cannot improve current best path\n            est_total_cost = cost + math.dist(new_pos, goal_pos)\n            if est_total_cost >= c_best:\n                continue\n\n            # Create and add new node\n            new_node = Node(new_pos, parent=nearest, cost=cost)\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            # Rewire near nodes in tree_a\n            near_nodes = [n for n in tree_a if n is not new_node and math.dist(n.position, new_pos) <= self.rewire_radius]\n\n            for near in near_nodes:\n                dist_new_to_near = math.dist(new_node.position, near.position)\n                potential_cost = new_node.cost + dist_new_to_near\n                if potential_cost < near.cost:\n                    # Check edge feasibility before rewiring\n                    if not self._is_edge_in_obstacle(new_node.position, near.position, obstacles, is_3d):\n                        # Remove old parent-child edge\n                        if near.parent is not None:\n                            near.parent.remove_child(near)\n                            if (near.parent, near) in edges:\n                                edges.remove((near.parent, near))\n                        # Rewire\n                        near.parent = new_node\n                        near.cost = potential_cost\n                        new_node.add_child(near)\n                        edges.append((new_node, near))\n\n            # Try connecting new_node to tree_b\n            nearest_b = min(tree_b, key=lambda n: math.dist(n.position, new_node.position))\n\n            if not self._is_edge_in_obstacle(new_node.position, nearest_b.position, obstacles, is_3d):\n                path_cost = new_node.cost + math.dist(new_node.position, nearest_b.position) + nearest_b.cost\n                if path_cost < c_best:\n                    c_best = path_cost\n                    # Construct full path\n                    path_a = new_node.path_from_root()\n                    path_b = nearest_b.path_from_root()\n                    # Remove duplicated connecting node at connection point\n                    if path_b:\n                        path_b.reverse()\n                    best_path = path_a + path_b[1:] if len(path_b) > 1 else path_a + path_b\n                    success = True\n\n                    # Prune nodes in both trees that can't improve better than c_best\n                    self._prune_tree(tree_start, c_best, goal_pos, obstacles, is_3d)\n                    self._prune_tree(tree_goal, c_best, start_pos, obstacles, is_3d)\n\n            # Swap trees for next iteration\n            if i % 2 == 0:\n                tree_start, tree_goal = tree_a, tree_b\n            else:\n                tree_goal, tree_start = tree_a, tree_b\n\n        return PlannerResult(success=success, path=best_path, nodes=nodes, edges=edges)\n\n    def _informed_sample(self, start, goal, c_best, c_min, bounds, dim):\n        import numpy as np, math, random\n        if c_best == float('inf'):\n            # Uniform random sample in bounds\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n        c_best = max(c_best, c_min)  # Ensure c_best >= c_min\n        x_center_np = (np.array(start) + np.array(goal)) / 2\n        a1 = np.array(goal) - np.array(start)\n        norm_a1 = np.linalg.norm(a1)\n        if norm_a1 == 0:\n            # Start and goal coincide\n            return tuple(start)\n        a1 = a1 / norm_a1\n\n        # Create orthonormal basis\n        id1 = np.zeros((dim,))\n        id1[0] = 1\n        M = np.outer(a1, id1)\n        U, _, Vt = np.linalg.svd(M)\n        det = np.linalg.det(U) * np.linalg.det(Vt)\n        C = U @ np.diag([1] * (dim - 1) + [det]) @ Vt\n\n        r1 = c_best / 2\n        if c_best * c_best - c_min * c_min < 0:\n            r2_val = 0\n        else:\n            r2_val = math.sqrt(c_best * c_best - c_min * c_min) / 2\n        L = np.diag([r1] + [r2_val] * (dim - 1))\n\n        while True:\n            x_ball = np.random.normal(0, 1, dim)\n            norm_ball = np.linalg.norm(x_ball)\n            if norm_ball == 0:\n                continue\n            x_ball = x_ball / norm_ball\n            radius_sample = random.random() ** (1 / dim)\n            x_ball = x_ball * radius_sample\n            x_rand = C @ L @ x_ball + x_center_np\n            if all(0 <= x_rand[d] <= bounds[d] for d in range(dim)):\n                return tuple(x_rand)\n\n    def _adaptive_step(self, from_pos, to_pos, obstacles, is_3d):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        steps = max(2, int(dist))\n        for i in range(1, steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                # Reduce step near obstacle but keep minimum 1.0 to avoid too small steps\n                return max(self.base_step * 0.3, 1.0)\n        return self.base_step\n\n    def _steer(self, from_pos, to_pos, step):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= step:\n            return to_pos\n        ratio = step / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _prune_tree(self, tree, c_best, opposite_root_pos, obstacles, is_3d):\n        import math\n        # Remove nodes whose cost + heuristic to goal exceed c_best\n        to_remove = []\n        for node in tree:\n            heuristic = math.dist(node.position, opposite_root_pos)\n            if node.cost + heuristic >= c_best:\n                to_remove.append(node)\n        for node in to_remove:\n            # Avoid removing root nodes\n            if node.parent is None:\n                continue\n            # Disconnect node from parent\n            if node.parent:\n                node.parent.remove_child(node)\n            # Remove descendants recursively\n            self._remove_subtree(node, tree)\n\n    def _remove_subtree(self, node, tree):\n        # Remove children recursively\n        for c in list(node.children):\n            self._remove_subtree(c, tree)\n        if node in tree:\n            tree.remove(node)\n        node.children.clear()\n        node.parent = None\n\n    def _in_bounds(self, pos, bounds):\n        return all(0 <= pos[d] <= bounds[d] for d in range(len(bounds)))\n\n    # Placeholder methods for obstacle checks - should be implemented or available from the imported utilities\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        # Assuming map or utility has method to check if position is inside obstacle\n        for obs in obstacles:\n            if self._point_in_obstacle(pos, obs, is_3d):\n                return True\n        return False\n\n    def _is_edge_in_obstacle(self, p1, p2, obstacles, is_3d):\n        # Assuming map or utility has method to check if edge intersects obstacle\n        for obs in obstacles:\n            if self._edge_intersects_obstacle(p1, p2, obs, is_3d):\n                return True\n        return False\n\n    def _point_in_obstacle(self, pos, obstacle, is_3d):\n        # Placeholder: implement actual point-obstacle collision check\n        return False\n\n    def _edge_intersects_obstacle(self, p1, p2, obstacle, is_3d):\n        # Placeholder: implement actual edge-obstacle collision check\n        return False",
     "objective": 13046.95822,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 2.5610111951828003,
               "num_nodes_avg": 1278.2,
               "path_length_avg": 138.59292911256324,
               "success_improvement": 0.0,
               "time_improvement": -26432.31180777173,
               "length_improvement": 30.73258611503557,
               "objective_score": -7923.547025108512
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 1.6417880535125733,
               "num_nodes_avg": 1293.2,
               "path_length_avg": 92.84934033152844,
               "success_improvement": 0.0,
               "time_improvement": -11287.89596670035,
               "length_improvement": 69.18944764501393,
               "objective_score": -3372.5309004811015
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 1.757906436920166,
               "num_nodes_avg": 1275.4,
               "path_length_avg": 30.0,
               "success_improvement": 0.0,
               "time_improvement": -5890.653104568392,
               "length_improvement": 81.57819276959427,
               "objective_score": -1750.8802928165987
          }
     ]
}
{
     "operator": "m1",
     "algorithm_description": "This algorithm implements an enhanced Bidirectional RRT* planner with goal biasing, informed sampling, adaptive rewiring radius, and path smoothing to improve planning efficiency, path quality, robustness, and success rate. It dynamically expands two trees from start and goal, rewires nodes based on cost, and attempts connections while carefully avoiding obstacles. Once a path is found, it performs post-processing smoothing to reduce path length and increase smoothness.",
     "planning_mechanism": "The planner samples points preferentially near the line connecting start and goal (informed sampling), uses a goal bias to accelerate convergence, employs an adaptive radius for rewiring based on the number of nodes in each tree, and alternates tree expansions bidirectionally. It includes rigorous collision checks for nodes and edges. When connection occurs, the path is extracted and smoothed by shortcutting.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def distance(self, other_pos):\n        import math\n        return math.dist(self.position, other_pos)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = 0.1   # Probability of sampling goal to bias search\n        self.rewire_constant = 30.0   # Constant factor for rewiring radius\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path = []\n        nodes = []\n        edges = []\n\n        start_root = Node(start_position)\n        goal_root = Node(goal_position)\n        nodes.extend([start_root, goal_root])\n        tree_a, tree_b = [start_root], [goal_root]\n\n        for iter_num in range(self.max_iter):\n\n            # Goal biasing: sample goal directly with some probability\n            if random.random() < self.goal_sample_rate:\n                rand_point = goal_position\n            else:\n                rand_point = self._informed_sample(bounds, obstacles, is_3d, start_position, goal_position)\n\n            new_a = self._extend_and_rewire(tree_a, rand_point, obstacles, is_3d, nodes, edges)\n            if new_a is None:\n                tree_a, tree_b = tree_b, tree_a  \n                continue\n\n            new_b = self._connect_and_rewire(tree_b, new_a, obstacles, is_3d, nodes, edges)\n            if new_b is not None:\n                # Connection successful - reconstruct and smooth path\n                success_state = True\n                path_a = new_a.path_from_root()\n                path_b = new_b.path_from_root()\n                raw_path = path_a + path_b[::-1]\n                extracted_path = self._smooth_path(raw_path, obstacles, is_3d)\n                break\n\n            tree_a, tree_b = tree_b, tree_a\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _informed_sample(self, bounds, obstacles, is_3d, start, goal):\n        # Samples inside an ellipsoidal informed region between start and goal to focus search and improve path quality\n        import random, math\n\n        dim = len(bounds)\n        c_best = math.dist(start, goal)\n        center = tuple((start[i] + goal[i]) / 2 for i in range(dim))\n        unit_vec = tuple((goal[i] - start[i]) / c_best if c_best > 0 else 0.0 for i in range(dim))\n\n        # Radii of ellipsoid (min radius is step_size)\n        radii = [c_best / 2 if i == 0 else math.sqrt(c_best**2 - self.step_size**2) / 2 for i in range(dim)]\n\n        # Sample random point in unit n-ball\n        while True:\n            # Sample in unit n-ball\n            point_ball = self._sample_unit_ball(dim)\n            # Scale by radii\n            scaled = tuple(point_ball[i] * radii[i] for i in range(dim))\n\n            # Rotate scaled point to align with the axis from start to goal\n            rotated = self._rotate_to_unit_vector(scaled, unit_vec)\n\n            sample_point = tuple(center[i] + rotated[i] for i in range(dim))\n            # Check bounds and obstacle free\n            if all(0 <= sample_point[i] <= bounds[i] for i in range(dim)) and not self._is_in_obstacle(sample_point, obstacles, is_3d):\n                return sample_point\n\n    def _sample_unit_ball(self, dim):\n        import random, math\n        # Marsaglia method for uniform distribution in n-ball\n        while True:\n            coords = [random.uniform(-1, 1) for _ in range(dim)]\n            length_sq = sum(x*x for x in coords)\n            if 0 < length_sq <= 1:\n                scale = random.random() ** (1.0/dim) / (length_sq ** 0.5)\n                return tuple(x * scale for x in coords)\n\n    def _rotate_to_unit_vector(self, vec, unit_vec):\n        # Rotate vec so that x-axis aligns with unit_vec in dim-dimensional space (dim=2 or 3)\n        # For 2D and 3D only\n        import math\n        dim = len(vec)\n        if dim == 2:\n            # Angle between x-axis and unit_vec\n            angle = math.atan2(unit_vec[1], unit_vec[0])\n            cos_a = math.cos(angle)\n            sin_a = math.sin(angle)\n            x, y = vec\n            return (cos_a * x - sin_a * y, sin_a * x + cos_a * y)\n        elif dim == 3:\n            # Rotate using Rodrigues' rotation formula\n            # unit_vec is axis; rotation aligns x-axis to unit_vec\n            x_axis = (1, 0, 0)\n            v = unit_vec\n            # cross product x_axis x v\n            import numpy as np\n            a = np.array(x_axis)\n            b = np.array(v)\n            cross = np.cross(a, b)\n            dot = np.dot(a, b)\n            if np.linalg.norm(cross) < 1e-10:\n                return vec  # Already aligned or opposite\n            k = cross / np.linalg.norm(cross)\n            vec_np = np.array(vec)\n            cos_theta = dot\n            sin_theta = np.linalg.norm(cross)\n            rotated = (vec_np * cos_theta +\n                       np.cross(k, vec_np) * sin_theta +\n                       k * np.dot(k, vec_np) * (1 - cos_theta))\n            return tuple(rotated.tolist())\n        else:\n            # No rotation for other dims\n            return vec\n\n    def _nearest(self, tree, point):\n        import math\n        return min(tree, key=lambda node: math.dist(node.position, point))\n\n    def _steer(self, from_pos, to_pos):\n        import math\n        dist = math.dist(from_pos, to_pos)\n        if dist <= self.step_size:\n            return to_pos\n        ratio = self.step_size / dist\n        return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(len(from_pos)))\n\n    def _near_nodes(self, tree, position):\n        import math\n        if not tree:\n            return []\n        n = len(tree) + 1\n        radius = min(self.rewire_constant * (math.log(n) / n) ** 0.5, self.step_size * 5)  # Adaptive radius\n        return [node for node in tree if math.dist(node.position, position) <= radius]\n\n    def _extend_and_rewire(self, tree, point, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, point)\n        new_pos = self._steer(nearest.position, point)\n\n        if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n           self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n            return None\n\n        new_node = Node(new_pos)\n        neighbors = self._near_nodes(tree, new_pos)\n\n        min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n        best_parent = nearest\n        for neighbor in neighbors:\n            cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n            if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                min_cost = cost\n                best_parent = neighbor\n\n        best_parent.add_child(new_node)\n        new_node.cost = min_cost\n        new_node.parent = best_parent\n        tree.append(new_node)\n        nodes.append(new_node)\n        edges.append((best_parent, new_node))\n\n        # Rewire neighbors\n        for neighbor in neighbors:\n            new_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n            if new_cost < neighbor.cost and not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                if neighbor.parent:\n                    try:\n                        edges.remove((neighbor.parent, neighbor))\n                    except ValueError:\n                        pass\n                    if neighbor.parent.children and neighbor in neighbor.parent.children:\n                        neighbor.parent.children.remove(neighbor)\n                neighbor.parent = new_node\n                neighbor.cost = new_cost\n                new_node.add_child(neighbor)\n                edges.append((new_node, neighbor))\n\n        return new_node\n\n    def _connect_and_rewire(self, tree, new_node, obstacles, is_3d, nodes, edges):\n        import math\n        nearest = self._nearest(tree, new_node.position)\n        last_node = None\n\n        while True:\n            new_pos = self._steer(nearest.position, new_node.position)\n\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest.position, new_pos, obstacles, is_3d):\n                return None\n\n            connect_node = Node(new_pos)\n            neighbors = self._near_nodes(tree, new_pos)\n\n            min_cost = nearest.cost + math.dist(nearest.position, new_pos)\n            best_parent = nearest\n            for neighbor in neighbors:\n                cost = neighbor.cost + math.dist(neighbor.position, new_pos)\n                if cost < min_cost and not self._is_edge_in_obstacle(neighbor.position, new_pos, obstacles, is_3d):\n                    min_cost = cost\n                    best_parent = neighbor\n\n            best_parent.add_child(connect_node)\n            connect_node.cost = min_cost\n            connect_node.parent = best_parent\n            tree.append(connect_node)\n            nodes.append(connect_node)\n            edges.append((best_parent, connect_node))\n\n            # Rewire neighbors\n            for neighbor in neighbors:\n                new_cost = connect_node.cost + math.dist(connect_node.position, neighbor.position)\n                if new_cost < neighbor.cost and not self._is_edge_in_obstacle(connect_node.position, neighbor.position, obstacles, is_3d):\n                    if neighbor.parent:\n                        try:\n                            edges.remove((neighbor.parent, neighbor))\n                        except ValueError:\n                            pass\n                        if neighbor.parent.children and neighbor in neighbor.parent.children:\n                            neighbor.parent.children.remove(neighbor)\n                    neighbor.parent = connect_node\n                    neighbor.cost = new_cost\n                    connect_node.add_child(neighbor)\n                    edges.append((connect_node, neighbor))\n\n            if math.dist(connect_node.position, new_node.position) <= self.step_size:\n                last_node = connect_node\n                break\n\n            nearest = connect_node\n\n        return last_node\n\n    def _smooth_path(self, path, obstacles, is_3d):\n        import random\n        if len(path) <= 2:\n            return path\n\n        smooth_path = path[:]\n        max_attempts = 100\n        attempt = 0\n\n        while attempt < max_attempts:\n            if len(smooth_path) <= 2:\n                break\n            i = random.randint(0, len(smooth_path) - 2)\n            j = random.randint(i + 1, len(smooth_path) - 1)\n\n            p1, p2 = smooth_path[i], smooth_path[j]\n            if self._is_edge_in_obstacle(p1, p2, obstacles, is_3d):\n                attempt += 1\n                continue\n\n            # Remove intermediate points between i and j\n            smooth_path = smooth_path[:i+1] + smooth_path[j:]\n            attempt += 1\n\n        return smooth_path\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 88.68264,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.03950786590576172,
               "num_nodes_avg": 80.6,
               "path_length_avg": 158.97770322182237,
               "success_improvement": 0.0,
               "time_improvement": -309.30512878780394,
               "length_improvement": 20.544471943418976,
               "objective_score": -88.68264424765738
          },
          {
               "map_id": 1,
               "success_rate": 0.0,
               "time_avg": 1.5421787738800048,
               "num_nodes_avg": 2367.2,
               "path_length_avg": NaN,
               "success_improvement": -100.0,
               "time_improvement": -10596.978456765522,
               "length_improvement": NaN,
               "objective_score": NaN
          },
          {
               "map_id": 2,
               "success_rate": 0.0,
               "time_avg": 1.7752649545669557,
               "num_nodes_avg": 2511.0,
               "path_length_avg": NaN,
               "success_improvement": -100.0,
               "time_improvement": -5949.808049022452,
               "length_improvement": NaN,
               "objective_score": NaN
          }
     ]
}
{
     "operator": "m2",
     "algorithm_description": "This is an optimized RRT* (Rapidly-exploring Random Tree Star) planner that improves path planning efficiency and path quality by introducing goal biasing, adaptive neighbor radius based on the iteration number, and a refined rewiring strategy. It ensures robustness and path smoothness by meticulous collision checking and node steering within bounds, balancing exploration and exploitation for faster convergence and higher success rates.",
     "planning_mechanism": "The planner samples points with a bias towards the goal, extends the tree by steering from the nearest node within a fixed step size, dynamically adjusts the neighborhood radius for selecting parents and rewiring, and rewire nodes for cost optimality while always checking for collision-free nodes and edges. The path is extracted once a connection to the goal is found.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n\n    def remove_child(self, child_node):\n        if child_node in self.children:\n            self.children.remove(child_node)\n\n    def update_parent(self, new_parent, new_cost):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        if new_parent:\n            new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 4.0, goal_sample_rate: float = 0.1, \n                 neighbor_radius_initial: float = 15.0, neighbor_radius_min: float = 5.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.neighbor_radius_initial = neighbor_radius_initial\n        self.neighbor_radius_min = neighbor_radius_min\n\n    def plan(self, map) -> PlannerResult:\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...] (W,H) or (W,H,D)\n        goal_position = map.goal           # Tuple[float, ...] (W,H) or (W,H,D)\n        obstacles = map.obstacles          # Rectangular blocks: 2D=(x,y,w,h), 3D=(x,y,z,w,h,d)\n\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        success_state = False\n        extracted_path: list[tuple[float, ...]] = []\n        nodes: list[Node] = []\n        edges: list[tuple[Node, Node]] = []\n\n        root = Node(start_position, parent=None, cost=0.0)\n        nodes.append(root)\n\n        def in_bounds(pos):\n            # Check if position lies within the map bounds (inclusive)\n            for i in range(dim):\n                if pos[i] < 0 or pos[i] > bounds[i]:\n                    return False\n            return True\n\n        for i in range(1, self.max_iter + 1):\n            # Adaptive neighbor radius decreasing with iteration count\n            neighbor_radius = max(\n                self.neighbor_radius_min,\n                self.neighbor_radius_initial * (1 - (i / self.max_iter))\n            )\n\n            # Sampling with goal biasing\n            if random.random() < self.goal_sample_rate:\n                sample = goal_position\n            else:\n                sample = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n            if not in_bounds(sample):\n                continue\n            if self._is_in_obstacle(sample, obstacles, is_3d):\n                continue\n\n            # Find nearest node\n            nearest_node = min(nodes, key=lambda n: math.dist(n.position, sample))\n\n            # Steer towards sample with step size limit\n            direction = tuple(sample[d] - nearest_node.position[d] for d in range(dim))\n            dist_to_sample = math.dist(nearest_node.position, sample)\n            if dist_to_sample == 0:\n                continue\n            unit = tuple(d / dist_to_sample for d in direction)\n            new_position = tuple(nearest_node.position[d] + unit[d] * min(self.step_size, dist_to_sample) for d in range(dim))\n\n            if not in_bounds(new_position):\n                continue\n            if self._is_in_obstacle(new_position, obstacles, is_3d):\n                continue\n            if self._is_edge_in_obstacle(nearest_node.position, new_position, obstacles, is_3d):\n                continue\n\n            # Find nearby nodes for parent selection and rewiring\n            near_nodes = [n for n in nodes if math.dist(n.position, new_position) <= neighbor_radius]\n\n            min_cost = nearest_node.cost + math.dist(nearest_node.position, new_position)\n            best_parent = nearest_node\n\n            for near_node in near_nodes:\n                # Check if path from near_node to new_position is collision free and cost less\n                dist_to_new = math.dist(near_node.position, new_position)\n                if dist_to_new == 0:\n                    continue\n                tentative_cost = near_node.cost + dist_to_new\n                if tentative_cost < min_cost and not self._is_edge_in_obstacle(near_node.position, new_position, obstacles, is_3d):\n                    min_cost = tentative_cost\n                    best_parent = near_node\n\n            new_node = Node(new_position)\n            new_node.update_parent(best_parent, min_cost)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewiring: try to improve paths of neighbors through new_node\n            for near_node in near_nodes:\n                if near_node == best_parent:\n                    continue\n                dist_back = math.dist(new_node.position, near_node.position)\n                if dist_back == 0:\n                    continue\n                cost_through_new = new_node.cost + dist_back\n                if cost_through_new < near_node.cost and not self._is_edge_in_obstacle(new_node.position, near_node.position, obstacles, is_3d):\n                    # Remove old edge\n                    if (near_node.parent, near_node) in edges:\n                        edges.remove((near_node.parent, near_node))\n                    near_node.update_parent(new_node, cost_through_new)\n                    edges.append((new_node, near_node))\n\n            # Check if new_node can connect directly to goal\n            dist_to_goal = math.dist(new_position, goal_position)\n            if dist_to_goal <= self.step_size:\n                if (not self._is_in_obstacle(goal_position, obstacles, is_3d)\n                    and not self._is_edge_in_obstacle(new_position, goal_position, obstacles, is_3d)):\n                    goal_node = Node(goal_position)\n                    goal_cost = new_node.cost + dist_to_goal\n                    goal_node.update_parent(new_node, goal_cost)\n                    nodes.append(goal_node)\n                    edges.append((new_node, goal_node))\n                    success_state = True\n\n                    # Extract path from goal_node back to root\n                    path = []\n                    cur = goal_node\n                    while cur is not None:\n                        path.append(cur.position)\n                        cur = cur.parent\n                    extracted_path = path[::-1]\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 1909.00205,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.1652271032333374,
               "num_nodes_avg": 327.9,
               "path_length_avg": 163.47927774122377,
               "success_improvement": 0.0,
               "time_improvement": -1611.7680041101441,
               "length_improvement": 18.294628265491244,
               "objective_score": -479.87147557994496
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.6792936563491822,
               "num_nodes_avg": 1230.4,
               "path_length_avg": 228.64177193970622,
               "success_improvement": 0.0,
               "time_improvement": -4611.7686553958965,
               "length_improvement": 24.128924774999103,
               "objective_score": -1378.704811663769
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.08417313098907471,
               "num_nodes_avg": 325.5,
               "path_length_avg": 117.01906946474912,
               "success_improvement": 0.0,
               "time_improvement": -186.84804713747266,
               "length_improvement": 28.14324200129783,
               "objective_score": -50.425765740982236
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "A simplified hybrid bidirectional informed RRT* planner combining the strengths of informed sampling, adaptive step sizing, dynamic rewiring, branch pruning, and incremental path smoothing to efficiently generate high-quality, smooth, and robust paths with improved success rate and reduced search time.",
     "planning_mechanism": "The planner alternately grows two trees from start and goal positions using an ellipsoidal informed sampling strategy constrained by the best known path cost. It adaptively determines step sizes near obstacles to ensure safety and efficiency. New nodes and edges undergo strict collision and edge feasibility checks. Local rewiring is dynamically performed based on neighborhood density to optimize path costs. Branch pruning removes nodes unlikely to improve solutions, and incremental smoothing refines the current best path periodically, balancing exploration and exploitation for optimal path discovery.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position\n        self.parent = parent\n        self.cost = cost\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node: 'Node'):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: 'Node'):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: 'Node', new_cost: float):\n        if self.parent:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float = 5.0, goal_sample_rate: float = 0.15, rewire_base_radius: float = 20.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate\n        self.rewire_base_radius = rewire_base_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n        import numpy as np\n\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        dim = len(bounds)\n        is_3d = (dim == 3)\n\n        tree_start = [Node(start_position, cost=0.0)]\n        tree_goal = [Node(goal_position, cost=0.0)]\n        all_nodes = [tree_start[0], tree_goal[0]]\n        edges = []\n\n        success = False\n        best_cost = float('inf')\n        best_path: List[Tuple[float, ...]] = []\n\n        c_min = math.dist(start_position, goal_position)\n        c_best = float('inf')\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def in_bounds(pos):\n            return all(0 <= pos[d] <= bounds[d] for d in range(dim))\n\n        def informed_sample(c_best_val):\n            if c_best_val == float('inf'):\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            center = np.array([(s + g) / 2 for s, g in zip(start_position, goal_position)])\n            a = np.array(goal_position) - np.array(start_position)\n            length = np.linalg.norm(a)\n            if length == 0:\n                return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n            a_unit = a / length\n            M = np.outer(a_unit, np.eye(dim)[0])\n            U, _, Vt = np.linalg.svd(M)\n            C = U @ np.diag([1] * (dim - 1) + [np.linalg.det(U) * np.linalg.det(Vt)]) @ Vt\n\n            r1 = c_best_val / 2.0\n            val = max(c_best_val ** 2 - c_min ** 2, 0)\n            r2 = math.sqrt(val) / 2.0\n\n            L = np.diag([r1] + [r2] * (dim - 1))\n            for _ in range(100):\n                x_ball = np.random.normal(0, 1, dim)\n                norm_ball = np.linalg.norm(x_ball)\n                if norm_ball == 0:\n                    continue\n                x_ball /= norm_ball\n                scale = random.random() ** (1 / dim)\n                x_ball *= scale\n                sampled = C @ L @ x_ball + center\n                if np.all((sampled >= 0) & (sampled <= np.array(bounds))):\n                    return tuple(sampled)\n            return tuple(random.uniform(0, bounds[d]) for d in range(dim))\n\n        def adaptive_step(from_pos, to_pos):\n            dist_full = dist(from_pos, to_pos)\n            max_pts = max(5, int(dist_full))\n            for i in range(1, max_pts + 1):\n                interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * i / max_pts for d in range(dim))\n                if self._is_in_obstacle(interp, obstacles, is_3d):\n                    return max(self.step_size * 0.4, 1.0)\n            return self.step_size\n\n        def steer(from_pos, to_pos, step):\n            direction = tuple(to_pos[d] - from_pos[d] for d in range(dim))\n            dist_full = dist(from_pos, to_pos)\n            if dist_full <= step:\n                return to_pos\n            unit_dir = tuple(d / dist_full for d in direction)\n            return tuple(from_pos[d] + unit_dir[d] * step for d in range(dim))\n\n        def rewire_radius(n_nodes):\n            gamma = self.rewire_base_radius\n            if n_nodes <= 1:\n                return gamma\n            val = (math.log(n_nodes) / n_nodes) ** (1 / dim)\n            return min(gamma * val, self.step_size * 25)\n\n        def valid_new_node_and_edge(from_pos, to_pos):\n            if not in_bounds(to_pos):\n                return False\n            if self._is_in_obstacle(to_pos, obstacles, is_3d):\n                return False\n            if self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n                return False\n            return True\n\n        def prune_nodes(tree_nodes, cost_threshold):\n            to_remove = [node for node in tree_nodes if node.cost > cost_threshold]\n            for node in to_remove:\n                if node.parent:\n                    node.parent.remove_child(node)\n                stack = node.children[:]\n                while stack:\n                    child = stack.pop()\n                    if child in tree_nodes:\n                        tree_nodes.remove(child)\n                    stack.extend(child.children)\n                if node in tree_nodes:\n                    tree_nodes.remove(node)\n\n        def smooth_path(path_in: List[Tuple[float, ...]]) -> List[Tuple[float, ...]]:\n            if len(path_in) < 3:\n                return path_in\n            smoothed = [path_in[0]]\n            idx = 0\n            while idx < len(path_in) - 1:\n                next_idx = len(path_in) - 1\n                for j in range(len(path_in) - 1, idx, -1):\n                    if (not self._is_edge_in_obstacle(smoothed[-1], path_in[j], obstacles, is_3d) and in_bounds(path_in[j])):\n                        next_idx = j\n                        break\n                if next_idx == idx:\n                    smoothed.append(path_in[idx + 1])\n                    idx += 1\n                else:\n                    smoothed.append(path_in[next_idx])\n                    idx = next_idx\n                if smoothed[-1] == path_in[-1]:\n                    break\n            return smoothed\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n\n            if random.random() < self.goal_sample_rate:\n                sample = tree_a[0].position if tree_a is tree_goal else goal_position\n            else:\n                sample = informed_sample(c_best)\n\n            nearest = min(tree_a, key=lambda n: dist(n.position, sample))\n            step = adaptive_step(nearest.position, sample)\n            new_pos = steer(nearest.position, sample, step)\n\n            if not valid_new_node_and_edge(nearest.position, new_pos):\n                continue\n\n            new_cost = nearest.cost + dist(nearest.position, new_pos)\n            if new_cost + c_min - 1e-9 >= c_best:\n                continue\n\n            new_node = Node(new_pos, cost=new_cost)\n            new_node.parent = nearest\n            nearest.add_child(new_node)\n            tree_a.append(new_node)\n            all_nodes.append(new_node)\n            edges.append((nearest, new_node))\n\n            curr_radius = rewire_radius(len(tree_a))\n            near_nodes = [n for n in tree_a if n is not new_node and dist(n.position, new_node.position) <= curr_radius]\n            for near in near_nodes:\n                potential_cost = new_node.cost + dist(new_node.position, near.position)\n                if potential_cost + 1e-9 < near.cost:\n                    if valid_new_node_and_edge(new_node.position, near.position):\n                        if near.parent:\n                            try:\n                                edges.remove((near.parent, near))\n                            except ValueError:\n                                pass\n                            near.parent.remove_child(near)\n                        near.update_parent(new_node, potential_cost)\n                        edges.append((new_node, near))\n\n            nearest_b = min(tree_b, key=lambda n: dist(n.position, new_node.position))\n            dist_between = dist(new_node.position, nearest_b.position)\n            total_cost = new_node.cost + dist_between + nearest_b.cost\n\n            if total_cost + 1e-9 < c_best:\n                if valid_new_node_and_edge(new_node.position, nearest_b.position):\n                    c_best = total_cost\n                    path_start = new_node.path_from_root()\n                    path_goal = nearest_b.path_from_root()\n                    best_path = path_start + path_goal[::-1]\n                    success = True\n\n                    prune_nodes(tree_start, c_best)\n                    prune_nodes(tree_goal, c_best)\n\n            if success and i % 400 == 0 and len(best_path) > 3:\n                best_path = smooth_path(best_path)\n\n        if success and len(best_path) > 2:\n            best_path = smooth_path(best_path)\n\n        return PlannerResult(\n            success=success,\n            path=best_path,\n            nodes=all_nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d and len(obs) == 6:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            elif not is_3d and len(obs) == 4:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=0.5):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            point = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(point, obstacles, is_3d):\n                return True\n        return False",
     "objective": 19194.87874,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 2.2576931715011597,
               "num_nodes_avg": 903.6,
               "path_length_avg": 160.0623929008538,
               "success_improvement": 0.0,
               "time_improvement": -23289.90915198641,
               "length_improvement": 20.00235446733044,
               "objective_score": -6982.972274702457
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 3.9857800722122194,
               "num_nodes_avg": 2680.7,
               "path_length_avg": 235.9622425566491,
               "success_improvement": 0.0,
               "time_improvement": -27546.472826617235,
               "length_improvement": 21.699744961754185,
               "objective_score": -8259.60189899282
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 3.8998242616653442,
               "num_nodes_avg": 2935.0,
               "path_length_avg": 124.73206192583605,
               "success_improvement": 0.0,
               "time_improvement": -13189.953224898294,
               "length_improvement": 23.4069999917073,
               "objective_score": -3952.3045674711466
          }
     ]
}
{
     "operator": "e1",
     "algorithm_description": "The proposed algorithm is \"Bidirectional Anytime RRT*\", combining bidirectional search with anytime path improvement. It initially performs a fast path search using bidirectional RRT to quickly find a feasible path. Then it iteratively improves the path quality by rewiring and shortcutting, while also dynamically adjusting the search radius and step size. This approach enhances planning efficiency, path quality, success rate, and smoothness by balancing rapid exploration and continuous optimization.",
     "planning_mechanism": "The planning mechanism grows two trees simultaneously from start and goal states using adaptive step sizes and radii. It tries to connect these trees quickly for a feasible solution. Upon first connection, it repeatedly refines the discovered path by local shortcutting and rewiring nearby nodes to lower total cost, enabling anytime improvements during available computation time. Collision checks are performed for both nodes and edges in all steps to ensure correctness and robustness.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position      # Tuple[float, ...]\n        self.parent = parent          # Node or None\n        self.cost = cost              # cumulative cost from root\n        self.children = []\n        self.valid = True\n\n    def add_child(self, child_node):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0):\n        self.max_iter = max_iter\n        self.base_step_size = step_size\n        self.base_radius = step_size * 4.0\n\n    def plan(self, map) -> 'PlannerResult':\n        import math, random, time\n        bounds = map.size\n        start_position = map.start\n        goal_position = map.goal\n        obstacles = map.obstacles\n\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def dist(a, b):\n            return math.dist(a, b)\n\n        def steer(from_pos, to_pos, step):\n            d = dist(from_pos, to_pos)\n            if d <= step:\n                return to_pos\n            ratio = step / d\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: dist(n.position, point))\n\n        def near_nodes(tree, pos, radius):\n            return [n for n in tree if dist(n.position, pos) <= radius]\n\n        def collision_check(node_pos):\n            return not self._is_in_obstacle(node_pos, obstacles, is_3d)\n\n        def edge_check(from_pos, to_pos):\n            return not self._is_edge_in_obstacle(from_pos, to_pos, obstacles, is_3d)\n\n        def extract_path(node_start, node_goal):\n            path_start = []\n            cur = node_start\n            while cur:\n                path_start.append(cur.position)\n                cur = cur.parent\n            path_start.reverse()\n\n            path_goal = []\n            cur = node_goal\n            while cur:\n                path_goal.append(cur.position)\n                cur = cur.parent\n\n            # avoid duplicate connecting node\n            if path_start and path_goal and path_start[-1] == path_goal[0]:\n                return path_start + path_goal[1:]\n            return path_start + path_goal\n\n        def add_edge(p, c):\n            edges.append((p, c))\n            p.add_child(c)\n            nodes.append(c)\n\n        def try_extend(tree, point, radius, step):\n            nearest_node = nearest(tree, point)\n            new_pos = steer(nearest_node.position, point, step)\n            if not collision_check(new_pos):\n                return None\n            if not edge_check(nearest_node.position, new_pos):\n                return None\n\n            neighbors = near_nodes(tree, new_pos, radius)\n\n            # Find best parent with minimum cost + edge cost and feasible edge\n            min_cost = nearest_node.cost + dist(nearest_node.position, new_pos)\n            best_parent = nearest_node\n            for nbr in neighbors:\n                if edge_check(nbr.position, new_pos):\n                    cost = nbr.cost + dist(nbr.position, new_pos)\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_parent = nbr\n\n            new_node = Node(new_pos)\n            new_node.cost = min_cost\n            best_parent.add_child(new_node)\n            new_node.parent = best_parent\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((best_parent, new_node))\n\n            # Rewire neighbors\n            for nbr in neighbors:\n                if nbr == best_parent:\n                    continue\n                if edge_check(new_node.position, nbr.position):\n                    new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                    if new_cost < nbr.cost:\n                        # Remove old edge\n                        if nbr.parent:\n                            try:\n                                edges.remove((nbr.parent, nbr))\n                                nbr.parent.children.remove(nbr)\n                            except Exception:\n                                pass\n                        nbr.parent = new_node\n                        nbr.cost = new_cost\n                        new_node.add_child(nbr)\n                        edges.append((new_node, nbr))\n\n            return new_node\n\n        def connect_trees(node_from, tree_to, radius, step):\n            nearest_node = nearest(tree_to, node_from.position)\n            cur = nearest_node\n            last_added = None\n            while True:\n                new_pos = steer(cur.position, node_from.position, step)\n                if not collision_check(new_pos):\n                    return None\n                if not edge_check(cur.position, new_pos):\n                    return None\n\n                # If new_pos is very close to node_from, connect directly\n                dist_to_target = dist(new_pos, node_from.position)\n                connect_direct = dist_to_target <= step\n\n                neighbors = near_nodes(tree_to, new_pos, radius)\n                min_cost = cur.cost + dist(cur.position, new_pos)\n                best_parent = cur\n                for nbr in neighbors:\n                    if edge_check(nbr.position, new_pos):\n                        cost = nbr.cost + dist(nbr.position, new_pos)\n                        if cost < min_cost:\n                            min_cost = cost\n                            best_parent = nbr\n\n                new_node = Node(new_pos)\n                new_node.cost = min_cost\n                best_parent.add_child(new_node)\n                new_node.parent = best_parent\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((best_parent, new_node))\n\n                for nbr in neighbors:\n                    if nbr == best_parent:\n                        continue\n                    if edge_check(new_node.position, nbr.position):\n                        new_cost = new_node.cost + dist(new_node.position, nbr.position)\n                        if new_cost < nbr.cost:\n                            if nbr.parent:\n                                try:\n                                    edges.remove((nbr.parent, nbr))\n                                    nbr.parent.children.remove(nbr)\n                                except Exception:\n                                    pass\n                            nbr.parent = new_node\n                            nbr.cost = new_cost\n                            new_node.add_child(nbr)\n                            edges.append((new_node, nbr))\n\n                if connect_direct:\n                    # final connection node to node_from\n                    if not collision_check(node_from.position):\n                        return None\n                    if not edge_check(new_node.position, node_from.position):\n                        return None\n                    last_node = Node(node_from.position)\n                    last_node.cost = new_node.cost + dist(new_node.position, node_from.position)\n                    new_node.add_child(last_node)\n                    last_node.parent = new_node\n                    tree_to.append(last_node)\n                    nodes.append(last_node)\n                    edges.append((new_node, last_node))\n                    return last_node\n\n                cur = new_node\n\n        def shortcut_path(path, max_attempts=100):\n            if len(path) <= 2:\n                return path\n            for _ in range(max_attempts):\n                if len(path) <= 2:\n                    break\n                i = random.randint(0, len(path) - 3)\n                j = random.randint(i + 2, len(path) - 1)\n\n                p1, p2 = path[i], path[j]\n                if not edge_check(p1, p2):\n                    continue\n                # if edge is valid, shortcut path by removing intermediates\n                path = path[:i + 1] + path[j:]\n            return path\n\n        time_start = time.time()\n        radius = self.base_radius\n        step = self.base_step_size\n\n        for iter in range(1, self.max_iter+1):\n            # Adaptive step size & radius shrinking over iterations to refine path\n            if iter % 500 == 0:\n                radius = max(self.base_step_size * 2, radius * 0.85)\n                step = max(self.base_step_size * 0.5, step * 0.9)\n\n            # Sample a valid random point\n            while True:\n                rand_point = tuple(random.uniform(0, bounds[d]) for d in range(len(bounds)))\n                if collision_check(rand_point):\n                    break\n\n            # Extend start tree towards sample\n            new_start_node = try_extend(start_tree, rand_point, radius, step)\n            if new_start_node is None:\n                # Swap trees and continue\n                start_tree, goal_tree = goal_tree, start_tree\n                continue\n\n            # Try connect goal tree to new node\n            connected_node = connect_trees(new_start_node, goal_tree, radius, step)\n            if connected_node:\n                success_state = True\n                extracted_path = extract_path(new_start_node, connected_node)\n\n                # Perform anytime path improvement via shortcutting & rewiring limited by time\n                time_budget = 0.5  # seconds for refinement per run after success\n                t_ref_start = time.time()\n                while time.time() - t_ref_start < time_budget:\n                    # Shortcut the current path to smooth and shorten\n                    extracted_path = shortcut_path(extracted_path, max_attempts=20)\n\n                    # Try rewiring each node along the path locally\n                    for node in nodes:\n                        if node.parent is None:\n                            continue\n                        neighbors = near_nodes(nodes, node.position, radius)\n                        for nbr in neighbors:\n                            if nbr == node or nbr == node.parent:\n                                continue\n                            if edge_check(nbr.position, node.position):\n                                new_cost = nbr.cost + dist(nbr.position, node.position)\n                                if new_cost < node.cost:\n                                    # Rewire node to nbr\n                                    if node.parent:\n                                        try:\n                                            edges.remove((node.parent, node))\n                                            node.parent.children.remove(node)\n                                        except Exception:\n                                            pass\n                                    node.parent = nbr\n                                    node.cost = new_cost\n                                    nbr.add_child(node)\n                                    edges.append((nbr, node))\n\n                    # Re-extract path after rewiring start and goal trees roots\n                    start_closest = nearest(start_tree, goal_position)\n                    goal_closest = nearest(goal_tree, start_position)\n                    extracted_path = extract_path(start_closest, goal_closest)\n\n                break\n\n            # Swap to grow other tree next iteration\n            start_tree, goal_tree = goal_tree, start_tree\n\n        return type('PlannerResult', (), dict(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        ))()\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 3961.91787,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.6013188600540161,
               "num_nodes_avg": 68.2,
               "path_length_avg": 141.3684144676756,
               "success_improvement": 0.0,
               "time_improvement": -6129.718761423927,
               "length_improvement": 29.345425211119025,
               "objective_score": -1833.0465433849545
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.7322922706604004,
               "num_nodes_avg": 212.2,
               "path_length_avg": 141.04258111955664,
               "success_improvement": 0.0,
               "time_improvement": -4979.381700736409,
               "length_improvement": 53.197299901646645,
               "objective_score": -1483.1750502405932
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.6762112855911255,
               "num_nodes_avg": 167.5,
               "path_length_avg": 35.595502771724625,
               "success_improvement": 0.0,
               "time_improvement": -2204.41572559907,
               "length_improvement": 78.14221698899722,
               "objective_score": -645.6962742819215
          }
     ]
}
{
     "operator": "m1",
     "algorithm_description": "The algorithm is an enhanced bidirectional RRT-Connect variant that integrates heuristic-biased sampling towards the goal, adaptive step sizing, and path smoothing. It grows two trees simultaneously from the start and goal, attempts to connect them efficiently, and improves the path quality by shortcut smoothing.",
     "planning_mechanism": "The planner alternates growth of two RRT trees towards randomly sampled points with a goal bias to speed convergence, uses adaptive step sizes to efficiently explore open spaces, and attempts tree connections with rigorous collision checks. Upon successful connection, the final path is extracted and smoothed by shortcutting unnecessary nodes to improve path quality and reduce length.",
     "code": "class Node:\n    def __init__(self, position, parent=None, cost=0.0):\n        self.position = position        # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent            # Node or None\n        self.cost = cost                # Path cost\n        self.children = []\n        self.valid = True               # For collision checking etc.\n\n    def add_child(self, child):\n        self.children.append(child)\n        child.parent = self\n\n    def path_from_root(self):\n        path = []\n        node = self\n        while node is not None:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def path_cost_from_root(self):\n        cost = 0.0\n        node = self\n        while node.parent is not None:\n            cost += self._distance(node.position, node.parent.position)\n            node = node.parent\n        return cost\n\n    @staticmethod\n    def _distance(a, b):\n        import math\n        return math.dist(a, b)\nclass Planner:\n    def __init__(self, max_iter: int = 5000, step_size: float=5.0, goal_sample_rate: float=0.1):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.goal_sample_rate = goal_sample_rate  # Probability to sample the goal directly\n\n    def plan(self, map) -> 'PlannerResult':\n        import random, math\n\n        bounds = map.size                  # Tuple[int, ...]: (W,H) or (W,H,D)\n        start_position = map.start         # Tuple[float, ...]\n        goal_position = map.goal           # Tuple[float, ...]\n        obstacles = map.obstacles          # Rectangular blocks\n        is_3d = len(bounds) == 3\n\n        start_tree = [Node(start_position)]\n        goal_tree = [Node(goal_position)]\n\n        nodes = start_tree + goal_tree\n        edges = []\n\n        success_state = False\n        extracted_path = []\n\n        def sample():\n            if random.random() < self.goal_sample_rate:\n                return goal_position\n            while True:\n                if is_3d:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]),\n                         random.uniform(0, bounds[2]))\n                else:\n                    p = (random.uniform(0, bounds[0]),\n                         random.uniform(0, bounds[1]))\n                if not self._is_in_obstacle(p, obstacles, is_3d):\n                    return p\n\n        def nearest(tree, point):\n            return min(tree, key=lambda node: math.dist(node.position, point))\n\n        def steer(from_pos, to_pos, max_len):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= max_len:\n                return to_pos\n            ratio = max_len / dist\n            return tuple(from_pos[i] + (to_pos[i] - from_pos[i]) * ratio for i in range(len(from_pos)))\n\n        def try_extend(tree, target_point):\n            nearest_node = nearest(tree, target_point)\n            adaptive_step = self.adaptive_step_size(nearest_node.position, target_point, bounds)\n            new_pos = steer(nearest_node.position, target_point, adaptive_step)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                return None\n            if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                return None\n            new_node = Node(new_pos, parent=nearest_node)\n            nearest_node.add_child(new_node)\n            tree.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n            return new_node\n\n        def connect_trees(node_from, tree_to):\n            current = node_from\n            while True:\n                nearest_node = nearest(tree_to, current.position)\n                if self._is_edge_in_obstacle(current.position, nearest_node.position, obstacles, is_3d):\n                    return None  # No path between them\n                dist = math.dist(current.position, nearest_node.position)\n                if dist <= self.step_size:\n                    # Connect directly\n                    return nearest_node\n                new_pos = steer(nearest_node.position, current.position, self.step_size)\n                if self._is_in_obstacle(new_pos, obstacles, is_3d):\n                    return None\n                if self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                    return None\n                new_node = Node(new_pos, parent=nearest_node)\n                nearest_node.add_child(new_node)\n                tree_to.append(new_node)\n                nodes.append(new_node)\n                edges.append((nearest_node, new_node))\n                nearest_node = new_node\n                current = current\n\n        def extract_path(meet_node_a, meet_node_b):\n            path_a = meet_node_a.path_from_root()\n            path_b = meet_node_b.path_from_root()\n            return path_a + path_b[::-1]\n\n        def shortcut_path(path):\n            # Attempt to shortcut path by skipping intermediate nodes when direct line is collision free\n            if len(path) < 3:\n                return path\n            smoothed = [path[0]]\n            i = 0\n            while i < len(path) -1:\n                j = len(path) -1\n                while j > i+1:\n                    if not self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                        break\n                    j -= 1\n                smoothed.append(path[j])\n                i = j\n            return smoothed\n\n        for _ in range(self.max_iter):\n            rnd_point = sample()\n\n            # Alternate tree growing\n            new_node_start = try_extend(start_tree, rnd_point)\n            if new_node_start:\n                new_node_goal = connect_trees(new_node_start, goal_tree)\n                if new_node_goal:\n                    success_state = True\n                    extracted_path = extract_path(new_node_start, new_node_goal)\n                    extracted_path = shortcut_path(extracted_path)\n                    break\n\n            new_node_goal = try_extend(goal_tree, rnd_point)\n            if new_node_goal:\n                new_node_start = connect_trees(new_node_goal, start_tree)\n                if new_node_start:\n                    success_state = True\n                    extracted_path = extract_path(new_node_start, new_node_goal)\n                    extracted_path = shortcut_path(extracted_path)\n                    break\n\n        return PlannerResult(\n            success=success_state,\n            path=extracted_path,\n            nodes=nodes,\n            edges=edges\n        )\n\n    def adaptive_step_size(self, from_pos, to_pos, bounds, min_step=1.0, max_step=7.0):\n        \"\"\"\n        Adaptive step size: increase step if free space is likely large,\n        reduce if close to boundary or obstacles (not explicitly checking obstacles here for speed).\n        \"\"\"\n        import math\n\n        dist_to_goal = math.dist(from_pos, to_pos)\n        # Reduce step size near map boundaries\n        margin = 5.0\n        for i, coord in enumerate(from_pos):\n            if coord < margin or coord > bounds[i] - margin:\n                return max(min_step, self.step_size * 0.5)\n        # Adaptive step proportional to distance, bounded\n        adaptive_step = min(max_step, max(min_step, dist_to_goal, self.step_size))\n        return adaptive_step\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False",
     "objective": 103.58093,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.02944056987762451,
               "num_nodes_avg": 104.3,
               "path_length_avg": 179.228986024157,
               "success_improvement": 0.0,
               "time_improvement": -205.007014909152,
               "length_improvement": 10.423075443951982,
               "objective_score": -59.4174893839552
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.024379825592041014,
               "num_nodes_avg": 198.6,
               "path_length_avg": 239.2329382393437,
               "success_improvement": 0.0,
               "time_improvement": -69.10521241427439,
               "length_improvement": 20.61441748167655,
               "objective_score": -16.608680227947005
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.060218071937561034,
               "num_nodes_avg": 317.7,
               "path_length_avg": 130.20553113190894,
               "success_improvement": 0.0,
               "time_improvement": -105.21318542748801,
               "length_improvement": 20.045960171846076,
               "objective_score": -27.55476359387719
          }
     ]
}
{
     "operator": "m3",
     "algorithm_description": "A simplified bidirectional RRT* planner that efficiently grows start and goal trees by incrementally steering towards random samples. It performs collision checks for nodes and edges, rewires neighbors within a radius to optimize path cost, and attempts to connect the two trees to find a feasible path. The algorithm focuses on balancing planning efficiency, path quality, and robustness through straightforward rewiring and early connection attempts.",
     "planning_mechanism": "The planner alternates expanding between two trees from start and goal, samples points uniformly within bounds, steers nodes by a fixed step size, checks collisions before adding nodes and edges, and rewires local neighbors to improve cost. Once the trees connect, a path is extracted by combining paths from both trees.",
     "code": "class Node:\n    def __init__(self, position: Tuple[float, ...], parent=None, cost: float = 0.0):\n        self.position = position                # Tuple[float, ...] \u2192 2D: (x,y), 3D: (x,y,z)\n        self.parent = parent                    # Node or None\n        self.cost = cost                        # Path cost from root\n        self.children: List[Node] = []\n        self.valid = True                       # For collision checking etc.\n\n    def add_child(self, child_node: \"Node\"):\n        self.children.append(child_node)\n        child_node.parent = self\n\n    def remove_child(self, child_node: \"Node\"):\n        if child_node in self.children:\n            self.children.remove(child_node)\n            child_node.parent = None\n\n    def path_from_root(self) -> List[Tuple[float, ...]]:\n        path, node = [], self\n        while node:\n            path.append(node.position)\n            node = node.parent\n        return path[::-1]\n\n    def update_parent(self, new_parent: \"Node\", new_cost: float):\n        if self.parent is not None:\n            self.parent.remove_child(self)\n        self.parent = new_parent\n        self.cost = new_cost\n        new_parent.add_child(self)\nclass Planner:\n    def __init__(self, max_iter: int = 3000, step_size: float = 5.0, rewire_radius: float = 15.0):\n        self.max_iter = max_iter\n        self.step_size = step_size\n        self.rewire_radius = rewire_radius\n\n    def plan(self, map) -> PlannerResult:\n        import math\n        import random\n\n        bounds = map.size                    # Tuple[int, ...] (W,H) or (W,H,D)\n        start_pos = map.start                # Tuple[float, ...]\n        goal_pos = map.goal                  # Tuple[float, ...]\n        obstacles = map.obstacles            # Rectangles or cuboids\n        is_3d = len(bounds) == 3\n        dim = len(bounds)\n\n        tree_start: List[Node] = [Node(start_pos)]\n        tree_goal: List[Node] = [Node(goal_pos)]\n        nodes: List[Node] = [tree_start[0], tree_goal[0]]\n        edges: List[Tuple[Node, Node]] = []\n\n        success_state = False\n        final_path: List[Tuple[float, ...]] = []\n\n        def sample_free():\n            while True:\n                point = tuple(random.uniform(0, bounds[d]) for d in range(dim))\n                if not self._is_in_obstacle(point, obstacles, is_3d):\n                    return point\n\n        def nearest(tree, point):\n            return min(tree, key=lambda n: math.dist(n.position, point))\n\n        def steer(from_pos, to_pos):\n            dist = math.dist(from_pos, to_pos)\n            if dist <= self.step_size:\n                return to_pos\n            ratio = self.step_size / dist\n            return tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * ratio for d in range(dim))\n\n        def near_nodes(tree, position):\n            return [node for node in tree if math.dist(node.position, position) <= self.rewire_radius]\n\n        for i in range(self.max_iter):\n            tree_a, tree_b = (tree_start, tree_goal) if i % 2 == 0 else (tree_goal, tree_start)\n            rnd_point = sample_free()\n\n            nearest_node = nearest(tree_a, rnd_point)\n            new_pos = steer(nearest_node.position, rnd_point)\n            if self._is_in_obstacle(new_pos, obstacles, is_3d) or \\\n               self._is_edge_in_obstacle(nearest_node.position, new_pos, obstacles, is_3d):\n                continue\n\n            new_cost = nearest_node.cost + math.dist(nearest_node.position, new_pos)\n            new_node = Node(new_pos)\n            new_node.parent = nearest_node\n            new_node.cost = new_cost\n            nearest_node.add_child(new_node)\n            tree_a.append(new_node)\n            nodes.append(new_node)\n            edges.append((nearest_node, new_node))\n\n            # Rewire\n            neighbors = near_nodes(tree_a, new_pos)\n            for neighbor in neighbors:\n                potential_cost = new_node.cost + math.dist(new_node.position, neighbor.position)\n                if potential_cost + 1e-6 < neighbor.cost:\n                    if not self._is_edge_in_obstacle(new_node.position, neighbor.position, obstacles, is_3d):\n                        if neighbor.parent:\n                            neighbor.parent.remove_child(neighbor)\n                            if (neighbor.parent, neighbor) in edges:\n                                edges.remove((neighbor.parent, neighbor))\n                        neighbor.update_parent(new_node, potential_cost)\n                        edges.append((new_node, neighbor))\n\n            # Attempt connection between trees\n            nearest_to_new = nearest(tree_b, new_node.position)\n            dist_between = math.dist(new_node.position, nearest_to_new.position)\n            total_cost = new_node.cost + dist_between + nearest_to_new.cost\n\n            # Connect if edge is collision free\n            if not self._is_edge_in_obstacle(new_node.position, nearest_to_new.position, obstacles, is_3d):\n                success_state = True\n                path_start = new_node.path_from_root()\n                path_goal = nearest_to_new.path_from_root()\n                final_path = path_start + path_goal[::-1]\n                break\n\n        return PlannerResult(\n            success=success_state,\n            path=self._smooth_path(final_path, obstacles, is_3d, bounds) if success_state else [],\n            nodes=nodes,\n            edges=edges\n        )\n\n    def _is_in_obstacle(self, pos, obstacles, is_3d):\n        for obs in obstacles:\n            if is_3d:\n                x, y, z, w, h, d = obs\n                px, py, pz = pos\n                if x <= px <= x + w and y <= py <= y + h and z <= pz <= z + d:\n                    return True\n            else:\n                x, y, w, h = obs\n                px, py = pos\n                if x <= px <= x + w and y <= py <= y + h:\n                    return True\n        return False\n\n    def _is_edge_in_obstacle(self, from_pos, to_pos, obstacles, is_3d, resolution=1.0):\n        import math\n        distance = math.dist(from_pos, to_pos)\n        steps = max(1, int(distance / resolution))\n        for i in range(steps + 1):\n            interp = tuple(from_pos[d] + (to_pos[d] - from_pos[d]) * (i / steps) for d in range(len(from_pos)))\n            if self._is_in_obstacle(interp, obstacles, is_3d):\n                return True\n        return False\n\n    def _smooth_path(self, path: List[Tuple[float, ...]], obstacles, is_3d, bounds):\n        import math\n        if len(path) < 3:\n            return path\n        smoothed = [path[0]]\n        idx = 0\n        while idx < len(path) - 1:\n            next_idx = len(path) - 1\n            for j in range(len(path) - 1, idx, -1):\n                if self._is_edge_in_obstacle(smoothed[-1], path[j], obstacles, is_3d):\n                    continue\n                if any((p < 0 or p > bounds[d]) for d, p in enumerate(path[j])):\n                    continue\n                next_idx = j\n                break\n            if next_idx == idx:\n                smoothed.append(path[idx + 1])\n                idx += 1\n            else:\n                smoothed.append(path[next_idx])\n                idx = next_idx\n        return smoothed",
     "objective": 134.2284,
     "other_inf": [
          {
               "map_id": 0,
               "success_rate": 1.0,
               "time_avg": 0.03318908214569092,
               "num_nodes_avg": 107.3,
               "path_length_avg": 179.57384269618302,
               "success_improvement": 0.0,
               "time_improvement": -243.84194718069816,
               "length_improvement": 10.250719393862173,
               "objective_score": -71.10244027543702
          },
          {
               "map_id": 1,
               "success_rate": 1.0,
               "time_avg": 0.03660280704498291,
               "num_nodes_avg": 199.6,
               "path_length_avg": 239.78109602900696,
               "success_improvement": 0.0,
               "time_improvement": -153.88719197077515,
               "length_improvement": 20.432520182062902,
               "objective_score": -42.07965355481996
          },
          {
               "map_id": 2,
               "success_rate": 1.0,
               "time_avg": 0.05408687591552734,
               "num_nodes_avg": 268.2,
               "path_length_avg": 128.24945191885757,
               "success_improvement": 0.0,
               "time_improvement": -84.31908793020376,
               "length_improvement": 21.247110644853944,
               "objective_score": -21.04630425009034
          }
     ]
}
